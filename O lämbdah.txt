Lämbdy - eto funkçionaljnyje objekty, objavläjemyje neposredstvenno v meste ispoljzovanija (v konktekste vyraženija) i ne imejuscije posemu imeni.

Lämbdy mogut zahvatyvatj okružajuscije peremennyje - po znaceniju ili po ssylke.
Lämbda, zahvativšaja ssylku, logiceski hranit jejo v sebe, podobno strukture so ssylkoj vnutri.

Objekt, sozdavajemyj vyraženijem-lämbdoj - eto objekt tipa klassa, soderžascij metod ().
Klass etot unikaljnyj dlä každoj lämbdy.
Vnutri objekta hranätsä zahvacennyje peremennyje, vozmožno kak ssylki.
Klass možet bytj kopirujem, jesli zahvacennyje peremennyje kopirujemy.
Zahvacennyje ssylki pri etom scitajutsä kopirujemymi.
Ne ponätno, nužno li sravnenije na ravenstvo.

Sposob zahvata peremennyh nužno umetj kontrolirovatj - ukazyvatj javno kakije peremennyje i kakim obrazom nado zahvatitj.
Dlä prostoty možno dobavitj sposob ukazatj "zahvatitj vsö po kopii" i "zahvatitj vsö po izmenäjemoj/neizmenäjemoj ssylke".
V etom slucaje zahvatätsä ukazannym sposobom vse peremennyje, kotoryje vnutri lämbdy ispoljzujutsä (no toljko oni).

Vozmožno stoit dobavitj vozmožnostj pereimenovatj zahvacennuju peremennuju.

Dolžen suscestvovatj sposob ukazatj tip operatora () lämbdy - vklücaja argumenty, vozvrascajemoje znacenije, "unsafe" flag, ssylocnyje notaçii i t. d.
Dolžen suscestvovatj sposob sdelatj lämbdu šablonnoj.

Ne vpolne ponätno, kak obrascatjsä s "this".
Vrode by "this" dolžen v metode () lämbdy ukazyvatj na objekt lämbdy.
No togda ne ponätno, kak obrascatjsä k "this" iz okružajuscego konteksta.
Vozmožno, stoit vnesti otdeljnoje klücevoje slovo dlä dostupa k "this" lämbdy, vrode "lambda_this".

Takže stoit predusmotretj sposob peredaci "lambda_this" - po izmenäjemoj ili neizmenäjemoj ssylke.

Objavlenije lämbdy dolžno po vozmožnosti bytj kak možno boleje lakonicnym.
Stoit predusmotretj podhodäscije umolcateljnyje znacenija jejo svojstv.
Vozmožno daže ukazanije tipov argumentov i vozvrascajemogo znacenija stoit sdelatj neobäzateljnym - s ih avtovyvodom.
Takže avtovyvod možet bytj poleznym dlä ssylocnoj notaçii - sväzyvanija ssylok, vozvrascajemyh ssylok, vozvrascajemyh vnutrennih ssylok.

Svojstvo "non_sync" lämbdy opredeläjetsä takovym svojstvom zahvacennyh peremennyh.

Postrojenije koda lämb viditsä vozmožnym sledujuscim obrazom:
Snacala telo lämbdy stroitsä obycnym obrazom - kak otdeljnaja funkçija, pri etom roditeljskoje prostranstvo imön eto prostranstvo okružajuscej funkçii.
V etom prohode zapominajetsä, k kakim peremennym iz okružajuscego konteksta byl dostup.
Takže proishodit avtovyvod vozvrascajemogo znacenija (i ssylocnoj notaçii).
Dalee stroitsä klass, kotoryj hranit zahvacennyje peremennyje i ssylki i lämbda stroitsä jescö raz kak jego metod ().
Vnešnije peremennyje stanovätsä polämi etogo klassa.

Dlä vyšeopisannogo sposoba nado umetj pri obrascenii k peremennym kak-to eto zapominatj.
Kak minimum, imetj scötcik obrascenij.

Takže etot podhod imejet suscestvennyj nedostatok - šablonnyje lämbdy tak ne sdelatj, ibo dlä nih pervonacaljnyj prohod ne budet rabotatj.
Kak minimum, eto pomešajet šablonnym lämbdam osuscestvlätj avtozahvat peremennyh iz okruženija.

Stoit takže rassmotretj, kakim obrazom mogut rabotatj lämbdy vnutri lämbd.

Ne ponätno, vozmožno li kak-to avtomaticeski opredelitj, po ssylke, izmenäjemoj ssylke ili po znaceniju nado zahvatyvatj peremennuju.
Jesli net, to stoit umolcateljno zahvatyvatj po ssylke (izmenäjemoj ili net, v zavisimosti ot izmenäjemosti ishodnoj peremennoj).

Stoit proektirovatj lämbdy tak, ctoby ne bylo nekonsistentnosti pri preproçessinge lämbd.
A imenno, daby ne bylo vozmožnosti kak-to sostavitj (naprimer) "static_if" na osnovanii informaçii o tipe tekuscej lämbdy.
Takaja vozmožnostj vedj možet privesti k tomu, cto pri preproçessinge lämbd i pri ih postrojenii mogut bytj vyzvany raznyje vetvi "static_if", cto privedöt k nekonsistentnosti nabora zahvacennyh peremennyh.
Takoje trebovanije prakticeski isklücajet nalicije klücevogo slova "this" dlä lämbd (ili drugogo slova s tem že znacenijem), ibo togda pojavitsä vozmožnostj ispoljzovatj "typeinfo</ typeof(this) />".

Ne vpolne jasno, kak obhoditjsä s zahvacennymi po znaceniju peremennymi lämbd s "byval this".
Vozmožno, stoit datj vozmožnostj peremescatj ih primerno kak argumenty-znacenija.

Poka jestj takaja ideja, kak sdelatj dostuk k zahvacennym peremennym v lämbdah:
Možno v nacale funkçii sozdatj imena dlä nih vseh, kotoryje ukazyvajut na sootvetstvujuscije polä v "this" lämbdy.
V "byval this" lämbdah ik možno sdelatj po analogii s argumentami-znacenijami, ctoby ih možno bylo peremescatj.
V takoj sheme možno takže realizovatj dostup k vnešnemu "this" i jego poläm.
Tocneje, polä etogo "this" budut zahvaceny v lämbdu prosto kak peremennyje iz okruženija.

Zahvacennyje peremennyje imejet smysl delatj polämi klassa lämbdy.
Pri etom oni dolžny bytj "private", daby ih neljzä bylo menätj izvne.

Ne jasno, cto delatj s "async" lämbdami i "generator" lämbdami.
Vpolne vozmožno, cto po nacalu ih stoit zapretitj.

Sintaksis obozvnacenija zahvata planirujetsä takovym:
* "=" dlä zahvata vsego po znaceniju
* "&" dlä zahvata vsego po ssylke
* spisok cerez zapätuju imön peremennyh dlä zahvata, s prefiksom "&" dlä zahvata po ssylke. Pri etom izmenäjemostj ssylki opredeläjetsä avtomaticeski (po izmenäjemosti ishodnoj peremennoj).
* Vozmožno ukazanije iniçializatora dlä zahvacennoj peremennoj cerez "=". Togda budet prosto dobavleno pole v lämbdu s takim iniçializatorom. Eto pozvolit peremescatj peremennyje v lämbdu.

Spisok zahvata stoit ukazyvatj v kakih-to skobkah, naprimer v "[]".
Ne jasno, kak nacinatj objavlenije lämbdy. Vozmožno stoit ispoljzovatj dlä etogo nekoje klücevoje slovo, vrode "lambda".
