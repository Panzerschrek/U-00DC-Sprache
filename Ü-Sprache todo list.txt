Here are some language features for future development of the language itself and its
compiler. Features are grouped and sorted by priority inside each group.
Delete the features from the list as soon as they are implemented.

General:
*) build-in "for" for array types.
*) equality compare for types (like "==").
*) Disassembly operator - declare variables with initializer as members of value of structure type.
*) Function to function pointer assignment
*) Functions references info in "typeinfo".
*) More float types ( 16 bit, 128 bit )
*) Constructor initializer for constexpr structs
*) Lambdas.
*) Custom field/class attributes, accessible via typeinfo (for metaprogramming)
*) Async functions.
*) Continious initializer for arrays
*) Auto-move in "return" for local variable
*) More advanced macros - more context, elements, string manipulations
*) switch-style operator for expression context
*) thread-local variables
*) "nodiscard" for types (and/or) functions

References:
*) Multiple inner reference tags for some types
*) Separate reference checking for array elements while accessing via constexpr index

Templates:
*) Default template arguments for short type template form
*) enable_if for type templates
*) Variadic templates
*) Function templates with template-dependent reference and mutability modifiers for arguments. Conditional move for
	such arguments.

Standart library:
*) Compilation speed-up - avoid generating some helper classes/functions
*) Associative containers - map, set, string_map
*) More algorithms
*) Iterators library with transformations/operations (map, filter, reduce, etc.)
*) Time library - get time functions, timers
*) File library
*) Console input/output library
*) Print fail message in asserts
*) Formatting library
*) More type traits
*) More math functions

Compiler:
*) Optimize typeinfo - avoid calculating mangled name for typeinfo types, avoid building lists if it's not necessary (buld them lazily)
*) Investigate optimization possibility - avoid mangling private functions
*) Add option to define some constants in prelude (like preprocessor defenitions in C++).
*) Imporve TBAA - use struct path-based TBAA.
*) Pass/return by-value composite values containing more than one scalar inside.
	Use some approach, dependent on target architecture, to determine, if type is suitable for passing in registers,
	or it would be better to pass it in memory.
*) Faster calling convention for non-cross-language functions.
*) Fix possible UB in float->int conversion.
*) Virtual call for final function optimization
*) Do not crash in some cases of code with errors
*) Prevent execution of constexpr functions with errors
*) Inline assembly/module level assembly support
*) Precompiled modules
*) More calling conventions (including platform-dependent)
*) Generate errors about unused function templates

Interpreter:
*) Support entry point with args and add possibility to provide such args (argc, argv?)
*) Add possibility to optimize code
*) Support math functions

Compiler1:
*) Support 128-bit types in switch operator

QtCreator plugin:
*) Language server features support

Language server
*) Reduce memory usage - avoid building unnecessary code, clear unused internal data structures, make mangled names shorter, etc.
*) Occurences search improvement - search not only in document and its imports, but in other opened and non-opened documents
*) Document symbols - provide proper ranges (for namespaces, classes, etc), provide exact selection ranges
*) A way to provide configuration (import directories, other compilation options)
*) Complete function argument types while writing function call
*) Avoid infinite calculations in constexpr functions executiong during compilation in the LanguageServer
*) Fix "go to definition" for templates - preprocess templates with dummy types in order to fill definitions table for them
*) Go to definition for non-value names - loop labels, reference tags, imports, etc.
*) Backup completion for non-compiled documents
*) Filter-out some symbol kinds in completion, depending on context
*) Sort completed items using some kind of prioroty
*) Links between errors for template/macro errors
*) More unit-tests
*) Create TargetMachine to obtain proper data layout

CPP Header converter:
*) White list of converted symbols
*) Black list of converted symbols
*) Ignore some headers or split result into several files

Documentation:
*) More, then one language
