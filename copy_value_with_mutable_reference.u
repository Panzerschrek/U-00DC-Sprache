import "/string.u"
import "/thread.u"

fn RaceConditionString()
{
	var ust::string8 mut s;

	// This thread modifies "s" variable.
	auto mut t=
		ust::make_thread(
			lambda[&]()
			{
				for( auto mut i= 0s; i < 1024s * 1024s; ++i )
				{
					s.push_back( 'a' );
				}
			}
		);

	// Error here - copy constructor is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	auto s_copy0= s;
	var ust::string8 s_copy1= s;

	// Error here - copy constructor is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	FuncWithStringArg( s );

	// Error here - copy constructor is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	with( s_copy2 : s )
	{
	}

	// Error here - copy constructor is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	var ust::string8 some= ( true ? s : ust::string8("abc") );

	// Error here - copy constructor is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	auto l= lambda[s]() : ust::string8 { return s; };

	move(t).join();
}

fn FuncWithStringArg( ust::string8 s );

fn RaceConditionInt() : u32
{
	var u32 mut x= 0u;

	// This thread modifies "s" variable.
	auto mut t=
		ust::make_thread(
			lambda[&]()
			{
				for( auto mut i= 0s; i < 1024s * 1024s; ++i )
				{
					++x;
				}
			}
		);

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	auto x_copy0= x;
	var u32 x_copy1= x;
	var u32 x_copy2(x);

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	FuncWithUintArg( x );

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	with( x_copy3 : x )
	{
	}

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	var u32 some= ( true ? x : 45u );

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	auto l= lambda[=]() : u32 { return x; };

	// We have race condition here too. Return value is read and copied before destruction of the thread, which modifies source value.
	return x;
}

fn FuncWithUintArg( u32 x );

fn RaceConditionTuple() : ust::string8
{
	var tup[ u32, ust::string8 ] mut tup_var[ 0u, "" ];

	// This thread modifies "s" variable.
	auto mut t=
		ust::make_thread(
			lambda[&]()
			{
				for( auto mut i= 0s; i < 1024s * 1024s; ++i )
				{
					++tup_var[0];
					tup_var[1].push_back( 'Q' );
				}
			}
		);

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	auto tup_var_copy0= tup_var;
	var tup[ u32, ust::string8 ] tup_var_copy1= tup_var;
	var tup[ u32, ust::string8 ] tup_var_copy2(tup_var);

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	FuncWithTupArg( tup_var );

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	with( tup_var_copy3 : tup_var )
	{
	}

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	var tup[ u32, ust::string8 ] some= ( true ? tup_var : ust::make_tuple( 78u, ust::string8() ) );

	// Error here - copying is executed while a mutable reference to source exists and this source is actively mutated by another thread.
	// We have race condition here.
	auto l= lambda[capture= tup_var]() : tup[ u32, ust::string8 ] { return capture; };

	// Should have error here too
	/*
	for( val : tup_var )
	{
	}
	*/

	// We have race condition here too. Return value is read and copied before destruction of the thread, which modifies source value.
	return tup_var[1];
}

fn FuncWithTupArg( tup[ u32, ust::string8 ] t );
