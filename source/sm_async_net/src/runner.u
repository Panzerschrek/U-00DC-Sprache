import "/assert.u"
import "/hash_map.u"
import "/sm_async_net/runner.uh"
import "task_tree_node.uh"
import "unix.uh"

namespace sm_async_net
{

fn runner::constructor()
	(
		state_
		{
			.tasks_queue( TasksQueue() ),
			.shutdown_flag( false ),
		},
		runner_thread_= ust::make_thread( RunnerThreadFunction( state_ ) )
	)
{
}

fn runner::destructor()
{
	// Set shudown flag first, than notify all runner threads waiting on the condition variable associated with the tasks queue.
	// Doing so we trigger stopping runner thread loops.
	// Do this under a lock to avoid race conditions with runner threads.
	with( l : state_.tasks_queue.lock() )
	{
		state_.shutdown_flag.write( true );
		state_.tasks_queue_condition_variable.notify_all();
	}

	// Destructors of runner threads execute "join" here. So we gracefully perform the shutdown sequence.
	// Generally it shouldn't be long, since runner threads may usually stop executing async functions after shutdown signal is set.
}

fn runner::add_task( this, root_task_type mut t )
{
	assert( !ust::coro_done( t ), "A finished task is added!" );

	// Lock tasks queue, add a task and notify condition variable to wake one of the runner threads.
	auto mut l= state_.tasks_queue.lock();
	l.deref().Push( move(t) );
	state_.tasks_queue_condition_variable.notify_one();
}

op runner::RunnerThreadFunction::()( byval this )
{
	// Set shared state global variable.
	// Since this global variable is thread-local and this function is running on a separate thread, it's not impossible here to overwrite someone else's variable instance.
	unsafe{ g_current_runner_thread_shared_state= $<( cast_mut(state_) ); }

	var ust::hash_map</TaskUniqueId, root_task_type/> mut tasks_map;

	var ust::vector</TaskUniqueId/> mut ready_for_execution_tasks;

	// Main runner loop.
	// Do not return from it, break instead!
	// It's necessary to perform necessary cleanup steps before exiting!
	loop label main_loop
	{
		// Lock tasks queue, try popping a task.
		// If no task is available, wait on condition variable for the tasks queue, than try popping a task again.
		// Break this loop if a new task is available or if shutdown flag is specified.
		// Since shutdown flag is set under the mutex lock, we are sure it's not possible for it to be changed between reading it and waiting on the condition variable.
		with( mut l : state_.tasks_queue.lock() )
		{
			loop
			{
				if( state_.shutdown_flag.read() )
				{
					break label main_loop;
				}

				var ust::optional</root_task_type/> mut next_task= l.deref().TryPop();

				if( !next_task.empty() )
				{
					move(l); // Unlock mutex as soon as possible.

					with( id : GetNewTaskId() )
					{
						tasks_map.insert_new( id, next_task.try_take() );

						// Initially a task is ready for execution (it waits for no event, no timeout, no socket, etc.).
						ready_for_execution_tasks.push_back( id );
					}
					break;
				}

				state_.tasks_queue_condition_variable.wait( l );
			}
		}

		// Execute all ready tasks.
		foreach( id : ready_for_execution_tasks )
		{
			{
				var root_task_type &mut task= tasks_map[id];

				// For now execute a task without any pause until it's possible.
				// Break early only if shudown is requested.
				loop
				{
					if( state_.shutdown_flag.read() )
					{
						break label main_loop;
					}

					if_coro_advance( v : task )
					{
						// The task is finished.
						ust::ignore_unused(v);
						break;
					}
				}
			}

			if( ust::coro_done( tasks_map[id] ) )
			{
				// Remove a finished task from the tasks container.
				tasks_map.drop_if_exists( id );
			}
		}

		// After we processed all tasks, there should be no task ready for execution.
		// This list may be populated later, like via "poll" call, timeout or something similar.
		ready_for_execution_tasks.clear();
	}

	// Perform cleanup steps.

	// Reset shared state global pointer.
	// It's strictly-speaking not necessary, but it's better to do so.
	unsafe{ g_current_runner_thread_shared_state= ust::nullptr</SharedState/>(); }

	return;
}

fn GetNewTaskId() : TaskUniqueId
{
	// Atomically increment global counter of tasks.
	// Return previous counter value.
	return unsafe( ust::atomic_inc( g_next_task_id ) );
}

// Start from 1, since 0 indicates no task.
var TaskUniqueId mut g_next_task_id= 1u64;

// Store here a raw pointer to shared state structure, when entering async function execution.
// Don't forget to zero it back when leaving an async function execution!
// Actual state isn't mutated by users of this variable.
thread_local $(SharedState) g_current_runner_thread_shared_state= zero_init;

fn add_task( root_task_type mut t )
{
	assert( !ust::coro_done( t ), "A finished task is added!" );

	unsafe
	{
		var $(SharedState) state_ptr= g_current_runner_thread_shared_state;
		assert( !ust::is_nullptr( state_ptr ), "The \"add_task\" function is called outside a runner thread!" );

		var SharedState& state= $>(state_ptr);

		with( mut l : state.tasks_queue.lock() )
		{
			if( state.shutdown_flag.read() )
			{
				// Do not add new tasks while shutting down.
				return;
			}

			l.deref().Push( move(t) );
			state.tasks_queue_condition_variable.notify_one();
		}
	}
}

} // namespace sm_async_net
