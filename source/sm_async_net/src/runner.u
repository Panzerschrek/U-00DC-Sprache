import "/assert.u"
import "/sm_async_net/runner.uh"
import "task_tree_node.uh"

namespace sm_async_net
{

fn runner::constructor()
	(
		state_
		{
			.tasks_queue( TasksQueue() ),
			.shutdown_flag( false ),
		},
		runner_thread_= ust::make_thread( RunnerThreadFunction( state_ ) )
	)
{
}

fn runner::destructor()
{
	// Set shudown flag first, than notify all runner threads waiting on the condition variable associated with the tasks queue.
	// Doing so we trigger stopping runner thread loops.
	// Do this under a lock to avoid race conditions with runner threads.
	with( l : state_.tasks_queue.lock() )
	{
		state_.shutdown_flag.write( true );
		state_.tasks_queue_condition_variable.notify_all();
	}

	// Destructors of runner threads execute "join" here. So we gracefully perform the shutdown sequence.
	// Generally it shouldn't be long, since runner threads may usually stop executing async functions after shutdown signal is set.
}

fn runner::add_task( this, root_task_type mut t )
{
	// Lock tasks queue, add a task and notify condition variable to wake one of the runner threads.
	auto mut l= state_.tasks_queue.lock();
	l.deref().Push( move(t) );
	state_.tasks_queue_condition_variable.notify_one();
}

op runner::RunnerThreadFunction::()( byval this )
{
	// Main runner loop.
	// Do not return from it, break instead!
	// It's necessary to perform necessary cleanup steps before exiting!
	loop label main_loop
	{
		var ust::optional</root_task_type/> mut next_task;

		// Lock tasks queue, try popping a task.
		// If no task is available, wait on condition variable for the tasks queue, than try popping a task again.
		// Break this loop if a new task is available or if shutdown flag is specified.
		// Since shutdown flag is set under the mutex lock, we are sure it's not possible for it to be changed between reading it and waiting on the condition variable.
		with( mut l : state_.tasks_queue.lock() )
		{
			loop
			{
				if( state_.shutdown_flag.read() )
				{
					break label main_loop;
				}

				next_task= l.deref().TryPop();

				if( !next_task.empty() )
				{
					break;
				}

				state_.tasks_queue_condition_variable.wait( l );
			}
		}

		var root_task_type &mut task= next_task.try_deref();

		// Set shared state global variable.
		// Since this global variable is thread-local and this function is running on a separate thread, it's not impossible here to overwrite someone else's variable instance.
		unsafe{ g_current_runner_thread_shared_state= $<( cast_mut(state_) ); }

		// For now execute a task without any pause until it's possible.
		// Break early only if shudown is requested.
		loop
		{
			if( state_.shutdown_flag.read() )
			{
				unsafe{ g_current_runner_thread_shared_state= ust::nullptr</SharedState/>(); }
				break label main_loop;
			}

			if_coro_advance( v : task )
			{
				ust::ignore_unused(v);
				break;
			}
		}

		unsafe{ g_current_runner_thread_shared_state= ust::nullptr</SharedState/>(); }
	}

	// Cleanup steps may be implemented here.
	return;
}

// Store here a raw pointer to shared state structure, when entering async function execution.
// Don't forget to zero it back when leaving an async function execution!
// Actual state isn't mutated by users of this variable.
thread_local $(SharedState) g_current_runner_thread_shared_state= zero_init;

fn add_task( root_task_type mut t )
{
	unsafe
	{
		var $(SharedState) state_ptr= g_current_runner_thread_shared_state;
		assert( !ust::is_nullptr( state_ptr ), "The \"add_task\" function is called outside a runner thread!" );

		var SharedState& state= $>(state_ptr);

		with( mut l : state.tasks_queue.lock() )
		{
			if( state.shutdown_flag.read() )
			{
				// Do not add new tasks while shutting down.
				return;
			}

			l.deref().Push( move(t) );
			state.tasks_queue_condition_variable.notify_one();
		}
	}
}

} // namespace sm_async_net
