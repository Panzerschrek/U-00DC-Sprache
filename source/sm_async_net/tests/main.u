import "/assert.u"
import "/enum_string_conversions.u"
import "/hash_set.u"
import "/main_wrapper.u"
import "/stdout.u"
import "/string_conversions.u"
import "/shared_barrier.u"
import "/sm_async_net/runner.uh"
import "/sm_async_net/udp_socket.uh"

pretty_main
{
	return sm_async_net::Main();
}

namespace sm_async_net
{

fn Main() : i32
{
	ust::stdout_print( "sm_async_net tests\n" );

	RunnerCreation_Test0::Run();
	RunnerTaskAdd_Test0::Run();
	RunnerTaskAdd_Test1::Run();
	RunnerTaskAdd_Test2::Run();
	RunnerTaskAdd_Test3::Run();
	AddTaskFreeFunction_Test0::Run();
	AddTaskFreeFunction_Test1::Run();
	UDPSocket_Test0::Run();
	UDPSocket_Test1::Run();
	UDPSocket_Test2::Run();
	UDPSocket_Test3::Run();
	UDPSocket_Test4::Run();

	return 0;
}

namespace RunnerCreation_Test0
{

fn Run()
{
	// Runner is default-constructible.

	var runner r;
}

}

namespace RunnerTaskAdd_Test0
{

fn Run()
{
	var runner r;

	// Adding a task doesn't require "r" instance to be mutable.
	r.add_task( Func() );
}

fn async Func() {}

}

namespace RunnerTaskAdd_Test1
{

fn Run()
{
	// Add a single task into a runner and wait for it to finish.

	var runner r;

	var ust::shared_atomic_variable</bool/> v(false);

	r.add_task( Func(v) );

	// Use a crude way to wait - via "thread_yield".
	while( !v.read() )
	{
		ust::yield_current_thread();
	}
}

fn async Func( ust::shared_atomic_variable</bool/> v )
{
	yield;
	yield;
	ust::stdout_print( "BasicRunnerAddAndEnsureExecutionFunc\n" );
	yield;
	yield;
	yield;
	ust::stdout_print( "BasicRunnerAddAndEnsureExecutionFunc - finish\n" );
	v.write( true );
}

}

namespace RunnerTaskAdd_Test2
{

fn Run()
{
	// Add multiple tasks into a runner and wait for them to finish.

	var runner r;

	var ust::shared_atomic_variable</u32/> v(0u);

	var u32 count= 1024u;

	for( auto mut i= 0u; i < count; ++i )
	{
		r.add_task( Func(v) );
	}

	// Use a crude way to wait - via "thread_yield".
	while( v.read() < count )
	{
		ust::yield_current_thread();
	}
}

fn async Func( ust::shared_atomic_variable</u32/> v )
{
	yield;
	v.inc();
	yield;
}

}

namespace RunnerTaskAdd_Test3
{

fn Run()
{
	// Add a single task having internal async calls into a runner and wait for it to finish.

	var runner r;

	var ust::shared_atomic_variable</bool/> v(false);

	r.add_task( Func0(v) );

	// Use a crude way to wait - via "thread_yield".
	while( !v.read() )
	{
		ust::yield_current_thread();
	}
}

fn async Func0( ust::shared_atomic_variable</bool/> mut v )
{
	Func1( move(v) ).await;
}

fn async Func1( ust::shared_atomic_variable</bool/> mut v )
{
	Func2( move(v) ).await;
}

fn async Func2( ust::shared_atomic_variable</bool/> mut v )
{
	Func3( move(v) ).await;
}

fn async Func3( ust::shared_atomic_variable</bool/> v )
{
	v.write( true );
}

}

namespace AddTaskFreeFunction_Test0
{

fn Run()
{
	// Add a task, which internally adds a new root task via "add_task" free function.

	var runner r;

	var ust::shared_atomic_variable</u32/> v(0u);

	r.add_task( Func0(v) );

	// Use a crude way to wait - via "thread_yield".
	while( v.read() != 3u )
	{
		ust::yield_current_thread();
	}
}

fn async Func0( ust::shared_atomic_variable</u32/> v )
{
	add_task( Func1( v ) );
	v.add( 1u );
}

fn async Func1( ust::shared_atomic_variable</u32/> v )
{
	v.add( 2u );
}

}

namespace AddTaskFreeFunction_Test1
{

fn Run()
{
	// Add several tasks, each of them internally adds several new root tasks via "add_task" free function.

	var runner r;

	var ust::shared_atomic_variable</u32/> v(0u);

	for( auto mut i= 0u; i < 4u; ++i )
	{
		r.add_task( Func0(v) );
	}

	// Use a crude way to wait - via "thread_yield".
	while( v.read() < 12u )
	{
		ust::yield_current_thread();
	}
}

fn async Func0( ust::shared_atomic_variable</u32/> v )
{
	for( auto mut i= 0u; i < 3u; ++i )
	{
		add_task( Func1( v ) );
	}
}

fn async Func1( ust::shared_atomic_variable</u32/> v )
{
	v.inc();
}

}

namespace UDPSocket_Test0
{

fn Run()
{
	// Create regular socket on the main thread, create an async one on runner thread.
	// Use blocking operation on the main thread.
	// Send a message using async UDP socket class, receive it using sync UDP socket class.

	var runner r;

	var ust::socket_address_v4 address( GetLoopbackIpAddress(), GetNextPort() );

	var ust::udp_socket mut server_socket= ust::udp_socket::create_and_bind( address ).try_take();

	r.add_task( Func( address ) );

	var [ char8, 32 ] mut buf= zero_init;

	result_match( server_socket.receive( ust::array_view_mut</char8/>(buf).to_byte8_range() ) )
	{
		Ok( bytes_received ) ->
		{
			assert( bytes_received == ust::string_view8(message).size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
			assert( ust::string_view8(buf).subrange_end( bytes_received ) == message, "Unexpected message!" );
		},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to receive message to from socket! Error code: ", ust::enum_to_string(e) ) );
		}
	}
}

auto& message= "Hello from async UDP socket!";

fn async Func( ust::socket_address_v4 server_address )
{
	var udp_socket mut client_socket= udp_socket::create_v4().try_take();

	var ust::string_view8 message_range= message;

	result_match( client_socket.send_to( server_address, message_range.to_byte8_range() ).await )
	{
		Ok( bytes_sent ) ->
		{
			assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
		},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
		}
	}
}

}

namespace UDPSocket_Test1
{

fn Run()
{
	// Create regular socket on the main thread, create an async one on runner thread.
	// Use blocking operation on the main thread.
	// Send a message using async UDP socket class, receive it using sync UDP socket class.
	// Connect socket first, before sending a message.

	var runner r;

	var ust::socket_address_v4 address( GetLoopbackIpAddress(), GetNextPort() );

	var ust::udp_socket mut server_socket= ust::udp_socket::create_and_bind( address ).try_take();

	r.add_task( Func( address ) );

	var [ char8, 64 ] mut buf= zero_init;

	result_match( server_socket.receive( ust::array_view_mut</char8/>(buf).to_byte8_range() ) )
	{
		Ok( bytes_received ) ->
		{
			assert( bytes_received == ust::string_view8(message).size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
			assert( ust::string_view8(buf).subrange_end( bytes_received ) == message, "Unexpected message!" );
		},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to receive message to from socket! Error code: ", ust::enum_to_string(e) ) );
		}
	}
}

auto& message= "Stich um Stich, meinen Wein kriegst du nicht!";

fn async Func( ust::socket_address_v4 server_address )
{
	var udp_socket mut client_socket= udp_socket::create_v4().try_take();

	result_match( client_socket.connect( server_address ) )
	{
		Ok( v ) -> { ust::ignore_unused(v); },
		Err( e ) -> { assert( false, ust::concat( "Failed to connect UDP socket! Error: ", ust::enum_to_string(e) ) ); }
	}

	var ust::string_view8 message_range= message;

	result_match( client_socket.send( message_range.to_byte8_range() ).await )
	{
		Ok( bytes_sent ) ->
		{
			assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
		},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
		}
	}
}

}

namespace UDPSocket_Test2
{

fn Run()
{
	// Create regular socket on the main thread, create an async one on runner thread.
	// Use blocking operation on the main thread.
	// Send a message using sync UDP socket class, receive it using async UDP socket class.

	var runner r;

	var ust::shared_barrier barrier( 2u );

	var ust::socket_address_v4 address( GetLoopbackIpAddress(), GetNextPort() );

	r.add_task( Func( barrier, address ) );

	var ust::udp_socket mut socket= ust::udp_socket::create_v4().try_take();

	barrier.wait();

	var ust::string_view8 message_buffer= message;

	assert( socket.send_to( address, message_buffer.to_byte8_range() ).try_take() == message_buffer.size() );

	barrier.wait();
}

auto& message= "1000 Milen und noch mehr - bis zum Ende dieser Welt.";

fn async Func( ust::shared_barrier barrier, ust::socket_address_v4 address )
{
	var udp_socket mut socket= udp_socket::create_and_bind( address ).try_take();

	barrier.wait();

	var [ char8, 64 ] mut buf= zero_init;

	var ust::string_view8 message_buffer= message;

	auto[ sender_address, size ]= socket.receive_from( ust::array_view_mut</char8/>( buf ).to_byte8_range() ).await.try_take();
	assert( size == message_buffer.size() );
	assert( ust::string_view8( buf ).subrange_end( size ) == message );

	barrier.wait();
}

}

namespace UDPSocket_Test3
{

fn Run()
{
	// Create regular socket on the main thread, create an async one on runner thread.
	// Use blocking operation on the main thread.
	// Send a message using sync UDP socket class, receive it using async UDP socket class.
	// Connect sender first.

	var runner r;

	var ust::shared_barrier barrier( 2u );

	var ust::socket_address_v4 address0( GetLoopbackIpAddress(), GetNextPort() );
	var ust::socket_address_v4 address1( GetLoopbackIpAddress(), GetNextPort() );

	r.add_task( Func( barrier, address0, address1 ) );

	var ust::udp_socket mut socket= ust::udp_socket::create_and_bind( address1 ).try_take();

	barrier.wait();

	var void v= socket.connect( address0 ).try_take();
	ust::ignore_unused(v);

	var ust::string_view8 message_buffer= message;

	assert( socket.send( message_buffer.to_byte8_range() ).try_take() == message_buffer.size() );

	barrier.wait();
}

auto& message= "Bis zu Unsterblichkeit!";

fn async Func( ust::shared_barrier barrier, ust::socket_address_v4 my_address, ust::socket_address_v4 other_address )
{
	var udp_socket mut socket= udp_socket::create_and_bind( my_address ).try_take();

	var void v= socket.connect( other_address ).try_take();
	ust::ignore_unused(v);

	barrier.wait();

	var [ char8, 64 ] mut buf= zero_init;

	var ust::string_view8 message_buffer= message;

	var size_type size = socket.receive( ust::array_view_mut</char8/>( buf ).to_byte8_range() ).await.try_take();
	assert( size == message_buffer.size() );
	assert( ust::string_view8( buf ).subrange_end( size ) == message );

	barrier.wait();
}

}

namespace UDPSocket_Test4
{

fn Run()
{
	// Create two tasks, each of them sends several messages to another.
	// At the end check if all expected messages are received.

	var runner r;

	var ust::shared_barrier barrier( 2u );

	var ust::socket_address_v4 address0( GetLoopbackIpAddress(), GetNextPort() );
	var ust::socket_address_v4 address1( GetLoopbackIpAddress(), GetNextPort() );

	r.add_task( Func( barrier, address0, address1 ) );
	r.add_task( Func( barrier, address1, address0 ) );

	barrier.wait();

	barrier.wait();
}

fn async Func( ust::shared_barrier barrier, ust::socket_address_v4 my_address, ust::socket_address_v4 other_address )
{
	var udp_socket mut socket= udp_socket::create_and_bind( my_address ).try_take();

	barrier.wait();

	var ust::hash_set</ust::string8/> mut expected_messages;
	expected_messages.insert( "Quick" );
	expected_messages.insert( "brown" );
	expected_messages.insert( "fox" );
	expected_messages.insert( "jumps" );
	expected_messages.insert( "over" );
	expected_messages.insert( "the" );
	expected_messages.insert( "lazy" );
	expected_messages.insert( "dog" );

	var ust::hash_set</ust::string8/> mut received_messages;

	var [ char8, 128 ] mut buf= zero_init;

	foreach( &message : expected_messages )
	{
		assert( socket.send_to( other_address, message.range().to_byte8_range() ).await.try_take() == message.size() );

		var size_type size= socket.receive( ust::array_view_mut</char8/>( buf ).to_byte8_range() ).await.try_take();

		received_messages.insert( ust::string_view8( buf ).subrange_end( size ) );
	}

	assert( expected_messages == received_messages );

	barrier.wait();
}

}

fn GetLoopbackIpAddress() : ust::ip_address_v4
{
	return ust::ip_address_v4( ust::make_array( 127u8, 0u8, 0u8, 1u8 ) );
}

fn GetNextPort() : u16
{
	unsafe
	{
		var u16 res= g_port_counter;
		++g_port_counter;
		return res;
	}
}

var u16 mut g_port_counter( 59000s + 500s * compiler::generation );

} // namespace sm_async_net
