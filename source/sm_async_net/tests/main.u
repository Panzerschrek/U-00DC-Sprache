import "/main_wrapper.u"
import "/stdout.u"
import "/sm_async_net/runner.uh"

pretty_main
{
	return sm_async_net::Main();
}

namespace sm_async_net
{

fn Main() : i32
{
	ust::stdout_print( "sm_async_net tests\n" );

	RunnerCreation_Test0::Run();
	RunnerTaskAdd_Test0::Run();
	RunnerTaskAdd_Test1::Run();
	RunnerTaskAdd_Test2::Run();
	RunnerTaskAdd_Test3::Run();
	AddTaskFreeFunction_Test0::Run();
	AddTaskFreeFunction_Test1::Run();

	return 0;
}

namespace RunnerCreation_Test0
{

fn Run()
{
	// Runner is default-constructible.

	var runner r;
}

}

namespace RunnerTaskAdd_Test0
{

fn Run()
{
	var runner r;

	// Adding a task doesn't require "r" instance to be mutable.
	r.add_task( Func() );
}

fn async Func() {}

}

namespace RunnerTaskAdd_Test1
{

fn Run()
{
	// Add a single task into a runner and wait for it to finish.

	var runner r;

	var ust::shared_atomic_variable</bool/> v(false);

	r.add_task( Func(v) );

	// Use a crude way to wait - via "thread_yield".
	while( !v.read() )
	{
		ust::yield_current_thread();
	}
}

fn async Func( ust::shared_atomic_variable</bool/> v )
{
	yield;
	yield;
	ust::stdout_print( "BasicRunnerAddAndEnsureExecutionFunc\n" );
	yield;
	yield;
	yield;
	ust::stdout_print( "BasicRunnerAddAndEnsureExecutionFunc - finish\n" );
	v.write( true );
}

}

namespace RunnerTaskAdd_Test2
{

fn Run()
{
	// Add multiple tasks into a runner and wait for them to finish.

	var runner r;

	var ust::shared_atomic_variable</u32/> v(0u);

	var u32 count= 1024u;

	for( auto mut i= 0u; i < count; ++i )
	{
		r.add_task( Func(v) );
	}

	// Use a crude way to wait - via "thread_yield".
	while( v.read() < count )
	{
		ust::yield_current_thread();
	}
}

fn async Func( ust::shared_atomic_variable</u32/> v )
{
	yield;
	v.inc();
	yield;
}

}

namespace RunnerTaskAdd_Test3
{

fn Run()
{
	// Add a single task having internal async calls into a runner and wait for it to finish.

	var runner r;

	var ust::shared_atomic_variable</bool/> v(false);

	r.add_task( Func0(v) );

	// Use a crude way to wait - via "thread_yield".
	while( !v.read() )
	{
		ust::yield_current_thread();
	}
}

fn async Func0( ust::shared_atomic_variable</bool/> mut v )
{
	Func1( move(v) ).await;
}

fn async Func1( ust::shared_atomic_variable</bool/> mut v )
{
	Func2( move(v) ).await;
}

fn async Func2( ust::shared_atomic_variable</bool/> mut v )
{
	Func3( move(v) ).await;
}

fn async Func3( ust::shared_atomic_variable</bool/> v )
{
	v.write( true );
}

}

namespace AddTaskFreeFunction_Test0
{

fn Run()
{
	// Add a task, which internally adds a new root task via "add_task" free function.

	var runner r;

	var ust::shared_atomic_variable</u32/> v(0u);

	r.add_task( Func0(v) );

	// Use a crude way to wait - via "thread_yield".
	while( v.read() != 3u )
	{
		ust::yield_current_thread();
	}
}

fn async Func0( ust::shared_atomic_variable</u32/> v )
{
	add_task( Func1( v ) );
	v.add( 1u );
}

fn async Func1( ust::shared_atomic_variable</u32/> v )
{
	v.add( 2u );
}

}

namespace AddTaskFreeFunction_Test1
{

fn Run()
{
	// Add several tasks, each of them internally adds several new root tasks via "add_task" free function.

	var runner r;

	var ust::shared_atomic_variable</u32/> v(0u);

	for( auto mut i= 0u; i < 4u; ++i )
	{
		r.add_task( Func0(v) );
	}

	// Use a crude way to wait - via "thread_yield".
	while( v.read() < 12u )
	{
		ust::yield_current_thread();
	}
}

fn async Func0( ust::shared_atomic_variable</u32/> v )
{
	for( auto mut i= 0u; i < 3u; ++i )
	{
		add_task( Func1( v ) );
	}
}

fn async Func1( ust::shared_atomic_variable</u32/> v )
{
	v.inc();
}

}

} // namespace sm_async_net
