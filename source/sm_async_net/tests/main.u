import "/main_wrapper.u"
import "/stdout.u"
import "/sm_async_net/runner.uh"

pretty_main
{
	return sm_async_net::Main();
}

namespace sm_async_net
{

fn Main() : i32
{
	ust::stdout_print( "sm_async_net tests\n" );

	BasicRunnerCreation();
	BasicRunnerTaskAdd();
	BasicRunnerAddAndEnsureExecution();

	return 0;
}

fn BasicRunnerCreation()
{
	var runner r;
}

fn BasicRunnerTaskAdd()
{
	var runner r;

	// Adding a task doesn't require "r" instance to be mutable.
	r.add_task( SimplesAsyncFunction() );
}

fn async SimplesAsyncFunction() {}

fn BasicRunnerAddAndEnsureExecution()
{
	var runner r;

	var ust::shared_atomic_variable</bool/> v(false);

	r.add_task( BasicRunnerAddAndEnsureExecutionFunc(v) );

	// Use a crude way to wait - via "thread_yield".
	while( !v.read() )
	{
		ust::yield_current_thread();
	}
}

fn async BasicRunnerAddAndEnsureExecutionFunc( ust::shared_atomic_variable</bool/> v )
{
	yield;
	yield;
	ust::stdout_print( "BasicRunnerAddAndEnsureExecutionFunc\n" );
	yield;
	yield;
	yield;
	ust::stdout_print( "BasicRunnerAddAndEnsureExecutionFunc - finish\n" );
	v.write( true );
}

} // namespace sm_async_net
