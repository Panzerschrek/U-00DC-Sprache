import "/shared_atomic_variable.u"
import "/shared_condition_variable.u"
import "/shared_ptr_final.u"
import "/shared_ptr_mt_mutex.u"
import "/thread.u"
import "queue.uh"

namespace sm_async_net
{

class runner
{
public:
	// Create runner instance, incliding background thread(s) for actual tasks running.
	fn constructor();

	// Destructor cancels all running tasks.
	fn destructor();

	// Add tasks for execution.
	// This function returns without waiting for task to finish.
	fn add_task( this, root_task_type t );

private:
	class RunnerThreadFunction
	{
	public:
		fn constructor( SharedState mut state )
			( state_= move(state) )
		{}

		// Thread entry point.
		op()( byval this );

	private:
		SharedState state_;
	}

private:
	SharedState state_;
	ust::thread</RunnerThreadFunction, void/> runner_thread_;
}

type root_task_type= (async : void);

// TODO - move internal structures definitions somewhere else.

type TasksQueue= Queue</root_task_type/>;
type TasksQueuePtr= ust::shared_ptr_mt_mutex</TasksQueue/>;
type TasksQueueConditionVariablePtr= ust::shared_condition_variable;
type ShutdownFlagPtr= ust::shared_atomic_variable</bool/>;

struct SharedState
{
	TasksQueuePtr tasks_queue;
	TasksQueueConditionVariablePtr tasks_queue_condition_variable;
	ShutdownFlagPtr shutdown_flag;
}

// Add a task into currently-active runner.
// This call is non-blocking, it doesn't wait until the added task is done.
// You should call this function only within another async task, so that the new one will be added into the same runner.
// The added task may be moved for execution to another thread.
// TODO - maybe return an error in case of addition fail?
fn add_task( root_task_type t );

} // namespace sm_async_net
