import "/shared_atomic_variable.u"
import "/shared_condition_variable.u"
import "/shared_ptr_final.u"
import "/shared_ptr_mt_mutex.u"
import "/thread.u"
import "queue.uh"

namespace sm_async_net
{

class runner
{
public:
	type root_task_type= (async : void);

public:
	// Create runner instance, incliding background thread(s) for actual tasks running.
	fn constructor();

	// Destructor cancels all running tasks.
	fn destructor();

	// Add tasks for execution.
	// This function returns without waiting for task to finish.
	fn add_task( this, root_task_type t );

private:
	type TasksQueue= Queue</root_task_type/>;
	type TasksQueuePtr= ust::shared_ptr_mt_mutex</TasksQueue/>;
	type TasksQueueConditionVariablePtr= ust::shared_condition_variable;
	type ShutdownFlagPtr= ust::shared_atomic_variable</bool/>;

	class RunnerThreadFunction
	{
	public:
		fn constructor(
			TasksQueuePtr mut tasks_queue,
			TasksQueueConditionVariablePtr mut tasks_queue_condition_variable,
			ShutdownFlagPtr mut shutdown_flag )
			(
				tasks_queue_= move(tasks_queue),
				tasks_queue_condition_variable_= move(tasks_queue_condition_variable),
				shutdown_flag_= move(shutdown_flag),

			)
		{}

		// Thread entry point.
		op()( byval this );

	private:
		TasksQueuePtr tasks_queue_;
		TasksQueueConditionVariablePtr tasks_queue_condition_variable_;
		ShutdownFlagPtr shutdown_flag_;
	}

private:
	TasksQueuePtr tasks_queue_;
	TasksQueueConditionVariablePtr tasks_queue_condition_variable_;
	ShutdownFlagPtr shutdown_flag_;
	ust::thread</RunnerThreadFunction, void/> runner_thread_;
}

} // namespace sm_async_net
