import "/box.u"

namespace sm_async_net
{

// Task type used by the runner class.
// Return type should be void, since runner shouldn't bother handling return values (it can't do so).
// It's not "non_sync", since a task may be passed to another thread for execution.
// Caputured references aren't supported, since passed task may outlive such captured references.
type root_task_type= (async : void);

// The main class, needed for async tasks execution.
// Usually you only need to create one runner.
//
// Use an interface for runner class to hide internals.
// It requires a little bit of overhead in "add_task" call, but this is not a huge problem.
class runner_interface interface
{
public:
	// Destructor cancels all running tasks.
	fn virtual destructor(){}

	// Add tasks for execution.
	// This function returns without waiting for task to finish.
	fn virtual pure add_task( this, root_task_type t );
}

// Create runner instance, incliding background thread(s) for actual tasks running.
fn create_runner() : ust::box</runner_interface/>;

// Add a task into currently-active runner.
// This call is non-blocking, it doesn't wait until the added task is done.
// You should call this function only within another async task, so that the new one will be added into the same runner.
// The added task may be moved for execution to another thread.
// TODO - maybe return an error in case of addition fail?
fn add_task( root_task_type t );

} // namespace sm_async_net
