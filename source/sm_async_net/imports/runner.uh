import "/assert.u"
import "/atomic_variable.u"
import "/coro.u"
import "/hash_map.u"
import "/shared_atomic_variable.u"
import "/shared_ptr_mt_final.u"
import "/shared_ptr_mt_mutex.u"
import "/file.u"
import "/native_socket.u"
import "/thread.u"
import "/variant.u"
import "queue.uh"

namespace sm_async_net
{

class runner
{
public:
	// Create runner instance, incliding background thread(s) for actual tasks running.
	fn constructor();

	// Destructor cancels all running tasks.
	fn destructor();

	// Add tasks for execution.
	// This function returns without waiting for task to finish.
	fn add_task( this, root_task_type t );

private:
	class RunnerThreadFunction
	{
	public:
		fn constructor( SharedState mut state, PollWakerSharedPtr mut waker )
			( state_= move(state), waker_= move(waker) )
		{}

		// Thread entry point.
		op()( byval this );

	private:
		SharedState state_;
		PollWakerSharedPtr waker_;
	}

private:
	SharedState state_;
	ust::thread</RunnerThreadFunction, void/> runner_thread_;
}

type root_task_type= (async : void);

// TODO - move internal structures definitions somewhere else.

type TasksQueue= Queue</root_task_type/>;
type TasksQueuePtr= ust::shared_ptr_mt_mutex</TasksQueue/>;
type ShutdownFlagPtr= ust::shared_atomic_variable</bool/>;

struct SharedState
{
	TasksQueuePtr tasks_queue;
	ust::vector</PollWakerSharedPtr/> runner_thread_wakers; // Wakers of all threads using this state.
	ShutdownFlagPtr shutdown_flag;
}

// Root task or subtask.
struct RunningTask
{
	// Task handle (what is executed).
	// Store async function object itself for root tasks,
	// store raw handle for tasks which are subtasks of other tasks and thus are owned by them (parent tasks are responsible for their deletion ).
	ust::variant</ tup[ root_task_type, ust::raw_coro_handle ] /> task;

	// If non-empty, this task shouldn't be resumed until given socket isn't ready.
	ust::optional</SocketForWaiting/> socket_to_wait; // TODO - use some sort of null socket value?

	// Connections to other tasks (parent, siblings, children).
	RunningTaskConnections connections;
}

struct RunningTaskConnections
{
	TaskUniqueId parent; // Zero for root task.
	TaskUniqueId prev_sibling; // Points to previous sibling or is zero if has no previous sibling or no siblings at all.
	TaskUniqueId next_sibling; // Points to next sibling or is zero if has no next sibling or no siblings at all.
	TaskUniqueId last_child; // The most recent added child, zero if has no children.
}

struct SocketForWaiting
{
	enum Operations{ Read, Write, ReadWrite }

	ust::native_socket_fd fd;
	Operations operations;
}

type TasksMap= ust::hash_map</TaskUniqueId, RunningTask/>;

// Class for internal usage.
// This class registers a socket operation to wait and un-registers it in its destructor.
// This destructor may be called in normal path (after a socket operation was performed successfully or with error), or in case of cancellation.
class TaskSocketOperationHolder
{
public:
	fn constructor( ust::native_socket_fd socket, SocketForWaiting::Operations operations ) unsafe
		( task_id_= unsafe( RegisterCurrentTaskSocketOperation( socket, operations ) ) )
	{
	}

	fn destructor()
	{
		unsafe( CancelTaskSocketOperation( task_id_ ) );
	}

private:
	TaskUniqueId task_id_;
}

// Register socket operation for currently running task.
// This function may be called only within a running task.
// It halts if current task already has an active socket operation or children tasks.
// It returns current task id.
fn RegisterCurrentTaskSocketOperation( ust::native_socket_fd socket, SocketForWaiting::Operations operations ) unsafe : TaskUniqueId;

// Cncels currently-active socket operation.
// This function may be called only within a running task - for this task or for its children.
fn CancelTaskSocketOperation( TaskUniqueId task_id ) unsafe;

// Add a subtask for currently-running task.
// The subtask added will be automatically removed after it finishes.
fn AddCurrentTaskSubtask( ust::raw_coro_handle handle ) unsafe;

// Call this in case of subtasks destruction.
// Don't call on normal subtasks completion.
// This function checks if it's valid to cancel a subtask, which is valid only during runner shutdown.
fn HandleTaskSubtasksCancellation() unsafe;

type PollWakerSharedPtr= ust::shared_ptr_mt_final</PollWaker/>;

class PollWaker
{
public:
	fn constructor();
	fn destructor();

	// Wake a thread, which is potentially waiting on "poll" and using the handle obtained via "GetWakeHandle" call in this "poll" call.
	fn Wake( this );

	// Reset awaken state.
	// You need to call it if "poll" indicates that data can be read from handle, returned via "GetWakeHandle" call.
	fn ResetWake( this );

	// Get handle used for "poll" call.
	fn GetWakeHandle( this ) : ust::native_file_handle;

private:
	ust::native_file_handle pipe_write_end_;
	ust::native_file_handle pipe_read_end_;
	ust::atomic_variable</bool/> wakeup_in_progress_;
}

// Each root task or subtask receives an unique identifier.
// This idintifier is unique even in different runner instances.
// Idenrifiers aren't recycled and reused.
// Zero indicates no task (it can't be assigned to some task).
type TaskUniqueId= u64;

// Add a task into currently-active runner.
// This call is non-blocking, it doesn't wait until the added task is done.
// You should call this function only within another async task, so that the new one will be added into the same runner.
// The added task may be moved for execution to another thread.
// TODO - maybe return an error in case of addition fail?
fn add_task( root_task_type t );

// Execute given two async functions concurrently, but on the same thread.
// Given async function objects should return value, not reference, returning references isn't supported.
template</type A, type B/>
fn async join_subtasks( ( async : A ) mut a, ( async : B ) mut b ) : tup[ A, B ]
{
	unsafe
	{
		var ust::raw_coro_handle handle_a= ust::get_raw_coro_handle(a);
		var ust::raw_coro_handle handle_b= ust::get_raw_coro_handle(b);

		// Ensure given async functions aren't done yet (we can resume them).
		halt if( coro_done_impl( handle_a ) );
		halt if( coro_done_impl( handle_b ) );

		// Register subtasks for given assync functions.
		AddCurrentTaskSubtask( handle_a );
		AddCurrentTaskSubtask( handle_b );

		// Use a helper class, which destroys result of the passed async function, if it's already finished.
		// This is needed to call destructor of the result value in case of cancellation.
		var AsyncFunctionObjectResultDestroyer</A/> mut destroyer_a( handle_a );
		var AsyncFunctionObjectResultDestroyer</B/> mut destroyer_b( handle_b );

		// Pause execution.
		// The runner should ensure it's resumed only after all subtasks are done.
		yield;

		assert( coro_done_impl( handle_a ) & coro_done_impl( handle_b ), "Subtasks execution method is resumed without waiting for subtasks to finish" );

		// TODO - prevent cancellation of this async function in normal case.

		// Now we don't need to destroy the results, but take them.
		move(destroyer_a).SkipDesruction();
		move(destroyer_b).SkipDesruction();

		// Extract results.

		var tup[ A, B ] mut res= uninitialized;

		ust::memory_copy_aligned(
			typeinfo</A/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[0]) ),
			ust::coro_return_value_address( a ),
			typeinfo</A/>.size_of );

		ust::memory_copy_aligned(
			typeinfo</B/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[1]) ),
			ust::coro_return_value_address( b ),
			typeinfo</B/>.size_of );

		return res;
	}
}

// A class which destroys result of the given async function, if it's finished.
// It's for internal usage only.
template</type T/>
class AsyncFunctionObjectResultDestroyer
{
public:
	// Construct with non-owning handle to async function returning a value (not reference) of type "T".
	fn constructor( ust::raw_coro_handle handle ) unsafe
		( handle_= handle )
	{}

	fn destructor()
	{
		unsafe
		{
			if( coro_done_impl( handle_ ) )
			{
				var $(byte8) mut ret_ptr= zero_init;

				switch( typeinfo</T/>.align_of )
				{
					1s -> { ret_ptr= coro_return_value_address_impl_align1( handle_ ); },
					2s -> { ret_ptr= coro_return_value_address_impl_align2( handle_ ); },
					4s -> { ret_ptr= coro_return_value_address_impl_align4( handle_ ); },
					8s -> { ret_ptr= coro_return_value_address_impl_align8( handle_ ); },
					16s -> { ret_ptr= coro_return_value_address_impl_align16( handle_ ); },
					default -> { ret_ptr= coro_return_value_address_impl_align16( handle_); },
				}

				var T &mut ret= $>( ust::byte_ptr_cast</T/>( ret_ptr ) );
				ust::call_destructor( ret );
			}
		}
	}

	// Call if if you need to take the result instead of ignoring it.
	fn SkipDesruction( byval mut this ) unsafe
	{
		unsafe( ust::move_into_nowhere( move(this) ) );
	}

private:
	ust::raw_coro_handle handle_;
}

} // namespace sm_async_net
