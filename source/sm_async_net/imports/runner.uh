import "/box.u"

namespace sm_async_net
{

// Use an interface for runner class to hide internals.
// It requires a little bit of overhead in "add_task" call, but this is not a huge problem.
class runner_interface interface
{
public:
	// Destructor cancels all running tasks.
	fn virtual destructor(){}

	// Add tasks for execution.
	// This function returns without waiting for task to finish.
	fn virtual pure add_task( this, root_task_type t );
}

// Create runner instance, incliding background thread(s) for actual tasks running.
fn create_runner() : ust::box</runner_interface/>;

type root_task_type= (async : void);

// Add a task into currently-active runner.
// This call is non-blocking, it doesn't wait until the added task is done.
// You should call this function only within another async task, so that the new one will be added into the same runner.
// The added task may be moved for execution to another thread.
// TODO - maybe return an error in case of addition fail?
fn add_task( root_task_type t );

} // namespace sm_async_net
