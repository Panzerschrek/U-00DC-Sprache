import "/atomic_variable.u"
import "/coro.u"
import "/hash_map.u"
import "/shared_atomic_variable.u"
import "/shared_ptr_mt_final.u"
import "/shared_ptr_mt_mutex.u"
import "/file.u"
import "/native_socket.u"
import "/thread.u"
import "/variant.u"
import "queue.uh"

namespace sm_async_net
{

class runner
{
public:
	// Create runner instance, incliding background thread(s) for actual tasks running.
	fn constructor();

	// Destructor cancels all running tasks.
	fn destructor();

	// Add tasks for execution.
	// This function returns without waiting for task to finish.
	fn add_task( this, root_task_type t );

private:
	class RunnerThreadFunction
	{
	public:
		fn constructor( SharedState mut state, PollWakerSharedPtr mut waker )
			( state_= move(state), waker_= move(waker) )
		{}

		// Thread entry point.
		op()( byval this );

	private:
		SharedState state_;
		PollWakerSharedPtr waker_;
	}

private:
	SharedState state_;
	ust::thread</RunnerThreadFunction, void/> runner_thread_;
}

type root_task_type= (async : void);

// TODO - move internal structures definitions somewhere else.

type TasksQueue= Queue</root_task_type/>;
type TasksQueuePtr= ust::shared_ptr_mt_mutex</TasksQueue/>;
type ShutdownFlagPtr= ust::shared_atomic_variable</bool/>;

struct SharedState
{
	TasksQueuePtr tasks_queue;
	ust::vector</PollWakerSharedPtr/> runner_thread_wakers; // Wakers of all threads using this state.
	ShutdownFlagPtr shutdown_flag;
}

// Root task or subtask.
struct RunningTask
{
	// Task handle (what is executed).
	// Store async function object itself for root tasks,
	// store raw handle for tasks which are subtasks of other tasks and thus are owned by them (parent tasks are responsible for their deletion ).
	ust::variant</ tup[ root_task_type, ust::raw_coro_handle ] /> task;

	// If non-empty, this task shouldn't be resumed until given socket isn't ready.
	ust::optional</SocketForWaiting/> socket_to_wait; // TODO - use some sort of null socket value?
}

struct SocketForWaiting
{
	enum Operations{ Read, Write, ReadWrite }

	ust::native_socket_fd fd;
	Operations operations;
}

type TasksMap= ust::hash_map</TaskUniqueId, RunningTask/>;

// Class for internal usage.
// This class registers a socket operation to wait and un-registers it in its destructor.
// This destructor may be called in normal path (after a socket operation was performed successfully or with error), or in case of cancellation.
class TaskSocketOperationHolder
{
public:
	fn constructor( ust::native_socket_fd socket, SocketForWaiting::Operations operations ) unsafe
		( task_id_= unsafe( RegisterCurrentTaskSocketOperation( socket, operations ) ) )
	{
	}

	fn destructor()
	{
		unsafe( CancelTaskSocketOperation( task_id_ ) );
	}

private:
	TaskUniqueId task_id_;
}

// Register socket operation for currently running task.
// This function may be called only within a running task.
// It halts if current task already has an active socket operation or children tasks.
// It returns current task id.
fn RegisterCurrentTaskSocketOperation( ust::native_socket_fd socket, SocketForWaiting::Operations operations ) unsafe : TaskUniqueId;

// Cncels currently-active socket operation.
// This function may be called only within a running task - for this task or for its children.
fn CancelTaskSocketOperation( TaskUniqueId task_id ) unsafe;

type PollWakerSharedPtr= ust::shared_ptr_mt_final</PollWaker/>;

class PollWaker
{
public:
	fn constructor();
	fn destructor();

	// Wake a thread, which is potentially waiting on "poll" and using the handle obtained via "GetWakeHandle" call in this "poll" call.
	fn Wake( this );

	// Reset awaken state.
	// You need to call it if "poll" indicates that data can be read from handle, returned via "GetWakeHandle" call.
	fn ResetWake( this );

	// Get handle used for "poll" call.
	fn GetWakeHandle( this ) : ust::native_file_handle;

private:
	ust::native_file_handle pipe_write_end_;
	ust::native_file_handle pipe_read_end_;
	ust::atomic_variable</bool/> wakeup_in_progress_;
}

// Each root task or subtask receives an unique identifier.
// This idintifier is unique even in different runner instances.
// Idenrifiers aren't recycled and reused.
// Zero indicates no task (it can't be assigned to some task).
type TaskUniqueId= u64;

// Add a task into currently-active runner.
// This call is non-blocking, it doesn't wait until the added task is done.
// You should call this function only within another async task, so that the new one will be added into the same runner.
// The added task may be moved for execution to another thread.
// TODO - maybe return an error in case of addition fail?
fn add_task( root_task_type t );

} // namespace sm_async_net
