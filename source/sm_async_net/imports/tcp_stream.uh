import "/tcp_stream.u"
import "runner.uh"

namespace sm_async_net
{

class tcp_stream
{
public:
	fn async connect( ust::socket_address& a ) : ust::io_result</tcp_stream/>
	{
		// TODO - implement proper async connection.
		result_unwrap_or_return( mut stream : ust::tcp_stream::connect( a ) );
		result_unwrap_or_return( v : stream.set_nonblocking( true ) );
		ust::ignore_unused(v);
		return unsafe( tcp_stream( move(stream) ) );
	}

	fn constructor( ust::tcp_stream s ) unsafe; // constructor for internal usage.

	fn async read( mut this, ust::array_view_mut</byte8/> buf ) : ust::io_result</size_type/>
	{
		// Try reading first, before waiting.
		// Doing so we avoid current task switching if data is already available.
		{
			var ust::io_result</size_type/> res= stream_.read( buf );
			if( res.is_ok() )
			{
				return res;
			}
			if( res.try_deref_error() != ust::io_error::would_block )
			{
				// Unexpected error code - return it.
				return res;
			}
		}

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream_.get_native_fd(), SocketForWaiting::Operations::Read );

			loop
			{
				// "WOULDBLOCK"/"EGAIN" error codes means that operation can't be performed yet.
				// We need to wait here.
				// If all works as expected, this async function will be resumed only when socket operation may be performed, but for case if it's not so, use a loop here.
				yield;

				var ust::io_result</size_type/> res= stream_.read( buf );
				if( res.is_ok() )
				{
					return res;
				}

				if( res.try_deref_error() != ust::io_error::would_block )
				{
					// Unexpected error code - return it.
					return res;
				}
			}
		}
	}

	fn async write( mut this, ust::array_view_imut</byte8/> buf ) : ust::io_result</size_type/>
	{
		// Optimistically expect that a write operation may be performed witohut blocking.
		// So we make a write request first, before going waiting.
		{
			var ust::io_result</size_type/> res= stream_.write( buf );
			if( res.is_ok() )
			{
				return res;
			}
			if( res.try_deref_error() != ust::io_error::would_block )
			{
				// Unexpected error code - return it.
				return res;
			}
		}

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream_.get_native_fd(), SocketForWaiting::Operations::Write );

			loop
			{
				// "WOULDBLOCK"/"EGAIN" error codes means that operation can't be performed yet.
				// We need to wait here.
				// If all works as expected, this async function will be resumed only when socket operation may be performed, but for case if it's not so, use a loop here.
				yield;

				var ust::io_result</size_type/> res= stream_.write( buf );
				if( res.is_ok() )
				{
					return res;
				}

				if( res.try_deref_error() != ust::io_error::would_block )
				{
					// Unexpected error code - return it.
					return res;
				}
			}
		}
	}

	fn async peek( mut this, ust::array_view_mut</byte8/> buf ) : ust::io_result</size_type/>
	{
		// Try reading first, before waiting.
		// Doing so we avoid current task switching if data is already available.
		{
			var ust::io_result</size_type/> res= stream_.peek( buf );
			if( res.is_ok() )
			{
				return res;
			}
			if( res.try_deref_error() != ust::io_error::would_block )
			{
				// Unexpected error code - return it.
				return res;
			}
		}

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream_.get_native_fd(), SocketForWaiting::Operations::Read );

			loop
			{
				// "WOULDBLOCK"/"EGAIN" error codes means that operation can't be performed yet.
				// We need to wait here.
				// If all works as expected, this async function will be resumed only when socket operation may be performed, but for case if it's not so, use a loop here.
				yield;

				var ust::io_result</size_type/> res= stream_.peek( buf );
				if( res.is_ok() )
				{
					return res;
				}

				if( res.try_deref_error() != ust::io_error::would_block )
				{
					// Unexpected error code - return it.
					return res;
				}
			}
		}
	}

	fn async close( byval mut this ) : ust::io_result</void/>
	{
		// TODO - implement proper async closing?
		return move(this).take_underlying_stream().close();
	}

	fn get_local_address( this ) : ust::io_result</ust::socket_address/>;
	fn get_peer_address( this ) : ust::io_result</ust::socket_address/>;

	fn get_ttl( this ) : ust::io_result</u8/>;
	fn set_ttl( mut this, u8 ttl ) : ust::io_result</void/>;

	fn get_nodelay( this ) : ust::io_result</bool/>;
	fn set_nodelay( mut this, bool nodelay ) : ust::io_result</void/>;

	// Get underlying stream.
	// Use it with caution, don't attempt to change it to non-blocking mode!
	fn get_uderlying_stream( this ) unsafe : ust::tcp_stream&;
	fn get_uderlying_stream( mut this ) unsafe : ust::tcp_stream &mut;

	fn take_underlying_stream( byval this ) : ust::tcp_stream;

private:
	ust::tcp_stream stream_;
}

} // namespace sm_async_net
