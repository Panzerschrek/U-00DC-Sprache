import "/box.u"

namespace sm_async_net
{

// Task type used by the runner class.
// Return type should be void, since runner shouldn't bother handling return values (it can't do so).
// It's not "non_sync", since a task may be passed to another thread for execution.
// Caputured references aren't supported, since passed task may outlive such captured references.
type root_task_type= (async : void);

// The main class, needed for async tasks execution.
// Usually you only need to create one runner.
//
// Use an interface for runner class to hide internals.
// It requires a little bit of overhead in "add_task" call, but this is not a huge problem.
class runner_interface interface
{
public:
	// Destructor cancels all running tasks.
	fn virtual destructor(){}

	// Add a task for execution.
	// This function returns without waiting for task to finish.
	// if you need to wait, you can use some synchrononization primitive in order to do this.
	//
	// Use this function with caution if large number of tasks are added.
	// There is no hard limit for task count, so adding too much tasks may lead to degraded performance up do denial of service.
	// If it may be a problem, consider implementing some sort of mechanism for monitoring the number of active/scheduled tasks and limiting them.
	//
	fn virtual pure add_task( this, root_task_type t );
}

// Create runner instance, incliding background thread(s) for actual tasks running.
fn create_runner() : ust::box</runner_interface/>;

// Create runner which uses multiple threads.
// You can create it for the numer of available CPU cores, using "ust::get_number_of_available_cpus" function.
fn create_multithreaded_runner( u32 num_threads ) : ust::box</runner_interface/>;

// Add a task into currently-active runner.
// It halts if it's called outside a runner thread, so you can call it only within an async function running on some runner.
// See "runner_interface::add_task" method for more details.
fn add_task( root_task_type t );

} // namespace sm_async_net
