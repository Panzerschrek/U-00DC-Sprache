import "/tcp_stream.u"
import "runner_internal.uh"

namespace sm_async_net
{

// Async version of TCP stream class.
// It mostly exposes the same API as ustlib version, but in async form.
// Some APIs are hidden, since they shouldn't be used diectly in async code.
// Note that async methods should be executed only within a task runner thread.
class tcp_stream
{
public:
	fn async connect( ust::socket_address& a ) : ust::io_result</tcp_stream/>
	{
		// Create stream without connecting it, make it non-blocking and then initiate connection.
		// Wait until it isn't done.

		result_unwrap_or_return( mut stream : ( a.has</ust::socket_address_v4/>() ? ust::tcp_stream::create_unconnected_v4() : ust::tcp_stream::create_unconnected_v6() ) );
		result_unwrap_or_return( v : stream.set_nonblocking( true ) );
		ust::ignore_unused( v );

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream.get_native_fd(), SocketOperationsForWaiting::Write );
			loop
			{
				var ust::io_result</void/> coonection_res= stream.connect_unconnected( a );
				if( coonection_res.is_ok() )
				{
					return tcp_stream( move(stream) );
				}

				var ust::io_error e= coonection_res.try_deref_error();
				if( e == ust::io_error::in_progress || e == ust::io_error::would_block )
				{

					// Wait until connection isn't completed.
					yield;
				}
				else
				{
					// Unexpected error code - return it.
					return e;
				}
			}
		}
	}

	fn constructor( ust::tcp_stream s ) unsafe; // constructor for internal usage.

	fn async read( mut this, ust::array_view_mut</byte8/> buf ) : ust::io_result</size_type/>
	{
		// Try reading first, before waiting.
		// Doing so we avoid current task switching if data is already available.
		{
			var ust::io_result</size_type/> res= stream_.read( buf );
			if( res.is_ok() )
			{
				return res;
			}
			if( res.try_deref_error() != ust::io_error::would_block )
			{
				// Unexpected error code - return it.
				return res;
			}
		}

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream_.get_native_fd(), SocketOperationsForWaiting::Read );

			loop
			{
				// "WOULDBLOCK"/"EGAIN" error codes mean that operation can't be performed yet.
				// We need to wait here.
				// If all works as expected, this async function will be resumed only when socket operation may be performed, but for case if it's not so, use a loop here.
				yield;

				var ust::io_result</size_type/> res= stream_.read( buf );
				if( res.is_ok() )
				{
					return res;
				}

				if( res.try_deref_error() != ust::io_error::would_block )
				{
					// Unexpected error code - return it.
					return res;
				}
			}
		}
	}

	fn async write( mut this, ust::array_view_imut</byte8/> buf ) : ust::io_result</size_type/>
	{
		// Optimistically expect that a write operation may be performed without blocking.
		// So we make a write request first, before going waiting.
		{
			var ust::io_result</size_type/> res= stream_.write( buf );
			if( res.is_ok() )
			{
				return res;
			}
			if( res.try_deref_error() != ust::io_error::would_block )
			{
				// Unexpected error code - return it.
				return res;
			}
		}

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream_.get_native_fd(), SocketOperationsForWaiting::Write );

			loop
			{
				// "WOULDBLOCK"/"EGAIN" error codes mean that operation can't be performed yet.
				// We need to wait here.
				// If all works as expected, this async function will be resumed only when socket operation may be performed, but for case if it's not so, use a loop here.
				yield;

				var ust::io_result</size_type/> res= stream_.write( buf );
				if( res.is_ok() )
				{
					return res;
				}

				if( res.try_deref_error() != ust::io_error::would_block )
				{
					// Unexpected error code - return it.
					return res;
				}
			}
		}
	}

	fn async peek( mut this, ust::array_view_mut</byte8/> buf ) : ust::io_result</size_type/>
	{
		// Try reading first, before waiting.
		// Doing so we avoid current task switching if data is already available.
		{
			var ust::io_result</size_type/> res= stream_.peek( buf );
			if( res.is_ok() )
			{
				return res;
			}
			if( res.try_deref_error() != ust::io_error::would_block )
			{
				// Unexpected error code - return it.
				return res;
			}
		}

		unsafe // Because of TaskSocketOperationHolder.
		{
			var TaskSocketOperationHolder op_holder( stream_.get_native_fd(), SocketOperationsForWaiting::Read );

			loop
			{
				// "WOULDBLOCK"/"EGAIN" error codes mean that operation can't be performed yet.
				// We need to wait here.
				// If all works as expected, this async function will be resumed only when socket operation may be performed, but for case if it's not so, use a loop here.
				yield;

				var ust::io_result</size_type/> res= stream_.peek( buf );
				if( res.is_ok() )
				{
					return res;
				}

				if( res.try_deref_error() != ust::io_error::would_block )
				{
					// Unexpected error code - return it.
					return res;
				}
			}
		}
	}

	fn async close( byval mut this ) : ust::io_result</void/>
	{
		// TODO - implement proper async closing?
		return move(this).take_underlying_stream().close();
	}

	fn get_local_address( this ) : ust::io_result</ust::socket_address/>;
	fn get_peer_address( this ) : ust::io_result</ust::socket_address/>;

	fn get_ttl( this ) : ust::io_result</u8/>;
	fn set_ttl( mut this, u8 ttl ) : ust::io_result</void/>;

	fn get_nodelay( this ) : ust::io_result</bool/>;
	fn set_nodelay( mut this, bool nodelay ) : ust::io_result</void/>;

	// Get underlying stream.
	// Use it with caution, don't attempt to change it to non-blocking mode!
	fn get_uderlying_stream( this ) unsafe : ust::tcp_stream&;
	fn get_uderlying_stream( mut this ) unsafe : ust::tcp_stream &mut;

	fn take_underlying_stream( byval this ) : ust::tcp_stream;

private:
	ust::tcp_stream stream_;
}

} // namespace sm_async_net
