import "/sm_async_net_sys/unix.uh"
import "poll_waker.uh"

namespace sm_async_net
{

fn PollWaker::constructor()
	( pipe_write_end_= zero_init, pipe_read_end_= zero_init, wakeup_in_progress_(false) )
{
	unsafe
	{
		var [ i32, 2 ] mut pipe_ends= zero_init;
		var i32 res= ::pipe2( $<(pipe_ends[0]), O_NONBLOCK );
		halt if( res != 0 );

		pipe_read_end_= pipe_ends[0];
		pipe_write_end_= pipe_ends[1];
	}
}

fn PollWaker::destructor()
{
	unsafe
	{
		::close( pipe_write_end_ );
		::close( pipe_read_end_ );
	}
}

fn PollWaker::Wake( this )
{
	if( wakeup_in_progress_.swap( true ) )
	{
		// Wakeup is already in progress, nothing to do.
		return;
	}

	// Write a single byte into the pipe, to trigger wakeup of a "poll" call waiting on the writing end.

	unsafe
	{
		var byte8 mut b= zero_init;
		var ssize_t res= ::write( pipe_write_end_, $<(b), size_t(1) );
		halt if( res != ssize_t(1) );
	}
}

fn PollWaker::ResetWake( this )
{
	if( !wakeup_in_progress_.swap( false ) )
	{
		// No wakeup was scheduled, don't need to cancel it.
		return;
	}

	// Read a single byte from the pipe, which should possible if previos wakeup was scheduled.

	unsafe
	{
		var byte8 mut b= zero_init;
		var ssize_t res= ::read( pipe_read_end_, $<(b), size_t(1) );
		// "res" may be still zero, if previous "write" result didn't come yet.
		ust::ignore_unused( res );
	}
}

fn PollWaker::GetWakeHandle( this ) : ust::native_file_handle
{
	return pipe_read_end_;
}

} // namespace sm_async_net
