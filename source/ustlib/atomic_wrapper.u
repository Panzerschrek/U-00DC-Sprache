import "atomic.u"
import "container_utils.u"
import "reference_notation.u"

namespace ust
{

// A helper class for passing atomic variables to different threads.
// It holds an immutable reference to given atomic variable, but allows to modify it by using some black-magic techniques.
// It works for now only for types on which atomic operations are supported.
template</type T/>
class atomic_wrapper
{
public:
	static_assert( typeinfo</T/>.is_fundamental && typeinfo</T/>.is_integer, "Only integer is_fundamental types are allowed in this class" );

public:
	// Consttruct this wrapper with a reference to mutable atomic variable.
	// But result container will hold immutable logical reference
	fn constructor( mut this, T &mut x ) @( reference_notation::pollution::param0_param_1_reference )
		( ptr_= $<(x) )
	{
	}

	fn load( this ) : T
	{
		return atomic_read( unsafe( $>(ptr_) ) );
	}

	fn store( this, T x )
	{
		atomic_write( unsafe( $>(ptr_) ), x );
	}

	fn add( this, T x ) : T
	{
		return atomic_add( unsafe( $>(ptr_) ), x );
	}

	fn sub( this, T x ) : T
	{
		return atomic_sub( unsafe( $>(ptr_) ), x );
	}

	fn inc( this ) : T
	{
		return atomic_inc( unsafe( $>(ptr_) ) );
	}

	fn dec( this ) : T
	{
		return atomic_dec( unsafe( $>(ptr_) ) );
	}


private:
	// Use immutable tag in order to hold immutable logical reference.
	ReferenceContainerTag</ T, false /> container_tag_;
	$(T) ptr_;
}

} // namespace ust
