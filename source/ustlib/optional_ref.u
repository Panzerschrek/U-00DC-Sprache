import "container_utils.u"

namespace ust
{

struct null_optional_ref_type{}
var null_optional_ref_type constexpr null_optional_ref{};

// Optional reference.
template</ type T, bool is_mutable />
class optional_ref
{
public:
	type this_type= optional_ref</T, is_mutable/>;

	fn constructor( this_type &imut other )= default;
	op=( mut this, this_type &imut other )= default;

	// Default constructor - set to zero
	fn constructor()
		( ptr_= zero_init )
	{}

	// Use this conversion constructor in order to use simple "ust::null_optional_ref" to pass/return empty optional_ref, without specifying exact optional_ref type.
	fn conversion_constructor( null_optional_ref_type n )
		( ptr_= zero_init )
	{}

	// Construct from reference
	fn enable_if( is_mutable )
	constructor( mut this'x', T &'y  mut ref ) ' x <- y '
		( ptr_= $<(ref) )
	{
	}

	// Construct 'imut' reference from 'mut' reference.
	fn enable_if( !is_mutable )
	constructor( mut this'x', T &'y imut ref ) ' x <- y '
		( ptr_= $<( unsafe( cast_mut(ref) ) ) )
	{
	}

	// Construct form raw pointer. Pointer should be valid or should be null.
	fn constructor( $(T) ptr ) unsafe
	( ptr_= ptr )
	{}

	// Assign 'mut' reference to 'imut' reference.
	op enable_if( !is_mutable )
	=( mut this'x', optional_ref</ T, true />& other'y' ) ' x <- y'
	{
		this.ptr_= unsafe( other.get_ptr() );
	}

	op=( mut this, null_optional_ref_type n )
	{
		reset();
	}

	fn empty( this ) : bool
	{
		return is_nullptr(ptr_);
	}

	fn enable_if( is_mutable )
	try_deref( this'x' ) : T &'x mut
	{
		halt if(empty());
		return unsafe( deref_unchecked() );
	}

	fn enable_if( !is_mutable )
	try_deref( this'x' ) : T &'x imut
	{
		halt if(empty());
		return unsafe( deref_unchecked() );
	}

	fn enable_if( is_mutable )
	deref_unchecked( this'x' ) unsafe : T &'x mut
	{
		return unsafe( $>(ptr_) );
	}

	fn enable_if( !is_mutable )
	deref_unchecked( this'x' ) unsafe : T &'x imut
	{
		return unsafe( $>(ptr_) );
	}

	// Get raw pointer. Returns null if empty.
	fn get_ptr( this ) unsafe : $(T)
	{
		return ptr_;
	}

	fn reset( mut this )
	{
		ptr_= nullptr</T/>();
	}

	fn enable_if( is_mutable )
	reset( mut this'x', T &'y  mut ref ) ' x <-  y '
	{
		ptr_= $<(ref);
	}

	fn enable_if( !is_mutable )
	reset( mut this'x', T &'y imut ref ) ' x <- y '
	{
		ptr_= $<( unsafe( cast_mut(ref) ) );
	}

	// Compare with null optional_ref. Result is true if optional_ref is empty.

	op==( this_type& l, null_optional_ref_type n ) : bool
	{
		return l.empty();
	}

	op==( null_optional_ref_type n, this_type& r ) : bool
	{
		return r.empty();
	}

private:
	ReferenceContainerTag</ T, is_mutable /> container_tag_;
	$(T) ptr_;
}

template</ type T />
type optional_ref_mut = optional_ref</T, true />;

template</ type T />
type optional_ref_imut= optional_ref</T, false/>;

} // namespace ust
