import "helpers.u"
import "memory.u"

namespace ust
{

// Place this struct inside each containter.
template</ type T /> struct ContainerTag{ [ T, 0 ] dummy; }

template</ type T />
struct ReferenceContainerTag</ T, false />
{
	struct Impl{ T &imut r; }
	[ Impl, 0 ] dummy;
}

template</ type T />
struct ReferenceContainerTag</ T, true  />
{
	struct Impl{ T & mut r; }
	[ Impl, 0 ] dummy;
}

template</ type T />
fn call_destructor( T&mut t ) unsafe
{
	static_if( typeinfo</T/>.is_class )
	{
		// In case of polymorph class virtual destructor (with address correction, if necessary) will be called.
		unsafe( t.destructor() );
	}
	else static_if( typeinfo</T/>.is_array )
	{
		for( var size_type mut i(0); i < typeinfo</T/>.element_count; ++i )
		{
			unsafe( ust::call_destructor( t[i] ) );
		}
	}
	else static_if( typeinfo</T/>.is_tuple )
	{
		for( &mut el : t )
		{
			unsafe( ust::call_destructor( el ) );
		}
	}
	else static_if(
		typeinfo</T/>.is_fundamental ||
		typeinfo</T/>.is_function_pointer ||
		typeinfo</T/>.is_raw_pointer ||
		typeinfo</T/>.is_enum )
	{
		// Destructor for these types kind is trivial.
		ignore_unused(t);
	}
	else
	{
		static_assert( false, "Undhandled type kind!" );
	}
}

template</ type T />
fn call_default_constructor( T&mut t ) unsafe
{
	static_assert( typeinfo</T/>.is_default_constructible, "expected default-constructible type" );

	static_if( typeinfo</T/>.is_class )
	{
		unsafe( t.constructor() );
	}
	else static_if( typeinfo</T/>.is_array )
	{
		for( var size_type mut i(0); i < typeinfo</T/>.element_count; ++i )
		{
			unsafe( ust::call_default_constructor( t[i] ) );
		}
	}
	else static_if( typeinfo</T/>.is_tuple )
	{
		for( &mut el : t )
		{
			unsafe( ust::call_default_constructor( el ) );
		}
	}
}

fn move_into_nowhere_impl(){}

template</ type T />
fn move_into_nowhere( T mut t ) unsafe
{
	// Hack! Use function pointer conversions to call () function as (T) function.
	// It works, because compiler uses "c calling convention".
	var ( fn( T t ) ) mut ptr= zero_init;
	unsafe{  cast_ref_unsafe</ fn() />(ptr)= (fn())(move_into_nowhere_impl);  }
	ptr( move(t) );
}

template</ type T />
fn move_into_uninitialized( T& mut uninitialized_dst, T mut src ) unsafe
{
	unsafe
	{
		memory_copy_aligned( typeinfo</T/>.align_of, cast_ref_unsafe</byte8/>( uninitialized_dst ), cast_ref_unsafe</byte8/>( src ), typeinfo</T/>.size_of );
		move_into_nowhere( move(src) );
	}
}

} // namespace ust
