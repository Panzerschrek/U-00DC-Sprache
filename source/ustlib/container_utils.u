import "helpers.u"
import "memory.u"

namespace ust
{

// Place this struct inside containers, that store some type indirectly - vai internal buffer or heap memory.
// This is needed in order to propagate reference tags and non_sync tags.
// Avoid using this for containers, that are used for recursive structs (including indirectly-recursive), use manual non_sync tag propagation instead.
template</ type T /> struct ContainerTag{ [ T, 0 ] dummy; }

// Use reference tag for types, that are logically store reference to some type.
// This is needed to ensure reference tags and non_sync tags propagation.
template</ type T />
struct ReferenceContainerTag</ T, false />
{
	struct Impl{ T &imut r; }
	[ Impl, 0 ] dummy;
}

template</ type T />
struct ReferenceContainerTag</ T, true  />
{
	struct Impl{ T & mut r; }
	[ Impl, 0 ] dummy;
}

template</ type T />
fn call_destructor( T&mut t ) unsafe
{
	static_if( typeinfo</T/>.is_class )
	{
		// In case of polymorph class virtual destructor (with address correction, if necessary) will be called.
		unsafe( t.destructor() );
	}
	else static_if( typeinfo</T/>.is_array )
	{
		for( var size_type mut i(0); i < typeinfo</T/>.element_count; ++i )
		{
			unsafe( call_destructor( t[i] ) );
		}
	}
	else static_if( typeinfo</T/>.is_tuple )
	{
		for( &mut el : t )
		{
			unsafe( call_destructor( el ) );
		}
	}
	else static_if(
		typeinfo</T/>.is_fundamental ||
		typeinfo</T/>.is_function_pointer ||
		typeinfo</T/>.is_raw_pointer ||
		typeinfo</T/>.is_enum )
	{
		// Destructor for these types kind is trivial.
		ignore_unused(t);
	}
	else
	{
		static_assert( false, "Undhandled type kind!" );
	}
}

template</ type T />
fn call_default_constructor( T&mut t ) unsafe
{
	static_assert( typeinfo</T/>.is_default_constructible, "expected default-constructible type" );

	static_if( typeinfo</T/>.is_class )
	{
		unsafe( t.constructor() );
	}
	else static_if( typeinfo</T/>.is_array )
	{
		for( var size_type mut i(0); i < typeinfo</T/>.element_count; ++i )
		{
			unsafe( call_default_constructor( t[i] ) );
		}
	}
	else static_if( typeinfo</T/>.is_tuple )
	{
		for( &mut el : t )
		{
			unsafe( call_default_constructor( el ) );
		}
	}
}

fn move_into_nowhere_impl(){}

template</ type T />
fn move_into_nowhere( T mut t ) unsafe
{
	// Hack! Use function pointer conversions to call () function as (T) function.
	// It works, because compiler uses "c calling convention".
	var ( fn( T t ) ) mut ptr= zero_init;
	unsafe{  cast_ref_unsafe</ fn() />(ptr)= (fn())(move_into_nowhere_impl);  }
	ptr( move(t) );
}

template</ type T />
fn move_into_uninitialized( T& mut uninitialized_dst, T mut src ) unsafe
{
	unsafe
	{
		memory_copy_aligned( typeinfo</T/>.align_of, ptr_cast_to_byte</byte8/>( $<(uninitialized_dst) ), ptr_cast_to_byte</byte8/>( $<(src) ), typeinfo</T/>.size_of );
		move_into_nowhere( move(src) );
	}
}

// Use this function to initialize a value with actually uninitialized data.
// This is helpful in constructor initializer list, where using "uninitialized" initializer syntactically isn't possible,
// but it's possible to call unsafe functions.
// Initializing a variable with such function call requires "memcpy",
// but it's effectively eliminated by LLVM optimization passes, because "memcpy" with uninitialized data as source has no effect.
template</type T/>
fn get_uninitialized_value() unsafe : T
{
	unsafe
	{
		var T s= uninitialized;
		return s;
	}
}

fn constexpr get_vector_first_allocation_size( size_type element_size ) : size_type
{
	if     ( element_size ==  0s ) { return ~0s; } // Max for zero-sized elements.
	else if( element_size >= 16s ) { return  1s; }
	else { return 16s / element_size; }
}

} // namespace ust
