import "compare.u"
import "random_access_range.u"

namespace ust
{

namespace binary_heap
{

// sort_by_key overloading for containers
template</type T, type KeyProvider/>
fn sort_by_key( T &mut container, KeyProvider mut key_provider )
{
	sort_by_key( container.range(), move(key_provider) );
}

// Sort by key obtained via given key provider function.
// This function accepts a single value and should return a value or a reference with operator <=> defined for its type.
template</type T, type KeyProvider/>
fn sort_by_key( random_access_range</T, true/> range, KeyProvider mut key_provider )
{
	sort( range, compare_by_key</T, KeyProvider/>{ .key_provider= move(key_provider) } );
}

template</type T, size_type S/>
fn sort( [ T, S ] &mut arr )
{
	sort( array_view_mut</T/>( arr ), default_compare</T/>() );
}

// Generic sort overloading for types other than "random_access_range".
// It works only for types with "range" method returing proper "random_access_range" - like "vector" or "string".
template</type T/>
fn sort( T &mut container )
{
	sort( container.range() );
}

template</type T/>
fn sort( array_view_mut</T/> range )
{
	sort( range, default_compare</T/>() );
}

template</type T, type Compare/>
fn sort( array_view_mut</T/> range, Compare& comp )
{
	make_heap( range, comp );

	for( auto mut s= range.size(); s > 1s; --s )
	{
		// We ensure here that range passed to this function contains at least two elements.
		unsafe( pop_heap_unchecked( range.subrange_end(s), comp ) );
	}
}

// Given range shouldn't be empty, otherwise this function halts.
template</type T, type Compare/>
fn push_heap( array_view_mut</T/> range, Compare& comp )
{
	halt if( range.empty() );
	unsafe( push_heap_unchecked( range, comp ) );
}

// Given range shouldn't be empty.
template</type T, type Compare/>
fn push_heap_unchecked( array_view_mut</T/> range, Compare& comp ) unsafe
{
	unsafe
	{
		// Use here raw pointer operations for better performance.

		var $(T) ptr= range.data();
		auto mut index= range.size() - 1s;

		while( index > 0s )
		{
			auto parent_index= (index - 1s) >> 1s;

			var T &mut el_parent= $>(ptr + parent_index);
			var T &mut el= $>(ptr + index);

			if( safe( comp( el_parent, el ) ) )
			{
				swap( el_parent, el ); // It's fine to call this function, since elements are at different address.
				index= parent_index;
			}
			else
			{
				break;
			}
		}
	}
}

// Given range shouldn't be empty, otherwise this function halts.
template</type T, type Compare/>
fn pop_heap( array_view_mut</T/> range, Compare& comp )
{
	halt if( range.empty() );
	if( range.size() == 1s )
	{
		return; // Nothing to do.
	}
	unsafe( pop_heap_unchecked( range, comp ) );
}

// Given range shouldn contain at least two elements.
template</type T, type Compare/>
fn pop_heap_unchecked( array_view_mut</T/> range, Compare& comp ) unsafe
{
	unsafe
	{
		// Use here raw pointer operations for better performance.

		var $(T) ptr= range.data();
		auto last= range.size() - 1s;

		swap( $>(ptr), $>(ptr + last) ); // It's fine to call this function, since elements are at different address.

		auto mut index= 0s;

		loop
		{
			auto child0_index= (index << 1s) + 1s;
			auto child1_index= (index << 1s) + 2s;
			if( child0_index >= last )
			{
				// No children at all.
				break;
			}

			var T &mut el= $>(ptr + index);
			var T &mut el_child0= $>(ptr + child0_index);

			if( child1_index >= last )
			{
				// Single child.
				if( safe( comp( el, el_child0 ) ) )
				{
					swap( el, el_child0 ); // It's fine to call this function, since elements are at different address.
				}
				break;
			}

			var T &mut el_child1= $>(ptr + child1_index);

			if( safe( !comp( el, el_child0 ) && !comp( el, el_child1 ) ) )
			{
				break;
			}

			if( safe( comp( el_child0, el_child1 ) ) )
			{
				swap( el, el_child1 ); // It's fine to call this function, since elements are at different address.
				index= child1_index;
			}
			else
			{
				swap( el, el_child0 ); // It's fine to call this function, since elements are at different address.
				index= child0_index;
			}
		}
	}
}

template</type T, type Compare/>
fn make_heap( array_view_mut</T/> range, Compare& comp )
{
	for( auto mut i= 1s; i < range.size(); ++i )
	{
		// We ensure here that passed range isn't empty.
		unsafe( push_heap_unchecked( range.subrange_end( i + 1s ), comp ) );
	}
}

} // namespace binary_heap

} // namespace ust
