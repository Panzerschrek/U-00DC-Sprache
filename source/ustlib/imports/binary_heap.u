import "compare.u"
import "random_access_range.u"

namespace ust
{

namespace binary_heap
{

// sort_by_key overloading for containers
template</type T, type KeyProvider/>
fn sort_by_key( T &mut container, KeyProvider mut key_provider )
{
	sort_by_key( container.range(), move(key_provider) );
}

// Sort by key obtained via given key provider function.
// This function accepts a single value and should return a value or a reference with operator <=> defined for its type.
template</type T, type KeyProvider/>
fn sort_by_key( random_access_range</T, true/> range, KeyProvider mut key_provider )
{
	sort( range, compare_by_key</T, KeyProvider/>{ .key_provider= move(key_provider) } );
}

template</type T, size_type S/>
fn sort( [ T, S ] &mut arr )
{
	sort( array_view_mut</T/>( arr ), default_compare</T/>() );
}

// Generic sort overloading for types other than "random_access_range".
// It works only for types with "range" method returing proper "random_access_range" - like "vector" or "string".
template</type T/>
fn sort( T &mut container )
{
	sort( container.range() );
}

template</type T/>
fn sort( array_view_mut</T/> range )
{
	sort( range, default_compare</T/>() );
}

template</type T, type Compare/>
fn sort( array_view_mut</T/> range, Compare& comp )
{
	make_heap( range, comp );

	for( auto mut s= range.size(); s > 1s; --s )
	{
		// We ensure here that range passed to this function contains at least two elements.
		unsafe( pop_heap_unchecked( range.subrange_end(s), comp ) );
	}
}

// Given range shouldn't be empty, otherwise this function halts.
template</type T, type Compare/>
fn push_heap( array_view_mut</T/> range, Compare& comp )
{
	halt if( range.empty() );
	unsafe( push_heap_unchecked( range, comp ) );
}

// Given range shouldn't be empty.
template</type T, type Compare/>
fn push_heap_unchecked( array_view_mut</T/> range, Compare& comp ) unsafe
{
	unsafe
	{
		// Use here raw pointer operations for better performance.

		var $(T) ptr= range.data();
		auto mut index= range.size() - 1s;

		while( index > 0s )
		{
			auto parent_index= (index - 1s) >> 1s;

			var T &mut el_parent= $>(ptr + parent_index);
			var T &mut el= $>(ptr + index);

			if( safe( comp( el_parent, el ) ) )
			{
				swap( el_parent, el ); // It's fine to call this function, since elements are at different address.
				index= parent_index;
			}
			else
			{
				break;
			}
		}
	}
}

// Given range shouldn't be empty, otherwise this function halts.
template</type T, type Compare/>
fn pop_heap( array_view_mut</T/> range, Compare& comp )
{
	halt if( range.empty() );
	if( range.size() == 1s )
	{
		return; // Nothing to do.
	}
	unsafe( pop_heap_unchecked( range, comp ) );
}

// Given range shouldn contain at least two elements.
template</type T, type Compare/>
fn pop_heap_unchecked( array_view_mut</T/> range, Compare& comp ) unsafe
{
	unsafe
	{
		// Use here raw pointer operations for better performance.

		var $(T) ptr= range.data();
		auto last= range.size() - 1s;

		auto constexpr element_size= typeinfo</T/>.size_of;
		auto constexpr element_alignment= typeinfo</T/>.align_of;
		var aligned_storage</ element_size, element_alignment /> mut top_element_storage= uninitialized;
		memory_copy_aligned( element_alignment, ptr_cast_to_byte8( $<(top_element_storage) ), ptr_cast_to_byte8( ptr ), element_size );

		auto mut index= 0s;

		loop
		{
			auto child0_index= (index << 1s) + 1s;
			auto child1_index= (index << 1s) + 2s;
			if( child0_index >= last )
			{
				// No children at all.
				break;
			}

			if( child1_index >= last )
			{
				// Single child.
				memory_copy_aligned( element_alignment, ptr_cast_to_byte8( ptr + index ), ptr_cast_to_byte8( ptr + child0_index ), element_size );
				index= child0_index;
				break;
			}

			if( safe( comp( unsafe( $>(ptr + child0_index) ), unsafe( $>(ptr + child1_index) ) ) ) )
			{
				memory_copy_aligned( element_alignment, ptr_cast_to_byte8( ptr + index ), ptr_cast_to_byte8( ptr + child1_index ), element_size );
				index= child1_index;
			}
			else
			{
				memory_copy_aligned( element_alignment, ptr_cast_to_byte8( ptr + index ), ptr_cast_to_byte8( ptr + child0_index ), element_size );
				index= child0_index;
			}
		}

		if( index != last )
		{
			memory_copy_aligned( element_alignment, ptr_cast_to_byte8( ptr + index ), ptr_cast_to_byte8( ptr + last ), element_size );
			while( index > 0s )
			{
				auto parent_index= (index - 1s) >> 1s;

				var T &mut el_parent= $>(ptr + parent_index);
				var T &mut el= $>(ptr + index);

				if( safe( comp( el_parent, el ) ) )
				{
					swap( el_parent, el ); // It's fine to call this function, since elements are at different address.
					index= parent_index;
				}
				else
				{
					break;
				}
			}
		}

		memory_copy_aligned( element_alignment, ptr_cast_to_byte8( ptr + last ), ptr_cast_to_byte8( $<(top_element_storage) ), element_size );
	}
}

template</type T, type Compare/>
fn make_heap( array_view_mut</T/> range, Compare& comp )
{
	for( auto mut i= 1s; i < range.size(); ++i )
	{
		// We ensure here that passed range isn't empty.
		unsafe( push_heap_unchecked( range.subrange_end( i + 1s ), comp ) );
	}
}

} // namespace binary_heap

} // namespace ust
