import "assert.u"
import "compare.u"
import "random_access_range.u"

namespace ust
{

namespace binary_search
{

// Find index of the first element which is greater than given value.
// Returns range size if not found.
template</type T, type Compare/>
fn first_greater( array_view_imut</T/> r, T& el, Compare& comp ) : size_type
{
	var size_type mut begin= 0s, mut end= r.size();
	while( begin < end )
	{
		debug_assert( begin < r.size() );
		debug_assert( end <= r.size() );

		var size_type middle= begin + ((end - begin) >> 1u);
		debug_assert( middle >= begin && middle < end );

		// Use unchecked indexing for better performance.
		if( comp( el, unsafe( r.index_unchecked(middle) ) ) )
		{
			end= middle;
		}
		else
		{
			begin= middle + 1s;
		}
	}

	debug_assert( begin <= r.size() );
	return begin;
}

// Search using key obtained via given key provider function.
template</type T, type KeyProvider/>
fn first_greater_by_key( array_view_imut</T/> r, T& el, KeyProvider mut key_provider ) : size_type
{
	return first_greater( r, el, compare_by_key</T, KeyProvider/>{ .key_provider= move(key_provider) } );
}

template</type T/>
fn first_greater( array_view_imut</T/> r, T& el ) : size_type
{
	return first_greater</T/>( r, el, default_compare</T/>() );
}

template</type T/>
fn first_greater( array_view_mut</T/> r, T& el ) : size_type
{
	return first_greater</T/>( array_view_imut</T/>(r), el );
}

template</type T, size_type S/>
fn first_greater( [T, S]& arr, T& el ) : size_type
{
	return first_greater</T/>( array_view_imut</T/>(arr), el );
}

// Find index of the first element which is greater than given value or equal to it.
// Returns range size if not found.
template</type T, type Compare/>
fn first_greater_or_equal( array_view_imut</T/> r, T& el, Compare& comp ) : size_type
{
	var size_type mut begin= 0s, mut end= r.size();
	while( begin < end )
	{
		debug_assert( begin < r.size() );
		debug_assert( end <= r.size() );

		var size_type middle= begin + ((end - begin) >> 1u);
		debug_assert( middle >= begin && middle < end );

		// Use unchecked indexing for better performance.
		if( comp( unsafe( r.index_unchecked(middle) ), el ) )
		{
			begin= middle + 1s;
		}
		else
		{
			end= middle;
		}
	}

	debug_assert( begin <= r.size() );
	return begin;
}

// Search using key obtained via given key provider function.
template</type T, type KeyProvider/>
fn first_greater_or_equal_by_key( array_view_imut</T/> r, T& el, KeyProvider mut key_provider ) : size_type
{
	return first_greater_or_equal( r, el, compare_by_key</T, KeyProvider/>{ .key_provider= move(key_provider) } );
}

template</type T/>
fn first_greater_or_equal( array_view_imut</T/> r, T& el ) : size_type
{
	return first_greater_or_equal( r, el, default_compare</T/>() );
}

template</type T/>
fn first_greater_or_equal( array_view_mut</T/> r, T& el ) : size_type
{
	return first_greater_or_equal</T/>( array_view_imut</T/>(r), el );
}

template</type T, size_type S/>
fn first_greater_or_equal( [T, S]& arr, T& el ) : size_type
{
	return first_greater_or_equal</T/>( array_view_imut</T/>(arr), el );
}

// Returns a pair of indices.
// Index 0 points to the first element which is greater than given or equal to it.
// Index 1 points to the first element which is greater than given.
// Index0 <= Index1
// Index0 or Index1 may be equal to range size.
// This function effectively combines "first_greater_or_equal" and "first_greater".
template</type T, type Compare/>
fn equal_range( array_view_imut</T/> r, T& el, Compare& comp ) : [ size_type, 2 ]
{
	var size_type g= first_greater( r, el, comp );
	var size_type ge= first_greater_or_equal( r.subrange_end(g), el, comp );
	var [ size_type, 2 ] res[ ge, g ];
	return res;
}

// Search using key obtained via given key provider function.
template</type T, type KeyProvider/>
fn equal_range_by_key( array_view_imut</T/> r, T& el, KeyProvider mut key_provider ) : [ size_type, 2 ]
{
	return equal_range( r, el, compare_by_key</T, KeyProvider/>{ .key_provider= move(key_provider) } );
}

template</type T/>
fn equal_range( array_view_imut</T/> r, T& el ) : [ size_type, 2 ]
{
	return equal_range( r, el, default_compare</T/>() );
}

template</type T/>
fn equal_range( array_view_mut</T/> r, T& el ) : [ size_type, 2 ]
{
	return equal_range</T/>( array_view_imut</T/>(r), el );
}

template</type T, size_type S/>
fn equal_range( [T, S]& arr, T& el ) : [ size_type, 2 ]
{
	return equal_range</T/>( array_view_imut</T/>(arr), el );
}

} // namespace binary_search

} // namespace ust
