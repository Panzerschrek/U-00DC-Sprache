import "memory.u"

namespace ust
{

// Helper functions for hashing.
// Use them in your "hash" method implementation for your class for members needed to be hashed.

// Basic scalars - execute hasher directly, since it should implement hashing methods for them.
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, void v ) { hasher(v); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, bool b ) { hasher(b); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, i8 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, u8 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, i16 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, u16 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, i32 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, u32 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, i64 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, u64 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, i128 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, u128 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, ssize_type x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, size_type x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, char8 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, char16 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, char32 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, byte8 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, byte16 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, byte32 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, byte64 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, byte128 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, f32 x ) { hasher(x); }
template</type Hasher/> fn apply_value_to_hasher( Hasher &mut hasher, f64 x ) { hasher(x); }

// Overloading for arrays.
template</type Hasher, type T, size_type S/>
fn apply_value_to_hasher( Hasher &mut hasher, [ T, S ]& arr )
{
	// Apply size first, in order to produce different hashes for sequences like [ a, b ], [ c, d, e ] and [ a, b, c ], [ d, e ]
	hasher( S );

	for( auto mut i= 0s; i < S; ++i )
	{
		hasher( arr[i] );
	}
}

// Overloading 0-sized tuples.
template</type Hasher/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[]& t )
{
	hasher( 0s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 1-sized tuples.
template</type Hasher, type A/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A ]& t )
{
	hasher( 1s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 2-sized tuples.
template</type Hasher, type A, type B/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B ]& t )
{
	hasher( 2s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 3-sized tuples.
template</type Hasher, type A, type B, type C/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B, C ]& t )
{
	hasher( 3s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 4-sized tuples.
template</type Hasher, type A, type B, type C, type D/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B, C, D ]& t )
{
	hasher( 4s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 5-sized tuples.
template</type Hasher, type A, type B, type C, type D, type E/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B, C, D, E ]& t )
{
	hasher( 5s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 6-sized tuples.
template</type Hasher, type A, type B, type C, type D, type E, type F/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B, C, D, E, F ]& t )
{
	hasher( 6s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 7-sized tuples.
template</type Hasher, type A, type B, type C, type D, type E, type F, type G/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B, C, D, E, F, G ]& t )
{
	hasher( 7s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading 8-sized tuples.
template</type Hasher, type A, type B, type C, type D, type E, type F, type G, type H/>
fn apply_value_to_hasher( Hasher &mut hasher, tup[ A, B, C, D, E, F, G, H ]& t )
{
	hasher( 8s ); // Apply size first, in order to produce different hashes for sequences of sequences.
	for( &el : t )
	{
		hasher( el );
	}
}

// Overloading for raw pointers.
template</type Hasher, type T/>
fn apply_value_to_hasher( Hasher &mut hasher, $(T) ptr )
{
	// Hash raw pointers as integer type with address value.
	hasher( ptr_to_int( ptr ) );
}

// Overloading for other type kinds.
template</type Hasher, type T/>
fn apply_value_to_hasher( Hasher &mut hasher, T& t )
{
	static_if( typeinfo</T/>.is_enum )
	{
		// Hash enums as their underlying type.
		hasher( typeinfo</T/>.underlying_type.src_type( t ) );
	}
	else static_if( typeinfo</T/>.is_function_pointer )
	{
		// For function pointers just take value of function pointer.
		hash( unsafe( cast_ref_unsafe</size_type/>(x) ) );
	}
	else static_if( typeinfo</T/>.is_class )
	{
		static_if( typeinfo</T/>.is_coroutine )
		{
			// Now coroutine classes contain only single pointer field.
			// Just hash this pointer.
			// Change this, if internal representation of coroutine will be changed.
			hasher( unsafe( cast_ref_unsafe</size_type/>(x) ) );
		}
		else
		{
			// TODO - call "hash" method on T or perform per-field hashing if it doesn't exist.
			static_assert( false, "Unsupported class type for hashing!" );
		}
	}
	else
	{
		static_assert( false, "Unsupported type for hashing!" );
	}
}


} // namespace ust
