import "alloc.u"
import "container_utils.u"
import "polymorph.u"

namespace ust
{


class any
{
public:
	fn constructor()
		( ptr_= zero_init )
	{
	}

	// TODO - disable it for types with references inside.
	template</type T/>
	fn constructor( T mut value )
		( ptr_= zero_init )
	{
		type storage= any_storage</T/>;

		unsafe
		{
			var $(byte8) ptr= memory_allocate( typeinfo</storage/>.size_of );

			var storage &mut ptr_to_storage= cast_ref_unsafe</storage/>( $>(ptr) );
			move_into_uninitialized( ptr_to_storage, storage( move(value) ) );

			ptr_= $<( cast_ref</any_storage_interface/>( ptr_to_storage ) );
		}
	}

	// Doesn't have constructor and copy-assignment operator, since not any type is copyable.

	fn destructor()
	{
		if( is_nullptr(ptr_) )
		{
			return;
		}

		unsafe
		{
			call_destructor( $>(ptr_) ); // Since we have reference to polymorph base class, virtual call should be performed here.
			memory_free( ptr_cast_to_byte8( ptr_ ) );
		}
	}

	fn reset( mut this )
	{
		if( is_nullptr(ptr_) )
		{
			return;
		}

		unsafe
		{
			call_destructor( $>(ptr_) ); // Since we have reference to polymorph base class, virtual call should be performed here.
			memory_free( ptr_cast_to_byte8( ptr_ ) );
			ptr_= nullptr</ any_storage_interface />();
		}
	}

	fn empty( this ) : bool
	{
		return is_nullptr(ptr_);
	}

	template</ type T />
	fn has( this ) : bool
	{
		if( is_nullptr(ptr_) )
		{
			return false;
		}

		return polymorph_is_instance_of</ any_storage</T/> />( unsafe( $>(ptr_) ) );
	}

	template</ type T />
	fn try_get( this ) : T&
	{
		halt if( is_nullptr(ptr_) );
		return polymorph_cast</ any_storage</T/> />( unsafe( $>(ptr_) ) ).try_deref().value_;
	}

	template</ type T />
	fn try_get( mut this ) : T &mut
	{
		halt if( is_nullptr(ptr_) );
		return polymorph_cast</ any_storage</T/> />( unsafe( $>(ptr_) ) ).try_deref().value_;
	}

	template</ type T />
	fn get( this ) : optional_ref_imut</T/> @( reference_notation::return_inner_references::param0 )
	{
		if( is_nullptr(ptr_) )
		{
			return null_optional_ref;
		}

		auto opt_ref= polymorph_cast</ any_storage</T/> />( unsafe( $>(ptr_) ) );
		if( opt_ref.empty() )
		{
			return null_optional_ref;
		}
		return opt_ref.try_deref().value_;
	}

	template</ type T />
	fn get( mut this ) : optional_ref_mut</T/> @( reference_notation::return_inner_references::param0 )
	{
		if( is_nullptr(ptr_) )
		{
			return null_optional_ref;
		}

		auto opt_ref= polymorph_cast</ any_storage</T/> />( unsafe( $>(ptr_) ) );
		if( opt_ref.empty() )
		{
			return null_optional_ref;
		}
		return opt_ref.try_deref().value_;
	}

	// Try to move value out of the container. Halts, if it's empty or if it doesn't contain value of specified type.
	template</ type T />
	fn nodiscard try_move( byval mut this ) : T
	{
		halt if( is_nullptr(ptr_) );

		auto opt_ref= polymorph_cast</ any_storage</T/> />( unsafe( $>(ptr_) ) );

		var T &mut stored_value= opt_ref.try_deref().value_; // Halts if contains wrong type.

		unsafe
		{
			var T mut result= uninitialized;
			memory_copy_aligned(
				typeinfo</T/>.align_of,
				ptr_cast_to_byte8( $<(result) ),
				ptr_cast_to_byte8( $<(stored_value) ),
				typeinfo</T/>.size_of );

			// Free memory, but don't call destructor.
			memory_free( ptr_cast_to_byte8( ptr_ ) );
			ptr_= nullptr</any_storage_interface/>();

			return result;
		}
	}

	// Try to make copy of the stored value.
	// If this container is empty or if stored type isn't copyable - empty container is returned.
	fn try_copy( this ) : any
	{
		if( is_nullptr(ptr_) )
		{
			return any();
		}

		return unsafe( $>(ptr_).try_copy() );
	}

private:
	// Use for storage a polymorph class - to use polymorph cast and virtual destructor.
	class any_storage_interface interface
	{
	public:
		// Copy if copyable, returns empty container if can't copy.
		fn virtual pure try_copy( this ) : any;
	}

	template</type T/>
	class any_storage : any_storage_interface
	{
	public:
		fn constructor( T mut value )
			( value_= move(value) )
		{}

		fn virtual final try_copy( this ) : any
		{
			static_if( typeinfo</T/>.is_copy_constructible )
			{
				return any( value_ );
			}
			else
			{
				return any();
			}
		}

	public:
		T value_;
	}

private:
	$(any_storage_interface) ptr_;
}

} // namespace ust
