import "file_metadata.u"
import "string.u"
import "result.u"
import "type_traits.u"

namespace ust
{

enum io_error
{
	permission_denied,
	not_found,
	not_a_directory,
	already_exists,
	out_of_memory,
	other, // Some non-listed error code.
	// TODO - add other errors
}

template</type T/>
type file_result= result</T, io_error/>;

type file_path= array_view_imut</char8/>;

class file_readable
{
public:
	// Open existing file for reading.
	fn open( file_path path ) : file_result</file_readable/>;

public:
	fn constructor( native_file_handle handle ) unsafe; // constructor for internal usage.
	fn destructor();

public:
	// Get handle to perform some system-specific file operations with it. Do not try to close it!
	fn get_native_handle( this ) unsafe : native_file_handle;
	// Take native handle and destroy this class instance. Caller is responsible for file closing.
	fn take_native_handle( byval this ) unsafe : native_file_handle;

	fn get_metatada( this ) : file_result</file_metadata/>;
	fn get_size( this ) : file_result</u64/>;

	fn read( mut this, array_view_mut</byte8/> buf ) : file_result</size_type/>;

	// May fail if file is not seekable (sequential).
	fn seek( mut this, u64 offset ) : file_result</void/>;

private:
	native_file_handle handle_;
}

class file_writeable
{
public:
	// Open existing file for writing.
	fn open( file_path path ) : file_result</file_writeable/>;
	// Create file or open an existing file with trunction for writing.
	fn create( file_path path ) : file_result</file_writeable/>;
	// Creates file for writing, but only if it doesn't exist.
	fn create_new( file_path path ) : file_result</file_writeable/>;

public:
	fn constructor( native_file_handle handle ) unsafe; // constructor for internal usage.
	fn destructor();

public:
	// Get handle to perform some system-specific file operations with it. Do not try to close it!
	fn get_native_handle( this ) unsafe : native_file_handle;
	// Take native handle and destroy this class instance. Caller is responsible for file closing.
	fn take_native_handle( byval this ) unsafe : native_file_handle;

	fn get_metatada( this ) : file_result</file_metadata/>;
	fn get_size( this ) : file_result</u64/>;

	fn write( mut this, array_view_imut</byte8/> buf ) : file_result</size_type/>;

	// Flush all data to the device, ensuring they are safely stored.
	fn flush( mut this ) : file_result</void/>;
	// Flush all, including metadata.
	fn flush_all( mut this ) : file_result</void/>;

	// Truncates or extends file with zeros.
	fn resize( mut this, u64 new_size ) : file_result</void/>;

	// May fail if file is not seekable (sequential).
	fn seek( mut this, u64 offset ) : file_result</void/>;

private:
	native_file_handle handle_;
}

class file_readable_writeable
{
public:
	// Open existing file for reading/writing.
	fn open( file_path path ) : file_result</file_readable_writeable/>;
	// Create file or open an existing file with trunction for reading/writing.
	fn create( file_path path ) : file_result</file_readable_writeable/>;
	// Creates file for reading/writing, but only if it doesn't exist.
	fn create_new( file_path path ) : file_result</file_readable_writeable/>;

public:
	fn constructor( native_file_handle handle ) unsafe; // constructor for internal usage.
	fn destructor();

public:
	// Get handle to perform some system-specific file operations with it. Do not try to close it!
	fn get_native_handle( this ) unsafe : native_file_handle;
	// Take native handle and destroy this class instance. Caller is responsible for file closing.
	fn take_native_handle( byval this ) unsafe : native_file_handle;

	fn get_metatada( this ) : file_result</file_metadata/>;
	fn get_size( this ) : file_result</u64/>;

	fn read( mut this, array_view_mut</byte8/> buf ) : file_result</size_type/>;
	fn write( mut this, array_view_imut</byte8/> buf ) : file_result</size_type/>;

	// Flush all data to the device, ensuring they are safely stored.
	fn flush( mut this ) : file_result</void/>;
	// Flush all, including metadata.
	fn flush_all( mut this ) : file_result</void/>;

	// Truncates or extends file with zeros.
	fn resize( mut this, u64 new_size ) : file_result</void/>;

	// May fail if file is not seekable (sequential).
	fn seek( mut this, u64 offset ) : file_result</void/>;

private:
	native_file_handle handle_;
}

// Native file handle, in platform-specific format.
type native_file_handle=
	type_select</
		constexpr_string_equals( compiler::target::os, "windows" ),
		$(byte8),
		i32 />;

// Request metadata for given path (file, directory, etc.).
fn get_metadata_for_path( file_path path ) : file_result</file_metadata/>;

// Create a single directory (but only if parent exists).
// Fails if given path exists but it's not a directory.
fn create_directory( file_path path ) : file_result</void/>;

fn copy_file( file_path src_path, file_path dst_path ) : file_result</void/>;
fn copy_file_if_not_exists( file_path src_path, file_path dst_path ) : file_result</void/>;

fn rename_file_or_directory( file_path src_path, file_path dst_path ) : file_result</void/>;
fn rename_file_or_directory_if_not_exists( file_path src_path, file_path dst_path ) : file_result</void/>;

// Remove file or link.
fn remove_file( file_path path ) : file_result</void/>;

// Remove an empty directory.
fn remove_directory( file_path path ) : file_result</void/>;

fn get_current_directory() : string8;
fn set_current_directory( file_path path ) : file_result</void/>;

// Directory iterator

struct directory_entry
{
	string8 name;
	file_kind kind;
	// TODO - add a system-specific fields, which are available for a directory entry (like permissions).
}

fn open_directory_for_iteration( file_path path ) : file_result</ iterator</ directory_raw_iterator /> />
{
	return directory_raw_iterator::open( path );
}

class directory_raw_iterator
{
public:
	// Factory method for creating iterator instance.
	fn open( file_path path ) : file_result</ iterator</ directory_raw_iterator /> />;

public:
	// Constructor for internal usage.
	fn constructor( impl_windows mut impl ) unsafe
		( impl_= move(impl) )
	{}

public:
	fn next( mut this ) : optional</ file_result</directory_entry/> />
	{
		return impl_.next();
	}

private:
	class impl_windows
	{
	public:
		fn constructor( $(byte8) handle, directory_entry first_entry ) unsafe;
		fn destructor();

		fn next( mut this ) : optional</ file_result</directory_entry/> />;

	private:
		$(byte8) handle_;
		optional</directory_entry/> first_entry_;
	}

private:
	impl_windows impl_;
}

} // namespace ust
