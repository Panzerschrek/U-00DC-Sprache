import "memory.u"

namespace ust
{

// Raw pointer classes.

template</ type T />
class raw_ptr_mut
{
public:
	type this_type= raw_ptr_mut</T/>;

	fn constructor( this_type &imut other )= default;
	op=( mut this, this_type &imut other )= default;

	// Default constructor - set to zero
	fn constructor() ( val_= zero_init ) {}

	// Construct from reference
	fn constructor( T &mut ref )
	( val_= zero_init )
	{
		unsafe{  val_= $<(ref);  }
	}

	// Construct from reference to array
	template</ size_type array_size />
	fn constructor( [ T, array_size ] &mut ref )
	( val_= zero_init )
	{
		unsafe{  val_= $<( cast_ref_unsafe</T/>(ref) );  }
	}

	fn is_null( this ) : bool
	{
		var $(T) null= zero_init;
		return val_ == null;
	}

	// Dereference and indexing.

	fn get_ref( this ) unsafe : T &mut
	{
		unsafe{  return $>(val_);  }
	}

	template</ size_type array_size />
	fn as_array( this ) unsafe : [ T, array_size ] &mut
	{
		unsafe{  return cast_ref_unsafe</ [ T, array_size ] />( get_ref() );  }
	}

	op[]( this, size_type s ) unsafe : T&mut
	{
		unsafe{  return $>( val_ + s );  }
	}

	// Compare.
	op< ( this, this_type other ) : bool  { return this.val_ <  other.val_; }
	op<=( this, this_type other ) : bool  { return this.val_ <= other.val_; }
	op> ( this, this_type other ) : bool  { return this.val_ >  other.val_; }
	op>=( this, this_type other ) : bool  { return this.val_ >= other.val_; }
	op==( this, this_type other ) : bool  { return this.val_ == other.val_; }
	op!=( this, this_type other ) : bool  { return this.val_ != other.val_; }

	// Pointer to int operations
	op++( mut this )  { ++val_; }
	op--( mut this )  { --val_; }
	op+=( mut this, size_type s )  { val_+= s; }
	op-=( mut this, size_type s )  { val_-= s; }

	op+( this, size_type s ) : this_type
	{
		var this_type mut result= this;
		result+= s;
		return result;
	}
	op+( size_type s, this_type self ) : this_type
	{
		return self + s;
	}
	op-( this, size_type s ) : this_type
	{
		var this_type mut result= this;
		result-= s;
		return result;
	}

	op-( this_type a, this_type b ) : ptr_diff_type
	{
		static_if( typeinfo</T/>.size_of > 0s )
		{
			return a.val_ - b.val_;
		}
		else
		{
			return ptr_diff_type(0);
		}
	}

private:
	$(T) val_;
}

} // namespace ust
