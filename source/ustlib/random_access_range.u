import "aligned_storage.u"
import "container_utils.u"
import "helpers.u"
import "iterator.u"
import "memory.u"
import "optional_ref.u"
import "reference_notation.u"

namespace ust
{

struct empty_range_type{}
var empty_range_type constexpr empty_range{};

template</ type T, bool is_mutable />
class random_access_range
{
public:
	fn constructor()= default;

	fn constructor( mut this, this_type &imut other )= default;

	op=( mut this, this_type &imut other )= default;

	// Use this conversion constructor in order to use simple "ust::empty_range" to pass/return empty range, without specifying exact range type.
	fn conversion_constructor( empty_range_type e )
	{
		ignore_unused(e);
	}

	template</ size_type size />
	fn enable_if( is_mutable )
	conversion_constructor( mut this, [ T, size ] & mut arr ) @( reference_notation::pollution::param0_param_1_reference )
		( size_(size) )
	{
		unsafe{  begin_= $<( cast_ref_unsafe</T/>(arr) );  }
	}

	template</ size_type size />
	fn enable_if( !is_mutable )
	conversion_constructor( mut this, [ T, size ] &imut arr ) @( reference_notation::pollution::param0_param_1_reference )
		( size_(size) )
	{
		unsafe{  begin_= $<( cast_mut( cast_ref_unsafe</T/>(arr) ) );  }
	}

	fn enable_if( !is_mutable )
	conversion_constructor( mut this, random_access_range</ T, true />& src_range ) @( reference_notation::pollution::param0_param_1_inner_reference )
	{
		unsafe
		{	// Hack! we can not access begin_/end_ members of different range type, so, just copy memory.
			static_assert( typeinfo</typeof(this)/>.size_of == typeinfo</typeof(src_range)/>.size_of );
			memory_copy_aligned( typeinfo</typeof(this)/>.align_of, cast_ref_unsafe</byte8/>( this ), cast_ref_unsafe</byte8/>( src_range ), typeinfo</typeof(this)/>.size_of );
		}
	}

	// Construct from raw parts.
	fn constructor( $(T) begin, size_type size ) unsafe
		( begin_(begin), size_(size) )
	{}

	op enable_if( is_mutable )
	[]( this, size_type index ) : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if( empty() );
		return unsafe( index_unchecked(index) );
	}

	op
	enable_if( !is_mutable )
	[]( this, size_type index ) : T & imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if( empty() );
		return unsafe( index_unchecked(index) );
	}

	fn enable_if(  is_mutable ) index_unchecked( this, size_type index ) unsafe : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		return unsafe( $>(begin_ + index) );
	}

	fn enable_if( !is_mutable ) index_unchecked( this, size_type index ) unsafe : T &imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		return unsafe( $>(begin_ + index) );
	}

	fn enable_if(  is_mutable ) front( this ) : T &  mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if(empty());
		return unsafe( front_unchecked() );
	}

	fn enable_if( !is_mutable ) front( this ) : T & imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if(empty());
		return unsafe( front_unchecked() );
	}

	fn enable_if(  is_mutable ) back ( this ) : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if(empty());
		return unsafe( back_unchecked () );
	}

	fn enable_if( !is_mutable ) back ( this ) : T &imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if(empty());
		return unsafe( back_unchecked () );
	}

	fn enable_if(  is_mutable ) front_unchecked( this ) unsafe : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		return unsafe( $>(begin_) );
	}

	fn enable_if( !is_mutable ) front_unchecked( this ) unsafe : T &imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		return unsafe( $>(begin_) );
	}

	fn enable_if(  is_mutable ) back_unchecked ( this ) unsafe : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		return unsafe( $>(begin_ + size_ - 1s) );
	}

	fn enable_if( !is_mutable ) back_unchecked ( this ) unsafe : T &imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		return unsafe( $>(begin_ + size_ - 1s) );
	}

	fn subrange( this, size_type start_index, size_type end_index ) : this_type @( reference_notation::return_inner_references::param0_inner_reference0 )
	{
		halt if( start_index > end_index );
		halt if( end_index > size_ );
		return unsafe( this_type( begin_ + start_index, end_index - start_index ) );
	}

	fn empty( this ) : bool
	{
		return size_ == 0s;
	}

	fn size( this ) : size_type
	{
		return size_;
	}

	// ==
	op enable_if( typeinfo</T/>.is_equality_comparable )
	==( this_type& l, this_type& r ) : bool
	{
		if( l.size() != r.size() )
		{
			return false;
		}

		for( auto mut i= 0s; i < l.size_; ++i )
		{
			if( unsafe( l.index_unchecked(i) ) != unsafe( r.index_unchecked(i) ) )
			{
				return false;
			}
		}

		return true;
	}

	fn drop_front( mut this )
	{
		halt if( empty() );
		++begin_;
		--size_;
	}

	fn drop_back( mut this )
	{
		halt if( empty() );
		--size_;
	}

	// Precondition - range is nonempty.
	fn drop_front_unchecked( mut this ) unsafe
	{
		++begin_;
		--size_;
	}

	// Precondition - range is nonempty.
	fn drop_back_unchecked( mut this ) unsafe
	{
		--size_;
	}

	fn enable_if(is_mutable) drop_and_get_front( mut this ) : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if( empty() );
		return unsafe( drop_and_get_front_unchecked() );
	}

	fn enable_if(!is_mutable) drop_and_get_front( mut this ) : T &imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		halt if( empty() );
		return unsafe( drop_and_get_front_unchecked() );
	}

	// Precondition - range is nonempty.
	fn enable_if(is_mutable) drop_and_get_front_unchecked( mut this ) unsafe : T & mut @( reference_notation::return_references::param0_inner_reference0 )
	{
		auto & mut res= unsafe( $>(begin_) );
		++begin_;
		--size_;
		return res;
	}

	// Precondition - range is nonempty.
	fn enable_if(!is_mutable) drop_and_get_front_unchecked( mut this ) unsafe : T &imut @( reference_notation::return_references::param0_inner_reference0 )
	{
		auto &imut res= unsafe( $>(begin_) );
		++begin_;
		--size_;
		return res;
	}

	fn iter( this ) : iterator</iterator_raw/> @( reference_notation::return_inner_references::param0_inner_reference0 )
	{
		return wrap_raw_iterator( iterator_raw(this) );
	}

	// Access raw data.
	fn data( this ) unsafe : $(T)
	{
		return begin_;
	}

	fn enable_if( is_mutable ) swap( this, size_type i0, size_type i1 )
	{
		halt if( i0 >= size_ );
		halt if( i1 >= size_ );

		if( i0 == i1 ){ return; }

		unsafe( ust::swap( $>(begin_ + i0), $>(begin_ + i1) ) );
	}

	fn enable_if( is_mutable ) reverse( this )
	{
		for( var size_type mut i= 0s, half_size= size_ / 2s; i < half_size; ++i )
		{
			auto i0= i;
			auto i1= (size_ - 1s) - i;
			unsafe( ust::swap( $>(begin_ + i0), $>(begin_ + i1) ) );
		}
	}

public:
	// Iterator over range.
	class iterator_raw
	{
	public:
		fn constructor( random_access_range</ T, is_mutable /> mut range ) @( reference_notation::pollution::param0_param_1_inner_reference )
			( range_= move(range) )
		{}

		fn constructor( mut this, iterator_raw& other )= default;
		op=( mut this, iterator_raw& other )= default;

		fn next( mut this ) : auto
		{
			if( range_.empty() )
			{
				return optional_ref</ T, is_mutable />();
			}
			return optional_ref</ T, is_mutable />( range_.drop_and_get_front() );
		}

	private:
		random_access_range</ T, is_mutable /> range_;
	}

private:
	type this_type= random_access_range</ T, is_mutable />;

private:
	ReferenceContainerTag</ T, is_mutable /> reference_tag_;

private:
	// Store begin + size, instead of begin + end because we need to support elements with zero size.
	// TODO - maybe use begin + end for non-zero-sized elements?
	$(T) begin_= zero_init;
	size_type size_= 0s;
}

template</ type T />
type random_access_range_mut = random_access_range</ T, true  />;
template</ type T />
type array_view_mut = random_access_range</ T, true  />;

template</ type T />
type random_access_range_imut= random_access_range</ T, false />;
template</ type T />
type array_view_imut= random_access_range</ T, false />;

// Use free functions instead of consrtuctors in order to create array view for single element explicitly.
// Doing such we can avoid common mistakes.

template</type T/>
fn single_element_array_view( T & mut el ) : array_view_mut</T/> @( reference_notation::return_inner_references::param0 )
{
	return unsafe( array_view_mut</T/>( $<(el), 1s ) );
}

template</type T/>
fn single_element_array_view( T &imut el ) : array_view_imut</T/> @( reference_notation::return_inner_references::param0 )
{
	return unsafe( array_view_imut</T/>( $<(cast_mut(el)), 1s ) );
}

} // namespace ust
