import "aligned_storage.u"
import "container_utils.u"
import "memory.u"

namespace ust
{

template</ type T, bool is_mutable />
class random_access_range
{
public:
	fn constructor()= default;

	fn constructor( mut this, this_type &imut other )= default;

	op=( mut this, this_type &imut other )= default;

	template</ size_type size />
	fn enable_if( is_mutable )
	conversion_constructor( mut this'a', [ T, size ] &'b  mut arr ) ' a <-  b '
		( size_(size) )
	{
		unsafe{  begin_= $<( cast_ref_unsafe</T/>(arr) );  }
	}

	template</ size_type size />
	fn enable_if( !is_mutable )
	conversion_constructor( mut this'a', [ T, size ] &'b imut arr ) ' a <- b '
		( size_(size) )
	{
		unsafe{  begin_= $<( cast_mut( cast_ref_unsafe</T/>(arr) ) );  }
	}

	fn enable_if( !is_mutable )
	conversion_constructor( mut this'a', random_access_range</ T, true />& src_range'b' ) ' a <- b '
	{
		unsafe
		{	// Hack! we can not access begin_/end_ members of different range type, so, just copy memory.
			static_assert( typeinfo</typeof(this)/>.size_of == typeinfo</typeof(src_range)/>.size_of );
			memory_copy_aligned( typeinfo</typeof(this)/>.align_of, cast_ref_unsafe</byte8/>( this ), cast_ref_unsafe</byte8/>( src_range ), typeinfo</typeof(this)/>.size_of );
		}
	}

	fn constructor( $(T) begin, size_type size ) unsafe
		( begin_(begin), size_(size) )
	{}

	op enable_if( is_mutable )
	[]( this'x', size_type index ) : T &'x  mut
	{
		halt if( empty() );
		unsafe{  return index_unchecked(index);  }
	}

	op
	enable_if( !is_mutable )
	[]( this'x', size_type index ) : T &'x imut
	{
		halt if( empty() );
		unsafe{  return index_unchecked(index);  }
	}

	fn enable_if(  is_mutable ) index_unchecked( this'x', size_type index ) unsafe : T &'x  mut
	{
		unsafe{  return $>(begin_ + index);  }
	}

	fn enable_if( !is_mutable ) index_unchecked( this'x', size_type index ) unsafe : T &'x imut
	{
		unsafe{  return $>(begin_ + index);  }
	}

	fn enable_if(  is_mutable ) front( this'x' ) : T &'x  mut
	{
		halt if(empty());
		unsafe{  return front_unchecked();  }
	}

	fn enable_if( !is_mutable ) front( this'x' ) : T &'x imut
	{
		halt if(empty());
		unsafe{  return front_unchecked();  }
	}

	fn enable_if(  is_mutable ) back ( this'x' ) : T &'x  mut
	{
		halt if(empty());
		unsafe{  return back_unchecked ();  }
	}

	fn enable_if( !is_mutable ) back ( this'x' ) : T &'x imut
	{
		halt if(empty());
		unsafe{  return back_unchecked ();  }
	}

	fn enable_if(  is_mutable ) front_unchecked( this'x' ) unsafe : T &'x  mut
	{
		unsafe{  return $>(begin_);  }
	}

	fn enable_if( !is_mutable ) front_unchecked( this'x' ) unsafe : T &'x imut
	{
		unsafe{  return $>(begin_);  }
	}

	fn enable_if(  is_mutable ) back_unchecked ( this'x' ) unsafe : T &'x  mut
	{
		unsafe{  return $>(begin_ + size_ - 1s);  }
	}

	fn enable_if( !is_mutable ) back_unchecked ( this'x' ) unsafe : T &'x imut
	{
		unsafe{  return $>(begin_ + size_ - 1s);  }
	}

	fn subrange( this'x', size_type start_index, size_type end_index ) : this_type'x'
	{
		halt if( start_index > end_index );
		halt if( end_index > size_ );
		unsafe{  return this_type( begin_ + start_index, end_index - start_index );  }
	}

	fn empty( this ) : bool
	{
		return size_ == 0s;
	}

	fn size( this ) : size_type
	{
		return size_;
	}

	// ==
	op enable_if( typeinfo</T/>.is_equality_comparable )
	==( this_type& l, this_type& r ) : bool
	{
		if( l.size() != r.size() )
		{
			return false;
		}

		for( auto mut i= 0s; i < l.size_; ++i )
		{
			unsafe
			{
				var T& l_element= l.index_unchecked(i);
				var T& r_element= r.index_unchecked(i);
				safe
				{
					if( l_element != r_element )
					{
						return false;
					}
				}
			}
		}

		return true;
	}

	fn drop_front( mut this )
	{
		halt if( empty() );
		++begin_;
		--size_;
	}

	fn drop_back( mut this )
	{
		halt if( empty() );
		--size_;
	}

	// Precondition - range is nonempty.
	fn drop_front_unchecked( mut this ) unsafe
	{
		++begin_;
		--size_;
	}

	// Precondition - range is nonempty.
	fn drop_back_unchecked( mut this ) unsafe
	{
		--size_;
	}

	fn range( this'x' ) : this_type'x'
	{
		return this;
	}

	// Access raw data.
	fn data( this ) unsafe : $(T)
	{
		return begin_;
	}

	fn enable_if( is_mutable ) swap( this, size_type i0, size_type i1 )
	{
		halt if( i0 >= size_ );
		halt if( i1 >= size_ );

		if( i0 == i1 ){ return; }

		unsafe
		{
			ust::swap( $>(begin_ + i0), $>(begin_ + i1) );
		}
	}

private:
	type this_type= random_access_range</ T, is_mutable />;

private:
	ReferenceContainerTag</ T, is_mutable /> reference_tag_;

private:
	// Store begin + size, instead of begin + end because we need to support elements with zero size.
	// TODO - maybe use begin + end for non-zero-sized elements?
	$(T) begin_= zero_init;
	size_type size_= 0s;
}

template</ type T />
type random_access_range_mut = random_access_range</ T, true  />;
template</ type T />
type array_view_mut = random_access_range</ T, true  />;

template</ type T />
type random_access_range_imut= random_access_range</ T, false />;
template</ type T />
type array_view_imut= random_access_range</ T, false />;

} // namespace ust
