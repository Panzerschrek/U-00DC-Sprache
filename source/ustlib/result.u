import "aligned_storage.u"
import "container_utils.u"
import "optional_ref.u"
import "type_traits.u"

namespace ust
{

template</type ResultT, type ErrorT/>
class result
{
public:
	static_assert( !is_same_type</ResultT, ErrorT/>(), "Result and error types must be distinct!" );

public:
	// Construt from result.
	fn conversion_constructor( mut this'a', ResultT mut res'b' ) ' a <- b '
		( is_result_= true, storage_= zero_init ) // TODO - use uninitialized initializer for storage
	{
		unsafe( move_into_uninitialized( deref_unchecked(), move(res) ) );
	}

	// Construct from error.
	fn conversion_constructor( mut this'a', ErrorT mut err'b' ) ' a <- b '
		( is_result_= false, storage_= zero_init ) // TODO - use uninitialized initializer for storage
	{
		unsafe( move_into_uninitialized( deref_error_unchecked(), move(err) ) );
	}

	// Disable copying.
	// Since "result" container is designated for usage as return value, there is no reason to copy it somehow.
	// Normal usage is to call function, returning "result", check it and extract result or error.
	// Disabling copying prevens some common mistakes/ineffectiveness in usage of "result".
	fn constructor( mut this, this_type& other )= delete;
	op=( mut this, this_type& other )= delete;

	// Destroy either result or error.
	fn destructor()
	{
		if( is_result_ )
		{
			unsafe( call_destructor( deref_unchecked() ) );
		}
		else
		{
			unsafe( call_destructor( deref_error_unchecked() ) );
		}
	}

	// Check contents kind.

	fn is_ok( this ) : bool
	{
		return is_result_;
	}

	fn is_error( this ) : bool
	{
		return !is_ok();
	}

	// Access result value.

	fn try_deref(  mut this ) : ResultT & mut
	{
		halt if(!is_ok());
		return unsafe( deref_unchecked() );
	}

	fn try_deref( imut this ) : ResultT &imut
	{
		halt if(!is_ok());
		return unsafe( deref_unchecked() );
	}

	fn deref_unchecked(  mut this ) unsafe : ResultT & mut
	{
		return unsafe( cast_ref_unsafe</ResultT/>( storage_ ) );
	}

	fn deref_unchecked( imut this ) unsafe : ResultT &imut
	{
		return unsafe( cast_ref_unsafe</ResultT/>( storage_ ) );
	}

	// Access error value.

	fn try_deref_error(  mut this ) : ErrorT & mut
	{
		halt if(!is_error());
		return unsafe( deref_error_unchecked() );
	}

	fn try_deref_error( imut this ) : ErrorT &imut
	{
		halt if(!is_error());
		return unsafe( deref_error_unchecked() );
	}

	fn deref_error_unchecked(  mut this ) unsafe : ErrorT & mut
	{
		return unsafe( cast_ref_unsafe</ErrorT/>( storage_ ) );
	}

	fn deref_error_unchecked( imut this ) unsafe : ErrorT &imut
	{
		return unsafe( cast_ref_unsafe</ErrorT/>( storage_ ) );
	}

	// Get optional reference.

	fn
	enable_if( typeinfo</ResultT/>.references_tags_count == 0s )
	as_ref(  mut this ) : optional_ref_mut </ResultT/>'this'
	{
		if( is_result_ )
		{
			return optional_ref_mut </ResultT/>( unsafe( deref_unchecked() ) );
		}
		else
		{
			return optional_ref_mut </ResultT/>();
		}
	}

	fn
	enable_if( typeinfo</ResultT/>.references_tags_count == 0s )
	as_ref( imut this ) : optional_ref_imut</ResultT/>'this'
	{
		if( is_result_ )
		{
			return optional_ref_imut</ResultT/>( unsafe( deref_unchecked() ) );
		}
		else
		{
			return optional_ref_imut</ResultT/>();
		}
	}

	fn
	enable_if( typeinfo</ErrorT/>.references_tags_count == 0s )
	as_error_ref(  mut this ) : optional_ref_mut </ErrorT/>'this'
	{
		if( !is_result_ )
		{
			return optional_ref_mut </ErrorT/>( unsafe( deref_error_unchecked() ) );
		}
		else
		{
			return optional_ref_mut </ErrorT/>();
		}
	}

	fn
	enable_if( typeinfo</ErrorT/>.references_tags_count == 0s )
	as_error_ref( imut this ) : optional_ref_imut</ErrorT/>'this'
	{
		if( !is_result_ )
		{
			return optional_ref_imut</ErrorT/>( unsafe( deref_error_unchecked() ) );
		}
		else
		{
			return optional_ref_imut</ErrorT/>();
		}
	}

	// ==

	op enable_if( c_is_equality_comparable )
	==( this_type& l, this_type& r ) : bool
	{
		if( l.is_result_ && r.is_result_ )
		{
			// Both results - compare them.
			return unsafe( l.deref_unchecked() ) == unsafe( r.deref_unchecked() );
		}
		if( !l.is_result_ && !r.is_result_ )
		{
			// Both errors - compare them.
			return unsafe( l.deref_error_unchecked() ) == unsafe( r.deref_error_unchecked() );
		}

		// Different kinds - not equals.
		return false;
	}

	op enable_if( c_is_equality_comparable )
	==( this_type& l, ResultT& r ) : bool
	{
		if( l.is_result_ )
		{
			// Both results - compare them.
			return unsafe( l.deref_unchecked() ) == r;
		}

		// Different kinds - not equals.
		return false;
	}

	op enable_if( c_is_equality_comparable )
	==( ResultT& l, this_type& r ) : bool
	{
		if( r.is_result_ )
		{
			// Both results - compare them.
			return l == unsafe( r.deref_unchecked() );
		}

		// Different kinds - not equals.
		return false;
	}

	op enable_if( c_is_equality_comparable )
	==( this_type& l, ErrorT& r ) : bool
	{
		if( !l.is_result_ )
		{
			// Both errors - compare them.
			return unsafe( l.deref_error_unchecked() ) == r;
		}

		// Different kinds - not equals.
		return false;
	}

	op enable_if( c_is_equality_comparable )
	==( ErrorT& l, this_type& r ) : bool
	{
		if( !r.is_result_ )
		{
			// Both errors - compare them.
			return l == unsafe( r.deref_error_unchecked() );
		}

		// Different kinds - not equals.
		return false;
	}

private:
	type this_type= result</ResultT, ErrorT/>;

	var size_type constexpr c_storage_size = select( typeinfo</ResultT/>.size_of  > typeinfo</ErrorT/>.size_of  ? typeinfo</ResultT/>.size_of  : typeinfo</ErrorT/>.size_of  );
	var size_type constexpr c_storage_align= select( typeinfo</ResultT/>.align_of > typeinfo</ErrorT/>.align_of ? typeinfo</ResultT/>.align_of : typeinfo</ErrorT/>.align_of );

	var bool constexpr c_is_equality_comparable= typeinfo</ResultT/>.is_equality_comparable && typeinfo</ErrorT/>.is_equality_comparable;

private:
	aligned_storage</ c_storage_size, c_storage_align /> storage_;
	bool is_result_;
}

// Extract and return result.
template</type ResultT, type ErrorT/>
fn result_try_take( result</ResultT, ErrorT/> mut r ) : ResultT
{
	unsafe
	{
		var ResultT mut t= uninitialized;
		{
			auto& ref= r.try_deref(); // try_deref will halt if result contains error.
			memory_copy_aligned( typeinfo</ResultT/>.align_of, cast_ref_unsafe</byte8/>(t), cast_ref_unsafe</byte8/>( ref ), typeinfo</ResultT/>.size_of ); // Copy contents into the result.
		}
		move_into_nowhere( move(r) ); // Forget about the result container.
		return move(t);
	}
}

// Extract and return error.
template</type ResultT, type ErrorT/>
fn result_try_take_error( result</ResultT, ErrorT/> mut r ) : ErrorT
{
	unsafe
	{
		var ErrorT mut t= uninitialized;
		{
			auto& ref= r.try_deref_error(); // try_deref will halt if result contains no error.
			memory_copy_aligned( typeinfo</ErrorT/>.align_of, cast_ref_unsafe</byte8/>(t), cast_ref_unsafe</byte8/>( ref ), typeinfo</ErrorT/>.size_of ); // Copy contents into the result.
		}
		move_into_nowhere( move(r) ); // Forget about the result container.
		return move(t);
	}
}

} // namespace ust
