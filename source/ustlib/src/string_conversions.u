import "../imports/string_conversions.u"

namespace ust
{

fn to_string8 ( i8 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( u8 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( i16 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( u16 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( i32 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( u32 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( i64 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( u64 x ) : string8
{
	return to_string</char8 />(x);
}

fn to_string8 ( ssize_type x ) : string8
{
	static_if( typeinfo</ssize_type/>.size_of == typeinfo</i32/>.size_of )
	{
		return to_string8 ( i32(x) );
	}
	else
	{
		return to_string8 ( i64(x) );
	}
}

fn to_string8 ( size_type x ) : string8
{
	static_if( typeinfo</size_type/>.size_of == typeinfo</u32/>.size_of )
	{
		return to_string8 ( u32(x) );
	}
	else
	{
		return to_string8 ( u64(x) );
	}
}

fn to_string16( i8 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( u8 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( i16 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( u16 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( i32 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( u32 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( i64 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( u64 x ) : string16
{
	return to_string</char16/>(x);
}

fn to_string16( ssize_type x ) : string16
{
	static_if( typeinfo</ssize_type/>.size_of == typeinfo</i32/>.size_of )
	{
		return to_string16( i32(x) );
	}
	else
	{
		return to_string16( i64(x) );
	}
}

fn to_string16( size_type x ) : string16
{
	static_if( typeinfo</size_type/>.size_of == typeinfo</u32/>.size_of )
	{
		return to_string16( u32(x) );
	}
	else
	{
		return to_string16( u64(x) );
	}
}

fn to_string32( i8 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( u8 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( i16 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( u16 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( i32 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( u32 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( i64 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( u64 x ) : string32
{
	return to_string</char32/>(x);
}

fn to_string32( ssize_type x ) : string32
{
	static_if( typeinfo</ssize_type/>.size_of == typeinfo</i32/>.size_of )
	{
		return to_string32( i32(x) );
	}
	else
	{
		return to_string32( i64(x) );
	}
}

fn to_string32( size_type x ) : string32
{
	static_if( typeinfo</size_type/>.size_of == typeinfo</u32/>.size_of )
	{
		return to_string32( u32(x) );
	}
	else
	{
		return to_string32( u64(x) );
	}
}

template</type C/>
fn to_string( i8 x ) :string_base</C/>
{
	return to_string</C/>( i64(x) );
}

template</type C/>
fn to_string( u8 x ) : string_base</C/>
{
	return to_string</C/>( u64(x) );
}

template</type C/>
fn to_string( i16 x ) : string_base</C/>
{
	return to_string</C/>( i64(x) );
}

template</type C/>
fn to_string( u16 x ) : string_base</C/>
{
	return to_string</C/>( u64(x) );
}

template</type C/>
fn to_string( i32 x ) : string_base</C/>
{
	var string_base</C/> mut result;
	if( x >= 0 )
	{
		to_string_impl</C/>( u32( x), result );
	}
	else
	{
		result.push_back( C('-') );
		to_string_impl</C/>( u32(-x), result );
	}
	return result;
}

template</type C/>
fn to_string( u32 x ) : string_base</C/>
{
	var string_base</C/> mut result;
	to_string_impl</C/>( x, result );
	return result;
}

template</type C/>
fn to_string( i64 x ) : string_base</C/>
{
	var string_base</C/> mut result;
	if( x >= 0i64 )
	{
		to_string_impl</C/>( u64( x), result );
	}
	else
	{
		result.push_back( C('-') );
		to_string_impl</C/>( u64(-x), result );
	}
	return result;
}

template</type C/>
fn to_string( u64 x ) : string_base</C/>
{
	var string_base</C/> mut result;
	to_string_impl</C/>( x, result );
	return result;
}

// 32-bit version.
template</type C/>
fn to_string_impl( u32 x, string_base</C/>& mut result )
{
	auto constexpr zero_char= C('0');

	if( x == 0u )
	{
		result.push_back(zero_char);
	}
	else
	{
		// Count number of digits.
		var u32 mut num_digits= 0u;
		for( auto mut ten_power= 1u; ; )
		{
			if( x < ten_power )
			{
				break;
			}
			++num_digits;
			if( ten_power == 1000000000u )
			{
				break;
			}
			ten_power *= 10u;
		}

		unsafe // Because of uninitialized storage.
		{
			// Fill digits from minor to major.
			var [ C, 10 ] mut digits= uninitialized;

			var u32 mut rem= x;
			var u32 mut target_digit= num_digits - 1u;
			loop
			{
				// use only single division by 10 on each iteration, which should be fast.
				var u32 digit= rem % 10u;
				rem /= 10u;
				digits[ target_digit ]= C( digit + u32(zero_char) );
				if( target_digit == 0u )
				{
					break;
				}
				--target_digit;
			}

			// Push the whole array at one time, instead of using "push_back" on each iteration, which should be faster.
			result+= random_access_range_imut</C/>( digits ).subrange_end( size_type(num_digits) );
		}
	}
}

// 64-bit version.
template</type C/>
fn to_string_impl( u64 x, string_base</C/>& mut result )
{
	auto constexpr zero_char= C('0');

	if( x == 0u64 )
	{
		result.push_back(zero_char);
	}
	else
	{
		// Count number of digits.
		var u32 mut num_digits= 0u;
		for( auto mut ten_power= 1u64; ; )
		{
			if( x < ten_power )
			{
				break;
			}
			++num_digits;
			if( ten_power == 10000000000000000000u64 )
			{
				break;
			}
			ten_power *= 10u64;
		}

		unsafe // Because of uninitialized storage.
		{
			// Fill digits from minor to major.
			var [ C, 20 ] mut digits= uninitialized;

			var u64 mut rem= x;
			var u32 mut target_digit= num_digits - 1u;
			loop
			{
				// use only single division by 10 on each iteration, which should be fast.
				var u64 digit= rem % 10u64;
				rem /= 10u64;
				digits[ target_digit ]= C( digit + u64(zero_char) );
				if( target_digit == 0u )
				{
					break;
				}
				--target_digit;
			}

			// Push the whole array at one time, instead of using "push_back" on each iteration, which should be faster.
			result+= random_access_range_imut</C/>( digits ).subrange_end( size_type(num_digits) );
		}

	}
}

} // namespace ust
