import "../../imports/udp_socket.u"
import "errno.uh"

namespace ust
{

namespace net
{

fn udp_socket::create() : result</udp_socket, io_error/>
{
	unsafe
	{
		var native_socket_fd s= ::socket( PF_INET, i32(SOCK_DGRAM), 0 );
		if( s == -1 )
		{
			return translate_errno( get_errno() );
		}

		return udp_socket( s );
	}
}

fn udp_socket::create_and_bind( socket_address& a ) : result</udp_socket, io_error/>
{
	var result</udp_socket, io_error/> mut socket_or_error= create();
	if( socket_or_error.is_error() )
	{
		return socket_or_error;
	}

	var udp_socket mut socket= move(socket_or_error).try_take();

	if_var( &a_v4 : a.get</socket_address_v4/>() )
	{
		var sockaddr_in mut underlying_address
		{
			.sin_family( AF_INET ),
			.sin_port= a_v4.get_port(),
			.sin_addr{ .s_addr= a_v4.get_ip().get_bits() },
			.sin_zero= zero_init,
		};

		var i32 res=
			unsafe( ::bind(
				socket.socket_,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in/>.size_of ) ) );

		if( res != 0 )
		{
			// Socket will be destroyed on error return.
			return translate_errno( get_errno() );
		}
	}
	else
	{
		// TODO - support IP v6.
		halt;
	}

	return socket;
}

fn udp_socket::constructor( native_socket_fd s ) unsafe
	( socket_= s )
{}

fn udp_socket::destructor()
{
	unsafe( ::close( socket_ ) );
}

fn udp_socket::send( mut this, array_view_imut</byte8/> data ) : result</size_type, io_error/>
{
	var ssize_type bytes_written= unsafe( ::send( socket_, data.data(), data.size(), 0 ) );

	if( bytes_written < ssize_type(0) )
	{
		return translate_errno( get_errno() );
	}

	return size_type(bytes_written);
}

fn udp_socket::send_to( mut this, socket_address& a, array_view_imut</byte8/> data ) : result</size_type, io_error/>
{
	if_var( &a_v4 : a.get</socket_address_v4/>() )
	{
		var sockaddr_in mut underlying_address
		{
			.sin_family( AF_INET ),
			.sin_port= a_v4.get_port(),
			.sin_addr{ .s_addr= a_v4.get_ip().get_bits() },
			.sin_zero= zero_init,
		};

		var ssize_type bytes_written=
			unsafe( ::sendto(
				socket_,
				data.data(),
				data.size(),
				0,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in/>.size_of ) ) );

		if( bytes_written < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		return size_type(bytes_written);
	}
	else
	{
		// TODO - support IP v6.
		halt;
	}
}

fn udp_socket::receive_from( mut this, array_view_mut</byte8/> data ) : result</ tup[ socket_address, size_type ], io_error/>
{
	var sockaddr mut sender_address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut socket_address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var ssize_type bytes_read=
			unsafe( ::recvfrom(
				socket_,
				data.data(),
				data.size(),
				0,
				$<( sender_address ),
				$<( socket_address_length ) ) );

		if( bytes_read < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		if( i32(sender_address.sa_family) == AF_INET )
		{
			// Cast sockaddr to sockaddr_in using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
			var sockaddr_in mut sender_address_ip_v4= zero_init;

			memory_copy(
				ptr_cast_to_byte8( $<(sender_address_ip_v4) ),
				ptr_cast_to_byte8( $<(sender_address) ),
				typeinfo</sockaddr_in/>.size_of );

			var tup[ socket_address, size_type ] res
			[
				socket_address_v4( ip_address_v4( sender_address_ip_v4.sin_addr.s_addr ), sender_address_ip_v4.sin_port ),
				( bytes_read )
			];

			return res;
		}
		else
		{
			// TODO - support IP v6.
			return io_error::other;
		}
	}
}

fn udp_socket::receive( mut this, array_view_mut</byte8/> data ) : result</ size_type, io_error/>
{
	var ssize_type bytes_read= unsafe( ::recv( socket_, data.data(), data.size(), 0 ) );

	if( bytes_read < ssize_type(0) )
	{
		return translate_errno( get_errno() );
	}

	return size_type(bytes_read);
}

fn udp_socket::peek_from( mut this, array_view_mut</byte8/> data ) : result</ tup[ socket_address, size_type ], io_error/>
{
	var sockaddr mut sender_address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut socket_address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var ssize_type bytes_read=
			unsafe( ::recvfrom(
				socket_,
				data.data(),
				data.size(),
				i32( MSG_PEEK ),
				$<( sender_address ),
				$<( socket_address_length ) ) );

		if( bytes_read < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( sender_address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		var tup[ socket_address, size_type ] res
		[
			address_translated_opt.try_take(),
			( bytes_read )
		];

		return res;
	}
}

fn udp_socket::peek( mut this, array_view_mut</byte8/> data ) : result</ size_type, io_error/>
{
	var ssize_type bytes_read= unsafe( ::recv( socket_, data.data(), data.size(), i32(MSG_PEEK) ) );

	if( bytes_read < ssize_type(0) )
	{
		return translate_errno( get_errno() );
	}

	return size_type(bytes_read);
}

fn udp_socket::connect( mut this, socket_address& a ) : result</void, io_error/>
{
	if_var( &a_v4 : a.get</socket_address_v4/>() )
	{
		var sockaddr_in mut underlying_address
		{
			.sin_family( AF_INET ),
			.sin_port= a_v4.get_port(),
			.sin_addr{ .s_addr= a_v4.get_ip().get_bits() },
			.sin_zero= zero_init,
		};

		var i32 res=
			unsafe( ::connect(
				socket_,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in/>.size_of ) ) );

		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}
	}
	else
	{
		// TODO - support IP v6.
		halt;
	}

	return void();
}

fn udp_socket::is_nonblocking( this ) : result</bool, io_error/>
{
	var i32 flags= unsafe( ::fcntl( socket_, F_GETFL, 0 ) );

	if( flags == -1 )
	{
		return translate_errno( get_errno() );
	}

	return ( flags & O_NONBLOCK ) != 0;
}

fn udp_socket::set_nonblocking( mut this, bool nonblocking ) : result</void, io_error/>
{
	unsafe
	{
		var i32 mut flags= ::fcntl( socket_, F_GETFL, 0 );

		if( flags == -1 )
		{
			return translate_errno( get_errno() );
		}

		if( nonblocking )
		{
			flags|= O_NONBLOCK;
		}
		else
		{
			flags &= ~O_NONBLOCK;
		}

		var i32 res= ::fcntl( socket_, F_SETFL, flags );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}
	}

	return void();
}

fn udp_socket::get_local_address( this ) : result</socket_address, io_error/>
{
	var sockaddr mut address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var i32 res= ::getsockname( socket_, $<(address), $<(address_length) );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn udp_socket::get_peer_address( this ) : result</socket_address, io_error/>
{
	var sockaddr mut address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var i32 res= ::getpeername( socket_, $<(address), $<(address_length) );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn udp_socket::get_ttl( this ) : result</u32, io_error/>
{
	var u32 mut ttl= 0u;

	var socklen_t mut len( typeinfo</u32/>.size_of );

	var i32 res=
		unsafe( ::getsockopt(
			socket_,
			i32( IPPROTO_IP ),
			i32( IP_TTL ),
			ptr_cast_to_byte8( $<( ttl ) ),
			$<(len) ) );

	if( res != 0 )
	{
		return translate_errno( get_errno() );
	}

	return ttl;
}

fn udp_socket::set_ttl( mut this, u32 mut ttl ) : result</void, io_error/>
{
	var i32 res=
		unsafe( ::setsockopt(
			socket_,
			i32( IPPROTO_IP ),
			i32( IP_TTL ),
			ptr_cast_to_byte8( $<( ttl ) ),
			socklen_t( typeinfo</u32/>.size_of ) ) );

	if( res != 0 )
	{
		return translate_errno( get_errno() );
	}

	return void();
}

// Convert "sockaddr" into our own representation.
fn translate_socket_address( sockaddr& address ) : ust::optional</socket_address/>
{
	if( i32(address.sa_family) == AF_INET )
	{
		static_assert( typeinfo</sockaddr/>.size_of >= typeinfo</sockaddr_in/>.size_of );

		// Cast "sockaddr" to "sockaddr_in" using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
		var sockaddr_in mut address_ip_v4= zero_init;

		unsafe
		{
			memory_copy(
				ptr_cast_to_byte8( $<(address_ip_v4) ),
				ptr_cast_to_byte8( $<( cast_mut(address) ) ),
				typeinfo</sockaddr_in/>.size_of );
		}

		return socket_address( socket_address_v4( ip_address_v4( address_ip_v4.sin_addr.s_addr ), address_ip_v4.sin_port ) );
	}
	else
	{
		// TODO - support IP v6.
		return ust::null_optional;
	}
}

} // namespace net

} // namespace ust
