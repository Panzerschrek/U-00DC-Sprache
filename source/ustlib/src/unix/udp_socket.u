import "../../imports/udp_socket.u"
import "errno.uh"
import "socket.uh"

namespace ust
{

fn udp_socket::create() : result</udp_socket, io_error/>
{
	unsafe
	{
		var native_socket_fd s= ::socket( PF_INET, i32(SOCK_DGRAM), 0 );
		if( s == -1 )
		{
			return translate_errno( get_errno() );
		}

		return udp_socket( s );
	}
}

fn udp_socket::create_and_bind( socket_address& a ) : result</udp_socket, io_error/>
{
	unsafe
	{
		if_var( &a_v4 : a.get</socket_address_v4/>() )
		{
			var native_socket_fd s= ::socket( PF_INET, i32(SOCK_DGRAM), 0 );
			if( s == -1 )
			{
				return translate_errno( get_errno() );
			}

			var sockaddr_in mut underlying_address= translate_socket_address( a_v4 );

			var i32 res=
				::bind(
					s,
					$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
					socklen_t( typeinfo</sockaddr_in/>.size_of ) );

			if( res != 0 )
			{
				var i32 e= get_errno();
				::close( s );
				return translate_errno( e );
			}

			return udp_socket( s );
		}
		else if_var( &a_v6 : a.get</socket_address_v6/>() )
		{
			var native_socket_fd s= ::socket( PF_INET6, i32(SOCK_DGRAM), 0 );
			if( s == -1 )
			{
				return translate_errno( get_errno() );
			}

			var sockaddr_in6 mut underlying_address= translate_socket_address( a_v6 );

			var i32 res=
				::bind(
					s,
					$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
					socklen_t( typeinfo</sockaddr_in6/>.size_of ) );

			if( res != 0 )
			{
				var i32 e= get_errno();
				::close( s );
				return translate_errno( e );
			}

			return udp_socket( s );
		}
		else { halt; }
	}
}

fn udp_socket::constructor( native_socket_fd s ) unsafe
	( socket_= s )
{}

fn udp_socket::destructor()
{
	unsafe( ::close( socket_ ) );
}

fn udp_socket::send( mut this, array_view_imut</byte8/> data ) : result</size_type, io_error/>
{
	var ssize_type bytes_written= unsafe( ::send( socket_, data.data(), data.size(), 0 ) );

	if( bytes_written < ssize_type(0) )
	{
		return translate_errno( get_errno() );
	}

	return size_type(bytes_written);
}

fn udp_socket::send_to( mut this, socket_address& a, array_view_imut</byte8/> data ) : result</size_type, io_error/>
{
	if_var( &a_v4 : a.get</socket_address_v4/>() )
	{
		var sockaddr_in mut underlying_address= translate_socket_address( a_v4 );

		var ssize_type bytes_written=
			unsafe( ::sendto(
				socket_,
				data.data(),
				data.size(),
				0,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in/>.size_of ) ) );

		if( bytes_written < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		return size_type(bytes_written);
	}
	else if_var( &a_v6 : a.get</socket_address_v6/>() )
	{
		var sockaddr_in6 mut underlying_address= translate_socket_address( a_v6 );

		var ssize_type bytes_written=
			unsafe( ::sendto(
				socket_,
				data.data(),
				data.size(),
				0,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in6/>.size_of ) ) );

		if( bytes_written < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		return size_type(bytes_written);
	}
	else { halt; }
}

fn udp_socket::receive_from( mut this, array_view_mut</byte8/> data ) : result</ tup[ socket_address, size_type ], io_error/>
{
	var sockaddr_storage mut sender_address= zero_init;

	var socklen_t mut socket_address_length( typeinfo</sockaddr_storage/>.size_of );

	unsafe
	{
		var ssize_type bytes_read=
			unsafe( ::recvfrom(
				socket_,
				data.data(),
				data.size(),
				0,
				$<( cast_ref_unsafe</sockaddr/>( sender_address ) ),
				$<( socket_address_length ) ) );

		if( bytes_read < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( sender_address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		var tup[ socket_address, size_type ] res
		[
			address_translated_opt.try_take(),
			( bytes_read )
		];

		return res;
	}
}

fn udp_socket::receive( mut this, array_view_mut</byte8/> data ) : result</ size_type, io_error/>
{
	var ssize_type bytes_read= unsafe( ::recv( socket_, data.data(), data.size(), 0 ) );

	if( bytes_read < ssize_type(0) )
	{
		return translate_errno( get_errno() );
	}

	return size_type(bytes_read);
}

fn udp_socket::peek_from( mut this, array_view_mut</byte8/> data ) : result</ tup[ socket_address, size_type ], io_error/>
{
	var sockaddr_storage mut sender_address= zero_init;

	var socklen_t mut socket_address_length( typeinfo</sockaddr_storage/>.size_of );

	unsafe
	{
		var ssize_type bytes_read=
			unsafe( ::recvfrom(
				socket_,
				data.data(),
				data.size(),
				i32( MSG_PEEK ),
				$<( cast_ref_unsafe</sockaddr/>( sender_address ) ),
				$<( socket_address_length ) ) );

		if( bytes_read < ssize_type(0) )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( sender_address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		var tup[ socket_address, size_type ] res
		[
			address_translated_opt.try_take(),
			( bytes_read )
		];

		return res;
	}
}

fn udp_socket::peek( mut this, array_view_mut</byte8/> data ) : result</ size_type, io_error/>
{
	var ssize_type bytes_read= unsafe( ::recv( socket_, data.data(), data.size(), i32(MSG_PEEK) ) );

	if( bytes_read < ssize_type(0) )
	{
		return translate_errno( get_errno() );
	}

	return size_type(bytes_read);
}

fn udp_socket::connect( mut this, socket_address& a ) : result</void, io_error/>
{
	if_var( &a_v4 : a.get</socket_address_v4/>() )
	{
		var sockaddr_in mut underlying_address= translate_socket_address( a_v4 );

		var i32 res=
			unsafe( ::connect(
				socket_,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in/>.size_of ) ) );

		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}
	}
	else if_var( &a_v6 : a.get</socket_address_v6/>() )
	{
		var sockaddr_in6 mut underlying_address= translate_socket_address( a_v6 );

		var i32 res=
			unsafe( ::connect(
				socket_,
				$<( cast_ref_unsafe</sockaddr/>( underlying_address ) ),
				socklen_t( typeinfo</sockaddr_in6/>.size_of ) ) );

		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}
	}
	else { halt; }

	return void();
}

fn udp_socket::is_nonblocking( this ) : result</bool, io_error/>
{
	return is_socket_nonblocking( socket_ );
}

fn udp_socket::set_nonblocking( mut this, bool nonblocking ) : result</void, io_error/>
{
	return set_socket_nonblocking( socket_, nonblocking );
}

fn udp_socket::get_local_address( this ) : result</socket_address, io_error/>
{
	return get_socket_local_address( socket_ );
}

fn udp_socket::get_peer_address( this ) : result</socket_address, io_error/>
{
	return get_socket_peer_address( socket_ );
}

fn udp_socket::get_ttl( this ) : result</u8, io_error/>
{
	return get_socket_ttl( socket_ );
}

fn udp_socket::set_ttl( mut this, u8 mut ttl ) : result</void, io_error/>
{
	return set_socket_ttl( socket_, ttl );
}

fn udp_socket::get_native_fd( this ) unsafe : native_socket_fd
{
	return socket_;
}

fn udp_socket::take_native_fd( byval mut this ) unsafe : native_socket_fd
{
	var native_socket_fd s= socket_;
	unsafe( move_into_nowhere( move(this) ) ); // Forget about "this" to avoid calling destructor.
	return s;
}

} // namespace ust
