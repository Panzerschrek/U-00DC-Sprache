import "../../imports/memory.u"
import "../../imports/alloc.u"
import "../../imports/atomic.u"
import "../../imports/semaphore_impl.u"
import "semaphore.uh"

namespace ust
{

namespace semaphore_impl
{

static_assert( same_type</ semaphore_handle_t, $(byte8) />, "Invalid type for semaphore handle!" );

var bool is_darwin= constexpr_string_equals( compiler::target::vendor, "apple" );

var u32 mut semaphore_unique_index= 1u;

fn create_semaphore( u32 initial_value ) unsafe : semaphore_handle_t
{
	static_if( is_darwin )
	{
		// MacOS doesn't support unnamed semaphores, so, create named one.
		// Use atomic variable to generate names - to ensure uniqueness.
		// TODO - use also process id for name generation.

		var u32 id= unsafe( atomic_inc( semaphore_unique_index ) );
		auto mut name_nt= "u_semaphore_000000000\0";
		var u32 name_size_without_null( typeinfo</ typeof(name_nt) />.size_of - 1s );

		for( var u32 mut i= 0u, mut t= 1u; i < 9u; ++i, t *= 10u )
		{
			name_nt[ name_size_without_null - 1u - i ]= char8( u32('0') + id / t % 10u );
		}

		var $(sem_t) res= unsafe( ::sem_open( $<(name_nt[0]), i32(O_CREAT | O_EXCL), mode_t(0o744), initial_value ) );
		halt if( is_nullptr(res) );
		return unsafe( ptr_cast_to_byte8( res ) );
	}
	else
	{
		unsafe
		{
			// We need stable address of the semaphore object, so, allocate it on heap.
			var $(byte8) mem= memory_allocate( typeinfo</sem_t/>.size_of );
			var i32 res= ::sem_init( byte_ptr_cast</sem_t/>( mem ), 0, initial_value );
			halt if( res != 0 );
			return mem;
		}
	}
}

fn destroy_semaphore( semaphore_handle_t s ) unsafe
{
	static_if( is_darwin )
	{
		unsafe( ::sem_close( byte_ptr_cast</sem_t/>(s) ) );
	}
	else
	{
		unsafe
		{
			::sem_destroy( byte_ptr_cast</sem_t/>( s ) );
			memory_free( s );
		}
	}
}

fn acquire_semaphore( semaphore_handle_t s ) unsafe
{
	unsafe
	{
		var i32 res= ::sem_wait( byte_ptr_cast</sem_t/>( s ) );
		halt if( res != 0 );
	}
}

fn release_semaphore( semaphore_handle_t s ) unsafe
{
	unsafe
	{
		var i32 res= ::sem_post( byte_ptr_cast</sem_t/>( s ) );
		halt if( res != 0 );
	}
}

} // namespace semaphore_impl

} // namespace ust
