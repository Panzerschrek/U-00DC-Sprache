import "../../imports/file.u"
import "../../imports/string.u" // TODO - remove this import, it's too heavy and unnecessary.
import "unix.uh"

namespace ust
{

//
// sequential_read_file
//

fn sequential_read_file::open( file_path path ) : file_result</sequential_read_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= true, .write= false, .create= false, .truncate= false } ) );
		return sequential_read_file(handle);
	}
}

fn sequential_read_file::constructor( native_file_handle handle ) unsafe
	( handle_= handle )
{}

fn sequential_read_file::destructor()
{
	unsafe( close_file_impl( handle_ ) );
}

fn sequential_read_file::read( mut this, ust::array_view_mut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( read_impl( handle_, buf ) );
}

//
// sequential_write_file
//

fn sequential_write_file::open( file_path path ) : file_result</sequential_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= false, .write= true, .create= false, .truncate= false } ) );
		return sequential_write_file(handle);
	}
}

fn sequential_write_file::create( file_path path ) : file_result</sequential_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= false, .write= true, .create= true, .truncate= true } ) );
		return sequential_write_file(handle);
	}
}

fn sequential_write_file::constructor( native_file_handle handle ) unsafe
	( handle_= handle )
{}

fn sequential_write_file::destructor()
{
	unsafe( close_file_impl( handle_ ) );
}

fn sequential_write_file::write( mut this, ust::array_view_imut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( write_impl( handle_, buf ) );
}

//
// sequential_read_write_file
//

fn sequential_read_write_file::open( file_path path ) : file_result</sequential_read_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= true, .write= true, .create= false, .truncate= false } ) );
		return sequential_read_write_file(handle);
	}
}

fn sequential_read_write_file::create( file_path path ) : file_result</sequential_read_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= true, .write= true, .create= true, .truncate= true } ) );
		return sequential_read_write_file(handle);
	}
}

fn sequential_read_write_file::constructor( native_file_handle handle ) unsafe
	( handle_= handle )
{}

fn sequential_read_write_file::destructor()
{
	unsafe( close_file_impl( handle_ ) );
}

fn sequential_read_write_file::read( mut this, ust::array_view_mut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( read_impl( handle_, buf ) );
}

fn sequential_read_write_file::write( mut this, ust::array_view_imut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( write_impl( handle_, buf ) );
}

//
// seekable_read_file
//

fn seekable_read_file::open( file_path path ) : file_result</seekable_read_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= true, .write= false, .create= false, .truncate= false } ) );
		return seekable_read_file(handle);
	}
}

fn seekable_read_file::constructor( native_file_handle handle ) unsafe
	( handle_= handle )
{}

fn seekable_read_file::destructor()
{
	unsafe( close_file_impl( handle_ ) );
}

fn seekable_read_file::read( mut this, ust::array_view_mut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( read_impl( handle_, buf ) );
}

fn seekable_read_file::seek( mut this, u64 offset ) : file_result</void/>
{
	return unsafe( seek_impl( handle_, offset ) );
}

//
// seekable_write_file
//

fn seekable_write_file::open( file_path path ) : file_result</seekable_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path , open_options{ .read= false, .write= true, .create= false, .truncate= false } ) );
		return seekable_write_file(handle);
	}
}

fn seekable_write_file::create( file_path path ) : file_result</seekable_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= false, .write= true, .create= true, .truncate= true } ) );
		return seekable_write_file(handle);
	}
}

fn seekable_write_file::constructor( native_file_handle handle ) unsafe
	( handle_= handle )
{}

fn seekable_write_file::destructor()
{
	unsafe( close_file_impl( handle_ ) );
}

fn seekable_write_file::write( mut this, ust::array_view_imut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( write_impl( handle_, buf ) );
}

fn seekable_write_file::seek( mut this, u64 offset ) : file_result</void/>
{
	return unsafe( seek_impl( handle_, offset ) );
}

//
// seekable_read_write_file
//

fn seekable_read_write_file::open( file_path path ) : file_result</seekable_read_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= true, .write= true, .create= false, .truncate= false } ) );
		return seekable_read_write_file(handle);
	}
}

fn seekable_read_write_file::create( file_path path ) : file_result</seekable_read_write_file/>
{
	unsafe
	{
		result_unwrap_or_return( handle : open_file_impl( path, open_options{ .read= true, .write= true, .create= true, .truncate= true } ) );
		return seekable_read_write_file(handle);
	}
}

fn seekable_read_write_file::constructor( native_file_handle handle ) unsafe
	( handle_= handle )
{}

fn seekable_read_write_file::destructor()
{
	unsafe( close_file_impl( handle_ ) );
}

fn seekable_read_write_file::read( mut this, ust::array_view_mut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( read_impl( handle_, buf ) );
}

fn seekable_read_write_file::write( mut this, ust::array_view_imut</byte8/> buf ) : file_result</size_type/>
{
	return unsafe( write_impl( handle_, buf ) );
}

fn seekable_read_write_file::seek( mut this, u64 offset ) : file_result</void/>
{
	return unsafe( seek_impl( handle_, offset ) );
}

// impl functions

struct open_options
{
	bool read;
	bool write;
	bool create;
	bool truncate;
}

fn open_file_impl( file_path path, open_options& options ) unsafe : file_result</native_file_handle/>
{
	var ust::string8 mut path_nt= concat( path, "\0" ); // TODO - use scoped array instead.

	var i32 mut open_flags= 0;
	var u32 mut file_mode= 0u;

	if( options.read & options.write )
	{
		open_flags|= O_RDWR;
	}
	else if( options.read )
	{
		open_flags|= O_RDONLY;
	}
	else if( options.write )
	{
		open_flags|= O_WRONLY;
	}

	if( options.create )
	{
		open_flags|= O_CREAT;
		// TODO - provide permissions for newly-created files.
		file_mode|= 0o644u;
	}
	if( options.truncate )
	{
		open_flags|= O_TRUNC;
	}

	var i32 handle= unsafe( ::open( path_nt.data(), open_flags, file_mode ) );
	if( handle == -1 )
	{
		return io_error::other; // TODO - translate error code properly.
	}

	return handle;
}

fn close_file_impl( native_file_handle handle ) unsafe
{
	unsafe( ::close( handle ) );
	halt;
}

fn read_impl( native_file_handle handle, ust::array_view_mut</byte8/> buf ) unsafe : file_result</size_type/>
{
	// TODO - maybe read in loop to support larget sizes?

	var ssize_type read_res = unsafe( ::read( handle, buf.data(), buf.size() ) );

	if( read_res < ssize_type(0) )
	{
		return io_error::other; // TODO - translate error code properly.
	}

	if( read_res == ssize_type(0) )
	{
		return 0s; // End of file reached.
	}

	// Expected number of bytes or less.
	return size_type(read_res);
}

fn write_impl( native_file_handle handle, ust::array_view_imut</byte8/> buf ) unsafe : file_result</size_type/>
{
	// TODO - maybe write in loop to support larget sizes?

	var ssize_type write_res = unsafe( ::write( handle, buf.data(), buf.size() ) );

	if( write_res < ssize_type(0) )
	{
		return io_error::other; // TODO - translate error code properly.
	}

	if( write_res == ssize_type(0) )
	{
		return 0s; // End of file reached.
	}

	// Expected number of bytes or less.
	return size_type(write_res);
}

fn seek_impl( native_file_handle handle, u64 offset ) unsafe : file_result</void/>
{
	var ü__off64_t seek_res= unsafe( ::lseek64( handle, ü__off64_t(offset), SEEK_SET ) );

	if( seek_res == ü__off64_t(-1) )
	{
		return io_error::other; // TODO - translate error code properly.
	}

	return void();
}

} // namespace ust
