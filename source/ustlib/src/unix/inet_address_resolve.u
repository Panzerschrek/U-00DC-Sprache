import "../../imports/bytes_order.u"
import "../../imports/inet_address_resolve.u"
import "socket.uh"

namespace ust
{

fn resolve_inet_address( string_view8 name ) : vector</ip_address/>
{
	var vector</ip_address/> mut res;

	unsafe
	{
		var $(addrinfo) mut infos= zero_init;

		var i32 call_res= getaddrinfo( name.data(), nullptr</char8/>(), nullptr</addrinfo/>(), $<(infos) );
		if( call_res != 0 )
		{
			return res;
		}

		for( var $(addrinfo) mut info_ptr= infos; !is_nullptr( info_ptr ); info_ptr= $>(info_ptr).ai_next )
		{
			var addrinfo& info= $>(info_ptr);
			if( !is_nullptr( info.ai_addr ) )
			{
				if( i32( $>( info.ai_addr ).sa_family ) == AF_INET &&
					size_type( info.ai_addrlen ) >= typeinfo</sockaddr_in/>.size_of )
				{
					// Cast sockaddr to sockaddr_in using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
					var sockaddr_in mut address_ip_v4= zero_init;

					memory_copy(
						ptr_cast_to_byte8( $<(address_ip_v4) ),
						ptr_cast_to_byte8( info.ai_addr ),
						typeinfo</sockaddr_in/>.size_of );

					res.push_back( ip_address_v4( to_host_bytes_order( address_ip_v4.sin_addr.s_addr ) ) );
				}

				if( i32( $>( info.ai_addr ).sa_family ) == AF_INET6 &&
					size_type( info.ai_addrlen ) >= typeinfo</sockaddr_in6/>.size_of )
				{
					// Cast sockaddr to sockaddr_in using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
					var sockaddr_in6 mut address_ip_v6= zero_init;

					memory_copy(
						ptr_cast_to_byte8( $<(address_ip_v6) ),
						ptr_cast_to_byte8( info.ai_addr ),
						typeinfo</sockaddr_in/>.size_of );

					var u128 ip_raw=
						( u128( to_host_bytes_order( address_ip_v6.sin6_addr.parts[0] ) ) << 96u ) |
						( u128( to_host_bytes_order( address_ip_v6.sin6_addr.parts[1] ) ) << 64u ) |
						( u128( to_host_bytes_order( address_ip_v6.sin6_addr.parts[2] ) ) << 32u ) |
						( u128( to_host_bytes_order( address_ip_v6.sin6_addr.parts[3] ) ) <<  0u );


					res.push_back( ip_address_v6( ip_raw ) );
				}
			}
		}
	}

	return res;
}

} // namespace ust
