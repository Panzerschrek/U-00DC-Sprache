import "socket.uh"
import "errno.uh"

namespace ust
{

fn translate_socket_address( sockaddr& address ) : optional</socket_address/>
{
	if( i32(address.sa_family) == AF_INET )
	{
		static_assert( typeinfo</sockaddr/>.size_of >= typeinfo</sockaddr_in/>.size_of );

		// Cast "sockaddr" to "sockaddr_in" using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
		var sockaddr_in mut address_ip_v4= zero_init;

		unsafe
		{
			memory_copy(
				ptr_cast_to_byte8( $<(address_ip_v4) ),
				ptr_cast_to_byte8( $<( cast_mut(address) ) ),
				typeinfo</sockaddr_in/>.size_of );
		}

		return socket_address( socket_address_v4( ip_address_v4( address_ip_v4.sin_addr.s_addr ), address_ip_v4.sin_port ) );
	}
	else
	{
		// TODO - support IP v6.
		return ust::null_optional;
	}
}

fn is_socket_nonblocking( native_socket_fd s ) : result</bool, io_error/>
{
	var i32 flags= unsafe( ::fcntl( s, F_GETFL, 0 ) );

	if( flags == -1 )
	{
		return translate_errno( get_errno() );
	}

	return ( flags & O_NONBLOCK ) != 0;
}

fn set_socket_nonblocking( native_socket_fd s, bool nonblocking ) : result</void, io_error/>
{
	unsafe
	{
		var i32 mut flags= ::fcntl( s, F_GETFL, 0 );

		if( flags == -1 )
		{
			return translate_errno( get_errno() );
		}

		if( nonblocking )
		{
			flags |= O_NONBLOCK;
		}
		else
		{
			flags &= ~O_NONBLOCK;
		}

		var i32 res= ::fcntl( s, F_SETFL, flags );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}
	}

	return void();
}

} // namespace ust
