import "socket.uh"
import "errno.uh"

namespace ust
{

fn translate_socket_address( sockaddr& address ) : optional</socket_address/>
{
	if( i32(address.sa_family) == AF_INET )
	{
		static_assert( typeinfo</sockaddr/>.size_of >= typeinfo</sockaddr_in/>.size_of );

		// Cast "sockaddr" to "sockaddr_in" using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
		var sockaddr_in mut address_ip_v4= zero_init;

		unsafe
		{
			memory_copy(
				ptr_cast_to_byte8( $<(address_ip_v4) ),
				ptr_cast_to_byte8( $<( cast_mut(address) ) ),
				typeinfo</sockaddr_in/>.size_of );
		}

		return socket_address( socket_address_v4( ip_address_v4( address_ip_v4.sin_addr.s_addr ), address_ip_v4.sin_port ) );
	}
	else
	{
		// TODO - support IP v6.
		return null_optional;
	}
}

fn is_socket_nonblocking( native_socket_fd s ) : result</bool, io_error/>
{
	var i32 flags= unsafe( ::fcntl( s, F_GETFL, 0 ) );

	if( flags == -1 )
	{
		return translate_errno( get_errno() );
	}

	return ( flags & O_NONBLOCK ) != 0;
}

fn set_socket_nonblocking( native_socket_fd s, bool nonblocking ) : result</void, io_error/>
{
	unsafe
	{
		var i32 mut flags= ::fcntl( s, F_GETFL, 0 );

		if( flags == -1 )
		{
			return translate_errno( get_errno() );
		}

		if( nonblocking )
		{
			flags |= O_NONBLOCK;
		}
		else
		{
			flags &= ~O_NONBLOCK;
		}

		var i32 res= ::fcntl( s, F_SETFL, flags );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}
	}

	return void();
}

fn get_socket_local_address( native_socket_fd s ) : result</socket_address, io_error/>
{
	var sockaddr mut address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var i32 res= ::getsockname( s, $<(address), $<(address_length) );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn get_socket_peer_address( native_socket_fd s ) : result</socket_address, io_error/>
{
	var sockaddr mut address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var i32 res= ::getpeername( s, $<(address), $<(address_length) );
		if( res != 0 )
		{
			return translate_errno( get_errno() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn get_socket_ttl( native_socket_fd s ) : result</u8, io_error/>
{
	var u32 mut ttl= 0u;

	var socklen_t mut len( typeinfo</u32/>.size_of );

	var i32 res=
		unsafe( ::getsockopt(
			s,
			i32( IPPROTO_IP ),
			i32( IP_TTL ),
			ptr_cast_to_byte8( $<( ttl ) ),
			$<(len) ) );

	if( res != 0 )
	{
		return translate_errno( get_errno() );
	}

	return u8( min( ttl, 255u ) );
}

fn set_socket_ttl( native_socket_fd s, u8 ttl ) : result</void, io_error/>
{
	var u32 mut ttl32( ttl );

	var i32 res=
		unsafe( ::setsockopt(
			s,
			i32( IPPROTO_IP ),
			i32( IP_TTL ),
			ptr_cast_to_byte8( $<( ttl32 ) ),
			socklen_t( typeinfo</u32/>.size_of ) ) );

	if( res != 0 )
	{
		return translate_errno( get_errno() );
	}

	return void();
}

} // namespace ust
