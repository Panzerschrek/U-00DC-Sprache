import "../imports/inet_address.u"
import "../imports/integer_parsing.u"

namespace ust
{

fn parse_ip_address_v4( string_view8 mut s ) : optional</ip_address_v4/>
{
	if_var( ip : extract_ip_v4_address(s) )
	{
		if( !s.empty() )
		{
			// Allow no trailing symbols.
			return null_optional;
		}

		return ip;
	}

	return null_optional;
}

fn parse_ip_address_v6( string_view8 mut s ) : optional</ip_address_v6/>
{
	var [ u16, 8 ] mut parts= zero_init;

	var size_type mut num_parts_parsed= 0s;

	var size_type mut zeros_position= ~0s;

	for( var size_type mut i= 0s; i < 8s && !s.empty(); ++i )
	{
		if( i == 0s )
		{
			if( s.starts_with( "::" ) )
			{
				if( zeros_position != ~0s )
				{
					return null_optional;
				}

				zeros_position= num_parts_parsed;

				s.drop_front();
				s.drop_front();
			}
		}
		else
		{
			if( s.empty() || s.front() != ':' )
			{
				return null_optional;
			}
			s.drop_front();

			if( !s.empty() && s.front() == ':' )
			{
				if( zeros_position != ~0s )
				{
					return null_optional;
				}

				zeros_position= num_parts_parsed;

				s.drop_front();
			}
		}

		var optional</u16/> d= extract_hex_u16( s );
		if( d.empty() )
		{
			break;
		}

		parts[num_parts_parsed]= d.try_deref();

		++num_parts_parsed;
	}

	if( !s.empty() )
	{
		// Allow no trailing symbols.
		return null_optional;
	}

	if( zeros_position == ~0s )
	{
		if( num_parts_parsed != 8s )
		{
			return null_optional;
		}

		var [ u8, 16 ] octets
		[
			( parts[0] >> 8u ), ( parts[0] ),
			( parts[1] >> 8u ), ( parts[1] ),
			( parts[2] >> 8u ), ( parts[2] ),
			( parts[3] >> 8u ), ( parts[3] ),
			( parts[4] >> 8u ), ( parts[4] ),
			( parts[5] >> 8u ), ( parts[5] ),
			( parts[6] >> 8u ), ( parts[6] ),
			( parts[7] >> 8u ), ( parts[7] ),
		];

		return ip_address_v6( octets );
	}
	else
	{
		var [ u8, 16 ] mut octets= zero_init;

		for( var size_type mut i= 0s; i < zeros_position; ++i )
		{
			var u16 part= parts[i];
			octets[ i * 2s + 0s ]= u8( part >> 8u );
			octets[ i * 2s + 1s ]= u8( part );
		}

		for( var size_type mut i= zeros_position + 8s - num_parts_parsed; i < 8s; ++i )
		{
			var u16 part= parts[ i - 8s + num_parts_parsed ];
			octets[ i * 2s + 0s ]= u8( part >> 8u );
			octets[ i * 2s + 1s ]= u8( part );
		}

		return ip_address_v6( octets );
	}
}

fn parse_socket_address_v4( string_view8 mut s ) : optional</socket_address_v4/>
{
	if_var( mut ip : extract_ip_v4_address(s) )
	{
		if( !( s.size() >= 1s && s.front() == ':' ) )
		{
			return null_optional;
		}
		s.drop_front();

		var u16 mut port= zero_init;

		if_var( p : parse_and_extract_integer</u16/>( s ) )
		{
			port= p;
		}
		else
		{
			return null_optional;
		}

		if( !s.empty() )
		{
			// Allow no trailing symbols.
			return null_optional;
		}

		return socket_address_v4( move(ip), port );
	}

	return null_optional;
}

fn parse_socket_address_v6( string_view8 s ) : optional</socket_address_v6/>
{
	// TODO
	ignore_unused( s );
	return null_optional;
}

fn parse_socket_address( string_view8 mut s ) : optional</socket_address/>
{
	if_var( mut a : parse_socket_address_v4( s ) )
	{
		return socket_address( move(a) );
	}
	if_var( mut a : parse_socket_address_v6( s ) )
	{
		return socket_address( move(a) );
	}

	return null_optional;
}

fn extract_ip_v4_address( string_view8 &mut s ) : optional</ip_address_v4/>
{
	var [ u8, 4 ] mut octets= zero_init;

	for( var size_type mut i= 0s; i < 3s; ++i )
	{
		if_var( o : parse_and_extract_integer</u8/>( s ) )
		{
			octets[i]= o;
		}
		else
		{
			return null_optional;
		}

		if( !( s.size() >= 1s && s.front() == '.' ) )
		{
			return null_optional;
		}
		s.drop_front();
	}

	if_var( o : parse_and_extract_integer</u8/>( s ) )
	{
		octets[3]= o;
	}
	else
	{
		return null_optional;
	}

	return ip_address_v4( octets );
}

fn extract_hex_u16( string_view8 &mut s ) : optional</u16/>
{
	// Always parse first digit.
	var u32 digit0= extract_hex_digit( s );
	if( digit0 == c_no_digit )
	{
		return null_optional;
	}

	var u32 mut res= digit0;

	// Parse maximum 3 digits.
	for( auto mut i= 0s; i < 3s; ++i )
	{
		auto mut d= extract_hex_digit( s );
		if( d == c_no_digit )
		{
			break;
		}

		res <<= 4u;
		res += d;
	}

	return u16( res );
}

var u32 c_no_digit= 0xFFFFFFFFu;

fn extract_hex_digit( string_view8 &mut s ) : u32
{
	if( s.empty() )
	{
		return c_no_digit;
	}

	var char8 c= s.front();

	if( c >= '0' && c <= '9' )
	{
		s.drop_front();
		return u32( c ) - u32( '0' );
	}

	if( c >= 'a' && c <= 'f' )
	{
		s.drop_front();
		return u32( c ) - u32( 'a' ) + 10u;
	}

	if( c >= 'A' && c <= 'F' )
	{
		s.drop_front();
		return u32( c ) - u32( 'A' ) + 10u;
	}

	return c_no_digit;
}

} // namespace ust
