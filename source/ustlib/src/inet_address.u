import "../imports/inet_address.u"
import "../imports/integer_parsing.u"
import "../imports/string_conversions.u"

namespace ust
{

fn ip_address_v4::parse( string_view8 mut s ) : optional</ip_address_v4/>
{
	if_var( ip : extract_ip_v4_address(s) )
	{
		if( !s.empty() )
		{
			// Allow no trailing symbols.
			return null_optional;
		}

		return ip;
	}

	return null_optional;
}

fn ip_address_v4::to_string( this ) : string8
{
	return
		concat(
			to_string8( u8( bits_ >> 24u ) ),
			".",
			to_string8( u8( bits_ >> 16u ) ),
			".",
			to_string8( u8( bits_ >>  8u ) ),
			".",
			to_string8( u8( bits_ >>  0u ) ) );
}

fn ip_address_v6::parse( string_view8 mut s ) : optional</ip_address_v6/>
{
	if_var( ip : extract_ip_v6_address(s) )
	{
		if( !s.empty() )
		{
			// Allow no trailing symbols.
			return null_optional;
		}

		return ip;
	}

	return null_optional;
}

fn ip_address_v6::to_string( this ) : string8
{
	var string8 mut res( 32s + 7s, ':' );

	var [ u8, 16 ] octets= get_octets();

	for( var size_type mut i= 0s; i < 8s; ++i)
	{
		var size_type dst= i * 5s;
		var u32 o0( octets[ i * 2s + 0s ] );
		res[ dst + 0s ]= get_hex_digit( o0 >> 4u );
		res[ dst + 1s ]= get_hex_digit( o0 & 15u );
		var u32 o1( octets[ i * 2s + 1s ] );
		res[ dst + 2s ]= get_hex_digit( o1 >> 4u );
		res[ dst + 3s ]= get_hex_digit( o1 & 15u );
	}

	return res;
}

fn socket_address_v4::parse( string_view8 mut s ) : optional</socket_address_v4/>
{
	if_var( mut ip : extract_ip_v4_address(s) )
	{
		if( !( s.size() >= 1s && s.front() == ':' ) )
		{
			return null_optional;
		}
		s.drop_front();

		var u16 mut port= zero_init;

		if_var( p : parse_and_extract_integer</u16/>( s ) )
		{
			port= p;
		}
		else
		{
			return null_optional;
		}

		if( !s.empty() )
		{
			// Allow no trailing symbols.
			return null_optional;
		}

		return socket_address_v4( move(ip), port );
	}

	return null_optional;
}

fn socket_address_v6::parse( string_view8 mut s ) : optional</socket_address_v6/>
{
	if( !( s.size() >= 1s && s.front() == '[' ) )
	{
		return null_optional;
	}
	s.drop_front();

	auto mut ip_address= extract_ip_v6_address( s );
	if( ip_address.empty() )
	{
		return null_optional;
	}

	var u32 mut scope_id= 0u;
	if( !s.empty() && s.front() == '%' )
	{
		s.drop_front();

		if_var( i : parse_and_extract_integer</u32/>( s ) )
		{
			scope_id= i;
		}
		else
		{
			return null_optional;
		}
	}

	if( !( s.size() >= 1s && s.front() == ']' ) )
	{
		return null_optional;
	}
	s.drop_front();

	if( !( s.size() >= 1s && s.front() == ':' ) )
	{
		return null_optional;
	}
	s.drop_front();

	var u16 mut port= zero_init;

	if_var( p : parse_and_extract_integer</u16/>( s ) )
	{
		port= p;
	}
	else
	{
		return null_optional;
	}

	if( !s.empty() )
	{
		// Allow no trailing symbols.
		return null_optional;
	}

	return socket_address_v6( ip_address.try_deref(), port, 0u, scope_id );
}

fn parse_socket_address( string_view8 mut s ) : optional</socket_address/>
{
	if_var( mut a : socket_address_v4::parse( s ) )
	{
		return socket_address( move(a) );
	}
	if_var( mut a : socket_address_v6::parse( s ) )
	{
		return socket_address( move(a) );
	}

	return null_optional;
}

fn extract_ip_v4_address( string_view8 &mut s ) : optional</ip_address_v4/>
{
	var [ u8, 4 ] mut octets= zero_init;

	for( var size_type mut i= 0s; i < 3s; ++i )
	{
		if_var( o : parse_and_extract_integer</u8/>( s ) )
		{
			octets[i]= o;
		}
		else
		{
			return null_optional;
		}

		if( !( s.size() >= 1s && s.front() == '.' ) )
		{
			return null_optional;
		}
		s.drop_front();
	}

	if_var( o : parse_and_extract_integer</u8/>( s ) )
	{
		octets[3]= o;
	}
	else
	{
		return null_optional;
	}

	return ip_address_v4( octets );
}

fn extract_ip_v6_address( string_view8 &mut s ) : optional</ip_address_v6/>
{
	var [ u16, 8 ] mut parts= zero_init;

	var size_type mut num_parts_parsed= 0s;

	var size_type mut zeros_position= ~0s;

	for( var size_type mut i= 0s; i < 8s && !s.empty(); ++i )
	{
		if( i == 0s )
		{
			if( s.starts_with( "::" ) )
			{
				if( zeros_position != ~0s )
				{
					return null_optional;
				}

				zeros_position= num_parts_parsed;

				s.drop_front();
				s.drop_front();
			}
		}
		else
		{
			if( s.empty() || s.front() != ':' )
			{
				break;
			}
			s.drop_front();

			if( !s.empty() && s.front() == ':' )
			{
				if( zeros_position != ~0s )
				{
					return null_optional;
				}

				zeros_position= num_parts_parsed;

				s.drop_front();
			}
		}

		var optional</u16/> d= extract_hex_u16( s );
		if( d.empty() )
		{
			break;
		}

		parts[num_parts_parsed]= d.try_deref();

		++num_parts_parsed;
	}

	if( zeros_position == ~0s )
	{
		if( num_parts_parsed != 8s )
		{
			return null_optional;
		}

		var [ u8, 16 ] octets
		[
			( parts[0] >> 8u ), ( parts[0] ),
			( parts[1] >> 8u ), ( parts[1] ),
			( parts[2] >> 8u ), ( parts[2] ),
			( parts[3] >> 8u ), ( parts[3] ),
			( parts[4] >> 8u ), ( parts[4] ),
			( parts[5] >> 8u ), ( parts[5] ),
			( parts[6] >> 8u ), ( parts[6] ),
			( parts[7] >> 8u ), ( parts[7] ),
		];

		return ip_address_v6( octets );
	}
	else
	{
		var [ u8, 16 ] mut octets= zero_init;

		for( var size_type mut i= 0s; i < zeros_position; ++i )
		{
			var u16 part= parts[i];
			octets[ i * 2s + 0s ]= u8( part >> 8u );
			octets[ i * 2s + 1s ]= u8( part );
		}

		for( var size_type mut i= zeros_position + 8s - num_parts_parsed; i < 8s; ++i )
		{
			var u16 part= parts[ i - 8s + num_parts_parsed ];
			octets[ i * 2s + 0s ]= u8( part >> 8u );
			octets[ i * 2s + 1s ]= u8( part );
		}

		return ip_address_v6( octets );
	}
}

fn extract_hex_u16( string_view8 &mut s ) : optional</u16/>
{
	// Always parse first digit.
	var u32 digit0= extract_hex_digit( s );
	if( digit0 == c_no_digit )
	{
		return null_optional;
	}

	var u32 mut res= digit0;

	// Parse maximum 3 digits.
	for( auto mut i= 0s; i < 3s; ++i )
	{
		auto mut d= extract_hex_digit( s );
		if( d == c_no_digit )
		{
			break;
		}

		res <<= 4u;
		res += d;
	}

	return u16( res );
}

var u32 c_no_digit= 0xFFFFFFFFu;

fn extract_hex_digit( string_view8 &mut s ) : u32
{
	if( s.empty() )
	{
		return c_no_digit;
	}

	var char8 c= s.front();

	if( c >= '0' && c <= '9' )
	{
		s.drop_front();
		return u32( c ) - u32( '0' );
	}

	if( c >= 'a' && c <= 'f' )
	{
		s.drop_front();
		return u32( c ) - u32( 'a' ) + 10u;
	}

	if( c >= 'A' && c <= 'F' )
	{
		s.drop_front();
		return u32( c ) - u32( 'A' ) + 10u;
	}

	return c_no_digit;
}

// Input number shouldn't be greater than 15!
fn get_hex_digit( u32 d ) : char8
{
	if( d < 10u )
	{
		return char8( d + u32( '0' ) );
	}
	return char8( d - 10u + u32( 'a' ) );
}

} // namespace ust
