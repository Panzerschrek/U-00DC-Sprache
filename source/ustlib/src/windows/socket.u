import "../../imports/bytes_order.u"
import "../../imports/atomic.u"
import "socket.uh"

namespace ust
{

fn call_wsa_startup()
{
	// Use an atomic variable indicating that we already called "WSAStartup".
	// Atomic variable is necessary in order to avoid race conditions in its reading/updating.

	unsafe
	{
		if( atomic_read( wsa_startup_called ) )
		{
			return;
		}

		var WSAData mut wsa_data= zero_init;
		var i32 res= WSAStartup( u16(0x202), $<(wsa_data) );
		halt if( res != 0 );

		var bool prev_wsa_startup_called= atomic_swap( wsa_startup_called, true );
		if( prev_wsa_startup_called )
		{
			// Some other thread managed to call "WSAStartup" first.
			// In such case it's a good practice to call cleanup.
			WSACleanup();
		}
	}
}

var bool mut wsa_startup_called= false;

fn translate_wsa_error( i32 e ) : io_error
{
	switch( e )
	{
		WSAENOTCONN -> { return io_error::not_connected; },
		WSAEWOULDBLOCK -> { return io_error::would_block; },
		WSAEADDRINUSE -> { return io_error::address_already_in_use; },
		WSAECONNABORTED -> { return io_error::connection_aborted; },
		WSAECONNREFUSED -> { return io_error::connection_refused; },
		default -> { return io_error::other; },
		// TODO - handle other WinSock2 errors.
	}
}

fn translate_ip_address( in_addr& a ) : ip_address_v4
{
	return ip_address_v4( to_host_bytes_order( u32( a.S_un.union_contents[0] ) ) );
}

fn translate_ip_address( in6_addr& a ) : ip_address_v6
{
	var u128 ip_raw=
		( u128( to_host_bytes_order( a.parts[0] ) ) << 112u ) |
		( u128( to_host_bytes_order( a.parts[1] ) ) <<  96u ) |
		( u128( to_host_bytes_order( a.parts[2] ) ) <<  80u ) |
		( u128( to_host_bytes_order( a.parts[3] ) ) <<  64u ) |
		( u128( to_host_bytes_order( a.parts[4] ) ) <<  48u ) |
		( u128( to_host_bytes_order( a.parts[5] ) ) <<  32u ) |
		( u128( to_host_bytes_order( a.parts[6] ) ) <<  16u ) |
		( u128( to_host_bytes_order( a.parts[7] ) ) <<   0u );

	return ip_address_v6( ip_raw );
}

fn translate_socket_address( sockaddr_storage& address ) : optional</socket_address/>
{
	if( i32(address.ss_family) == AF_INET )
	{
		static_assert( typeinfo</sockaddr_storage/>.size_of >= typeinfo</sockaddr_in/>.size_of );

		// Cast sockaddr to sockaddr_in using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
		var sockaddr_in mut address_ip_v4= zero_init;

		unsafe( memory_copy(
			ptr_cast_to_byte8( $<(address_ip_v4) ),
			ptr_cast_to_byte8( $<( cast_mut(address) ) ),
			typeinfo</sockaddr_in/>.size_of ) );

		return socket_address( socket_address_v4(
			ip_address_v4( translate_ip_address( address_ip_v4.sin_addr ) ),
			to_host_bytes_order( address_ip_v4.sin_port ) ) );
	}
	else if( i32(address.ss_family) == AF_INET6 )
	{
		static_assert( typeinfo</sockaddr_storage/>.size_of >= typeinfo</sockaddr_in6/>.size_of );

		// Cast sockaddr to sockaddr_in6 using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
		var sockaddr_in6 mut address_ip_v6= zero_init;

		unsafe( memory_copy(
			ptr_cast_to_byte8( $<(address_ip_v6) ),
			ptr_cast_to_byte8( $<( cast_mut(address) ) ),
			typeinfo</sockaddr_in6/>.size_of ) );

		return
			socket_address( socket_address_v6(
				translate_ip_address( address_ip_v6.sin6_addr ),
				to_host_bytes_order( address_ip_v6.sin6_port ),
				to_host_bytes_order( address_ip_v6.sin6_flowinfo ),
				to_host_bytes_order( address_ip_v6.sin6_scope_id ) ) );
	}
	else
	{
		// Some unsupported address.
		return null_optional;
	}
}

fn translate_socket_address( socket_address_v4& address ) : sockaddr_in
{
	return sockaddr_in
	{
		.sin_family( AF_INET ),
		.sin_port= to_network_bytes_order( address.get_port() ),
		.sin_addr{ .S_un{ .union_contents[ ( to_network_bytes_order( address.get_ip().get_bits() ) ) ] } },
		.sin_zero= zero_init,
	};
}

fn translate_socket_address( socket_address_v6& address ) : sockaddr_in6
{
	var u128 ip_raw= address.get_ip().get_bits();

	return sockaddr_in6
	{
		.sin6_family( AF_INET6 ),
		.sin6_port= to_network_bytes_order( address.get_port() ),
		.sin6_addr
		{
			.parts
			[
				to_network_bytes_order( u16( ip_raw >> 112u ) ),
				to_network_bytes_order( u16( ip_raw >>  96u ) ),
				to_network_bytes_order( u16( ip_raw >>  80u ) ),
				to_network_bytes_order( u16( ip_raw >>  64u ) ),
				to_network_bytes_order( u16( ip_raw >>  48u ) ),
				to_network_bytes_order( u16( ip_raw >>  32u ) ),
				to_network_bytes_order( u16( ip_raw >>  16u ) ),
				to_network_bytes_order( u16( ip_raw >>   0u ) ),
			]
		},
		.sin6_flowinfo= to_network_bytes_order( address.get_flow_info() ),
		.sin6_scope_id= to_network_bytes_order( address.get_scope_id() ),
	};
}

fn is_socket_nonblocking( native_socket_fd s ) : io_result</bool/>
{
	// There is no API to retrieve such property.
	ignore_unused(s);
	return io_error::other;
}

fn set_socket_nonblocking( native_socket_fd s, bool nonblocking ) : io_result</void/>
{
	var i32 mut non_blocking_int= ( nonblocking ? 1 : 0 );

	var i32 res= unsafe( ::ioctlsocket( s, i32( FIONBIO ), $<( cast_ref_unsafe</u_long/>( non_blocking_int ) ) ) );

	if( res != 0 )
	{
		return translate_wsa_error( unsafe( WSAGetLastError() ) );
	}

	return void();
}

fn get_socket_local_address( native_socket_fd s ) : io_result</socket_address/>
{
	var sockaddr_storage mut address= zero_init;

	var socklen_t mut address_length( typeinfo</sockaddr_storage/>.size_of );

	unsafe
	{
		var i32 res= ::getsockname( s, $<( cast_ref_unsafe</sockaddr/>( address ) ), $<(address_length) );
		if( res != 0 )
		{
			return translate_wsa_error( WSAGetLastError() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn get_socket_peer_address( native_socket_fd s ) : io_result</socket_address/>
{
	var sockaddr_storage mut address= zero_init;

	var socklen_t mut address_length( typeinfo</sockaddr_storage/>.size_of );

	unsafe
	{
		var i32 res= ::getpeername( s, $<( cast_ref_unsafe</sockaddr/>( address ) ), $<(address_length) );
		if( res != 0 )
		{
			return translate_wsa_error( WSAGetLastError() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn get_socket_ttl( native_socket_fd s ) : io_result</u8/>
{
	var u32 mut ttl= 0u;

	var socklen_t mut len( typeinfo</u32/>.size_of );

	var i32 res=
		unsafe( ::getsockopt(
			s,
			IPPROTO_IP,
			IP_TTL,
			$<( cast_ref_unsafe</char8/>( ttl ) ),
			$<(len) ) );

	if( res != 0 )
	{
		return translate_wsa_error( unsafe( WSAGetLastError() ) );
	}

	return u8( min( ttl, 255u ) );
}

fn set_socket_ttl( native_socket_fd s, u8 ttl ) : io_result</void/>
{
	var u32 mut ttl32( ttl );

	var i32 res=
		unsafe( ::setsockopt(
			s,
			IPPROTO_IP,
			IP_TTL,
			$<( cast_ref_unsafe</char8/>( ttl32 ) ),
			socklen_t( typeinfo</u32/>.size_of ) ) );

	if( res != 0 )
	{
		return translate_wsa_error( unsafe( WSAGetLastError() ) );
	}

	return void();
}

} // namespace ust
