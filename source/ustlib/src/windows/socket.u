import "../../imports/atomic.u"
import "socket.uh"

namespace ust
{

fn call_wsa_startup()
{
	unsafe
	{
		if( atomic_read( wsa_startup_called ) )
		{
			return;
		}

		var WSAData mut wsa_data= zero_init;
		var i32 res= WSAStartup( u16(0x202), $<(wsa_data) );
		halt if( res != 0 );

		if( atomic_swap( wsa_startup_called, true ) )
		{
			// Some other thread managed to call "WSAStartup" first.
			WSACleanup();
		}
	}
}

var bool mut wsa_startup_called= false;

fn translate_wsa_error( i32 e ) : io_error
{
	switch( e )
	{
		WSAENOTCONN -> { return io_error::not_connected; },
		WSAEWOULDBLOCK -> { return io_error::would_block; },
		WSAEADDRINUSE -> { return io_error::address_already_in_use; },
		default -> { return io_error::other; },
	}
}

fn translate_socket_address( sockaddr& address ) : optional</socket_address/>
{
	if( i32(address.sa_family) == AF_INET )
	{
		// Cast sockaddr to sockaddr_in using memcpy. Just performing "ref_cast" isn't safe due to TBAA.
		var sockaddr_in mut address_ip_v4= zero_init;

		unsafe( memory_copy(
			ptr_cast_to_byte8( $<(address_ip_v4) ),
			ptr_cast_to_byte8( $<( cast_mut(address) ) ),
			typeinfo</sockaddr_in/>.size_of ) );

		return socket_address( socket_address_v4( ip_address_v4( u32( address_ip_v4.sin_addr.S_un.union_contents[0] ) ), address_ip_v4.sin_port ) );
	}
	else
	{
		// TODO - support IP v6.
		return null_optional;
	}
}

fn is_socket_nonblocking( native_socket_fd s ) : result</bool, io_error/>
{
	// There is no API to retrieve such property.
	ignore_unused(s);
	return io_error::other;
}

fn set_socket_nonblocking( native_socket_fd s, bool nonblocking ) : result</void, io_error/>
{
	var i32 mut non_blocking_int= ( nonblocking ? 1 : 0 );

	var i32 res= unsafe( ::ioctlsocket( s, i32( FIONBIO ), $<( cast_ref_unsafe</u_long/>( non_blocking_int ) ) ) );

	if( res != 0 )
	{
		return translate_wsa_error( unsafe( WSAGetLastError() ) );
	}

	return void();
}

fn get_socket_local_address( native_socket_fd s ) : result</socket_address, io_error/>
{
	var sockaddr mut address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var i32 res= ::getsockname( s, $<(address), $<(address_length) );
		if( res != 0 )
		{
			return translate_wsa_error( WSAGetLastError() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn get_socket_peer_address( native_socket_fd s ) : result</socket_address, io_error/>
{
	var sockaddr mut address= zero_init;
	static_assert( typeinfo</sockaddr_in/>.size_of <= typeinfo</sockaddr/>.size_of );

	var socklen_t mut address_length( typeinfo</sockaddr/>.size_of );

	unsafe
	{
		var i32 res= ::getpeername( s, $<(address), $<(address_length) );
		if( res != 0 )
		{
			return translate_wsa_error( WSAGetLastError() );
		}

		auto mut address_translated_opt= translate_socket_address( address );
		if( address_translated_opt.empty() )
		{
			return io_error::other;
		}

		return address_translated_opt.try_take();
	}
}

fn get_socket_ttl( native_socket_fd s ) : result</u32, io_error/>
{
	var u32 mut ttl= 0u;

	var socklen_t mut len( typeinfo</u32/>.size_of );

	var i32 res=
		unsafe( ::getsockopt(
			s,
			IPPROTO_IP,
			IP_TTL,
			$<( cast_ref_unsafe</char8/>( ttl ) ),
			$<(len) ) );

	if( res != 0 )
	{
		return translate_wsa_error( unsafe( WSAGetLastError() ) );
	}

	return ttl;
}

fn set_socket_ttl( native_socket_fd s, u32 mut ttl ) : result</void, io_error/>
{
	var i32 res=
		unsafe( ::setsockopt(
			s,
			IPPROTO_IP,
			IP_TTL,
			$<( cast_ref_unsafe</char8/>( ttl ) ),
			socklen_t( typeinfo</u32/>.size_of ) ) );

	if( res != 0 )
	{
		return translate_wsa_error( unsafe( WSAGetLastError() ) );
	}

	return void();
}

} // namespace ust
