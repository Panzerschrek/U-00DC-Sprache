import "../../imports/path_utils.u"

namespace ust
{

namespace path
{

var char8 constexpr g_native_separator = "\\"c8;

fn is_absolute( filesystem_path_view p ) : bool
{
	var prefix pref= parse_prefix(p);
	if( !p.empty() )
	{
		if( pref.is_implicit_root )
		{
			return true;
		}
		auto remainder= p.subrange_start( pref.p.size() );
		return !remainder.empty() && is_separator( remainder.front() );
	}
	return false;
}

fn is_relative( filesystem_path_view p ) : bool
{
	return !is_absolute(p);
}

fn is_separator( char8 c ) : bool
{
	return c == "/"c8 || c == g_native_separator;
}

fn join( filesystem_path_view p0 ) : filesystem_path
{
	return p0;
}

fn join( filesystem_path_view p0, filesystem_path_view p1 ) : filesystem_path
{
	var [ filesystem_path_view, 2 ] components[ p0, p1 ];
	return join_impl( components );
}

fn join( filesystem_path_view p0, filesystem_path_view p1, filesystem_path_view p2 ) : filesystem_path
{
	var [ filesystem_path_view, 3 ] components[ p0, p1, p2 ];
	return join_impl( components );
}

fn join( filesystem_path_view p0, filesystem_path_view p1, filesystem_path_view p2, filesystem_path_view p3 ) : filesystem_path
{
	var [ filesystem_path_view, 4 ] components[ p0, p1, p2, p3 ];
	return join_impl( components );
}

fn join( filesystem_path_view p0, filesystem_path_view p1, filesystem_path_view p2, filesystem_path_view p3, filesystem_path_view p4 ) : filesystem_path
{
	var [ filesystem_path_view, 5 ] components[ p0, p1, p2, p3, p4 ];
	return join_impl( components );
}

fn join( filesystem_path_view p0, filesystem_path_view p1, filesystem_path_view p2, filesystem_path_view p3, filesystem_path_view p4, filesystem_path_view p5 ) : filesystem_path
{
	var [ filesystem_path_view, 6 ] components[ p0, p1, p2, p3, p4, p5 ];
	return join_impl( components );
}

fn join_impl( array_view_imut</filesystem_path_view/> components ) : filesystem_path
{
	// Start from last absolute component.
	var size_type mut start_component= 0s;
	for( auto mut i= components.size() - 1s; ; )
	{
		var filesystem_path_view& component= components[i];
		if( is_absolute( component ) )
		{
			start_component= i;
			break;
		}
		if( i == 0s )
		{
			break;
		}
		--i;
	}

	var filesystem_path mut result;

	foreach( &component : components.subrange_start( start_component  ) )
	{
		if( !result.empty() && ! is_separator( result.back() ) )
		{
			// Add separator if result ends with non-separator char.
			result.push_back( g_native_separator );
		}

		result+= component;
	}

	return result;
}

fn get_file_extension( filesystem_path_view p )
	: optional</filesystem_path_view/> @( reference_notation::return_inner_references::param0_inner_reference0 )
{
	var prefix pref= parse_prefix(p);
	if( pref.p.size() == p.size() )
	{
		return null_optional;
	}

	// Iterate backwards up to first "." or separator or prefix.
	for( auto mut i= p.size() - 1s; ; )
	{
		var char8 c= p[i];
		if( c == "."c8 )
		{
			if( i > 0s )
			{
				var char8 prev_c= p[ i - 1s ];
				if( prev_c == "."c8 )
				{
					if( i > 1s )
					{
						var char8 prev_prev_s= p[ i - 2s ];
						if( is_separator( prev_prev_s ) )
						{
							// It's something like "some/path/..".
							break;
						}
					}
					else
					{
						// Path starting with "..".
						if( i == p.size() - 1s )
						{
							// ".." is a special name with no extension.
							break;
						}
					}
				}
				else if( is_separator( prev_c ) )
				{
					// File starts with "." - it has no extension.
					break;
				}

				// Return what remains after this ".".
				return p.subrange_start( i + 1s );
			}
			else
			{
				// It's single ".".
				break;
			}
		}
		else if( is_separator( c ) )
		{
			// Reached directories separator without encounting ".".
			break;
		}

		if( i == pref.p.size() )
		{
			break;
		}
		--i;
	}

	return null_optional;
}

fn get_path_without_extension( filesystem_path_view p )
	: filesystem_path_view @( reference_notation::return_inner_references::param0_inner_reference0 )
{
	// TODO
	halt;
}

fn get_file_name( filesystem_path_view p )
	: optional</filesystem_path_view/> @( reference_notation::return_inner_references::param0_inner_reference0 )
{
	// TODO
	halt;
}

fn get_parent_path( filesystem_path_view p )
	: optional</filesystem_path_view/> @( reference_notation::return_inner_references::param0_inner_reference0 )
{
	// TODO
	halt;
}

fn normalize( filesystem_path_view p ) : filesystem_path
{
	// TODO
	halt;
}

fn components_raw_iterator::constructor( mut this, filesystem_path_view p )
	@( reference_notation::pollution::param0_param_1_inner_reference )
	( p_= p )
{}

fn nodiscard components_raw_iterator::next( mut this )
	: optional</filesystem_path_view/> @( reference_notation::return_inner_references::param0_inner_reference0 )
{
	// TODO
	halt;
}

struct prefix
{
	filesystem_path_view p;
	bool is_implicit_root= false;
}

// Returns empty prefix if it's not valid.
fn parse_prefix( filesystem_path_view p )
	: prefix @( reference_notation::return_inner_references::param0_inner_reference0 )
{
	if( p.size() >= 2s )
	{
		var char8 c0= p[0s];
		var char8 c1= p[1s];

		if( ( ( c0 >= "a"c8 && c0 <= "z"c8 ) || ( c0 >= "A"c8 && c0 <= "Z"c8 ) ) && c1 == ":"c8 )
		{
			// C:
			return prefix{ .p= p.subrange_end(2s), .is_implicit_root= false };
		}
		else if( c0 == g_native_separator && c1 == g_native_separator )
		{
			// \\
			if( p.size() >= 3s )
			{
				var char8 c2= p[2s];
				if( c2 == "?"c8 )
				{
					// \\?
					if( p.size() >= 4s )
					{
						var char8 c3= p[3s];
						if( c3 == g_native_separator )
						{
							// \\?\
							if( p.size() >= 8s && p.subrange( 4s, 8s ) == "UNC\\" )
							{
								// \\?\UNC\server\share

								auto mut i= 7s;
								// Skip server
								while( i < p.size() && !is_separator( p[i] ) )
								{
									++i;
								}

								if( i == p.size() )
								{
									return prefix(); // Has only server
								}
								while( i < p.size() && is_separator( p[i] ) )
								{
									++i;
								}
								if( i == p.size() )
								{
									return prefix(); // Has only server\
								}

								// skip share
								while( i < p.size() && !is_separator( p[i] ) )
								{
									++i;
								}

								return prefix{ .p= p.subrange_end(i), .is_implicit_root= true };
							}
							if( p.size() >= 5s )
							{
								var char8 c4= p[4s];
								if( p.size() >= 6s )
								{
									var char8 c5= p[5s];
									if( ( ( c4 >= "a"c8 && c4 <= "z"c8 ) || ( c4 >= "A"c8 && c4 <= "Z"c8 ) ) && c5 == ":"c8 )
									{
										// \\?\C:
										return prefix{ .p= p.subrange_end(6s), .is_implicit_root= true };
									}
								}

								// \\?\server\share
								auto mut i= 4s;
								// Skip server
								while( i < p.size() && !is_separator( p[i] ) )
								{
									++i;
								}

								if( i == p.size() )
								{
									return prefix(); // Has only server
								}
								while( i < p.size() && is_separator( p[i] ) )
								{
									++i;
								}
								if( i == p.size() )
								{
									return prefix(); // Has only server\
								}

								// skip share
								while( i < p.size() && !is_separator( p[i] ) )
								{
									++i;
								}

								return prefix{ .p= p.subrange_end(i), .is_implicit_root= true };
							}
						}
					}
				}
				else if( c2 == "."c8 )
				{
					// Device namespace
					if( p.size() >= 4s )
					{
						var char8 c3= p[3s];
						if( is_separator( c3 ) )
						{
							// \\.\
							if( p.size() >= 4s )
							{
								// \\.\DEV

								// Skip device name
								var size_type mut i= 4s;
								while( i < p.size() && !is_separator( p[i] ) )
								{
									++i;
								}

								return prefix{ .p= p.subrange_end(i), .is_implicit_root= true };
							}
						}
					}
				}
				else
				{
					// \\server\share

					auto mut i= 2s;
					// Skip server
					while( i < p.size() && !is_separator( p[i] ) )
					{
						++i;
					}

					if( i == p.size() )
					{
						return prefix(); // Has only server
					}
					while( i < p.size() && is_separator( p[i] ) )
					{
						++i;
					}
					if( i == p.size() )
					{
						return prefix(); // Has only server\
					}

					// skip share
					while( i < p.size() && !is_separator( p[i] ) )
					{
						++i;
					}

					return prefix{ .p= p.subrange_end(i), .is_implicit_root= true };
				}
			}
			else
			{
				// At least one char is expected after "\\".
			}
		}
		else
		{
			// Not drive letter prefix or "\\" prefix.
		}
	}
	return prefix();
}

} // namespace path

} // namespace ust
