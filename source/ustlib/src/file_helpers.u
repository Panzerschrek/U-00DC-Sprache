import "../imports/file.u"
import "../imports/file_helpers.u"

namespace ust
{

fn read_file_to_byte8_vector( filesystem_path_view path ) : io_result</ vector</byte8/> />
{
	result_unwrap_or_return( mut f : file_readable::open( path ) );
	result_unwrap_or_return( s : f.get_size() );

	if( is_size_too_large_to_allocate(s) )
	{
		return io_error::out_of_memory;
	}

	unsafe // Because of uninitialized.
	{
		var vector</byte8/> mut res;

		// It's assumed that compiler can optimize-out filling container memory with uninitialized value.
		// So, using such approach we prevent unnecessary filling of memory, which will be soon overwritten.
		var byte8 filler= uninitialized;
		res.resize( size_type(s), filler );

		result_check_or_return( f.read_exact( res ) );

		return res;
	}
}

fn read_file_to_string( filesystem_path_view path ) : io_result</ string8 />
{
	result_unwrap_or_return( mut f : file_readable::open( path ) );
	result_unwrap_or_return( s : f.get_size() );

	if( is_size_too_large_to_allocate(s) )
	{
		return io_error::out_of_memory;
	}

	unsafe // Because of uninitialized.
	{
		var string8 mut res;

		// It's assumed that compiler can optimize-out filling container memory with uninitialized value.
		// So, using such approach we prevent unnecessary filling of memory, which will be soon overwritten.
		var char8 filler= uninitialized;
		res.resize( size_type(s), filler );

		result_check_or_return( f.read_exact( res.range().to_byte8_range() ) );

		return res;
	}
}

fn write_byte8_range_to_file( filesystem_path_view path, array_view_imut</byte8/> range ) : io_result</void/>
{
	result_unwrap_or_return( mut f : file_writeable::create( path ) );

	result_check_or_return( f.write_all( range ) );

	result_check_or_return( move(f).close() );

	return void();
}

fn write_string_view_to_file( filesystem_path_view path, string_view8 range ) : io_result</void/>
{
	return write_byte8_range_to_file( path, range.to_byte8_range() );
}

fn is_size_too_large_to_allocate( u64 size_bytes ) : bool
{
	// Allow allocating only less than half of the possible address space.
	var size_type constexpr limit= 1s << ( typeinfo</size_type/>.size_of * 8s - 1s );
	return size_bytes >= u64(limit);
}

} // namespace ust
