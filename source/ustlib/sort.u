import "random_access_range.u"

namespace ust
{

template</type T/>
fn sort( ust::random_access_range</T, true/> range )
{
	sort_impl::do_sort( range, sort_impl::default_compare</T/>() );
}

template</type T, type Compare/>
fn sort( ust::random_access_range</T, true/> range, Compare& comp )
{
	sort_impl::do_sort( range, comp );
}

namespace sort_impl
{

template</type T/>
struct default_compare
{
	op()( this, T& a, T& b ) : bool
	{
		return a < b;
	}
}

template</type T, type Compare/>
fn do_sort( ust::random_access_range</T, true/> range, Compare& comp )
{
	if( range.size() <= 1s )
	{
		return;
	}
	if( range.size() == 2s )
	{
		var bool mut less= false;
		{
			var ust::random_access_range</T, false/> range_copy= range;
			less= comp( range_copy.front(), range_copy.back() );
		}
		if( !less )
		{
			range.swap( 0s, 1s );
		}
		return;
	}

	// TODO - find approximate middle element and place it into last position.

	var size_type s= range.size();
	var size_type last= s - 1s;
	var size_type mut lo= 0s, mut hi= last;

	while( lo < hi )
	{
		var bool mut less= false;
		{
			var ust::random_access_range</T, false/> range_copy= range;
			less= comp( range_copy[lo], range_copy[last] );
		}

		if( less )
		{
			++lo;
		}
		else
		{
			--hi;
			range.swap( lo, hi );
		}
	}

	if( hi < last )
	{
		range.swap( hi, last );
	}

	do_sort( range.subrange( 0s, hi ), comp );
	do_sort( range.subrange( hi + 1s, s ), comp );
}

} // namespace sort_impl

} // namespace ust
