import "assert.u"
import "random_access_range.u"

namespace ust
{

template</type T/>
fn sort( random_access_range</T, true/> range )
{
	unsafe{  sort_impl::do_sort( range.data(), range.data() + range.size(), sort_impl::default_compare</T/>() );  }
}

template</type T, type Compare/>
fn sort( random_access_range</T, true/> range, Compare& comp )
{
	unsafe{  sort_impl::do_sort( range.data(), range.data() + range.size(), comp );  }
}

namespace sort_impl
{

template</type T/>
struct default_compare
{
	op()( this, T& a, T& b ) : bool
	{
		return a < b;
	}
}

/*
Simple quicksort implementation. Average complexity - O(log(n)), worst case complexity - O(n^2).
 TODO:
 * Use more simple sorting algorithm for small number of elements.
 * Select median element wisely.
*/

template</type T, type Compare/>
fn do_sort( $(T) mut start, $(T) mut end, Compare& comp ) unsafe
{
	loop
	{
		debug_assert( start <= end );
		auto size= end - start;

		if( size <= ssize_type(1) )
		{
			return;
		}
		if( size == ssize_type(2) )
		{
			unsafe
			{
				var T &mut l= $>(start);
				var T &mut r= $>(start + 1);

				if( !safe( comp( cast_imut(l), cast_imut(r) ) ) )
				{
					swap( l, r ); // TODO - make sure it isn't possible to swap an element with itself.
				}
			}
			return;
		}

		unsafe
		{
			// Assuming the middle element is at the end.
			// Compare all elements against it.
			// TODO - select somehow good enough middle element and put it at end.

			// Perform operations with raw pointers, because it seems to be the fastest way to do so.
			auto mut last= end - 1s;
			auto mut lo= start;
			auto mut hi= last;

			while( lo < hi )
			{
				var bool mut c= false;

				if( safe( comp( cast_imut( unsafe( $>(lo) ) ), cast_imut( unsafe( $>(last) ) ) ) ) )
				{
					++lo;
				}
				else
				{
					--hi;
					swap( $>(lo), $>(hi) ); // TODO - make sure it isn't possible to swap an element with itself.
				}
			}

			if( hi < last )
			{
				swap( $>(hi), $>(last) );  // TODO - make sure it isn't possible to swap an element with itself.
			}

			// Avoid deep recursion. Perform recursive call for smaller range, perform next loop interation for larger range.
			auto hi1= hi + 1s;
			if( hi - start < end - hi1 )
			{
				do_sort( start, hi, comp );
				start= hi1;
			}
			else
			{
				do_sort( hi1, end, comp );
				end= hi;
			}
		}
	}
}

} // namespace sort_impl

} // namespace ust
