import "pointer.u"
import "type_traits.u"

namespace ust
{

template</type T/>
fn polymorph_restore_original_ref( T &imut ref ) : void &imut
{
	static_if( polymorph_impl::is_polymorph</T/>() )
	{
		unsafe
		{
			// Virtual table pointer is always first filed in class.
			auto offset= cast_ref_unsafe</ polymorph_impl::virtual_class />(ref).vptr.offset_of_allocated_object;

			auto original_ptr= raw_ptr_mut</u8/>( cast_ref_unsafe</u8/>(cast_mut(ref)) ) - offset;
			return int_to_ref( ref_to_int( original_ptr.get_ref() ) );
		}
	}
	else
	{
		return ref;
	}
}

template</type A, type B/>
fn polymorph_is_same_type( A& a, B& b ) : bool
{
	static_if( polymorph_impl::is_polymorph</A/>() && polymorph_impl::is_polymorph</B/>() )
	{
		unsafe
		{
			// Virtual table pointer is always first filed in class.
			return
				cast_ref_unsafe</ polymorph_impl::virtual_class />(a).vptr.type_id ==
				cast_ref_unsafe</ polymorph_impl::virtual_class />(b).vptr.type_id;
		}
	}
	else
	{
		return is_same_type</A, B/>();
	}
}

namespace polymorph_impl
{

template</type T/>
fn constexpr is_polymorph() : bool
{
	static_if( typeinfo</T/>.is_class )
	{
		return typeinfo</T/>.is_polymorph;
	}
	else
	{
		return false;
	}
}

// If compiler virtual table layout changed, this must be changed too!
struct virtual_table
{
	size_type offset_of_allocated_object;
	size_type type_id;
}

struct virtual_class
{
	virtual_table& vptr;
}

} // namespace polymorph_impl

} // namespace ust
