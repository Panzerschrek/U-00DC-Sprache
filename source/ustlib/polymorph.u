import "optional_ref.u"
import "type_traits.u"

namespace ust
{

template</type T/>
fn polymorph_restore_original_ref( T &imut ref ) : byte8 &imut
{
	static_if( polymorph_impl::is_polymorph</T/>() )
	{
		unsafe
		{
			// Virtual table pointer is always first field in class.
			auto offset= cast_ref_unsafe</ polymorph_impl::virtual_class />(ref).vptr.offset_of_allocated_object;

			auto original_ptr= $<( cast_ref_unsafe</u8/>(cast_mut(ref)) ) - offset;
			return cast_ref_unsafe</ byte8 />( $>(original_ptr) );
		}
	}
	else
	{
		return unsafe( cast_ref_unsafe</byte8/>( ref ) );
	}
}

template</type A, type B/>
fn polymorph_is_same_type( A& a, B& b ) : bool
{
	static_if( polymorph_impl::is_polymorph</A/>() && polymorph_impl::is_polymorph</B/>() )
	{
		// Virtual table pointer is always first field in class.
		// Types are same if "type_id_table" address is same.
		return unsafe(
			cast_ref_unsafe</ polymorph_impl::virtual_class />(a).vptr.type_id_table ==
			cast_ref_unsafe</ polymorph_impl::virtual_class />(b).vptr.type_id_table );
	}
	else
	{
		return same_type</A, B/>;
	}
}

template</ type A, type B />
fn polymorph_is_instance_of( B& b ) : bool
{
	static_if( polymorph_impl::is_polymorph</A/>() && polymorph_impl::is_polymorph</B/>() )
	{
		unsafe
		{
			auto& virtual_table= cast_ref_unsafe</ polymorph_impl::virtual_class />(b).vptr;
			var polymorph_impl::type_id_table_element& type_id_table_first_element= $>( virtual_table.type_id_table );
			var $(size_type) size_type_address= $<( cast_mut( type_id_table_first_element.parent_offset ) );
			return size_type_address == $<( cast_mut( typeinfo</A/>.type_id ) );
		}
	}
	else
	{
		ust::ignore_unused(b);
		return false;
	}
}

template</ type To, type From />
fn polymorph_cast( From & mut from ) : optional_ref</ To, true  /> @( reference_notation::return_inner_references::param0 )
{
	polymorph_impl::polymorph_cast_impl</To/>(from);
}

template</ type To, type From />
fn polymorph_cast( From &imut from ) : optional_ref</ To, false /> @( reference_notation::return_inner_references::param0 )
{
	unsafe
	{
		auto res= polymorph_impl::polymorph_cast_impl</To/>( cast_mut(from) );
		if( !res.empty() )
		{
			return optional_ref</ To, false />( res.deref_unchecked() );
		}
		else
		{
			return optional_ref</ To, false />();
		}
	}
}

namespace polymorph_impl
{

// If compiler virtual table layout changed, this must be changed too!
struct virtual_table
{
	size_type offset_of_allocated_object;
	$(type_id_table_element) type_id_table;
}

struct type_id_table_element
{
	size_type parent_offset;
	$(type_id_table_element) parent_type_id_table;
}

struct virtual_class
{
	virtual_table& vptr;
}

template</type T/>
fn constexpr is_polymorph() : bool
{
	static_if( typeinfo</T/>.is_class )
	{
		return typeinfo</T/>.is_polymorph;
	}
	else
	{
		return false;
	}
}

// TODO - fix this. Now "polymorph_cast" for types with references inside is completely broken because of "optional_ref".
template</ type To, type From />
fn polymorph_cast_impl( From &mut from ) : optional_ref</ To, true /> @( reference_notation::return_inner_references::param0 )
{
	// Disable cast where it can produce internal reference out of nowhere.
	static_assert( typeinfo</To/>.references_tags_count <= typeinfo</From/>.references_tags_count );
	// Disable cast where it produces type with  mutable reference inside out of nowhere.
	static_assert( !( typeinfo</To/>.contains_mutable_references && !typeinfo</From/>.contains_mutable_references ) );

	static_if( is_polymorph</From/>() && is_polymorph</To/>() )
	{
		static_if( same_type</ From, To /> || is_ancestor_for</ To, From />() )
		{
			// Derived to base cast.
			return optional_ref</ To, true  />( from );
		}
		else
		{
			// Base to derived cast or cast for unrelated types.
			unsafe
			{
				// Obtain pointer to "type_id" table.
				auto& virtual_table= cast_ref_unsafe</ virtual_class />(from).vptr;
				var $(type_id_table_element) type_id_table= virtual_table.type_id_table;
				// Obtain pointer to allocated object.
				var $(u8) ptr= $<( cast_ref_unsafe</u8/>( from ) ) - virtual_table.offset_of_allocated_object;
				return optional_ref</ To, true />( polymorph_cast_r</To/>( ptr, type_id_table ) );
			}
		}
	}
	else
	{
		static_assert( false, "polymorph_cast for non-polymorph type" );
		halt;
	}
}

// Recursively try to find destination class in "type_id" tables of class and all its ancestors. If found - perform cast and return result.
template</ type To />
fn polymorph_cast_r( $(u8) ptr, $(type_id_table_element) mut type_id_table ) : $(To)
{
	unsafe
	{
		// If address of "type_id" from "typeinfo" is equal to "type_id_table" address - return result.
		var $(size_type) size_type_address= $<( $>(type_id_table).parent_offset );
		if( size_type_address == $<( cast_mut( typeinfo</To/>.type_id ) ) )
		{
			return $<( cast_ref_unsafe</To/>( $>(ptr) ) );
		}

		// Iterate over all parents and try to find target class.
		while( $>(type_id_table).parent_type_id_table != nullptr</type_id_table_element/>() )
		{
			auto ptr_corrected= ptr + $>(type_id_table).parent_offset;
			auto res= ust::polymorph_impl::polymorph_cast_r</To/>( ptr_corrected, $>(type_id_table).parent_type_id_table );
			if( !is_nullptr(res) )
			{
				return res;
			}
			++type_id_table;
		}

	}

	return nullptr</To/>();
}

} // namespace polymorph_impl

} // namespace ust
