import "pointer.u"

namespace ust
{

template</type T/>
fn polymorph_restore_original_ref( T &imut ref ) : void &imut
{
	unsafe
	{
		static_if( typeinfo</T/>.is_class )
		{
			static_if( typeinfo</T/>.is_polymorph )
			{
				// For polymorh class get offset of virtual table field, read this field, read first field in virtual table - original object offset.
				auto &mut ref_mut= cast_mut(ref);
				auto ptr0= ust::raw_ptr_mut</u8/>( cast_ref_unsafe</u8/>(ref_mut) ) + typeinfo</T/>.virtual_table_offset;
				auto ptr1= ust::raw_ptr_mut</size_type/>( cast_ref_unsafe</size_type/>( ptr0.get_ref() ) );
				auto virtual_table_ptr= ptr1.get_ref(); // do "load" here

				auto& virtual_table= cast_ref_unsafe</ polymorph_impl::virtual_table />( ust::int_to_ref( virtual_table_ptr ) );
				auto offset_of_allocated_object= virtual_table.offset_of_allocated_object; // do another "load" here

				auto ptr_for_free= ust::raw_ptr_mut</u8/>( cast_ref_unsafe</u8/>(ref_mut) ) - offset_of_allocated_object;
				return ust::int_to_ref( ust::ref_to_int( ptr_for_free.get_ref() ) );
			}
			else
			{
				return ref;
			}
		}
		else
		{
			return ref;
		}
	}
}

namespace polymorph_impl
{

// If compiler virtual table layout changed, this must be changed too!
struct virtual_table
{
	size_type offset_of_allocated_object;
}

} // namespace polymorph_impl

} // namespace ust
