//##success_test
import "../imports/assert.u"
import "../imports/enum_string_conversions.u"
import "../imports/string.u"
import "../imports/string_conversions.u"
import "../imports/udp_socket.u"

fn nomangle main() call_conv( "C" ) : i32
{
	var ust::net::ip_address_v4 loopback( ust::make_array( 127u8, 0u8, 0u8, 1u8 ) );

	// Create socket without binding.
	result_match( ust::net::udp_socket::create() )
	{
		Ok( s ) -> {},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to create socket! Error code: ", ust::enum_to_string(e) ) );
		}
	}

	// Create and bind socket.
	result_match( ust::net::udp_socket::create_and_bind( ust::net::socket_address_v4( ust::net::ip_address_v4( 0u ), GetNextPort() ) ) )
	{
		Ok( s ) -> {},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to create and bind socket! Error code: ", ust::enum_to_string(e) ) );
		}
	}

	// Create and bind socket to loopback connection.
	result_match( ust::net::udp_socket::create_and_bind( ust::net::socket_address_v4( ust::net::ip_address_v4( loopback ), GetNextPort() ) ) )
	{
		Ok( s ) -> {},
		Err( e ) ->
		{
			assert( false, ust::concat( "Failed to create and bind socket to loopback! Error code: ", ust::enum_to_string(e) ) );
		}
	}

	// Simple sendo/recvfrom test.
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );
		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		auto& message= "Wenn die Sonne untergeht und euer Vater schläft, dann spreche ich ein Stoßgebet in seiner Annegret.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send_to( receiver_address_for_sender, CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive_from( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut receive_result ) ->
			{
				auto [ address_obtained, bytes_received ]= move( receive_result );

				assert(
					address_obtained == sender_address || address_obtained == ust::net::socket_address_v4( loopback, sender_address.get_port() ),
					"Unexpected address obtained in \"receive_from\" call!" );

				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Simple sendo/recvfrom test, but sender was not bound.
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create().try_take();

		auto& message= "Ja Ihr wimmert und Ihr fleht, doch schreit: es ist zu spät. Es bringt Ihr Frohsinn wie Ihr seht, wir ficken bis die Hähne krähen.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send_to( receiver_address_for_sender, CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive_from( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut receive_result ) ->
			{
				auto [ address_obtained, bytes_received ]= move( receive_result );

				if_var( &a_ip_v4 : address_obtained.get</ust::net::socket_address_v4/>() )
				{
					assert( a_ip_v4.get_ip() == loopback, "Unexpected address obtained in \"receive_from\" call!" );
				}

				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Simple sendo/recvfrom test, but sender was not bound and receiver uses loopback address.
	{
		var ust::net::socket_address_v4 receiver_address( loopback, GetNextPort() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create().try_take();

		auto& message= "Sir Gernhart reinlunzen, Tor und Tür stehen mir auf, denn ich habe ein Schwert und sie nur einen hölzernen Knauf.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send_to( receiver_address, CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive_from( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut receive_result ) ->
			{
				auto [ address_obtained, bytes_received ]= move( receive_result );

				if_var( &a_ip_v4 : address_obtained.get</ust::net::socket_address_v4/>() )
				{
					assert( a_ip_v4.get_ip() == loopback, "Unexpected address obtained in \"receive_from\" call!" );
				}

				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Connect + send/receive.
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );

		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 sender_address_for_receiver( loopback, sender_address.get_port() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		receiver_socket.connect( sender_address_for_receiver ).try_deref();
		sender_socket.connect( receiver_address_for_sender ).try_deref();

		auto& message= "Ich steige durchs Fenster, schlüpfe zu Annegret. Nun sei dort nur noch eine Sache die zwischen uns steht.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send( CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut bytes_received ) ->
			{
				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Connect only receiver.
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );

		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 sender_address_for_receiver( loopback, sender_address.get_port() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		receiver_socket.connect( sender_address_for_receiver ).try_deref();

		auto& message= "Ja es ist Sir Schwanzelot, der nachts an das Fenster klopft, von der holden Annegret, sie bricht die Ehe, ich - das Bett.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send_to( receiver_address_for_sender, CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut bytes_received ) ->
			{
				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Connect only sender.
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );

		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		sender_socket.connect( receiver_address_for_sender ).try_deref();

		auto& message= "Gestern sah ich sie mit Sir Gernhart Reinlunzen im Gemach, doch hat sie noch nicht genug, also stoße ich sie heute Nacht.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send( CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive_from( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut receive_result ) ->
			{
				auto [ address_obtained, bytes_received ]= move( receive_result );

				if_var( &a_ip_v4 : address_obtained.get</ust::net::socket_address_v4/>() )
				{
					assert( a_ip_v4.get_ip() == loopback, "Unexpected address obtained in \"receive_from\" call!" );
				}

				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Use "receive" on unconnected receiver. Should work fine (receive what can be received).
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );

		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		auto& message= "Ach Ihr Zimmer liegt in Trümmern, doch sie hört nicht auf zu wimmern. Meine Stöße werden schlimmer, denn darauf beugt sie sich immer.";
		var ust::string_view8 message_range= message;

		result_match( sender_socket.send_to( receiver_address_for_sender, CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( bytes_sent == message_range.size(), ust::concat( "Sent unexpected number of bytes ", ust::to_string8(bytes_sent) ) );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to send message to socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}

		var typeof(message) mut received_message= zero_init;

		result_match( receiver_socket.receive( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ) )
		{
			Ok( mut bytes_received ) ->
			{
				assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
				assert( received_message == message, "Received unexpected message!" );
			},
			Err( e ) ->
			{
				assert( false, ust::concat( "Failed to receive message from socket! Error code: ", ust::enum_to_string(e) ) );
			}
		}
	}

	// Should fail unsing "send" without prior call to "connect".
	{
		var ust::net::udp_socket mut socket= ust::net::udp_socket::create().try_take();

		auto& message= "Bastard Barden";
		var ust::string_view8 message_range= message;

		result_match( socket.send( CastRangeToBytesRange( message_range ) ) )
		{
			Ok( bytes_sent ) ->
			{
				assert( false, "Should not send while unconnected!");
			},
			Err( e ) ->
			{
				assert(
					e == ust::io_error::destination_address_required || e == ust::io_error::not_connected,
					ust::concat( "Unexpected error code: \"", ust::enum_to_string(e), "\"" ) );
			}
		}
	}

	// send_to, peek_from, receive_from
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );
		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		auto& message= "Morgen kann sie nicht mehr stehen und uch kann sie nicht mehr sehen, also schleiche ich fort geschickt - morgen wird wieder gefickt!";
		var ust::string_view8 message_range= message;

		assert( sender_socket.send_to( receiver_address_for_sender, CastRangeToBytesRange( message_range ) ).try_take() == message_range.size() );

		// Can peek input message multiple times.
		for( var size_type mut i= 0s; i < 4s; ++i )
		{
			var typeof(message) mut peeked_message= zero_init;

			result_match( receiver_socket.peek_from( CastRangeToBytesRange( ust::array_view_mut</char8/>( peeked_message ) ) ) )
			{
				Ok( mut receive_result ) ->
				{
					auto [ address_obtained, bytes_received ]= move( receive_result );

					assert(
						address_obtained == sender_address || address_obtained == ust::net::socket_address_v4( loopback, sender_address.get_port() ),
						"Unexpected address obtained in \"receive_from\" call!" );

					assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
					assert( peeked_message == message, "Received unexpected message!" );
				},
				Err( e ) ->
				{
					assert( false, ust::concat( "Failed to peek message from socket! Error code: ", ust::enum_to_string(e) ) );
				}
			}
		}

		// Should receive data after previous "peek" calls.
		var typeof(message) mut received_message= zero_init;

		auto [ address_obtained, bytes_received ] = receiver_socket.receive_from( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ).try_take();
		assert(
			address_obtained == sender_address || address_obtained == ust::net::socket_address_v4( loopback, sender_address.get_port() ),
			"Unexpected address obtained in \"receive_from\" call!" );

		assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
		assert( received_message == message, "Received unexpected message!" );
	}

	// send, peek, receive
	{
		var ust::net::socket_address_v4 receiver_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 receiver_address_for_sender( loopback, receiver_address.get_port() );

		var ust::net::socket_address_v4 sender_address( ust::net::ip_address_v4( 0u ), GetNextPort() );
		var ust::net::socket_address_v4 sender_address_for_receiver( loopback, sender_address.get_port() );

		var ust::net::udp_socket mut receiver_socket= ust::net::udp_socket::create_and_bind( receiver_address ).try_take();
		var ust::net::udp_socket mut sender_socket= ust::net::udp_socket::create_and_bind( sender_address ).try_take();

		receiver_socket.connect( sender_address_for_receiver ).try_deref();
		sender_socket.connect( receiver_address_for_sender ).try_deref();

		auto& message= "Ihr seid als Hofnarr eine Schande, Ja, ihr seid ein Taugenichts, denn ihr bringt mich nie zum Lachen, ihr versäumеt eure Pflicht.";
		var ust::string_view8 message_range= message;

		assert( sender_socket.send( CastRangeToBytesRange( message_range ) ).try_take() == message_range.size() );

		// Can peek input message multiple times.
		for( var size_type mut i= 0s; i < 4s; ++i )
		{
			var typeof(message) mut peeked_message= zero_init;

			result_match( receiver_socket.peek( CastRangeToBytesRange( ust::array_view_mut</char8/>( peeked_message ) ) ) )
			{
				Ok( mut bytes_received ) ->
				{
					assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
					assert( peeked_message == message, "Received unexpected message!" );
				},
				Err( e ) ->
				{
					assert( false, ust::concat( "Failed to peek message from socket! Error code: ", ust::enum_to_string(e) ) );
				}
			}
		}

		// Should receive data after previous "peek" calls.
		var typeof(message) mut received_message= zero_init;

		var size_type bytes_received = receiver_socket.receive( CastRangeToBytesRange( ust::array_view_mut</char8/>( received_message ) ) ).try_take();

		assert( bytes_received == message_range.size(), ust::concat( "Received unexpected number of bytes ", ust::to_string8(bytes_received) ) );
		assert( received_message == message, "Received unexpected message!" );
	}

	return 0;
}

fn GetNextPort() : u16
{
	unsafe
	{
		var u16 res= g_port_counter;
		++g_port_counter;
		return res;
	}
}

var u16 mut g_port_counter= 59000u16;

// It's safe to cast between ranges of chars and bytes.
// TODO - create a library function for this?
template</bool is_mutable/>
fn CastRangeToBytesRange( ust::random_access_range</char8, is_mutable/> r ) : ust::random_access_range</byte8, is_mutable/>
{
	return unsafe( ust::random_access_range</byte8, is_mutable/>( ust::ptr_cast_to_byte8( r.data() ), r.size() ) );
}
