//##success_test
import "../imports/assert.u"
import "../imports/file.u"

fn nomangle main() : i32
{
	// Try opening non-existing file for reading.
	result_match( ust::file_readable::open( "this_file_does_not_exist" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open non-existing file!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try opening non-existing file for writing.
	result_match( ust::file_writeable::open( "this_file_does_not_exist" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open non-existing file!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try opening non-existing file for reading and writing.
	result_match( ust::file_readable_writeable::open( "this_file_does_not_exist" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open non-existing file!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Open a file for reading.
	result_match( ust::file_readable::open( "test_file0.txt" ) )
	{
		Ok( mut f ) ->
		{
			// Read the whole file in one call.
			var[ char8, 4 ] mut data= zero_init;
			auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
			assert( read_res.is_ok(), "Failed to read!" );
			assert( read_res.try_deref() == 4s );
			assert( data == "some", "Invalid file contents!" );
		},
		Err(e) ->
		{
			assert( false, "Failed to open file \"test_file0.txt\"" );
		},
	}

	// Try reading more than possible.
	result_match( ust::file_readable::open( "test_file0.txt" ) )
	{
		Ok( mut f ) ->
		{
			// Try to read more than file size.
			var[ char8, 9 ] mut data= zero_init;
			auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
			assert( read_res.is_ok(), "Failed to read!" );
			// Should get less than requested.
			assert( read_res.try_deref() == 4s );
			assert( data == "some\0\0\0\0\0", "Invalid file contents!" );
		},
		Err(e) ->
		{
			assert( false, "Failed to open file \"test_file0.txt\"" );
		},
	}

	// Read with seek.
	result_match( ust::file_readable::open( "test_file0.txt" ) )
	{
		Ok( mut f ) ->
		{
			{
				var[ char8, 4 ] mut data= zero_init;
				auto seek_res= f.seek( 1u64 );
				assert( seek_res.is_ok(), "Failed to seek!" );
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				// Should read last 3 bytes.
				assert( read_res.try_deref() == 3s );
				assert( data == "ome\0", "Invalid file contents!" );
			}
			{
				var[ char8, 4 ] mut data= zero_init;
				auto seek_res= f.seek( 3u64 );
				assert( seek_res.is_ok(), "Failed to seek!" );
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				// Should read last 1 byte.
				assert( read_res.try_deref() == 1s );
				assert( data == "e\0\0\0", "Invalid file contents!" );
			}
			{
				var[ char8, 4 ] mut data= zero_init;
				auto seek_res= f.seek( 0u64 );
				assert( seek_res.is_ok(), "Failed to seek!" );
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				// Should read last 1 byte.
				assert( read_res.try_deref() == 4s );
				assert( data == "some", "Invalid file contents!" );
			}
		},
		Err(e) ->
		{
			assert( false, "Failed to open file \"test_file0.txt\"" );
		},
	}

	// Writing and reading.
	{
		auto &constexpr file_data= "Handschuhe aus Menschenhaut";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		auto& file_path= "test_file_to_write.txt";

		// Write a file and close it.
		result_match( ust::file_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write the whole file in one call.
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"test_file_to_write.txt\"" );
			},
		}

		// Read file. Should get expected result.
		result_match( ust::file_readable::open( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Read the whole file in one call.
				var[ char8, file_data_size ] mut expected_file_data= zero_init;
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( expected_file_data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				assert( read_res.try_deref() == file_data_size );
				assert( expected_file_data == file_data, "Invalid file contents!" );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"test_file0.txt\"" );
			},
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	return 0;
}

// It's safe to cast between ranges of chars and bytes.
// TODO - move this into standart library.
template</bool is_mutable/>
fn CastRangeToBytesRange( ust::random_access_range</char8, is_mutable/> r ) : ust::random_access_range</byte8, is_mutable/>
{
	return unsafe( ust::random_access_range</byte8, is_mutable/>( ust::ptr_cast_to_byte8( r.data() ), r.size() ) );
}
