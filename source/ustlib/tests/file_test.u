//##success_test
import "../imports/assert.u"
import "../imports/file.u"
import "../imports/file_helpers.u"

// Some properties of the file classes.
static_assert( !typeinfo</ ust::file_readable />.is_copy_constructible );
static_assert( !typeinfo</ ust::file_readable />.is_copy_assignable );
static_assert( !typeinfo</ ust::file_readable />.is_equality_comparable );
static_assert( !non_sync</ ust::file_readable /> );
static_assert( !typeinfo</ ust::file_writeable />.is_copy_constructible );
static_assert( !typeinfo</ ust::file_writeable />.is_copy_assignable );
static_assert( !typeinfo</ ust::file_writeable />.is_equality_comparable );
static_assert( !non_sync</ ust::file_writeable /> );
static_assert( !typeinfo</ ust::file_readable_writeable />.is_copy_constructible );
static_assert( !typeinfo</ ust::file_readable_writeable />.is_copy_assignable );
static_assert( !typeinfo</ ust::file_readable_writeable />.is_equality_comparable );
static_assert( !non_sync</ ust::file_readable_writeable /> );

// We have 3 distinct types of files.
static_assert( !same_type</ ust::file_readable, ust::file_writeable /> );
static_assert( !same_type</ ust::file_readable, ust::file_readable_writeable /> );
static_assert( !same_type</ ust::file_writeable, ust::file_readable_writeable /> );

fn nomangle main() : i32
{
	// Try requesting metadata for non-existing path.
	result_match( ust::get_metadata_for_path( "this_file_does_not_exist" ) )
	{
		Ok(m) ->
		{
			assert( false, "Should not get metadata for non-existing path!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try opening non-existing file for reading.
	result_match( ust::file_readable::open( "this_file_does_not_exist" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open non-existing file for reading!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try opening non-existing file for writing.
	result_match( ust::file_writeable::open( "this_file_does_not_exist" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open non-existing file for writing!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try opening non-existing file for reading and writing.
	result_match( ust::file_readable_writeable::open( "this_file_does_not_exist" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open non-existing file!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try removing non-existing file.
	result_match( ust::remove_file( "this_file_does_not_exist" ) )
	{
		Ok(v) ->
		{
			assert( false, "Should remove non-existing file!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try removing non-existing directory.
	result_match( ust::remove_directory( "this_directory_does_not_exist" ) )
	{
		Ok(v) ->
		{
			assert( false, "Should remove non-existing directory!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::not_found, "Unexpected error code!" );
		},
	}

	// Try creating new file for writing. This should fail, since this file already exists.
	result_match( ust::file_writeable::create_new( "test_file0.txt" ) )
	{
		Ok(f) ->
		{
			assert( false, "Should not open already existing file!" );
		},
		Err(e) ->
		{
			assert( e == ust::io_error::already_exists, "Unexpected error code!" );
		},
	}

	// Request metatada for an existing file.
	result_match( ust::get_metadata_for_path( "test_file0.txt" ) )
	{
		Ok(m) ->
		{
			assert( m.kind == ust::file_kind::file, "Unexpected file kind!" );
			assert( m.size == 4u64, "Unexpected file size!" );
		},
		Err(e) ->
		{
			assert( false, "Failed to get metadata for an existing file!" );
		},
	}

	// Open a file for reading.
	result_match( ust::file_readable::open( "test_file0.txt" ) )
	{
		Ok( mut f ) ->
		{
			auto metadata_res= f.get_metatada();
			assert( metadata_res.is_ok(), "Failed to get file metadata!" );
			assert( metadata_res.try_deref().kind == ust::file_kind::file, "Unexpected file kind!" );
			assert( metadata_res.try_deref().size == 4u64, "Unexpected file size!" );

			auto size_res= f.get_size();
			assert( size_res.is_ok(), "Failed to get file size!" );
			assert( size_res.try_deref() == 4u64, "Unexpected file size!" );

			// Read the whole file in one call.
			var[ char8, 4 ] mut data= zero_init;
			auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
			assert( read_res.is_ok(), "Failed to read!" );
			assert( read_res.try_deref() == 4s );
			assert( data == "some", "Invalid file contents!" );
		},
		Err(e) ->
		{
			assert( false, "Failed to open file \"test_file0.txt\"" );
		},
	}

	// Read the whole file into vector of bytes.
	result_match( ust::read_file_to_byte8_vector( "test_file0.txt" ) )
	{
		Ok(s) ->
		{
			var [ byte8, 4 ] expected_result[ byte8("s"c8), byte8("o"c8), byte8("m"c8), byte8("e"c8) ];
			assert( s == expected_result, "Unexpected file contents!" );
		},
		Err(e) -> { assert( false, "Failed to read file \"test_file0.txt\" to vector</byte8/>!" ); }
	}

	// Read the whole file into string.
	result_match( ust::read_file_to_string( "test_file0.txt" ) )
	{
		Ok(s) ->
		{
			assert( s == "some", "Unexpected file contents!" );
		},
		Err(e) -> { assert( false, "Failed to read file \"test_file0.txt\" to string!" ); }
	}

	// Try reading more than possible.
	result_match( ust::file_readable::open( "test_file0.txt" ) )
	{
		Ok( mut f ) ->
		{
			// Try to read more than file size.
			var[ char8, 9 ] mut data= zero_init;
			auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
			assert( read_res.is_ok(), "Failed to read!" );
			// Should get less than requested.
			assert( read_res.try_deref() == 4s );
			assert( data == "some\0\0\0\0\0", "Invalid file contents!" );
		},
		Err(e) ->
		{
			assert( false, "Failed to open file \"test_file0.txt\"" );
		},
	}

	// Read with seek.
	result_match( ust::file_readable::open( "test_file0.txt" ) )
	{
		Ok( mut f ) ->
		{
			{
				var[ char8, 4 ] mut data= zero_init;
				auto seek_res= f.seek( 1u64 );
				assert( seek_res.is_ok(), "Failed to seek!" );
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				// Should read last 3 bytes.
				assert( read_res.try_deref() == 3s );
				assert( data == "ome\0", "Invalid file contents!" );
			}
			{
				var[ char8, 4 ] mut data= zero_init;
				auto seek_res= f.seek( 3u64 );
				assert( seek_res.is_ok(), "Failed to seek!" );
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				// Should read last 1 byte.
				assert( read_res.try_deref() == 1s );
				assert( data == "e\0\0\0", "Invalid file contents!" );
			}
			{
				var[ char8, 4 ] mut data= zero_init;
				auto seek_res= f.seek( 0u64 );
				assert( seek_res.is_ok(), "Failed to seek!" );
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				// Should read last 1 byte.
				assert( read_res.try_deref() == 4s );
				assert( data == "some", "Invalid file contents!" );
			}
		},
		Err(e) ->
		{
			assert( false, "Failed to open file \"test_file0.txt\"" );
		},
	}

	// Writing and reading.
	{
		auto &constexpr file_data= "Handschuhe aus Menschenhaut";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		auto& file_path= "test_file_to_write.txt";

		// Write a file and close it.
		result_match( ust::file_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write the whole file in one call.
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );

				// Check result file size.
				auto metadata_res= f.get_metatada();
				assert( metadata_res.is_ok(), "Failed to get file metadata!" );
				assert( metadata_res.try_deref().kind == ust::file_kind::file, "Unexpected file kind!" );
				assert( metadata_res.try_deref().size == u64(file_data_size), "Unexpected file size!" );

				auto size_res= f.get_size();
				assert( size_res.is_ok(), "Failed to get file size!" );
				assert( size_res.try_deref() == u64(file_data_size), "Unexpected file size!" );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Request metadata for file written previously.
		result_match( ust::get_metadata_for_path( file_path ) )
		{
			Ok(m) ->
			{
				assert( m.kind == ust::file_kind::file, "Unexpected file kind!" );
				assert( m.size == u64(file_data_size), "Unexpected file size!" );
			},
			Err(e) ->
			{
				assert( false, "Failed to get metadata for an existing file!" );
			},
		}

		// Read file. Should get expected result.
		result_match( ust::file_readable::open( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Check result file size after reopening it for reading.
				auto metadata_res= f.get_metatada();
				assert( metadata_res.is_ok(), "Failed to get file metadata!" );
				assert( metadata_res.try_deref().kind == ust::file_kind::file, "Unexpected file kind!" );
				assert( metadata_res.try_deref().size == u64(file_data_size), "Unexpected file size!" );

				auto size_res= f.get_size();
				assert( size_res.is_ok(), "Failed to get file size!" );
				assert( size_res.try_deref() == u64(file_data_size), "Unexpected file size!" );

				// Read the whole file in one call.
				var[ char8, file_data_size ] mut expected_file_data= zero_init;
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( expected_file_data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				assert( read_res.try_deref() == file_data_size );
				assert( expected_file_data == file_data, "Invalid file contents!" );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );

		// Removing second time should fail.
		auto remove_res2= ust::remove_file( file_path );
		assert( remove_res2.is_error(), "Removing already removed file not failed. WTF?" );
		assert( remove_res2.try_deref_error() == ust::io_error::not_found, "Unexpected error code while removing already removed file" );
	}

	// Write file via a helper function and read it again.
	{
		auto &constexpr file_path= "Für Elite";
		auto &constexpr contents= "Ich habe keinen Bock mehr auf die Ausbeutung der Welt!";

		auto write_res= ust::write_string_view_to_file( file_path, contents );
		assert( write_res.is_ok(), "Failed to write a file!" );

		auto metadata_res= ust::get_metadata_for_path( file_path );
		assert( metadata_res.is_ok(), "Failed to get file metadata!" );
		assert( metadata_res.try_deref().size == u64( typeinfo</ typeof(contents) />.size_of ), "Unexpected file size!" );

		// Read the whole file back.
		result_match( ust::read_file_to_string( file_path ) )
		{
			Ok(s) ->
			{
				assert( s == contents, "Unexpected file contents!" );
			},
			Err(e) -> { assert( false, "Failed to read file \"" + file_path + "\" to string!" ); }
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file \"" + file_path + "\"!" );
	}

	// Writing and reading using the same file.
	{
		auto &constexpr file_data= "Es is egal, ob die Grünen oder AfD";
		auto &constexpr file_data_tweaked= "Es is toll, ob die Grünen oder AfD";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		auto& file_path= "test_file_to_read_and_write.txt";

		result_match( ust::file_readable_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write the whole file in one call.
				{
					auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
					assert( write_res.is_ok(), "Failed to write!" );
					assert( write_res.try_deref() == file_data_size );
				}

				// Check result file size after writing.
				{
					auto metadata_res= f.get_metatada();
					assert( metadata_res.is_ok(), "Failed to get file metadata!" );
					assert( metadata_res.try_deref().kind == ust::file_kind::file, "Unexpected file kind!" );
					assert( metadata_res.try_deref().size == u64(file_data_size), "Unexpected file size!" );
				}
				{
					auto size_res= f.get_size();
					assert( size_res.is_ok(), "Failed to get file size!" );
					assert( size_res.try_deref() == u64(file_data_size), "Unexpected file size!" );
				}

				// Read the whole file after writing it.
				{
					auto seek_res= f.seek( 0u64 );
					assert( seek_res.is_ok(), "Seek failed!" );
					var[ char8, file_data_size ] mut expected_file_data= zero_init;
					auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( expected_file_data ) ) );
					assert( read_res.is_ok(), "Failed to read!" );
					assert( read_res.try_deref() == file_data_size );
					assert( expected_file_data == file_data, "Invalid file contents!" );
				}

				{ // Write part in the middle.
					auto seek_res= f.seek( 6u64 );
					assert( seek_res.is_ok(), "Seek failed!" );
					auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( "toll" ) ) );
					assert( write_res.is_ok(), "Failed to write!" );
					assert( write_res.try_deref() == 4s );
				}

				// Read the whole file again. Shold see changes written before.
				{
					auto seek_res= f.seek( 0u64 );
					assert( seek_res.is_ok(), "Seek failed!" );
					var[ char8, file_data_size ] mut expected_file_data= zero_init;
					auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( expected_file_data ) ) );
					assert( read_res.is_ok(), "Failed to read!" );
					assert( read_res.try_deref() == file_data_size );
					assert( expected_file_data == file_data_tweaked, "Invalid file contents!" );
				}
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Writing and reading of a file within a directory.
	{
		auto constexpr dir0= "some_dir0";
		auto constexpr dir1= dir0 + "/" + "some_subdir1";
		auto constexpr file_path= dir1 + "/" + "test_file_to_write.txt";

		// Create directories.
		result_match( ust::create_directory( dir0 ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to create directory!" ) },
		}
		result_match( ust::create_directory( dir1 ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to create directory!" ) },
		}

		// Request metatada for created directories.
		result_match( ust::get_metadata_for_path( dir0 ) )
		{
			Ok(m) -> { assert( m.kind == ust::file_kind::directory, "Unexpected directory kind!" ); },
			Err(e) -> { assert( false, "Failed to get metadata for an existing file!" ); },
		}
		result_match( ust::get_metadata_for_path( dir1 ) )
		{
			Ok(m) -> { assert( m.kind == ust::file_kind::directory, "Unexpected directory kind!" ); },
			Err(e) -> { assert( false, "Failed to get metadata for an existing file!" ); },
		}

		auto &constexpr file_data= "Was kann das sein?\nDas gibt's doch nie!\nNun ist mir klar: das wäre wahre Anarchie!\n";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		// Write a file and close it.
		result_match( ust::file_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write the whole file in one call.
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Read file. Should get expected result.
		result_match( ust::file_readable::open( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Read the whole file in one call.
				var[ char8, file_data_size ] mut expected_file_data= zero_init;
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( expected_file_data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				assert( read_res.try_deref() == file_data_size );
				assert( expected_file_data == file_data, "Invalid file contents!" );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );

		// Remove directories.
		result_match( ust::remove_directory( dir1 ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to remove directory!" ) },
		}
		result_match( ust::remove_directory( dir0 ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to remove directory!" ) },
		}

		// Check directories are removed.
		result_match( ust::get_metadata_for_path( dir1 ) )
		{
			Ok(m) -> { assert( false, "Should not get metadata for removed directory!" ); },
			Err(e) -> { assert( e == ust::io_error::not_found, "Unexpected error code!" ); },
		}
		result_match( ust::get_metadata_for_path( dir0 ) )
		{
			Ok(m) -> { assert( false, "Should not get metadata for removed directory!" ); },
			Err(e) -> { assert( e == ust::io_error::not_found, "Unexpected error code!" ); },
		}
	}

	// Writing and reading for a newly-created file.
	{
		auto &constexpr file_data= "Du bist das Produkt!";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		auto& file_path= "new_test_file_for_write.txt";

		// Write a file and close it.
		result_match( ust::file_writeable::create_new( file_path ) )
		{
			Ok( mut f ) ->
			{
				// First file size should be zero.
				auto metadata_res= f.get_metatada();
				assert( metadata_res.is_ok(), "Failed to get file metadata!" );
				assert( metadata_res.try_deref().kind == ust::file_kind::file, "Unexpected file kind!" );
				assert( metadata_res.try_deref().size == 0u64, "Unexpected file size!" );

				auto size_res= f.get_size();
				assert( size_res.is_ok(), "Failed to get file size!" );
				assert( size_res.try_deref() == 0u64, "Unexpected file size!" );

				// Write the whole file in one call.
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Read file. Should get expected result.
		result_match( ust::file_readable::open( file_path ) )
		{
			Ok( mut f ) ->
			{
				// File size should be expected.
				auto metadata_res= f.get_metatada();
				assert( metadata_res.is_ok(), "Failed to get file metadata!" );
				assert( metadata_res.try_deref().kind == ust::file_kind::file, "Unexpected file kind!" );
				assert( metadata_res.try_deref().size == u64(file_data_size), "Unexpected file size!" );

				auto size_res= f.get_size();
				assert( size_res.is_ok(), "Failed to get file size!" );
				assert( size_res.try_deref() == u64(file_data_size), "Unexpected file size!" );

				// Read the whole file in one call.
				var[ char8, file_data_size ] mut expected_file_data= zero_init;
				auto read_res= f.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( expected_file_data ) ) );
				assert( read_res.is_ok(), "Failed to read!" );
				assert( read_res.try_deref() == file_data_size );
				assert( expected_file_data == file_data, "Invalid file contents!" );
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Truncation.
	{
		auto &constexpr file_path= "truncation_test.txt";
		auto &constexpr file_data= "Hegen sie die Absicht, uns abhängig zu machen";
		var size_type constexpr file_data_size= typeinfo</ typeof(file_data) />.size_of;
		var size_type extra_tail_size= 7s;
		var size_type cut_size= 6s;

		result_match( ust::file_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write some contents
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );

				// Check result file size.
				{
					auto size_res= f.get_size();
					assert( size_res.is_ok(), "Failed to get file size!" );
					assert( size_res.try_deref() == u64(file_data_size), "Unexpected file size!" );
				}

				// Increase file size.
				auto resize_res= f.resize( u64( file_data_size + extra_tail_size ) );
				assert( resize_res.is_ok(), "Failed to resize file" );

				{ // Check file size again.
					auto size_res= f.get_size();
					assert( size_res.is_ok(), "Failed to get file size!" );
					assert( size_res.try_deref() == u64(file_data_size + extra_tail_size), "Unexpected file size!" );
				}
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Read the whole file into string.
		result_match( ust::read_file_to_string( file_path ) )
		{
			Ok(s) ->
			{
				assert( s.size() == file_data_size + extra_tail_size, "Unexected file size!" );
				assert( s.range().subrange_end(file_data_size) == file_data, "Invalid file contents!" );
				// Should be filled with zeros.
				assert( s.range().subrange_start(file_data_size) == ust::string8( 7s, "\0"c8 ), "Invalid file contents!" );
			},
			Err(e) -> { assert( false, "Failed to read file \"" + file_path + "\" to string!" ); }
		}

		// Open again and truncate down.
		result_match( ust::file_writeable::open( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Decrease file size.
				auto resize_res= f.resize( u64( file_data_size - cut_size ) );
				assert( resize_res.is_ok(), "Failed to resize file" );

				{ // Check file size again.
					auto size_res= f.get_size();
					assert( size_res.is_ok(), "Failed to get file size!" );
					assert( size_res.try_deref() == u64(file_data_size - cut_size), "Unexpected file size!" );
				}
			},
			Err(e) ->
			{
				assert( false, "Failed to open file \"" + file_path + "\"" );
			},
		}

		// Read the whole file into string again. Should be affected by truncation.
		result_match( ust::read_file_to_string( file_path ) )
		{
			Ok(s) ->
			{
				assert( s.size() == file_data_size - cut_size, "Unexected file size!" );
				assert( s == ust::string_view8( file_data ).subrange_end( file_data_size - cut_size ), "Invalid file contents!" );
			},
			Err(e) -> { assert( false, "Failed to read file \"" + file_path + "\" to string!" ); }
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Writing and reading with flush.
	{
		auto &constexpr file_data= "Sehr treue Anhänger staatlicher Institutionen";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		auto& file_path= "S.T.A.S.I";

		// Write a file, flush and close it.
		result_match( ust::file_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write the whole file in one call.
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );

				// Flush.
				assert( f.flush().is_ok(), "Flush failed!" );

				// Check result file size.
				auto size_res= f.get_size();
				assert( size_res.is_ok(), "Failed to get file size!" );
				assert( size_res.try_deref() == u64(file_data_size), "Unexpected file size!" );
			},
			Err(e) -> { assert( false, "Failed to open file \"" + file_path + "\"" ); },
		}


		// Read file. Should get expected result.
		result_match( ust::read_file_to_string( file_path ) )
		{
			Ok( s ) -> { assert( s == file_data, "Invald file contents!" ); },
			Err(e) -> { assert( false, "Failed to open file \"" + file_path + "\"" ); },
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Writing and reading with flushing all.
	{
		auto &constexpr file_data= "Die Hoffnung stirbt zuletzt";
		auto constexpr file_data_size= typeinfo</ typeof(file_data) />.element_count;

		auto& file_path= "Aber sie stirbt";

		// Write a file, flush and close it.
		result_match( ust::file_writeable::create( file_path ) )
		{
			Ok( mut f ) ->
			{
				// Write the whole file in one call.
				auto write_res= f.write( CastRangeToBytesRange( ust::array_view_imut</char8/>( file_data ) ) );
				assert( write_res.is_ok(), "Failed to write!" );
				assert( write_res.try_deref() == file_data_size );

				// Flush all.
				assert( f.flush_all().is_ok(), "Flush failed!" );
			},
			Err(e) -> { assert( false, "Failed to open file \"" + file_path + "\"" ); },
		}

		// Read file. Should get expected result.
		result_match( ust::read_file_to_string( file_path ) )
		{
			Ok( s ) -> { assert( s == file_data, "Invald file contents!" ); },
			Err(e) -> { assert( false, "Failed to open file \"" + file_path + "\"" ); },
		}

		// Remove this file.
		auto remove_res= ust::remove_file( file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Create already created directory.
	{
		auto &constexpr dir_name= "some_dir_to_create";

		// Create it.
		result_match( ust::create_directory( dir_name ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to create directory!" ) },
		}
		// Create again - should NOT get error.
		result_match( ust::create_directory( dir_name ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to create directory!" ) },
		}

		// Remove directory.
		result_match( ust::remove_directory( dir_name ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to remove directory!" ) },
		}
		// Remove directory again. Should get an error.
		result_match( ust::remove_directory( dir_name ) )
		{
			Ok(v) -> { assert( false, "Removal of non-existing directory isn't failed. WTF?" ); },
			Err(e) -> { assert( e == ust::io_error::not_found, "Unexpected error code!" ) },
		}
	}

	// Create directory with name equal to already existing file. Should fail.
	result_match( ust::create_directory( "test_file0.txt" ) )
	{
		Ok(v) -> { assert( false, "Creating of directory with existing path isn't failed!" ); },
		Err(e) -> { assert( e == ust::io_error::already_exists, "Unexpected error code!" ) },
	}

	// file copy
	{
		auto &constexpr src_file_path= "test_file0.txt";
		auto &constexpr dst_file_path= "test_file0_copy.txt";
		auto &constexpr contents= "some";

		// Perform copy.
		result_match( ust::copy_file( src_file_path, dst_file_path ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to copy file \"" + src_file_path + "\"!" ); },
		}

		// Read copy.
		result_match( ust::read_file_to_string( dst_file_path ) )
		{
			Ok(s) -> { assert( s == contents, "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"" + dst_file_path + "\" to string!" ); }
		}

		// Read original.
		result_match( ust::read_file_to_string( src_file_path ) )
		{
			Ok(s) -> { assert( s == contents, "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"" + src_file_path + "\" to string!" ); }
		}

		// Perform copy again. Shouldn't fail.
		result_match( ust::copy_file( src_file_path, dst_file_path ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to copy file \"" + src_file_path + "\"!" ); },
		}

		// Read copy again.
		result_match( ust::read_file_to_string( dst_file_path ) )
		{
			Ok(s) -> { assert( s == contents, "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"" + dst_file_path + "\" to string!" ); }
		}

		// Remove copy.
		auto remove_res= ust::remove_file( dst_file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Copy file if not exists
	{
		auto &constexpr src_file_path= "test_file0.txt";
		auto &constexpr dst_file_path= "test_file0_copy.txt";
		auto &constexpr contents= "some";

		// Perform copy.
		result_match( ust::copy_file_if_not_exists( src_file_path, dst_file_path ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to copy file \"" + src_file_path + "\"!" ); },
		}

		// Perform copy second time. Should fail.
		result_match( ust::copy_file_if_not_exists( src_file_path, dst_file_path ) )
		{
			Ok(v) -> { assert( false, "Should fail to copy file \"" + src_file_path + "\" if it exists!" ) },
			Err(e) -> { assert( e == ust::io_error::already_exists, "Unexpected error code!" ); },
		}

		// Read copy.
		result_match( ust::read_file_to_string( dst_file_path ) )
		{
			Ok(s) -> { assert( s == contents, "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"" + dst_file_path + "\" to string!" ); }
		}

		// Read original.
		result_match( ust::read_file_to_string( src_file_path ) )
		{
			Ok(s) -> { assert( s == contents, "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"" + src_file_path + "\" to string!" ); }
		}

		// Remove copy.
		auto remove_res= ust::remove_file( dst_file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Rename file
	{
		auto &constexpr src_file_path= "file_for_later_rename.txt";
		auto &constexpr dst_file_path= "file_end_name.txt";
		auto &constexpr contents= "Stirb Langsam";

		// Write a file.
		result_match( ust::write_string_view_to_file( src_file_path, contents ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to write file \"" + src_file_path + "\"!" ); },
		}

		// Rename file.
		result_match( ust::rename_file_or_directory( src_file_path, dst_file_path ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to rename file \"" + src_file_path + "\"!" ); },
		}

		// Read renamed file.
		result_match( ust::read_file_to_string( dst_file_path ) )
		{
			Ok(s) -> { assert( s == contents, "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"" + dst_file_path + "\" to string!" ); }
		}

		// Read original. Should fail.
		result_match( ust::read_file_to_string( src_file_path ) )
		{
			Ok(s) -> { assert( false, "Reading renamed file should fail!" ); },
			Err(e) -> { assert( e == ust::io_error::not_found, "Unexpected error code!" ); }
		}

		// Remove renamed file.
		auto remove_res= ust::remove_file( dst_file_path );
		assert( remove_res.is_ok(), "Failed to remove file!" );
	}

	// Rename file if not exists.
	{
		auto &constexpr src_file_path= "file_for_later_rename.txt";
		auto &constexpr dst_file_path= "file_end_name.txt";
		auto &constexpr contents= "Stirb Langsam";

		// Write a file.
		result_match( ust::write_string_view_to_file( src_file_path, contents ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to write file \"" + src_file_path + "\"!" ); },
		}

		// Write something into destination.
		result_match( ust::write_string_view_to_file( dst_file_path, "Do not care about contents" ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to write file \"" + src_file_path + "\"!" ); },
		}

		// Rename file if not exists  - should fail.
		result_match( ust::rename_file_or_directory_if_not_exists( src_file_path, dst_file_path ) )
		{
			Ok(v) -> { assert( false, "Should fail to rename file \"" + src_file_path + "\" if it exists!" ) },
			Err(e) -> { assert( e == ust::io_error::already_exists, "Unexpected error code!" ); },
		}

		// Remove both files
		assert( ust::remove_file( dst_file_path ).is_ok(), "Failed to remove file!" );
		assert( ust::remove_file( src_file_path ).is_ok(), "Failed to remove file!" );
	}

	// Rename directory
	{
		auto& constexpr src_path= "dir_initial";
		auto& constexpr dst_path= "dir_final";

		// Create directory.
		result_match( ust::create_directory( src_path ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to create directory!" ) },
		}

		// Rename directory.
		result_match( ust::rename_file_or_directory( src_path, dst_path ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to rename directory!" ) },
		}

		// Get metadata for original - should fail.
		auto src_metatada_res= ust::get_metadata_for_path( src_path );
		assert( src_metatada_res.is_error(), "Expected error for src directory metadata!" );
		assert( src_metatada_res.try_deref_error() == ust::io_error::not_found, "Unexpected error code!" );

		// Get metadata for final name.
		auto dsr_metatada_res= ust::get_metadata_for_path( dst_path );
		assert( dsr_metatada_res.is_ok(), "Failed to get metadata for directory!" );

		// Remove final directory.
		assert( ust::remove_directory( dst_path ).is_ok(), "Failed to remove directory!" );
	}

	// Get current directory.
	{
		var ust::string8 dir= ust::get_current_directory();
		assert( !dir.empty(), "Current directory is empty!" );

		// Read file using absolute path based on current directory.
		result_match( ust::read_file_to_string( ust::concat( dir, "/", "test_file0.txt" ) ) )
		{
			Ok(s) -> { assert( s == "some", "Unexpected file contents!" ); },
			Err(e) -> { assert( false, "Failed to read file \"test_file0.txt\" to string!" ); }
		}
	}

	// Set current directory.
	{
		// Get current directory.
		var ust::string8 dir_initial= ust::get_current_directory();
		assert( !dir_initial.empty(), "Current directory is empty!" );

		// Create new directory within it.
		auto& separator= ( ust::string_view8(compiler::target::os) == "windows" ? "\\" : "/" );
		var ust::string8 dir_new= ust::concat( dir_initial, separator, "some_dir" );
		result_match( ust::create_directory( dir_new ) )
		{
			Ok(v) -> {},
			Err(e) -> { assert( false, "Failed to create directory!" ) },
		}

		// Make newly created directory current.
		assert( ust::set_current_directory( dir_new ).is_ok(), "Failed to set current directory!" );
		var ust::string8 dir_new_actual= ust::get_current_directory();
		assert( dir_new_actual == dir_new, "Unexpected current directory!" );

		// Change current directory back.
		assert( ust::set_current_directory( dir_initial ).is_ok(), "Failed to set current directory!" );
		assert( ust::get_current_directory() == dir_initial, "Unexpected current directory!" );

		// Remove directory created previously.
		assert( ust::remove_directory( dir_new ).is_ok(), "Failed to remove directory!" );
	}

	// Set current directory - fail for non-existing directory.
	result_match( ust::set_current_directory( "this_directory_does_not_exist" ) )
	{
		Ok(v) -> { assert( false, "Should not set current directory to non-existing!" ); },
		Err(e) -> { assert( e == ust::io_error::not_found, "Unexpected error code!" ) },
	}

	// Set current directory - fail, because it's not a directory but file.
	result_match( ust::set_current_directory( "test_file0.txt" ) )
	{
		Ok(v) -> { assert( false, "Should not set current directory to file path!" ); },
		Err(e) -> { assert( e == ust::io_error::not_a_directory, "Unexpected error code!" ) },
	}

	// Iterate over a directory.
	{
		var bool mut this_file_found= false, mut test_file0_txt_found= false;
		result_match( ust::directory_raw_iterator::open( ust::get_current_directory() ) )
		{
			Ok( mut it ) ->
			{
				foreach( mut entry_res : move(it) )
				{
					result_match( move(entry_res) )
					{
						Ok(entry) ->
						{
							ust::stdout_print( ust::concat( "Entry: ", entry.entry_name, "\n" ) );
							if( entry.entry_name == "file_test.u" )
							{
								this_file_found= true;
							}
							else if( entry.entry_name == "test_file0.txt" )
							{
								test_file0_txt_found= true;
							}
						},
						Err(e) ->
						{
							assert( false, "Failed to get directory entry!" );
						},
					}
				}
			},
			Err(e) -> { assert( false, "Failed to create directory iterator!" ); },
		}
		assert( this_file_found, "Directory iterator can't find \"file_test.u\"!" );
		assert( test_file0_txt_found, "Directory iterator can't find \"test_file0.txt\"!" );
	}

	return 0;
}

// It's safe to cast between ranges of chars and bytes.
// TODO - move this into standart library.
template</bool is_mutable/>
fn CastRangeToBytesRange( ust::random_access_range</char8, is_mutable/> r ) : ust::random_access_range</byte8, is_mutable/>
{
	return unsafe( ust::random_access_range</byte8, is_mutable/>( ust::ptr_cast_to_byte8( r.data() ), r.size() ) );
}
