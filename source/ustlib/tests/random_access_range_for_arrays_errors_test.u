//##fail_test
import "../imports/random_access_range.u"

type IntRangeMut = ust::random_access_range_mut </i32/>;
type IntRangeImut= ust::random_access_range_imut</i32/>;

class A polymorph{}
class B : A {}

struct SomeStruct{ i32 x; }

struct StructWithPadding ordered { i32 x; u8 y; }

struct AWrapper{ A a; }

struct BoolWrapper{ bool b; }

struct SomeEnumWrapper{ SomeEnum e; }

struct StructWithReference{ i32& r; }

enum SomeEnum{ A, B, C }

fn nomangle main() call_conv( "C" ) : i32
{
	{ // range itself is immutable by-default.
		var [ i32, 5 ] arr= zero_init;
		var IntRangeImut range(arr);
		range.drop_back(); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // Can convert mut range to imut range, but after it, mut range becomes inaccessible.
		var [ i32, 16 ] mut arr= zero_init;
		var IntRangeMut  range_mut (arr);
		var IntRangeImut range_imut(range_mut);
		range_mut.front(); //##expect_error ReferenceProtectionError
	}
	{ // Can not convert range_imut to range_mut.
		var [ i32, 16 ] mut arr= zero_init;
		var IntRangeIMut range_imut(arr);
		var IntRangeMut  range_mut (range_imut); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // Can not create range for single element.
		var A a;
		var ust::random_access_range_imut</A/> range(a); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // Can not create range for array of compatible type.
		var [ B, 4 ] b;
		var ust::random_access_range_imut</A/> range(b); //##expect_error CouldNotSelectOverloadedFunction
	}
	{
		var [ i32, 4 ] mut a0= zero_init;
		var [ i32, 4 ] mut a1= zero_init;
		var [ i32, 4 ] mut a2= zero_init;
		var [ ust::array_view_mut</i32/>, 3 ] mut views_array[ a0, a1, a2 ];

		var ust::array_view_imut</ ust::array_view_mut</i32/> /> views_to_views= views_array;

		var i32 &mut a00= views_to_views[0s][0s]; // Create a mutable reference pointing to "a0", "a1", or "a2".
		// Error - this call creates a temporary lock node for second order reference pointing to "a0", "a1", or "a2".
		views_to_views.size(); //##expect_error ReferenceProtectionError
	}
	// to_byte8_range - immutable range of bools can't be converted to bytes.
	{
		var [ bool, 2 ] arr[ true, false ];
		var ust::array_view_imut</ bool /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of tuples containing padding bytes can't be converted to bytes.
	{
		var [ tup[ i32, u16 ], 2 ] arr= zero_init;
		var ust::array_view_imut</ tup[ i32, u16 ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of tuples with class elements can't be converted to bytes.
	{
		var [ tup[ A ], 2 ] arr= zero_init;
		var ust::array_view_imut</ tup[ A ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of structs with padding bytes can't be converted to bytes.
	{
		var [ StructWithPadding, 5 ] arr= zero_init;
		var ust::array_view_imut</ StructWithPadding /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of arrays of structs with padding can't be converted to bytes.
	{
		var [ [ StructWithPadding, 2 ], 5 ] arr= zero_init;
		var ust::array_view_imut</ [ StructWithPadding, 2 ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of classes can't be converted to bytes.
	{
		var [ A, 5 ] arr= zero_init;
		var ust::array_view_imut</ A /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of structs containing classes can't be converted to bytes.
	{
		var [ AWrapper, 5 ] arr= zero_init;
		var ust::array_view_imut</ AWrapper /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of structs containing bools can't be converted to bytes.
	{
		var [ BoolWrapper, 5 ] arr= zero_init;
		var ust::array_view_imut</ BoolWrapper /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of bools can't be converted to bytes.
	{
		var [ bool, 2 ] mut arr[ true, false ];
		var ust::array_view_mut</ bool /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of tuples with padding bytes can't be converted to bytes.
	{
		var [ tup[ char16, i32 ], 2 ] mut arr= zero_init;
		var ust::array_view_mut</ tup[ char16, i32 ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of tuples with class elements can't be converted to bytes.
	{
		var [ tup[ B ], 2 ] mut arr= zero_init;
		var ust::array_view_mut</ tup[ B ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of structs with paddings can't be converted to bytes.
	{
		var [ StructWithPadding, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ StructWithPadding /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of arrays of structs with padding can't be converted to bytes.
	{
		var [ [ StructWithPadding, 2 ], 5 ] mut arr= zero_init;
		var ust::array_view_mut</ [ StructWithPadding, 2 ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of classes can't be converted to bytes.
	{
		var [ A, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ A /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of structs containing classes can't be converted to bytes.
	{
		var [ AWrapper, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ AWrapper /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of structs containing bools can't be converted to bytes.
	{
		var [ BoolWrapper, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ BoolWrapper /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of structs containing reference fields can't be converted to bytes.
	{
		var [ StructWithReference, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ StructWithReference /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of structs containing enums can't be converted to bytes.
	{
		var [ SomeEnumWrapper, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ SomeEnumWrapper /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of enums can't be converted to bytes.
	{
		var [ SomeEnum, 5 ] mut arr= zero_init;
		var ust::array_view_mut</ SomeEnum /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - mutable range of raw pointers can't be converted to bytes.
	{
		var [ $(f32), 5 ] mut arr= zero_init;
		var ust::array_view_mut</ $(f32) /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - result inner reference is linked to source.
	{
		var [ i32, 3 ] mut arr= zero_init;
		auto bytes_range= ust::array_view_imut</ i32 />( arr ).to_byte8_range();
		++arr[1]; //##expect_error ReferenceProtectionError
	}
	// to_byte8_range - result inner reference is linked to source.
	{
		var [ i32, 3 ] mut arr= zero_init;
		auto bytes_range= ust::array_view_mut</ i32 />( arr ).to_byte8_range();
		++arr[1]; //##expect_error ReferenceProtectionError
	}
	{ // "copy_from" isn't supported for immutable ranges.
		var [ i32, 3 ] a0= zero_init, a1= zero_init;
		var ust::array_view_imut</i32/> a0_range(a0);
		a0_range.copy_from( ust::array_view_imut</i32/>(a1) ); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // "copy_from" isn't supported for non-copyable types.
		var [ A, 3 ] mut a0, a1;
		var ust::array_view_mut</A/> a0_range(a0);
		a0_range.copy_from( ust::array_view_imut</A/>(a1) ); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // "copy_from" for types with references inside it's not supported.

		var i32 x= 11, y= 222;
		var [ ust::optional_ref_imut</i32/>, 1 ] mut a0[ (x) ], a1[ (y) ];
		var ust::array_view_mut</ust::optional_ref_imut</i32/>/> r0= a0;
		var ust::array_view_imut</ust::optional_ref_imut</i32/>/> r1= a1;
		r0.copy_from(r1); //##expect_error CouldNotSelectOverloadedFunction
	}

	return 0;
}
