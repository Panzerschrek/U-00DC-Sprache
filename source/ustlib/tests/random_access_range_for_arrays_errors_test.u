//##fail_test
import "../imports/random_access_range.u"

type IntRangeMut = ust::random_access_range_mut </i32/>;
type IntRangeImut= ust::random_access_range_imut</i32/>;

class A polymorph{}
class B : A {}

struct SomeStruct{ i32 x; }

fn nomangle main() call_conv( "C" ) : i32
{
	{ // range itself is immutable by-default.
		var [ i32, 5 ] arr= zero_init;
		var IntRangeImut range(arr);
		range.drop_back(); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // Can convert mut range to imut range, but after it, mut range becomes inaccessible.
		var [ i32, 16 ] mut arr= zero_init;
		var IntRangeMut  range_mut (arr);
		var IntRangeImut range_imut(range_mut);
		range_mut.front(); //##expect_error ReferenceProtectionError
	}
	{ // Can not convert range_imut to range_mut.
		var [ i32, 16 ] mut arr= zero_init;
		var IntRangeIMut range_imut(arr);
		var IntRangeMut  range_mut (range_imut); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // Can not create range for single element.
		var A a;
		var ust::random_access_range_imut</A/> range(a); //##expect_error CouldNotSelectOverloadedFunction
	}
	{ // Can not create range for array of compatible type.
		var [ B, 4 ] b;
		var ust::random_access_range_imut</A/> range(b); //##expect_error CouldNotSelectOverloadedFunction
	}
	{
		var [ i32, 4 ] mut a0= zero_init;
		var [ i32, 4 ] mut a1= zero_init;
		var [ i32, 4 ] mut a2= zero_init;
		var [ ust::array_view_mut</i32/>, 3 ] mut views_array[ a0, a1, a2 ];

		var ust::array_view_imut</ ust::array_view_mut</i32/> /> views_to_views= views_array;

		var i32 &mut a00= views_to_views[0s][0s]; // Create a mutable reference pointing to "a0", "a1", or "a2".
		// Error - this call creates a temporary lock node for second order reference pointing to "a0", "a1", or "a2".
		views_to_views.size(); //##expect_error ReferenceProtectionError
	}
	// to_byte8_range - immutable range of bools can't be converted to bytes.
	{
		var [ bool, 2 ] arr[ true, false ];
		var ust::array_view_imut</ bool /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of tuples can't be converted to bytes.
	{
		var [ tup[ i32 ], 2 ] arr= zero_init;
		var ust::array_view_imut</ tup[ i32 ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of structs can't be converted to bytes.
	{
		var [ SomeStruct, 5 ] arr= zero_init;
		var ust::array_view_imut</ SomeStruct /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - immutable range of arrays of structs can't be converted to bytes.
	{
		var [ [ SomeStruct, 2 ], 5 ] arr= zero_init;
		var ust::array_view_imut</ [ SomeStruct, 2 ] /> range= arr;
		range.to_byte8_range(); //##expect_error CouldNotSelectOverloadedFunction
	}
	// to_byte8_range - result inner reference is linked to source.
	{
		var [ i32, 3 ] mut arr= zero_init;
		auto bytes_range= ust::array_view_imut</ i32 />( arr ).to_byte8_range();
		++arr[1]; //##expect_error ReferenceProtectionError
	}

	return 0;
}
