//##success_test
import "../imports/arena_allocated_box.u"

// arena_allocated_box holds a reference to allocator.
static_assert( typeinfo</ ust::arena_allocated_box</i32/> />.reference_tag_count == 1s );

// arena_allocated_box has size equal to pointer.
static_assert( typeinfo</ ust::arena_allocated_box</i32/> />.size_of == typeinfo</size_type/>.size_of );

// arena_allocated_box is always "non_sync", since it holds a reference to allocator, whic is "non_sync".
static_assert( non_sync</ ust::arena_allocated_box</i32/> /> );

struct S
{
	//Convert reference to pointer and use unsafe because references forbidden in box.
	$(i32) x;
	fn constructor( mut this, i32 &mut in_x )
	( x= $<(in_x) ) {}

	fn destructor()
	{
		unsafe
		{
			++ $>(x);
		}
	}
}

class A polymorph{}
class B : A{}

fn nomangle main() call_conv( "C" ) : i32
{
	{ // Basic usage.
		var ust::arena_allocator allocator;
		var ust::arena_allocated_box</i32/> b( allocator, 42 );
		halt if( b.deref() != 42 );
	}
	{ // Can change stored value.
		var ust::arena_allocator allocator;
		var ust::arena_allocated_box</u32/> mut b( allocator, 422u );
		halt if( b.deref() != 422u );
		b.deref()= 224u;
		halt if( b.deref() != 224u );
	}
	{ // arena_allocated_box calls destructor.
		var ust::arena_allocator allocator;
		var i32 mut x= 0;
		{
			var ust::arena_allocated_box</ S /> box( allocator, S(x) );
		}
		halt if( x != 1 );
	}
	{ // is convertible form other box.
		var ust::arena_allocator allocator;
		var ust::arena_allocated_box</ B /> mut box_b( allocator, B() );
		var ust::arena_allocated_box</ A /> mut box_a( allocator, move(box_b) );
	}
	{ // take
		var ust::arena_allocator allocator;
		var ust::arena_allocated_box</ i32 /> mut box( allocator, 897 );
		auto val= move(box).take_value();
		halt if( val != 897 );
	}

	return 0;
}
