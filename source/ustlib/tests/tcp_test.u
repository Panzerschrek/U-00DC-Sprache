//##success_test
import "../imports/assert.u"
import "../imports/enum_string_conversions.u"
import "../imports/string_conversions.u"
import "../imports/thread.u"
import "../imports/tcp_listener.u"

fn nomangle main() call_conv( "C" ) : i32
{
	var ust::ip_address_v4 loopback( ust::make_array( 127u8, 0u8, 0u8, 1u8 ) );

	// Create tcp listener.
	result_match( ust::tcp_listener::create_and_bind( ust::socket_address_v4( loopback, GetNextPort() ) ) )
	{
		Ok( l ) ->{},
		Err( e ) -> { assert( false, ust::concat( "Failed to create TCP listener! Error code: ", ust::enum_to_string(e) ) ); },
	}

	// Basic server-client interaction.
	{
		var ust::socket_address_v4 server_address( loopback, GetNextPort() );

		// Create server first, in order to be sure that connection works even if listener thread isn't running yet.
		var ust::tcp_listener mut listener= ust::tcp_listener::create_and_bind( server_address ).try_take();

		auto& client_message= "Wer hat Angs vorm schwarzen Mann?";
		var size_type client_message_size= typeinfo</ typeof(client_message) />.size_of;

		auto& server_message= "Niemand hat Angst vor ihm!";
		var size_type server_message_size= typeinfo</ typeof(server_message) />.size_of;

		// Perform accept/read/write on a background thread.
		auto mut server_thread= ust::make_thread(
			lambda[&]()
			{
				// Accept a connection.
				result_match( listener.accept() )
				{
					Ok( mut accept_result ) ->
					{
						auto [ mut stream, client_address ]= move(accept_result);

						if_var( &client_address_v4 : client_address.get</ust::socket_address_v4/>() )
						{
							assert( client_address_v4.get_ip() == loopback || client_address_v4.get_ip().get_bits() == 0u, "Unexpected client address!" );
						}

						var typeof(client_message) mut client_message_received= zero_init;

						// Receive a request.
						result_match( stream.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( client_message_received ) ) ) )
						{
							Ok( bytes_read ) ->
							{
								assert( bytes_read == client_message_size, "Invalid number of bytes read!" );
								assert( client_message_received == client_message );
							},
							Err(e) -> { assert( false, ust::concat( "Failed to read from TCP stream! Error code: ", ust::enum_to_string(e) ) ); }
						}

						// Send responce.
						result_match( stream.write( CastRangeToBytesRange( ust::string_view8( server_message ) ) ) )
						{
							Ok( bytes_written ) -> { assert( bytes_written == server_message_size, "Invalid number of bytes written!" ); },
							Err(e) -> { assert( false, ust::concat( "Failed to write into TCP stream! Error code: ", ust::enum_to_string(e) ) ); }
						}

						// Check address of server stream.
						result_match( stream.get_local_address() )
						{
							Ok( a ) ->
							{
								if_var( &a_v4 : a.get</ust::socket_address_v4/>() )
								{
									assert( a_v4.get_ip() == loopback, "Unexpected IP address of TCP stream!" );
								}
							},
							Err( e ) -> { assert( false, ust::concat( "Failed to get TCP stream local address! Error code: ", ust::enum_to_string(e) ) ); },
						}

						// Check address of client.
						result_match( stream.get_peer_address() )
						{
							Ok( a ) ->
							{
								if_var( &a_v4 : a.get</ust::socket_address_v4/>() )
								{
									assert( a_v4.get_ip() == loopback, "Unexpected IP address of TCP stream!" );
								}
							},
							Err( e ) -> { assert( false, ust::concat( "Failed to get TCP stream remote address! Error code: ", ust::enum_to_string(e) ) ); },
						}
					},
					Err(e) -> { assert( false, ust::concat( "Failed to accept connection! Error code: ", ust::enum_to_string(e) ) ); },
				}
			} );

		// Connect to the server.
		result_match( ust::tcp_stream::connect( server_address ) )
		{
			Ok( mut stream ) ->
			{
				// Send a request.
				result_match( stream.write( CastRangeToBytesRange( ust::string_view8( client_message ) ) ) )
				{
					Ok( bytes_written ) -> { assert( bytes_written == client_message_size, "Invalid number of bytes written!" ); },
					Err(e) -> { assert( false, ust::concat( "Failed to write into TCP stream! Error code: ", ust::enum_to_string(e) ) ); }
				}

				var typeof(server_message) mut server_message_received= zero_init;

				// Receive a response.
				result_match( stream.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( server_message_received ) ) ) )
				{
					Ok( bytes_read ) ->
					{
						assert( bytes_read == server_message_size, "Invalid number of bytes read!" );
						assert( server_message_received == server_message );
					},
					Err(e) -> { assert( false, ust::concat( "Failed to read from TCP stream! Error code: ", ust::enum_to_string(e) ) ); }
				}

				// Check address of server stream.
				result_match( stream.get_peer_address() )
				{
					Ok( a ) ->
					{
						if_var( &a_v4 : a.get</ust::socket_address_v4/>() )
						{
							assert( a_v4.get_ip() == loopback, "Unexpected IP address of TCP stream!" );
						}
					},
					Err( e ) -> { assert( false, ust::concat( "Failed to get TCP stream remote address! Error code: ", ust::enum_to_string(e) ) ); },
				}

				// Check address of client.
				result_match( stream.get_local_address() )
				{
					Ok( a ) ->
					{
						if_var( &a_v4 : a.get</ust::socket_address_v4/>() )
						{
							assert( a_v4.get_ip() == loopback, "Unexpected IP address of TCP stream!" );
						}
					},
					Err( e ) -> { assert( false, ust::concat( "Failed to get TCP stream local address! Error code: ", ust::enum_to_string(e) ) ); },
				}
			},
			Err(e) -> { assert( false, ust::concat( "Failed to connect to server! Error code: ", ust::enum_to_string(e) ) ); },
		}

		move(server_thread).join();
	}

	// Several connections.
	{
		var ust::socket_address_v4 server_address( loopback, GetNextPort() );

		// Create server first, in order to be sure that connection works even if listener thread isn't running yet.
		var ust::tcp_listener mut listener= ust::tcp_listener::create_and_bind( server_address ).try_take();

		var size_type num_clients= 5s;

		var [ [ ust::string8, 2 ], num_clients ] messages
		[
			[ "GÃ¶ttin", "Centhron" ],
			[ "NDH", "Nebelhaus" ],
			[ "Meine Wut will nicht sterben", "Puhdys" ],
			[ "Lampenfieber", "Sturmmann" ],
			[ "Lipsta", "Oberschlesien" ],
		];

		// Perform accept/read/write on a background thread.
		auto mut server_thread= ust::make_thread(
			lambda[&]()
			{
				for( var size_type mut client_index= 0s; client_index < num_clients; ++client_index )
				{
					auto [ mut stream, client_address ]= listener.accept().try_take();

					if_var( &client_address_v4 : client_address.get</ust::socket_address_v4/>() )
					{
						assert( client_address_v4.get_ip() == loopback || client_address_v4.get_ip().get_bits() == 0u, "Unexpected client address!" );
					}

					var [ char8, 64 ] mut client_message_received= zero_init;

					// Receive a request.
					var size_type bytes_read= stream.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( client_message_received ) ) ).try_take();
					assert( bytes_read == messages[client_index][0].size(), "Invalid number of bytes read!" );
					assert( ust::string_view8( client_message_received ).subrange_end( bytes_read ) == messages[client_index][0] );

					// Send responce.
					var size_type bytes_written= stream.write( CastRangeToBytesRange( messages[client_index][1].range() ) ).try_take();
					assert( bytes_written == messages[client_index][1].size(), "Invalid number of bytes written!" );
				}
			} );

		for( var size_type mut client_index= 0s; client_index < num_clients; ++client_index )
		{
			var ust::tcp_stream mut stream= ust::tcp_stream::connect( server_address ).try_take();

			// Send a request.
			var size_type bytes_written= stream.write( CastRangeToBytesRange( messages[client_index][0].range() ) ).try_take();
			assert( bytes_written == messages[client_index][0].size(), "Invalid number of bytes written!" );

			var [ char8, 64 ] mut server_message_received= zero_init;

			// Receive a response.
			var size_type bytes_read= stream.read( CastRangeToBytesRange( ust::array_view_mut</char8/>( server_message_received ) ) ).try_take();
			assert( bytes_read == messages[client_index][1].size(), "Invalid number of bytes read!" );
			assert( ust::string_view8( server_message_received ).subrange_end( bytes_read ) == messages[client_index][1] );
		}

		move(server_thread).join();
	}

	// Non-blocking listener - should not block if nobody connects.
	{
		var ust::tcp_listener mut listener= ust::tcp_listener::create_and_bind( ust::socket_address_v4( loopback, GetNextPort() ) ).try_take();

		if( ust::string_view8( compiler::target::os ) != "windows" )
		{
			assert( !listener.is_nonblocking().try_take(), "Socket isn't blocking as expected!" );
		}

		result_match( listener.set_nonblocking( true ) )
		{
			Ok( v ) -> {},
			Err( e ) -> { assert( false, ust::concat( "Failed to set non-blocking mode for socket! Error code: ", ust::enum_to_string(e) ) ); }
		}

		if( ust::string_view8( compiler::target::os ) != "windows" )
		{
			assert( listener.is_nonblocking().try_take(), "Socket isn't non-blocking as expected!" );
		}

		result_match( listener.accept() )
		{
			Ok( mut accept_result ) ->
			{
				assert( false, "Should not accept without anobody trying to connect!" );

			},
			Err(e) -> { assert( e == ust::io_error::would_block, ust::concat( "Unexpected error code while accepting on non-blocking TCP listener: ", ust::enum_to_string(e) ) ); },
		}
	}

	// "get_local_address" for listener.
	{
		var ust::socket_address_v4 address( loopback, GetNextPort() );
		var ust::tcp_listener listener= ust::tcp_listener::create_and_bind( address ).try_take();

		result_match( listener.get_local_address() )
		{
			Ok( a ) -> { assert( a == address, "Unexpected address of TCP listener!" ); },
			Err( e ) -> { assert( false, ust::concat( "Failed to get TCP listener local address! Error code: ", ust::enum_to_string(e) ) ); },
		}
	}

	return 0;
}

fn GetNextPort() : u16
{
	unsafe
	{
		var u16 res= g_port_counter;
		++g_port_counter;
		return res;
	}
}

var u16 mut g_port_counter= 59000u16;

// It's safe to cast between ranges of chars and bytes.
// TODO - create a library function for this?
template</bool is_mutable/>
fn CastRangeToBytesRange( ust::random_access_range</char8, is_mutable/> r ) : ust::random_access_range</byte8, is_mutable/>
{
	return unsafe( ust::random_access_range</byte8, is_mutable/>( ust::ptr_cast_to_byte8( r.data() ), r.size() ) );
}
