//##success_test
import "../imports/assert.u"
import "../imports/binary_search.u"

fn nomangle main() : i32
{
	{
		// All nums are unique.
		var [ i32, 32 ] arr[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ];
		var ust::array_view_imut</i32/> range= arr;
		TestGreater( range );
		TestGreaterOrEqual( range );
		TestEqualRange( range );
	}
	{
		// Duplicates at start.
		var [ i32, 8 ] arr[ -1, -1, -1, 1, 4, 5, 7, 8 ];
		var ust::array_view_imut</i32/> range= arr;
		TestGreater( range );
		TestGreaterOrEqual( range );
		TestEqualRange( range );
	}
	{
		// Duplicates at end.
		var [ i32, 8 ] arr[ -2, -1, 1, 4, 5, 7, 8, 8 ];
		var ust::array_view_imut</i32/> range= arr;
		TestGreater( range );
		TestGreaterOrEqual( range );
		TestEqualRange( range );
	}
	{
		// Duplicates  in the middle.
		var [ i32, 8 ] arr[ -2, -1, 1, 4, 4, 5, 7, 8 ];
		var ust::array_view_imut</i32/> range= arr;
		TestGreater( range );
		TestGreaterOrEqual( range );
		TestEqualRange( range );
	}
	{
		// Duplicates  in the middle.
		var [ i32, 8 ] arr[ -2, -1, -1, 1, 4, 5, 7, 8 ];
		var ust::array_view_imut</i32/> range= arr;
		TestGreater( range );
		TestGreaterOrEqual( range );
		TestEqualRange( range );
	}
	{
		// Duplicates everywhere.
		var [ i32, 16 ] arr[ 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6 ];
		var ust::array_view_imut</i32/> range= arr;
		TestGreater( range );
		TestGreaterOrEqual( range );
		TestEqualRange( range );
	}

	// Test all possible combinations of numbers 0-7.
	// Even the most of these combinations aren't valid for binary search (not sorted), we still should ensure that binary search doesn't crash or loop forever.
	for( auto mut a= 0; a < 7; ++a )
	{
		for( auto mut b= 0; b < 7; ++b )
		{
			for( auto mut c= 0; c < 7; ++c )
			{
				for( auto mut d= 0; d < 7; ++d )
				{
					for( auto mut e= 0; e < 7; ++e )
					{
						for( auto mut f= 0; f < 7; ++f )
						{
							for( auto mut g= 0; g < 7; ++g )
							{
								var [ i32, 7 ] arr[ a, b, c, d, e, f, g ];
								var ust::array_view_imut</i32/> range= arr;

								var bool is_sorted= IsSorted( range );

								// For each possible subrange search for position for each possible number.
								for( var size_type mut start= 0s; start < range.size(); ++start )
								{
									for( var size_type mut end= start; end < range.size(); ++end )
									{
										auto subrange= range.subrange( start, end );
										for( auto mut i= -1; i < 7 + 1; ++i )
										{
											var size_type greater_res= ust::binary_search::first_greater( subrange, i );
											var size_type greater_equal_res= ust::binary_search::first_greater_or_equal( subrange, i );
											var [ size_type, 2 ] equal_range_res= ust::binary_search::equal_range( subrange, i );
											if( is_sorted )
											{
												// If this combination is sorted check if returned result is equal to expected by linear search.
												assert( greater_res == FirstGreaterLinear( subrange, i ) );
												assert( greater_equal_res == FirstGreaterOrEqualLinear( subrange, i ) );
												assert( equal_range_res[0] == greater_equal_res );
												assert( equal_range_res[1] == greater_res );
												assert( equal_range_res == EqualRangeLinear( subrange, i ) );
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return 0;
}

// TODO - create a function within ustlib?
template</type T/>
fn IsSorted( ust::array_view_imut</T/> range ) : bool
{
	if( range.size() <= 1s )
	{
		return true;
	}

	for( auto mut i= 1s; i < range.size(); ++i )
	{
		if( range[i - 1s] > range[i] )
		{
			return false;
		}
	}

	return true;
}

fn TestGreater( ust::array_view_imut</i32/> range )
{
	// For each possible subrange search for position for each possible number.
	for( var size_type mut start= 0s; start < range.size(); ++start )
	{
		for( var size_type mut end= start; end < range.size(); ++end )
		{
			auto subrange= range.subrange( start, end );
			foreach( el : range )
			{
				assert( ust::binary_search::first_greater( subrange, el ) == FirstGreaterLinear( subrange, el ) );
			}
			assert( ust::binary_search::first_greater( subrange, range.front() - 2 ) == 0s );
			assert( ust::binary_search::first_greater( subrange, range.front() - 1 ) == 0s );
			assert( ust::binary_search::first_greater( subrange, range.back() + 1 ) == subrange.size() );
			assert( ust::binary_search::first_greater( subrange, range.back() + 2 ) == subrange.size() );
		}
	}
}

fn TestGreaterOrEqual( ust::array_view_imut</i32/> range )
{
	// For each possible subrange search for position for each possible number.
	for( var size_type mut start= 0s; start < range.size(); ++start )
	{
		for( var size_type mut end= start; end < range.size(); ++end )
		{
			auto subrange= range.subrange( start, end );
			foreach( el : range )
			{
				assert( ust::binary_search::first_greater_or_equal( subrange, el ) == FirstGreaterOrEqualLinear( subrange, el ) );
			}
			assert( ust::binary_search::first_greater_or_equal( subrange, range.front() - 2 ) == 0s );
			assert( ust::binary_search::first_greater_or_equal( subrange, range.front() - 1 ) == 0s );
			assert( ust::binary_search::first_greater_or_equal( subrange, range.back() + 1 ) == subrange.size() );
			assert( ust::binary_search::first_greater_or_equal( subrange, range.back() + 2 ) == subrange.size() );
		}
	}
}

fn TestEqualRange( ust::array_view_imut</i32/> range )
{
	// For each possible subrange search for position for each possible number.
	for( var size_type mut start= 0s; start < range.size(); ++start )
	{
		for( var size_type mut end= start; end < range.size(); ++end )
		{
			auto subrange= range.subrange( start, end );
			foreach( el : range )
			{
				assert( ust::binary_search::equal_range( subrange, el ) == EqualRangeLinear( subrange, el ) );
			}
			assert( ust::binary_search::equal_range( subrange, range.front() - 2 ) == ust::make_array( 0s, 0s ) );
			assert( ust::binary_search::equal_range( subrange, range.front() - 1 ) == ust::make_array( 0s, 0s ) );
			assert( ust::binary_search::equal_range( subrange, range.back() + 1 ) == ust::make_array( subrange.size(), subrange.size() ) );
			assert( ust::binary_search::equal_range( subrange, range.back() + 2 ) == ust::make_array( subrange.size(), subrange.size() ) );
		}
	}
}


template</type T/>
fn FirstGreaterLinear( ust::array_view_imut</T/> r, T& el ) : size_type
{
	for( var size_type mut i= 0s; i < r.size(); ++i )
	{
		if( el < r[i] )
		{
			return i;
		}
	}
	return r.size();
}

template</type T/>
fn FirstGreaterOrEqualLinear( ust::array_view_imut</T/> r, T& el ) : size_type
{
	for( var size_type mut i= 0s; i < r.size(); ++i )
	{
		if( el <= r[i] )
		{
			return i;
		}
	}
	return r.size();
}

template</type T/>
fn EqualRangeLinear( ust::array_view_imut</T/> r, T& el ) : [ size_type, 2 ]
{
	var [ size_type, 2 ] res[ FirstGreaterOrEqualLinear( r, el ), FirstGreaterLinear( r, el ) ];
	return res;
}
