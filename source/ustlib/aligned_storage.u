import "memory.u"

namespace ust
{

template</ size_type size, size_type alignment />
struct aligned_storage
{
	template<//> struct byte_type_for_alignment</  1s />{ type t= byte8  ; }
	template<//> struct byte_type_for_alignment</  2s />{ type t= byte16 ; }
	template<//> struct byte_type_for_alignment</  4s />{ type t= byte32 ; }
	template<//> struct byte_type_for_alignment</  8s />{ type t= byte64 ; }
	template<//> struct byte_type_for_alignment</ 16s />{ type t= byte128; }
	template</ size_type S /> struct byte_type_for_alignment { type t= byte128; }

	type byte_type= byte_type_for_alignment</ alignment />::t;
	auto constexpr byte_type_size= typeinfo</byte_type/>.size_of;
	auto constexpr element_count= ( size + ( byte_type_size - 1s ) ) / byte_type_size;

	[ byte_type, element_count ] storage_;
}

// Special case for zero size. Avoid declaring even internal field.
// This helps compiler to optimize usage of this class (in some cases).
template</ size_type alignment />
struct aligned_storage</ 0s, alignment />
{}

template</type T/>
fn swap( T &mut a, T &mut b )
{
	auto constexpr size= typeinfo</T/>.size_of;
	auto constexpr alignment= typeinfo</T/>.align_of;
	unsafe
	{
		var aligned_storage</ size, alignment /> mut temp= uninitialized;
		memory_copy_aligned( alignment, cast_ref_unsafe</byte8/>( temp ), cast_ref_unsafe</byte8/>(    a ), size );
		memory_copy_aligned( alignment, cast_ref_unsafe</byte8/>(    a ), cast_ref_unsafe</byte8/>(    b ), size );
		memory_copy_aligned( alignment, cast_ref_unsafe</byte8/>(    b ), cast_ref_unsafe</byte8/>( temp ), size );
	}
}

} // namespace ust
