?macro <? if_var:block ( ?r:opt<? & ?> ?m:opt<? mut ?> ?var_name:ident : ?e:expr ) ?b:block ?alternative:opt<? else ?a:if_alternative ?> ?>
->
<?
	// Expand this macro into block in order to use it as "if alternative".
	{
		with( & ?m<? mut ?> ??e_result : ?e )
		{
			if( !??e_result.empty() )
			{
				with( ?r<? & ?> ?m<? mut ?> ?var_name : unsafe( ??e_result.deref_unchecked() ) )
				?b
			}
			?alternative
			<?
				// Unfortunately it is the only proper way to process if_var alternative - here, inside "with", when lock for ?e still exists.
				// There is no possibility to process alternative after "with", using "break label", for example,
				// because user-specified block before "break" can be terminal and "break" here will cause unreachable code error.
				else ?a
			?>
		}
	}
?>

?macro <? foreach:block ( ?r:opt<? & ?> ?m:opt<? mut ?> ?var_name:ident : ?e:expr ) ?l:opt<? label ?l:expr ?> ?b:block ?>
->
<?
	with( & ?m<? mut ?> ??e_result : ?e )
	{
		static_if( typeinfo</ typeof(??e_result) />.is_array )
		{
			for( var size_type mut ??i(0u); ??i < typeinfo</ typeof(??e_result) />.element_count; ++ ??i ) ?l<? label ?l ?>
			{
				auto ?r<? & ?> ?m<? mut ?> ?var_name= ??e_result[??i];
				?b
			}
		}
		else static_if( typeinfo</ typeof(??e_result) />.is_tuple )
		{
			for( ?r<? & ?> ?m<? mut ?> ?var_name : ??e_result ) ?l<? label ?l ?>
			?b
		}
		else
		{
			auto mut ??i= ??e_result.iter();
			loop ?l<? label ?l ?>
			{
				auto ??next_res= ??i.next();
				if( ??next_res.empty() )
				{
					break;
				}
				with( ?r<? & ?> ?m<? mut ?> ?var_name : unsafe( ??next_res.deref_unchecked() ) )
				{
					?b
				}
			}
		}
	}
?>
