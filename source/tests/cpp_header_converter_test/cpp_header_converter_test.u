import "/cpp_converted.u"

fn nomangle main() call_conv( "C" ) : i32
{
	unsafe
	{
		halt if( ExternCPrefixedFunc( 13 ) != 13 * 13 + 6 * 13 - 3 );
		halt if( ExternCPrefixedFunc( -2 ) != 2 * 2 - 6 * 2 - 3 );

		halt if( ExternCBlockFunc0( 13.5f, 3.0f ) != 13.5f * 3.0f * 3.25f - 0.75f );
		halt if( ExternCBlockFunc0( -5.0f, 21.25f ) != -5.0f * 21.25f * 3.25f - 0.75f );

		halt if( ExternCBlockFunc1() != 0xDEADBEEFu );
	}

	static_assert( same_type</CppStyleTypeAlias, f64/> );
	static_assert( same_type</CppStyleArrayTypeAlias, [ u32, 4 ]/> );
	static_assert( same_type</CppStyleFunctionPointer, ( fn( f32 arg0 ) unsafe call_conv( "C" ) : i32 )/> );

	// Reference params and return types are translated as raw pointers.
	static_assert( same_type</CppFunctionPointerWithReferences, ( fn( $(i32) a, $(f32) b ) unsafe call_conv( "C" ) : $(i32) )/> );

	// Generally all C+= reference types are translated as raw pointers.
	static_assert( same_type</CppDoubleReference, $(f64)/> );
	static_assert( same_type</CppDoubleConstReference, $(f64)/> );
	static_assert( same_type</CppDoubleRValueReference, $(f64)/> );

	static_assert( typeinfo</CppEnumClass/>.is_enum );
	static_assert( typeinfo</CppEnumClass/>.element_count == 7s );

	static_assert( i32( CppEnumClass::S ) == 0 );
	static_assert( i32( CppEnumClass::Z ) == 1 );
	static_assert( i32( CppEnumClass::T ) == 2 );
	static_assert( i32( CppEnumClass::L ) == 3 );
	static_assert( i32( CppEnumClass::J ) == 4 );
	static_assert( i32( CppEnumClass::I ) == 5 );
	static_assert( i32( CppEnumClass::O ) == 6 );

	{
		static_assert( typeinfo</Vec2f/>.size_of == typeinfo</f32/>.size_of * 2s );
		var Vec2f v{ .x= 78.0f, .y= -1.2345f };
	}

	// In C++ empty structs aren't really empty - they have one byte size.
	static_assert( typeinfo</CppEmptyStruct/>.size_of == 1s );

	{
		// C++ classes should be transformed as structs.
		var CppClass c{ .b_= false, .x_= 13.2f, .y_= 87 };
	}

	{ // C++ class with virtual method declaration shouldn't be empty and should contain virtual table pointer field.
		static_assert( typeinfo</CppInterface/>.size_of == typeinfo</$(byte8)/>.size_of );
		var CppInterface cpp_interface{ .ü_vptr= zero_init };
		static_assert( same_type</ typeof( cpp_interface.ü_vptr ), $(byte8) /> );
	}

	return 0;
}
