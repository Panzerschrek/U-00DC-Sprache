import "/cpp_converted.u"

fn nomangle main() call_conv( "C" ) : i32
{
	unsafe
	{
		halt if( ExternCPrefixedFunc( 13 ) != 13 * 13 + 6 * 13 - 3 );
		halt if( ExternCPrefixedFunc( -2 ) != 2 * 2 - 6 * 2 - 3 );

		halt if( ExternCBlockFunc0( 13.5f, 3.0f ) != 13.5f * 3.0f * 3.25f - 0.75f );
		halt if( ExternCBlockFunc0( -5.0f, 21.25f ) != -5.0f * 21.25f * 3.25f - 0.75f );

		halt if( ExternCBlockFunc1() != 0xDEADBEEFu );
	}

	static_assert( same_type</CppStyleTypeAlias, f64/> );
	static_assert( same_type</CppStyleArrayTypeAlias, [ u32, 4 ]/> );
	static_assert( same_type</CppStyleFunctionPointer, ( fn( f32 arg0 ) unsafe call_conv( "C" ) : i32 )/> );

	// Reference params and return types are translated as raw pointers.
	static_assert( same_type</CppFunctionPointerWithReferences, ( fn( $(i32) a, $(f32) b ) unsafe call_conv( "C" ) : $(i32) )/> );

	// Generally all C+= reference types are translated as raw pointers.
	static_assert( same_type</CppDoubleReference, $(f64)/> );
	static_assert( same_type</CppDoubleConstReference, $(f64)/> );
	static_assert( same_type</CppDoubleRValueReference, $(f64)/> );

	static_assert( typeinfo</CppEnumClass/>.is_enum );
	static_assert( typeinfo</CppEnumClass/>.element_count == 7s );

	static_assert( i32( CppEnumClass::S ) == 0 );
	static_assert( i32( CppEnumClass::Z ) == 1 );
	static_assert( i32( CppEnumClass::T ) == 2 );
	static_assert( i32( CppEnumClass::L ) == 3 );
	static_assert( i32( CppEnumClass::J ) == 4 );
	static_assert( i32( CppEnumClass::I ) == 5 );
	static_assert( i32( CppEnumClass::O ) == 6 );

	{
		static_assert( typeinfo</CppUnsequentialEnumClass/>.is_class );
		static_assert( CppUnsequentialEnumClass::One.ü_underlying_value == 1 );
		static_assert( CppUnsequentialEnumClass::TwentyTwo.ü_underlying_value == 22 );
		static_assert( CppUnsequentialEnumClass::Eight.ü_underlying_value == 8 );
	}

	{
		static_assert( typeinfo</Vec2f/>.size_of == typeinfo</f32/>.size_of * 2s );
		var Vec2f v{ .x= 78.0f, .y= -1.2345f };
	}

	// In C++ empty structs aren't really empty - they have one byte size.
	static_assert( typeinfo</CppEmptyStruct/>.size_of == 1s );

	{
		// C++ classes should be transformed as structs.
		var CppClass c{ .b_= false, .x_= 13.2f, .y_= 87 };
	}

	{ // C++ class with virtual method declaration shouldn't be empty and should contain virtual table pointer field.
		static_assert( typeinfo</CppInterface/>.size_of == typeinfo</$(byte8)/>.size_of );
		var CppInterface cpp_interface{ .ü_vptr= zero_init };
		static_assert( same_type</ typeof( cpp_interface.ü_vptr ), $(byte8) /> );
	}
	{ // Virtual table pointer isn't created if class has a base, which has a virtual table pointer.
		var CppDerived cpp_derived{ .ü_base0{ .ü_vptr= zero_init }, .some_field= zero_init };
		static_assert( typeinfo</CppDerived/>.size_of == typeinfo</ $(byte8) />.size_of * 2s );
	}

	static_assert( g_some_int_contant == 37 );
	static_assert( g_group_constant0 == 11u );
	static_assert( g_group_constant1 == 0xFFu );
	static_assert( g_group_constant2 == 2633676u );
	static_assert( g_group_constant3 == u32(g_some_int_contant) * 5u );
	static_assert( g_float_constant == -17.5f );
	static_assert( g_constant_with_constexpr_call_initializer == '7' );
	static_assert( g_constant_with_constructor_initializer == 3.1415926535 );
	static_assert( g_constant_with_universal_initializer == -612 );

	static_assert( typeinfo</ typeof(g_constant_array) />.element_count == 5s );
	static_assert( g_constant_array[0] == 88 );
	static_assert( g_constant_array[1] == 77 );
	static_assert( g_constant_array[2] == 66 );
	static_assert( g_constant_array[3] == 55 );
	static_assert( g_constant_array[4] == 44 );

	static_assert( typeinfo</ typeof(g_constant_2d_array) />.element_count == 2s );
	static_assert( typeinfo</ typeof(g_constant_2d_array[0]) />.element_count == 3s );
	static_assert( g_constant_2d_array[0][0] == -1.0f );
	static_assert( g_constant_2d_array[0][1] == 0.0f );
	static_assert( g_constant_2d_array[0][2] == 32.0f );
	static_assert( g_constant_2d_array[1][0] == 13.2f );
	static_assert( g_constant_2d_array[1][1] == -45.3f );
	static_assert( g_constant_2d_array[1][2] == 1111.0f );

	static_assert( typeinfo</ typeof(g_u64_array) />.element_count == 2s );
	static_assert( g_u64_array[0] == 12345678945u64 );
	static_assert( g_u64_array[1] == 0xFEDCBA9876543210u64 );

	return 0;
}
