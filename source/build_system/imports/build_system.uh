import "/string.u"
import "/variant.u"
import "/vector.u"

namespace BK
{

enum BuildTargetType
{
	// Normal executable, which can be launched.
	Executable,
	// Ü library, which can be used by other targets.
	Library,
	// Native shared library, ".so" or ".dll".
	SharedLibrary,
	// Object file, which may be used by a native linker to link result binary file.
	ObjectFile,
}

struct BuildTarget
{
	// Type of the build target. This should be specified explicitly.
	BuildTargetType target_type;

	// Name of a build target.
	// Empty names, names with some special characters and path separators aren't allowed.
	ust::string8 name;

	// List of source files of this build target. Order is irrelevant.
	// Containts paths relative to the package source directory (where the build script is located).
	// Paths with "." and ".." aren't allowed.
	// Duplicates aren't allowed.
	ust::vector</ust::string8/> source_files;

	// Publuc include directories of this build target.
	// They are used in this target and in all build targets dependent on it.
	// Imports like
	//    import "some_target/some_file.uh"
	// will lead to these directories - some_file.uh will be searched within them.
	// Paths with "." and ".." aren't allowed.
	// Duplicates aren't allowed.
	ust::vector</ust::string8/> public_include_directories;

	// List of dependencies, which should be also dependencies of other build targets dependent on this build target.
	ust::vector</ DependencyName /> public_dependencies;

	// List of dependencies of this build target, which are used internally.
	ust::vector</ DependencyName /> private_dependencies;

	// Contains names or paths of external libraries to link, like system libraries or libraries built outside Ü built system.
	ust::vector</ust::string8/> external_libraries;
}

struct DependencyName
{
	// A package where dependency is located.
	PackageName package_name;
	// Name of dependency. Should be a name of a build target within package specified.
	ust::string8 name;
}

// Package name - used for package dependencies and target names.
struct PackageName
{
	// Marker of case where this is name relative to current package.
	struct CurrentPackage{}

	// Base of package name (where to search it).
	ust::variant</ tup[ CurrentPackage, GlobalVersionedPackageName ] /> name_base;
	// Path starting from base.
	ust::string8 path;
}

// A package from global packages directory/centralized repository, with version specified.
struct GlobalVersionedPackageName
{
	ust::string8 name;
	SemanticVersion version;

	op<=>( GlobalVersionedPackageName& l, GlobalVersionedPackageName& r ) : i32
	{
		if( l.name != r.name ) { return l.name <=> r.name; }
		return l.version <=> r.version;
	}
}

struct SemanticVersion
{
	// Major and minor numbers must be specified. Other are zero by default.
	u32 major;
	u32 minor;
	u32 patch= 0u;
	u32 tweak= 0u;

	// Order compate for semantic version.
	op<=>( SemanticVersion& l, SemanticVersion& r ) : i32
	{
		if( l.major != r.major ) { return l.major <=> r.major; }
		if( l.minor != r.minor ) { return l.minor <=> r.minor; }
		if( l.tweak != r.tweak ) { return l.tweak <=> r.tweak; }
		return l.patch <=> r.patch;
	}
}

// Dependency description for a package.
struct PackageDependency
{
	enum RequiredSystem
	{
		Target,
		Host,
		Both,
	}

	// Which package to depend on.
	PackageName name;
	// How to depend on this package.
	RequiredSystem required_system= RequiredSystem::Target;
}

struct PackageInfo
{
	// Build targets of a package. Order is irrelevant.
	ust::vector</BuildTarget/> build_targets;

	ust::vector</PackageDependency/> package_dependencies;
}

// Signature of a function that should return package info.
// Returns empty optional in case of error.
type GetPackageInfoFunctionType = fn( BuildSystemInterface &mut build_system_interface ) : ust::optional</PackageInfo/>;

// A class which provides necessary information for "GetPackageInfo" function and also contains some helper functions.
// Use inheritance to avoid exposing build system internals to the build script.
//
// Also it helps to import necessary build functions into the build script shared library.
// Otherwise it would be necessary to mark each exported from the build system executable function as "dllexport" or "visibility(default)".
// Making all functions virtual and thus forcing call via the virtual table solves this problem.
class BuildSystemInterface interface
{
	fn virtual pure GetBuildConfiguration(this) : BuildConfiguration;
	fn virtual pure GetTargetTriple(this) : TargetTriple;

	fn virtual pure LogVerbose( mut this, ust::string_view8 message );
	fn virtual pure LogInfo( mut this, ust::string_view8 message );
	fn virtual pure LogError( mut this, ust::string_view8 message );

	// Get value for given configuration option.
	// Options are specified via a configuration file provided as build system command line option.
	// Returns empty ust::optional if option with given name wasn't specified.
	// Both option names and values are case-sensetive.
	// Non-string options are not supported.
	fn virtual pure GetConfigurationOption( this, ust::string_view8 name ) : ust::optional</ust::string8/>;
}

enum BuildConfiguration
{
	Debug,
	Release,
	// TODO - add other configurations
}

struct TargetTriple
{
	// Components are all lowercase strings.
	ust::string8 architecture;
	ust::string8 vendor;
	ust::string8 operating_system;
	ust::string8 environment;
}

} // namespace BK
