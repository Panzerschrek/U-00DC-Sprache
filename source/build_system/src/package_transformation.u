import "/sort.u"
import "package_transformation.uh"
import "options.uh"
import "path.uh"

namespace BK
{

fn TransformAndValidatePackageInfo(
	Logger &mut logger,
	PackageInfo& package_info,
	PackageAbsoluteName& package_absolute_name,
	WorkspaceInfo &mut workspace ) : bool
{
	var bool mut ok= true;

	var ust::vector</ ust::vector</ust::string8 /> /> mut prev_targets_directories;

	foreach( &build_target : package_info.build_targets )
	{
		if( !TargetNameIsValid(  build_target.name ) )
		{
			logger.LogError( ust::concat( "Error, invalid build target name \"", build_target.name, "\"!" ) );
			ok= false;
		}

		var BuildTargetAbsoluteName target_absolute_name
		{
			.package_name= package_absolute_name,
			.name= build_target.name,
		};

		var ust::string8 target_printable_name= BuildTargetAbsoluteNameToPrintableString( target_absolute_name );

		if( workspace.build_targets.exists( target_absolute_name ) )
		{
			logger.LogError( ust::concat( "Error, duplicated build target \"", target_printable_name, "\"!" ) );
			ok= false;
		}

		var WorkspaceInfo::BuildTarget mut out_build_target{ .target_type= build_target.target_type };

		// Process sources.

		if( !build_target.source_files.empty() )
		{
			// Check each source - if it's correct.
			foreach( &source_name : build_target.source_files )
			{
				if( !TargetSourceNameIsValid( source_name ) )
				{
					logger.LogError( ust::concat( "Invalid, source name \"", source_name, "\" of build target \"", target_printable_name, "\"!" ) );
					ok= false;
					continue;
				}

				out_build_target.source_files.push_back( NormalizePath( source_name ) );
			}

			// Normalize list of sources and detect duplicates.
			ust::sort( out_build_target.source_files );
			for( auto mut i = 1s; i < out_build_target.source_files.size(); ++i )
			{
				if( cast_imut(out_build_target).source_files[ i - 1s ] == cast_imut(out_build_target).source_files[i] )
				{
					logger.LogError( ust::concat( "Error, duplicated source file \"", out_build_target.source_files[i], "\" of the build target \"", target_printable_name, "\"!" ) );
					ok= false;
				}
			}

			var ust::vector</ust::string8/> mut sources_directory= CalculateBuildTargetSourceFilesCommonDirectory( out_build_target.source_files  );

			foreach( &component : sources_directory )
			{
				out_build_target.sources_directory+= component;
				out_build_target.sources_directory+= "/";
			}

			logger.LogVerbose( ust::concat( "All sources of the build target \"", target_printable_name, "\" are located within directory \"", out_build_target.sources_directory, "\"." ) );

			// Check for source directory conflict.
			foreach( &prev_source_directory : prev_targets_directories )
			{
				if( prev_source_directory == sources_directory )
				{
					logger.LogError( ust::concat( "Source directory \"", out_build_target.sources_directory, "\" of the build target \"", target_printable_name, "\" is already in use." ) );
					ok= false;
				}
				else if( sources_directory.size() < prev_source_directory.size() &&
					sources_directory == prev_source_directory.range().subrange_end( sources_directory.size() ) )
				{
					logger.LogError( ust::concat( "Source directory \"", out_build_target.sources_directory, "\" of the build target \"", target_printable_name, "\" is a prefix of another used directory." ) );
					ok= false;
				}
				else if( sources_directory.size() > prev_source_directory.size() &&
					prev_source_directory == cast_imut(sources_directory).range().subrange_end( prev_source_directory.size() ) )
				{
					logger.LogError( ust::concat( "Source directory \"", out_build_target.sources_directory, "\" of the build target \"", target_printable_name, "\" is located within another used directory." ) );
					ok= false;
				}
			}

			prev_targets_directories.push_back( move(sources_directory) );
		}

		// Process generated sources.

		foreach( &generated_source_file : build_target.generated_source_files )
		{
			if( !TargetSourceNameIsValid( generated_source_file ) )
			{
				logger.LogError( ust::concat( "Invalid, generated source name \"", generated_source_file, "\" of build target \"", target_printable_name, "\"!" ) );
				ok= false;
				continue;
			}

			out_build_target.generated_source_files.push_back( NormalizePath( generated_source_file ) );
		}

		// Normalize list of generated sources and detect duplicates.
		ust::sort( out_build_target.generated_source_files );
		for( auto mut i = 1s; i < out_build_target.generated_source_files.size(); ++i )
		{
			if( cast_imut(out_build_target).generated_source_files[ i - 1s ] == cast_imut(out_build_target).generated_source_files[i] )
			{
				logger.LogError( ust::concat( "Error, duplicated generated source file \"", out_build_target.generated_source_files[i], "\" of the build target \"", target_printable_name, "\"!" ) );
				ok= false;
			}
		}

		// Process generated private headers.

		foreach( &generated_private_header_file : build_target.generated_private_header_files )
		{
			if( !TargetSourceNameIsValid( generated_private_header_file ) )
			{
				logger.LogError( ust::concat( "Invalid, generated private header file name \"", generated_private_header_file, "\" of build target \"", target_printable_name, "\"!" ) );
				ok= false;
				continue;
			}

			out_build_target.generated_private_header_files.push_back( NormalizePath( generated_private_header_file ) );
		}

		// Normalize list of generated private headers and detect duplicates.
		ust::sort( out_build_target.generated_private_header_files );
		for( auto mut i = 1s; i < out_build_target.generated_private_header_files.size(); ++i )
		{
			if( cast_imut(out_build_target).generated_private_header_files[ i - 1s ] == cast_imut(out_build_target).generated_private_header_files[i] )
			{
				logger.LogError( ust::concat( "Error, duplicated generated private header file \"", out_build_target.generated_private_header_files[i], "\" of the build target \"", target_printable_name, "\"!" ) );
				ok= false;
			}
		}

		// Process generated public headers.

		foreach( &generated_public_header_file : build_target.generated_public_header_files )
		{
			if( !TargetSourceNameIsValid( generated_public_header_file ) )
			{
				logger.LogError( ust::concat( "Invalid, generated public header file name \"", generated_public_header_file, "\" of build target \"", target_printable_name, "\"!" ) );
				ok= false;
				continue;
			}

			out_build_target.generated_public_header_files.push_back( NormalizePath( generated_public_header_file ) );
		}

		// Normalize list of generated public headers and detect duplicates.
		ust::sort( out_build_target.generated_public_header_files );
		for( auto mut i = 1s; i < out_build_target.generated_public_header_files.size(); ++i )
		{
			if( cast_imut(out_build_target).generated_public_header_files[ i - 1s ] == cast_imut(out_build_target).generated_public_header_files[i] )
			{
				logger.LogError( ust::concat( "Error, duplicated generated public header file \"", out_build_target.generated_public_header_files[i], "\" of the build target \"", target_printable_name, "\"!" ) );
				ok= false;
			}
		}

		// Process public include directories.

		if( build_target.target_type == BuildTargetType::Executable && !build_target.public_include_directories.empty() )
		{
			// For now forbid specifying public include directories for executables.
			// It's useless, since exporting symbols from executables isn't supported.
			ok= false;
			logger.LogError( ust::concat( "Non-empty public include directories list for an executable build target \"", target_printable_name, "\"." ) );
		}

		foreach( &public_include_directory : build_target.public_include_directories )
		{
			if( !TargetSourceNameIsValid( public_include_directory ) )
			{
				logger.LogError( ust::concat( "Invalid path of a public source directory \"", public_include_directory, "\" of the build target \"", target_printable_name, "\"." ) );
				ok= false;
				continue;
			}
			auto mut public_include_directory_component_splitted=
				ust::vector</ust::string8/>::from_iterator( SplitPathIntoComponents( public_include_directory ).iter() );

			// Check for directory conflict.
			foreach( &prev_source_directory : prev_targets_directories )
			{
				if( prev_source_directory == public_include_directory_component_splitted )
				{
					logger.LogError( ust::concat( "Public include directory \"", public_include_directory, "\" of the build target \"", target_printable_name, "\" is already in use." ) );
					ok= false;
				}
				else if( public_include_directory_component_splitted.size() < prev_source_directory.size() &&
					public_include_directory_component_splitted == prev_source_directory.range().subrange_end( public_include_directory_component_splitted.size() ) )
				{
					logger.LogError( ust::concat( "Public include directory \"", public_include_directory, "\" of the build target \"", target_printable_name, "\" is a prefix of another used directory." ) );
					ok= false;
				}
				else if( public_include_directory_component_splitted.size() > prev_source_directory.size() &&
					prev_source_directory == cast_imut(public_include_directory_component_splitted).range().subrange_end( prev_source_directory.size() ) )
				{
					logger.LogError( ust::concat( "Public include directory \"", public_include_directory, "\" of the build target \"", target_printable_name, "\" is located within another used directory." ) );
					ok= false;
				}
			}

			var ust::string8 mut directory_normalized;
			foreach( &component : public_include_directory_component_splitted )
			{
				directory_normalized+= component;
				directory_normalized+= "/";
			}
			out_build_target.public_include_directories.push_back( move(directory_normalized) );

			prev_targets_directories.push_back( move(public_include_directory_component_splitted) );
		}

		NormalizeList( out_build_target.public_include_directories );

		// Process public dependencies.

		if( build_target.target_type == BuildTargetType::Executable && !build_target.public_dependencies.empty() )
		{
			// For now forbid specifying public dependencies for executables.
			// It's useless, since exporting symbols from executables isn't supported.
			ok= false;
			logger.LogError( ust::concat( "Non-empty public dependencies list for an executable build target \"", target_printable_name, "\"." ) );
		}

		// Process public dependencies.
		foreach( &public_dependency : build_target.public_dependencies )
		{
			auto mut dependency_name= TransformDependencyName( logger, package_absolute_name, public_dependency );
			if( dependency_name.empty() )
			{
				ok= false;
				continue;
			}
			out_build_target.public_dependencies.push_back( dependency_name.try_take() );
		}
		NormalizeList(out_build_target.public_dependencies);

		// Process private dependencies.
		foreach( &private_dependency : build_target.private_dependencies )
		{
			auto mut dependency_name= TransformDependencyName( logger, package_absolute_name, private_dependency );
			if( dependency_name.empty() )
			{
				ok= false;
				continue;
			}
			out_build_target.private_dependencies.push_back( dependency_name.try_take() );
		}
		NormalizeList(out_build_target.private_dependencies);

		// Process external libraries.
		out_build_target.external_libraries= build_target.external_libraries;
		NormalizeList( out_build_target.external_libraries );

		workspace.build_targets.insert( target_absolute_name, move( out_build_target ) );
	}

	foreach( mut custom_build_step : package_info.custom_build_steps )
	{
		foreach( &mut in_file : custom_build_step.input_files )
		{
			if( !IsAbsolutePath( in_file ) )
			{
				logger.LogError( ust::concat( "Error, custom build step input file path \"", in_file, "\" is not absolute!" ) );
				ok= false;
			}
			else
			{
				in_file= NormalizePath( in_file );
			}
		}

		foreach( &mut out_file : custom_build_step.output_files )
		{
			if( !IsAbsolutePath( out_file ) )
			{
				logger.LogError( ust::concat( "Error, custom build step output file path \"", out_file, "\" is not absolute!" ) );
				ok= false;
			}
			else
			{
				out_file= NormalizePath( out_file );
			}
		}

		NormalizeList( custom_build_step.input_files );
		NormalizeList( custom_build_step.output_files );

		if_var( &mut exe_command : custom_build_step.command.get</CustomBuildStep::ExeCommand/>() )
		{
			if( !IsAbsolutePath( exe_command.exe_path ) )
			{
				logger.LogError( ust::concat( "Error, custom build step executable path \"", exe_command.exe_path, "\" is not absolute!" ) );
				ok= false;
			}
			else
			{
				exe_command.exe_path= NormalizePath( exe_command.exe_path );
			}
		}
		if_var( &mut copy_command : custom_build_step.command.get</ CustomBuildStep::CopyCommand />() )
		{
			if( !IsAbsolutePath( copy_command.destination_path ) )
			{
				logger.LogError( ust::concat( "Error, custom build step copy destination \"", copy_command.destination_path, "\" is not absolute!" ) );
				ok= false;
			}
			else
			{
				copy_command.destination_path= NormalizePath( copy_command.destination_path );
				if( !IsInFilesList( custom_build_step.output_files, copy_command.destination_path ) )
				{
					logger.LogError( ust::concat( "Error, copy command destination file \"", copy_command.destination_path, "\" is not listed in output files!" ) );
					ok= false;
				}
			}

			if( !IsAbsolutePath( copy_command.source_path ) )
			{
				logger.LogError( ust::concat( "Error, custom build step copy source \"", copy_command.source_path, "\" is not absolute!" ) );
				ok= false;
			}
			else
			{
				copy_command.source_path= NormalizePath( copy_command.source_path );
				if( !IsInFilesList( custom_build_step.input_files, copy_command.source_path ) )
				{
					logger.LogError( ust::concat( "Error, copy command source file \"", copy_command.source_path, "\" is not listed in input files!" ) );
					ok= false;
				}
			}

			if( copy_command.destination_path == copy_command.source_path )
			{
				logger.LogError( ust::concat( "Error, custom build step copy source and destination are same path \"", copy_command.source_path, "\"!" ) );
				ok= false;
			}
		}
		if_var( &mut generate_command : custom_build_step.command.get</ CustomBuildStep::GenerateFileCommand />() )
		{
			if( !IsAbsolutePath( generate_command.destination_path ) )
			{
				logger.LogError( ust::concat( "Error, custom build step generate destination \"", generate_command.destination_path, "\" is not absolute!" ) );
				ok= false;
			}
			else
			{
				generate_command.destination_path= NormalizePath( generate_command.destination_path );
				if( !IsInFilesList( custom_build_step.output_files, generate_command.destination_path ) )
				{
					logger.LogError( ust::concat( "Error, generate command destination file \"", generate_command.destination_path, "\" is not listed in output files!" ) );
					ok= false;
				}
			}
		}

		workspace.custom_build_steps.push_back( move(custom_build_step) );
	}

	// TODO - check custom build steps outputs are located within package build directory.

	// Check if package directories are correct.
	foreach( &dependency : package_info.package_dependencies )
	{
		if( dependency.name.name_base.has</ PackageName::CurrentPackage />() )
		{
			auto mut relative_path_component_splitted=
				ust::vector</ust::string8/>::from_iterator( SplitPathIntoComponents( dependency.name.path ).iter() );

			var bool mut moves_up= false;
			foreach( &component : relative_path_component_splitted )
			{
				moves_up|= component == "..";
			}

			if( moves_up )
			{
				// For now ignore paths with ".." - we can't process them properly.
				continue;
			}

			if( !relative_path_component_splitted.empty() )
			{
				// Forbid using the same name for build targets and subpackages.
				// It's needed to avoid name conflicts in the package build directory.
				auto& first_component= relative_path_component_splitted.front();
				foreach( &build_target : package_info.build_targets )
				{
					if( first_component == build_target.name )
					{
						logger.LogError( ust::concat( "Package dependency directory \"", dependency.name.path, "\" conflicts with build target name \"", build_target.name, "\"!" ) );
						ok= false;
					}
				}
			}

			// Do not allow some package names - to avoid conflicts in the build directory.
			foreach( &component : relative_path_component_splitted )
			{
				// TODO - check other reserved names.
				if( component == BuildConfigurationToString( BuildConfiguration::Debug ) ||
					component == BuildConfigurationToString( BuildConfiguration::Release ) )
				{
					logger.LogError( ust::concat( "Package dependency directory \"", dependency.name.path, "\" contains a reserved word!" ) );
					ok= false;
				}
				if( !TargetNameIsValid( component ) ) // Use for package names check identical to target names check.
				{
					logger.LogError( ust::concat( "Package dependency directory \"", dependency.name.path, "\" name is invalid!" ) );
					ok= false;
				}
			}

			foreach( &prev_source_directory : prev_targets_directories )
			{
				if( prev_source_directory == relative_path_component_splitted )
				{
					logger.LogError( ust::concat( "Package dependency directory \"", dependency.name.path, "\" is already in use." ) );
					ok= false;
				}
				else if( relative_path_component_splitted.size() < prev_source_directory.size() &&
					relative_path_component_splitted == prev_source_directory.range().subrange_end( relative_path_component_splitted.size() ) )
				{
					logger.LogError( ust::concat( "Package dependency directory \"", dependency.name.path, "\" is a prefix of another used directory." ) );
					ok= false;
				}
				else if( relative_path_component_splitted.size() > prev_source_directory.size() &&
					prev_source_directory == cast_imut(relative_path_component_splitted).range().subrange_end( prev_source_directory.size() ) )
				{
					logger.LogError( ust::concat( "Package dependency directory \"", dependency.name.path, "\" is located within another used directory." ) );
					ok= false;
				}
			}

			// Do not store directory of this package dependency in "prev_targets_directories" list.
			// It's allowed to access package dependencies within other package dependencies.
		}
		else if_var( &global_versioned_package : dependency.name.name_base.get</ GlobalVersionedPackageName />() )
		{
			// Check here if package name is valid.
			// But generally this check isn't so necessary,
			// since package naming correctnes should be enforced by the authority of a repository.

			if( !TargetNameIsValid( global_versioned_package.name ) ) // For now apply build target naming rules.
			{
				logger.LogError( ust::concat( "Global package dependency \"", global_versioned_package.name, "\" is not valid!" ) );
				ok= false;
			}
			if( global_versioned_package.version == SemanticVersion( 0u, 0u ) )
			{
				logger.LogError( ust::concat( "Can't specify zero version for global package \"", global_versioned_package.name, "\"!" ) );
				ok= false;
			}
		}
	}

	return ok;
}

fn ProcessWorkspaceDependenciesGraph( Logger &mut logger, WorkspaceInfo &mut workspace ) : bool
{
	var bool mut ok= true;

	// Check for dependency graph validity.
	foreach( &pair : cast_imut(workspace).build_targets )
	{
		ok&= DependencyGraphIsValid( logger, workspace, pair.key() );
	}

	if( !ok )
	{
		// Stop here, if we have errors.
		// Avoid performing dependency graph analysis steps if dependency graph isn't valid.
		return false;
	}

	// Collect build target names in order to have possibility to iterate and change build targets map elements.
	var ust::vector</BuildTargetAbsoluteName/> mut build_target_names;
	foreach( &pair : workspace.build_targets )
	{
		build_target_names.push_back( pair.key() );
	}

	// Perform public dependencies retrieval.
	foreach( &build_target_name : build_target_names )
	{
		auto mut dependencies = GetAllTargetPublicDependencies( workspace, build_target_name );
		workspace.build_targets[build_target_name].public_dependencies_including_transitive= move(dependencies);
	}

	// Perform private dependencies retrieval.
	foreach( &build_target_name : build_target_names )
	{
		auto dependencies = GetAllTargetPrivateAndTheirTransitivePublicDependencies( workspace, build_target_name );

		auto &mut out_build_target= workspace.build_targets[ build_target_name ];

		// Remove private dependencies which are also public dependencies.

		auto& public_dependencies= out_build_target.public_dependencies_including_transitive;
		auto is_not_in_public_dependencies=
			lambda[&]( BuildTargetAbsoluteName& target_name ) : bool
			{
				foreach( &dependency : public_dependencies )
				{
					if( target_name == dependency )
					{
						return false;
					}
				}
				return true;
			};

		out_build_target.private_dependencies_including_transitive_public_dependencies.append(
			dependencies.iter().filter( is_not_in_public_dependencies ) );
	}

	// Perform shared libraries to link retrieval.
	foreach( &build_target_name : build_target_names )
	{
		auto mut dependencies= GetAllTargetSharedLibraryDependenciesToLink( workspace, build_target_name );
		workspace.build_targets[ build_target_name ].shared_library_dependencies_to_link= move(dependencies);
	}

	// Perform external libraries to link retrieval.
	foreach( &build_target_name : build_target_names )
	{
		auto mut libraries= GetAllTargetExternalLibrariesToLink( workspace, build_target_name );
		workspace.build_targets[ build_target_name ].all_external_libraries_to_link= move(libraries);
	}

	// Check dependency name conflicts.
	foreach( &pair : cast_imut(workspace).build_targets )
	{
		var BuildTargetAbsoluteName& build_target_name= pair.key();
		var WorkspaceInfo::BuildTarget& build_target= pair.value();

		auto all_deps=
			build_target.public_dependencies_including_transitive.iter().chain(
				build_target.private_dependencies_including_transitive_public_dependencies.iter() );

		foreach( &dep_a : all_deps )
		{
			foreach( &dep_b : all_deps )
			{
				if( dep_a.name == dep_b.name && dep_a.package_name < dep_b.package_name )
				{
					// Forbid having multiple dependnecies, including public and private and their transitive dependencies,
					// if they have identical name but come from different packages.
					// It's needed, since imports are prefixed just by dependency name without package name.
					logger.LogError(
						ust::concat(
							"Build target \"",
							BuildTargetAbsoluteNameToPrintableString( build_target_name ),
							"\" has dependencies with identical name \"",
							BuildTargetAbsoluteNameToPrintableString( dep_a ),
							"\" and \"",
							BuildTargetAbsoluteNameToPrintableString( dep_b ),
							"\"!" ) );
					ok= false;
				}
			}
		}
	}

	// Check custom build steps.
	// For now only check if no two steps produce same files.
	// TODO - detect dependency loops.
	for( auto mut i= 0s; i < workspace.custom_build_steps.size(); ++i )
	{
		var CustomBuildStep& step_i= workspace.custom_build_steps[i];
		for( auto mut j= i + 1s; j < workspace.custom_build_steps.size(); ++j )
		{
			var CustomBuildStep& step_j= cast_imut(workspace).custom_build_steps[j];

			foreach( &output_file_i : step_i.output_files )
			{
				foreach( &output_file_j : step_j.output_files )
				{
					// This should work because paths should be normalized previously.
					if( output_file_i == output_file_j )
					{
						logger.LogError( ust::concat(
							"Error, two custom build steps \"",
							step_i.comment,
							"\" and \"",
							step_j.comment,
							"\" share same output file \"",
							output_file_i,
							"\"!" ) );
						ok= false;
					}
				}
			}
		}
	}

	return ok;
}

fn ResolvePackageAbsoluteName(
	Logger &mut logger,
	PackageAbsoluteName& parent_package_absolute_name,
	PackageName& package_name ) : ust::optional</PackageAbsoluteName/>
{
	if( package_name.name_base.has</ PackageName::CurrentPackage/>() )
	{
		if( package_name.path.empty() )
		{
			return parent_package_absolute_name;
		}

		var ust::vector</ust::string8/> mut components;
		components.append( SplitPathIntoComponents( parent_package_absolute_name.path ).iter() );

		foreach( &child_component : SplitPathIntoComponents( package_name.path ) )
		{
			if( child_component == "." )
			{} // Do not push "."
			else if( child_component == ".." )
			{
				if( components.empty() )
				{
					logger.LogError(
						ust::concat(
							"Failed to resolve package dependency \"",
							package_name.path,
							"\" relative to \"",
							parent_package_absolute_name.path,
							"\" - too many \"..\"!" ) );
					return ust::null_optional;
				}
				components.pop_back();
			}
			else
			{
				components.push_back( child_component );
			}
		}

		var ust::string8 mut path;
		foreach( &component : components )
		{
			if( !path.empty() )
			{
				path+= "/";
			}
			path+= component;
		}

		return PackageAbsoluteName{ .path= NormalizePath( path ) };
	}
	else if_var( &global_versioned_package : package_name.name_base.get</ GlobalVersionedPackageName />() )
	{
		foreach( &component : SplitPathIntoComponents( package_name.path ) )
		{
			if( component == "." || component == ".." )
			{
				logger.LogError( "Paths with \".\" and \"..\" aren't allowed in global package names!" );
				return ust::null_optional;
			}
		}

		return PackageAbsoluteName{ .name_base= global_versioned_package, .path= package_name.path };
	}
	else
	{
		logger.LogError( "Non-handled package base name kind!" );
		return ust::null_optional;
	}
}

fn TargetNameIsValid( ust::string_view8 name ) : bool
{
	if( name.empty() )
	{
		return false;
	}

	if( name.back() == " "c8 )
	{
		return false; // Prevent names ending with space (Windows limitation).
	}
	if( name.front() == " "c8 )
	{
		return false; // Just to be sure prevent leading spaces.
	}

	foreach( c : name )
	{
		// Prevent symbols which may have special meaning in paths.
		switch(c)
		{
			// Dots are allowed in paths, but in target names they may be confusing.
			// Using dots is legal for file extension, but we don't need they in target names.
			"."c8,
			"/"c8,
			"\\"c8,
			":"c8,
			"\""c8,
			"'"c8,
			"<"c8,
			">"c8,
			"|"c8,
			"?"c8,
			"*"c8,
			char8(0) ... char8(31) // Forbid binary null and all control characters.
			-> { return false; },
			default -> {}
		}
	}

	return true;
}

fn TargetSourceNameIsValid( ust::string_view8 name ) : bool
{
	if( name.empty() )
	{
		return false;
	}

	if( name.front() == "/"c8 || name.front() == "\\"c8 )
	{
		// Do not allow absolute paths.
		return false;
	}

	if( name.size() >= 2s && name[0s] >= "A"c8 && name[0s] <= "Z"c8 && name[1s] == ":"c8 )
	{
		// Do not allow absolute Windows paths.
		return false;
	}

	// Disable "." and ".." in source file names.
	foreach( &component : SplitPathIntoComponents( name ) )
	{
		if( component == "." || component == ".." )
		{
			return false;
		}
	}

	// Further checks aren't really necessary.
	// If for example file name is invalid, it will not be found and build will fail.

	return true;
}

fn CalculateBuildTargetSourceFilesCommonDirectory( ust::array_view_imut</ust::string8/> sources ) : ust::vector</ust::string8/>
{
	if( sources.empty() )
	{
		return ust::vector</ust::string8/>();
	}

	var ust::vector</ust::vector</ust::string8/>/> mut sources_splitted_per_component;
	foreach( &source : sources )
	{
		sources_splitted_per_component.push_back( SplitPathIntoComponents(source).iter().collect</ ust::vector</ ust::string8 /> />() );
	}

	if( sources_splitted_per_component.size() == 1s )
	{
		// Special case with only one file - remove last component (presumably file name) and return it.
		var ust::vector</ust::string8/> mut result= sources_splitted_per_component.pop_back();
		if( !result.empty() )
		{
			result.drop_back();
		}
		return result;
	}

	var ust::vector</ust::string8/> mut result;

	// Calculate common prefix for all files.

	for( auto mut i= 0s; ; ++i ) label component_loop
	{
		var ust::vector</ust::string8/>& first_source= sources_splitted_per_component.front();
		if( i >= first_source.size() )
		{
			break label component_loop;
		}
		var ust::string8& first_source_component= first_source[i];

		foreach( & source_splitted : cast_imut(sources_splitted_per_component) )
		{
			if( i >= source_splitted.size() || source_splitted[i] != first_source_component )
			{
				break label component_loop;
			}
		}

		result.push_back( first_source_component );
	}

	return result;
}

fn TransformDependencyName(
	Logger& mut logger,
	PackageAbsoluteName& package_absolute_name,
	DependencyName& dependency_name ) : ust::optional</BuildTargetAbsoluteName/>
{
	auto mut dependency_package_name=
		ResolvePackageAbsoluteName( logger, package_absolute_name, dependency_name.package_name );
	if( dependency_package_name.empty() )
	{
		return ust::null_optional;
	}

	return BuildTargetAbsoluteName{ .package_name= dependency_package_name.try_take(), .name= dependency_name.name };
}

fn IsInFilesList( ust::array_view_imut</ust::string8/> files, ust::string_view8 f ) : bool
{
	foreach( &list_file : files )
	{
		if( f == list_file )
		{
			return true;
		}
	}
	return false;
}

// Returns true if dependency graph is valid.
fn DependencyGraphIsValid(
	Logger &mut logger, WorkspaceInfo& workspace, BuildTargetAbsoluteName& build_target_name ) : bool
{
	var ust::vector</BuildTargetAbsoluteName/> mut call_stack;
	return DependencyGraphIsValid_r( logger, workspace, build_target_name, call_stack );
}

fn DependencyGraphIsValid_r(
	Logger &mut logger,
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& build_target_name,
	ust::vector</BuildTargetAbsoluteName/> &mut call_stack ) : bool
{
	for( auto mut i= 0s; i < call_stack.size(); ++i )
	{
		if( build_target_name == call_stack[i] )
		{
			var ust::string8 mut message= "Dependency loop detected: ";
			for( auto mut j= i; j < call_stack.size(); ++j )
			{
				message += "\"";
				message += BuildTargetAbsoluteNameToPrintableString( call_stack[j] );
				message += "\"";
				message += " -> ";
			}
			message += "\"";
			message += BuildTargetAbsoluteNameToPrintableString( build_target_name );
			message += "\"";

			logger.LogError( message );

			return false;
		}
	}

	call_stack.push_back( build_target_name );

	var bool mut ok= true;

	if_var( &build_target : workspace.build_targets.find( build_target_name ) )
	{
		foreach( &dependency : build_target.public_dependencies.iter().chain( build_target.private_dependencies.iter() ) )
		{
			if( dependency == build_target_name )
			{
				logger.LogError( ust::concat( "Build target \"", BuildTargetAbsoluteNameToPrintableString( build_target_name ), "\" depends on itself." ) );
				ok= false;
				continue;
			}
			if_var( &dependency_build_target : workspace.build_targets.find( dependency ) )
			{
				if( !(
					dependency_build_target.target_type == BuildTargetType::Library ||
					dependency_build_target.target_type == BuildTargetType::SharedLibrary
					// For now do not allow depend on object file build target.
					// Technically it can be possible, but has a lot of caveats, so it's better not to support it.
					// Regular library targets should be used, if some common code needed to be used in some another build target(s).
					) )
				{
					logger.LogError(
						ust::concat(
							"Build target \"",
							BuildTargetAbsoluteNameToPrintableString( build_target_name ),
							"\" depends on non-library build target \"",
							dependency.name,
							"\"." ) );
					ok= false;
				}
			}

			ok&= DependencyGraphIsValid_r( logger, workspace, dependency, call_stack );
		}
	}
	else
	{
		ok= false;
		logger.LogError( ust::concat( "Dependency \"", BuildTargetAbsoluteNameToPrintableString( build_target_name ), "\" not found." ) );
	}

	call_stack.pop_back();
	return ok;
}

fn GetAllTargetPublicDependencies(
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& build_target_name )
	: ust::vector</BuildTargetAbsoluteName/>
{
	// Build targets existence should be checked before.

	var ust::vector</BuildTargetAbsoluteName/> mut result;
	GetAllTargetPublicDependencies_r( workspace, build_target_name, result );

	NormalizeList(result);

	return result;
}

fn GetAllTargetPrivateAndTheirTransitivePublicDependencies(
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& build_target_name )
	: ust::vector</BuildTargetAbsoluteName/>
{
	// Build targets existence should be checked before.

	var ust::vector</BuildTargetAbsoluteName/> mut result;

	foreach( &private_dependency : workspace.build_targets[ build_target_name ].private_dependencies )
	{
		GetAllTargetPublicDependencies_r( workspace, private_dependency, result );
		result.push_back( private_dependency );
	}

	NormalizeList(result);

	return result;
}

fn GetAllTargetPublicDependencies_r(
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& build_target_name,
	ust::vector</BuildTargetAbsoluteName/> &mut result )
{
	// Possible dependency loops and target names validity should be checked before.

	foreach( &public_dependency : workspace.build_targets[ build_target_name ].public_dependencies )
	{
		GetAllTargetPublicDependencies_r( workspace, public_dependency, result );
		result.push_back(public_dependency);
	}
}

fn GetAllTargetSharedLibraryDependenciesToLink(
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& build_target_name ) : ust::vector</BuildTargetAbsoluteName/>
{
	// Possible dependency loops and target names validity should be checked before.

	var WorkspaceInfo::BuildTarget& build_target= workspace.build_targets[ build_target_name ];
	var ust::vector</BuildTargetAbsoluteName/> mut result;

	foreach( &dependency : build_target.public_dependencies.iter().chain( build_target.private_dependencies.iter() ) )
	{
		GetAllTargetSharedLibraryDependenciesToLink_r( workspace, dependency, result );
	}

	NormalizeList(result);

	return result;
}

fn GetAllTargetSharedLibraryDependenciesToLink_r(
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& build_target_name,
	ust::vector</BuildTargetAbsoluteName/> &mut result )
{
	// Possible dependency loops and target names validity should be checked before.

	var WorkspaceInfo::BuildTarget& build_target= workspace.build_targets[ build_target_name ];

	switch( build_target.target_type )
	{
		BuildTargetType::Executable -> {}, // This should be checked before.
		BuildTargetType::Library ->
		{
			// Extract shared library dependencies of public and private library dependencies.
			foreach( &dependency : build_target.public_dependencies.iter().chain( build_target.private_dependencies.iter() ) )
			{
				GetAllTargetSharedLibraryDependenciesToLink_r( workspace, dependency, result );
			}
		},
		BuildTargetType::SharedLibrary ->
		{
			// Use this shared librarty.
			result.push_back( build_target_name );

			// Extract also shared library dependencies of public dependencies of this shared library.
			// But DO NOT extract shared library dependencies of private dependencies.
			foreach( &public_dependency : build_target.public_dependencies )
			{
				GetAllTargetSharedLibraryDependenciesToLink_r( workspace, public_dependency, result );
			}
		},
		BuildTargetType::ObjectFile -> {}, // This should be checked before.
	}
}

fn GetAllTargetExternalLibrariesToLink(
	WorkspaceInfo& workspace, BuildTargetAbsoluteName& build_target_name ) : ust::vector</ust::string8/>
{
	// Possible dependency loops and target names validity should be checked before.

	var ust::vector</ust::string8/> mut result;
	GetAllTargetExternalLibrariesToLink_r( workspace, build_target_name, result );
	NormalizeList(result);

	return result;
}

fn GetAllTargetExternalLibrariesToLink_r(
	WorkspaceInfo& workspace, BuildTargetAbsoluteName& build_target_name, ust::vector</ust::string8/> &mut result )
{
	// Possible dependency loops and target names validity should be checked before.

	var WorkspaceInfo::BuildTarget& build_target= workspace.build_targets[ build_target_name ];

	foreach( &external_library : build_target.external_libraries )
	{
		result.push_back( external_library );
	}

	// Extract external libraries of public and private library dependencies.
	foreach( &dependency : build_target.public_dependencies.iter().chain( build_target.private_dependencies.iter() ) )
	{
		if( workspace.build_targets[ dependency ].target_type == BuildTargetType::SharedLibrary )
		{
			// Do not extract external libraries of dependencies of shared library.
			// Assume that external libraries are used inside a shared library only privately.
			continue;
		}
		GetAllTargetExternalLibrariesToLink_r( workspace, dependency, result );
	}
}

fn BuildTargetAbsoluteNameToPrintableString( BuildTargetAbsoluteName& name ) : ust::string8
{
	var ust::string8 mut res;
	if( !name.package_name.path.empty() )
	{
		res+= name.package_name.path;
		res+= "/";
	}
	res+= name.name;
	return res;
}

template</type T/>
fn NormalizeList( ust::vector</T/> &mut list )
{
	ust::sort( list );
	list.remove_adjacent_duplicates();
}

} // namespace BK
