import "/path.u"
import "/string.u"
import "/vector.u"
import "logger.uh"

namespace BK
{

// Directed (normally) acyclic graph.
// Nodes in build graph are commands, edges are files.
// Caution! File paths should be normalized!
//
// If this is changed, serialization/deserialization code must be changed too!
struct BuildGraph
{
	// If this is changed, serialization/deserialization code must be changed too!
	struct Node
	{
		// Program to run.
		// May contain special build command name instead of executable path. Such commands are processed internally.
		ust::string8 program;

		// Program arguments.
		ust::vector</ust::string8/> command_line;

		// What is shown to the user during rebuild.
		// Contains something like command output file name.
		ust::string8 comment;

		// If non-empty - represents a dependency file.
		// It's produced during the command execution and may contain implicit input files ( like imports (headers) ).
		//
		// Caution! Dependency files are designed to track dependencies on static files (like imported sources).
		// If a file is generated by another command, it should be listed in "input_files", otherwise build order may be incorrect!
		ust::filesystem_path dep_file;

		// Files which this command requires (including command executable file, if it may be changed).
		ust::vector</ust::filesystem_path/> input_files;
		// Files which this command produces.
		ust::vector</ust::filesystem_path/> output_files;
	}

	// Nodes of the graph in some unspecified order.
	// Use vector to make index-based access possible.
	// Generally this order should be deterministic in order to allow fast build graph change check by just comparing its list of nodes.
	ust::vector</Node/> nodes;

	// Edges aren't stored explicitly - input/output edges (files) are stored in nodes.
	// Edges without start nodes are possible - like for source files.
	// Edges witohut end nodes are possible too - like for result files (executables, shared libraries, etc.).
}

// Perform the build, possibly rebuilding only necessary parts of the graph.
// Optional previous graph state may be provided. If it's empty, the full build will be triggered.
// Returns true on success.
fn nodiscard PerformGraphBuild(
	Logger &mut logger,
	BuildGraph& build_graph,
	ust::optional_ref_imut</BuildGraph/> prev_build_graph_opt,
	u32 max_number_of_parallel_jobs ) : bool;

namespace SpecialBuildCommands
{

// Prefix all special commands with "??" - regular paths can't start with it.

// Copy file from one place to another. command_line[0]= destination, command_line[1]= source
auto& copy_file= "??copy";

// Create file with contents specified. command_line[0]= destination, command_line[1]= contents
auto& generate_file= "??generate_file";

} // namespace SpecialBuildCommands

} // namespace BK
