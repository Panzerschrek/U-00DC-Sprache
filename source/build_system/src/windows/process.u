import "/assert.u"
import "/stdout.u"
import "/string_conversions.u"
import "../process.uh"
import "wide_string.uh"
import "windows.uh"

namespace BK
{

fn RunExecutable( Logger &mut logger, ust::string_view8 exe_path, ust::array_view_imut</ust::string8/> command_line ) : bool
{
	var WideString exe_path_wide = UTF8ToWideString( exe_path );

	var WideString mut exe_path_null_terminated = exe_path_wide;

	// Append exe if necessary.
	// TODO - do we really need to do this here?
	if(exe_path.size() < 4s || exe_path.subrange_start( exe_path.size() - 4s ) != ".exe" )
	{
		auto mut extension = UTF8ToWideString( ".exe" );
		exe_path_null_terminated.append( extension );
	}

	exe_path_null_terminated.push_back( WCHAR(0) );

	var WideString space = UTF8ToWideString( " " );
	var WideString quote = UTF8ToWideString( "\"" );

	var WideString mut command_line_combined;
	command_line_combined.append( quote.iter() );
	command_line_combined.append( exe_path_wide.iter() ); // Repeat exe path in command line - it's necessary to fill argv[0]
	command_line_combined.append( quote.iter() );

	foreach( &arg : command_line )
	{
		command_line_combined.append( space.iter() );
		command_line_combined.append( quote.iter() );
		command_line_combined.append( UTF8ToWideString( arg ).iter() );
		command_line_combined.append( quote.iter() );
	}

	command_line_combined.push_back( WCHAR(0) );

	var ü_STARTUPINFOW mut startup_info = zero_init;
	startup_info.cb = u32( typeinfo</ü_STARTUPINFOA/>.size_of );

	var ü_PROCESS_INFORMATION mut process_information = zero_init;

	var BOOL creation_result = unsafe( CreateProcessW(
		exe_path_null_terminated.data(),
		command_line_combined.data(),
		ust::nullptr</ü_SECURITY_ATTRIBUTES/>(),
		ust::nullptr</ü_SECURITY_ATTRIBUTES/>(),
		0, // Inherit handles.
		0u, // Flags
		ust::nullptr</byte8/>(), // Environment
		ust::nullptr</WCHAR/>(), // Current directory
		$<(startup_info),
		$<(process_information) ) );

	if( creation_result == 0 )
	{
		logger.LogError( ust::concat( "CreateProcessW error: ", ust::to_string8( unsafe( GetLastError() ) ), "\n" ) );
		return false;
	}

	// TODO - check if waiting fails.
	unsafe( WaitForSingleObject( process_information.hProcess, 0xFFFFFFFFu ) );

	var DWORD mut exit_code = 100u;
	// TODO - check if retrieving exit code fails.
	unsafe( GetExitCodeProcess( process_information.hProcess, $<(exit_code) ) );

	unsafe( CloseHandle( process_information.hProcess ) );
	unsafe( CloseHandle( process_information.hThread ) );

	return exit_code == 0u;
}

fn CreateProcessGroup( Logger &mut logger ) : ust::box_nullable</ProcessGroupInterface/>
{
	auto mut process_group_opt= ProcessGroup::Create( logger );
	if( process_group_opt.empty() )
	{
		return ust::box_nullable</ProcessGroupInterface/>();
	}
	return ust::make_box( process_group_opt.try_take() );
}

class ProcessGroup final : ProcessGroupInterface
{
public:
	fn Create( Logger &mut logger ) : ust::optional</ProcessGroup/>
	{
		var HANDLE io_port=
			unsafe( ::CreateIoCompletionPort(
				GetInvalidHandle(),
				ust::nullptr</byte8/>(),
				ULONG_PTR(0),
				1u ) );

		if( ust::is_nullptr( io_port ) )
		{
			logger.LogError( "Failed to create IO completion port!" );
			return ust::null_optional;
		}

		return unsafe( ProcessGroup( io_port ) );
	}

	fn constructor()= delete;

	// constructor for internal usage
	fn constructor( HANDLE io_port ) unsafe
		( io_port_= io_port )
	{
		assert( !ust::is_nullptr( io_port_ ) );
	}

	fn destructor()
	{
		unsafe( ::CloseHandle( io_port_ ) );
	}

public: // ProcessGroupInterface
	fn virtual override StartProcess(
		mut this,
		Logger &mut logger,
		ProcessId process_id,
		ust::string_view8 exe_path,
		ust::array_view_imut</ust::string8/> command_line ) : bool
	{
		var bool ok= RunExecutable( logger, exe_path, command_line );
		if( !ok )
		{
			return false;
		}
		finished_processes_.push_back( process_id );
		return true;
	}

	fn virtual override DoWork( mut this, Logger &mut logger ) : bool
	{
		ust::ignore_unused(logger);
		return true;
	}

	fn virtual override TakeFinishedProcess( mut this ) : ust::optional</ProcessId/>
	{
		if( !finished_processes_.empty() )
		{
			return finished_processes_.pop_back();
		}
		return ust::null_optional;
	}

	fn virtual override GetNumberOfRunningProcesses( mut this ) : size_type
	{
		return 0s;
	}

private:
	HANDLE imut io_port_;
	ust::vector</ProcessId/> finished_processes_;
}

// Produces INVALID_HANDLE_VALUE.
fn GetInvalidHandle() : HANDLE
{
	static_assert( typeinfo</ size_type />.size_of == typeinfo</HANDLE/>.size_of );

	// Make -1.
	var size_type mut s(0);
	--s;

	var HANDLE mut handle= zero_init;

	unsafe( ust::memory_copy(
		ust::ptr_cast_to_byte8( $<(handle) ),
		ust::ptr_cast_to_byte8( $<(s) ),
		typeinfo</ HANDLE />.size_of ) );

	return handle;
}

} // namespace BK
