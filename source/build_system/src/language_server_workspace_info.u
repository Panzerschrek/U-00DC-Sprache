import "filesystem.uh"
import "include_directories.uh"
import "json/serialization.uh"
import "language_server_workspace_info.uh"
import "path.uh"

namespace BK
{

fn WriteLanguageServerWorkspaceInfoFile(
	Logger &mut logger,
	BuildSystemPaths& build_system_paths,
	WorkspaceInfo& target_workspace,
	WorkspaceInfo& host_workspace,
	ust::string_view8 build_directory ) : bool
{
	var JsonValue::Array mut json_root;

	PopulateWorkspaceDirectoryGroups( build_system_paths, target_workspace, json_root );
	PopulateWorkspaceDirectoryGroups( build_system_paths, host_workspace, json_root );

	var ust::string8 file_path= ust::concat( build_directory, "/language_server_workspace_info.json" );

	return WriteFile( logger, file_path, SerializeJsonValuePretty( move(json_root) ) );
}

fn PopulateWorkspaceDirectoryGroups(
	BuildSystemPaths& build_system_paths,
	WorkspaceInfo& workspace,
	JsonValue::Array &mut json_root )
{
	foreach( &pair : workspace.build_targets )
	{
		var BuildTargetAbsoluteName& build_target_name= pair.key();
		var WorkspaceInfo::BuildTarget& build_target= pair.value();

		var ust::string8 package_source_directory=
			GetPackageSourceDirectory( build_system_paths, build_target_name.package_name );

		var JsonValue::Object mut file_group_json;

		// List sources directory and public include directories.
		// Doing so we ensure that each file within these directories will be treatet properly (with includes specified).
		{
			var JsonValue::Array mut directories_json;

			directories_json.push_back( NormalizePath( ust::concat( package_source_directory, "/", build_target.sources_directory ) ) );

			foreach( &directory : build_target.public_include_directories )
			{
				directories_json.push_back( NormalizePath( ust::concat( package_source_directory, "/", directory ) ) );
			}
			file_group_json.insert( "directories", move(directories_json) );
		}

		// TODO - add directories of generated files.

		auto mut includes=
			ExtractBuildTargetIncludeDirectories( workspace, build_system_paths, build_target_name, build_target );

		if( !build_target.source_files.empty() )
		{
			// Add also sources directory to list of includes.
			includes.push_back(
				ust::concat(
					NormalizePath( ust::concat( package_source_directory, "/", build_target.sources_directory ) ),
					g_include_dir_prefix_separator,
					build_target_name.name ) );
		}

		includes.push_back( build_system_paths.ustlib_path );

		if( !includes.empty() )
		{
			var JsonValue::Array mut includes_json;
			foreach( &inc : includes )
			{
				includes_json.push_back( inc );
			}
			file_group_json.insert( "includes", move(includes_json) );
		}

		// TODO - write directories of generated includes.

		json_root.push_back( move(file_group_json) );
	}
}

} // namespace BK
