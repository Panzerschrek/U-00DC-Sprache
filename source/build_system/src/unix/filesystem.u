import "/file.u"
import "/string_conversions.u"
import "../filesystem.uh"
import "../path.uh"
import "errno.uh"
import "unix.uh"


namespace BK
{

fn MakePathAbsolute( ust::string_view8 path ) : ust::string8
{
	if( !path.empty() && path.front() == "/"c8 )
	{
		return path;
	}

	return ust::concat( ust::get_current_directory(), "/", path );
}

fn EnsureDirectoryExists( Logger &mut logger, ust::string_view8 path ) : bool
{
	var ust::string8 path_absolute= MakePathAbsolute( path );

	// Optimistically assume that we need to create only one directory.
	if( EnsureSingleDirectoryExists( path_absolute ) )
	{
		return true;
	}

	// Failed to create it. Try to create all directories in given path.

	var ust::string8 mut path_iterative;
	foreach( &component : SplitPathIntoComponents( path_absolute ) )
	{
		path_iterative+= "/";
		path_iterative+= component;
		if( !EnsureSingleDirectoryExists( path_iterative ) )
		{
			logger.LogInfo( ust::concat( "Failed to create directory \"", path_iterative, "\": " ) );
			return false;
		}
	}

	return true;
}

fn EnsureSingleDirectoryExists( ust::string_view8 path_absolute ) : bool
{
	var ust::string8 mut path_null_terminated= path_absolute;
	path_null_terminated+= "\0";

	var i32 res= unsafe( ::mkdir( path_null_terminated.data(), 0o755u ) );
	if( res == 0 )
	{
		return true;
	}

	var i32 errno = GetErrno();
	if( errno == EEXIST )
	{
		// If given path already exists, check if it's a directory and not a file, symlink or something else.

		var stat_ mut s= zero_init;
		auto res= unsafe( ::lstat( path_null_terminated.data(), $<(s) ) );
		if( res == 0 && (s.st_mode & u32(S_IFMT)) == u32(S_IFDIR) )
		{
			return true;
		}
	}

	return false;
}

fn WriteFile( Logger &mut logger, ust::string_view8 path, ust::string_view8 contents ) : bool
{
	var ust::string8 mut path_null_terminated = path;
	path_null_terminated+= "\0";

	var i32 fd = unsafe( ::open( path_null_terminated.data(), O_WRONLY | O_CREAT | O_TRUNC, 0o755u ) );
	if( fd == -1 )
	{
		logger.LogError( ust::concat( "Failed to open file \"", path, "\" for writing, error: ", ust::to_string8( GetErrno() ) ) );
		return false;
	}

	// Perform writing in loop in order to handle cases where less than needed bytes were written.
	for( auto mut offset = 0s; offset < contents.size(); )
	{
		var ssize_type write_res = unsafe( ::write(
			fd,
			ust::ptr_cast_to_byte8( contents.data() ) + offset,
			contents.size() - offset ) );

		if( write_res < ssize_type(0) )
		{
			// Write failed.
			logger.LogError( ust::concat( "Failed to write to file \"", path, "\", error: ", ust::to_string8( GetErrno() ) ) );
			unsafe( ::close(fd) );
			return false;
		}

		offset+= size_type(write_res);
	}

	unsafe( ::close(fd) );

	return true;
}

fn CopyFile( Logger &mut logger, ust::string_view8 destination_path, ust::string_view8 source_path ) : bool
{
	var ust::string8 mut source_path_null_terminated = source_path;
	source_path_null_terminated+= "\0";

	var i32 fd_source = unsafe( ::open( source_path_null_terminated.data(), O_RDONLY, 0u ) );
	if( fd_source == -1 )
	{
		logger.LogError( ust::concat( "Failed to open file \"", source_path, "\" for reading, error: ", ust::to_string8( GetErrno() ) ) );
		return false;
	}

	auto source_file_size_opt= unsafe( GetFileSize( fd_source ) );
	if( source_file_size_opt.empty() )
	{
		logger.LogError( ust::concat( "Failed to get file size for \"", source_path, "\"." ) );
		unsafe( ::close(fd_source) );
		return false;
	}
	var u64 source_file_size= source_file_size_opt.try_deref();

	var ust::string8 mut destination_path_null_terminated = destination_path;
	destination_path_null_terminated+= "\0";

	var i32 fd_destination = unsafe( ::open( destination_path_null_terminated.data(), O_WRONLY | O_CREAT | O_TRUNC, 0o755u ) );
	if( fd_destination == -1 )
	{
		logger.LogError( ust::concat( "Failed to open file \"", destination_path, "\" for writing, error: ", ust::to_string8( GetErrno() ) ) );
		unsafe( ::close( fd_source ) );
		return false;
	}

	for( var off_t mut offset(0); offset < off_t(source_file_size); )
	{
		var ssize_type bytes_sent= unsafe( ::sendfile( fd_destination, fd_source, $<(offset), size_t( off_t(source_file_size) - offset ) ) );
		if( bytes_sent <= ssize_type(0) )
		{
			logger.LogError( ust::concat( "sendfile failed for destination \"", destination_path, "\" and source \"", source_path, "\", error: ", ust::to_string8( GetErrno() ) ) );
			unsafe( ::close( fd_source ) );
			unsafe( ::close( fd_destination ) );
			return false;
		}
	}

	unsafe( ::close( fd_source ) );
	unsafe( ::close( fd_destination ) );
	return true;
}

fn ReadFile( ust::string_view8 path ) : ust::optional</ust::string8/>
{
	var ust::string8 mut path_null_terminated = path;
	path_null_terminated+= "\0";

	var i32 fd = unsafe( ::open( path_null_terminated.data(), O_RDONLY, 0u ) );
	if( fd == -1 )
	{
		return ust::null_optional;
	}

	auto size_opt= unsafe( GetFileSize( fd ) );
	if( size_opt.empty() )
	{
		unsafe( ::close(fd) );
		return ust::null_optional;
	}

	var ust::string8 mut contents( size_type( size_opt.try_deref() ), "\0"c8 );

	// Perform reading in loop in order to handle cases where less than needed bytes were read.
	for( auto mut offset = 0s; offset < contents.size(); )
	{
		var ssize_type read_res = unsafe( ::read(
			fd,
			ust::ptr_cast_to_byte8( contents.data() ) + offset,
			contents.size() - offset ) );

		if( read_res < ssize_type(0) )
		{
			// Read filed.
			unsafe( ::close(fd) );
			return ust::null_optional;
		}

		offset+= size_type(read_res);
	}

	unsafe( ::close(fd) );

	return contents;
}

fn GetFileModificationTime( ust::string_view8 path ) : ust::optional</FileModificationTime/>
{
	var ust::string8 mut path_null_terminated = path;
	path_null_terminated+= "\0";

	var stat_ mut s= zero_init;
	auto res= unsafe( ::lstat( path_null_terminated.data(), $<(s) ) );
	if( res != 0 )
	{
		return ust::null_optional;
	}

	// Return nanoseconds.
	return u64( s.st_mtim.tv_sec ) * 1000000000u64 + u64( s.st_mtim.tv_nsec );
}

fn GetCurrentExecutablePath() : ust::string8
{
	auto mut link_path_nt= "/proc/self/exe\0";

	var ust::string8 mut res;
	res.resize( 256s, "\0"c8 );
	for( auto mut i= 0s; i < 8s; ++i )
	{
		auto len = unsafe( ::readlink( $<(link_path_nt[0]), res.data(), res.size() ) );
		if( len < ssize_type(0) )
		{
			return "";
		}
		if( size_type(len) >= res.size() )
		{
			// Possible truncation.
			auto new_size= res.size() * 2s;
			res.resize( new_size, "\0"c8 );
			continue;
		}

		res.resize( size_type(len), " "c8 );
		return res;
	}

	return "";
}

fn GetFileSize( i32 fd ) unsafe : ust::optional</u64/>
{
	var stat_ mut s= zero_init;
	auto res= unsafe( ::fstat( fd, $<(s) ) );
	if( res != 0 )
	{
		return ust::null_optional;
	}

	return u64(s.st_size);
}

} // namespace BK
