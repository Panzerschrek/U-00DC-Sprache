import "/file.u"
import "/file_helpers.u"
import "/string_conversions.u"
import "../filesystem.uh"
import "../path.uh"
import "errno.uh"
import "unix.uh"


namespace BK
{

fn MakePathAbsolute( ust::string_view8 path ) : ust::string8
{
	if( !path.empty() && path.front() == "/"c8 )
	{
		return path;
	}

	return ust::concat( ust::get_current_directory(), "/", path );
}

fn EnsureDirectoryExists( Logger &mut logger, ust::string_view8 path ) : bool
{
	var ust::string8 path_absolute= MakePathAbsolute( path );

	// Optimistically assume that we need to create only one directory.
	if( EnsureSingleDirectoryExists( path_absolute ) )
	{
		return true;
	}

	// Failed to create it. Try to create all directories in given path.

	var ust::string8 mut path_iterative;
	foreach( &component : SplitPathIntoComponents( path_absolute ) )
	{
		path_iterative+= "/";
		path_iterative+= component;
		if( !EnsureSingleDirectoryExists( path_iterative ) )
		{
			logger.LogInfo( ust::concat( "Failed to create directory \"", path_iterative, "\": " ) );
			return false;
		}
	}

	return true;
}

fn EnsureSingleDirectoryExists( ust::string_view8 path_absolute ) : bool
{
	return ust::create_directory( path_absolute ).is_ok();
}

fn WriteFile( Logger &mut logger, ust::string_view8 path, ust::string_view8 contents ) : bool
{
	result_match( ust::write_string_view_to_file( path, contents ) )
	{
		Ok(v) -> { ust::ignore_unused(v); return true; },
		Err(e) ->
		{
			logger.LogError( ust::concat( "Failed to write file \"", path, "\" error: ", ust::to_string8( u32(e) ) ) );
			return false;
		},
	}
}

fn CopyFile( Logger &mut logger, ust::string_view8 destination_path, ust::string_view8 source_path ) : bool
{
	// TODO - maybe also touch file modification timestamp?
	result_match( ust::copy_file( source_path, destination_path ) )
	{
		Ok(v) -> { ust::ignore_unused(v); return true; },
		Err(e) ->
		{
			logger.LogError( ust::concat( "Failed to copy file \"", source_path, "\" into \"", destination_path, "\", error: ", ust::to_string8( u32(e) ) ) );
			return false;
		},
	}
}

fn ReadFile( ust::string_view8 path ) : ust::optional</ust::string8/>
{
	result_match( ust::read_file_to_string( path ) )
	{
		Ok(s) -> { return s; },
		Err(e) -> { ust::ignore_unused(e); return ust::null_optional; },
	}
}

fn GetFileModificationTime( ust::string_view8 path ) : ust::optional</FileModificationTime/>
{
	result_match( ust::get_metadata_for_path( path ) )
	{
		Ok(v) -> { return v.modification_time; },
		Err(e) -> { ust::ignore_unused(e); return ust::null_optional; },
	}
}

fn GetCurrentExecutablePath() : ust::string8
{
	auto mut link_path_nt= "/proc/self/exe\0";

	var ust::string8 mut res;
	res.resize( 256s, "\0"c8 );
	for( auto mut i= 0s; i < 8s; ++i )
	{
		auto len = unsafe( ::readlink( $<(link_path_nt[0]), res.data(), res.size() ) );
		if( len < ssize_type(0) )
		{
			return "";
		}
		if( size_type(len) >= res.size() )
		{
			// Possible truncation.
			auto new_size= res.size() * 2s;
			res.resize( new_size, "\0"c8 );
			continue;
		}

		res.resize( size_type(len), " "c8 );
		return res;
	}

	return "";
}

} // namespace BK
