import "/assert.u"
import "/scoped_array.u"
import "/string_conversions.u"
import "/vector.u"
import "../process.uh"
import "errno.uh"
import "process.uh"

namespace BK
{

fn RunExecutable( Logger &mut logger, ust::string_view8 exe_path, ust::array_view_imut</ust::string_view8/> command_line ) : bool
{
	var ProcessGroupInterface::ProcessId useless_id(0);

	auto mut process_opt= Process::Run( logger, useless_id, exe_path, command_line );
	if( process_opt.empty() )
	{
		return false;
	}

	if_var( &out : process_opt.try_take().Finish( logger ) )
	{
		logger.LogInfo( out );
		return true;
	}
	else
	{
		return false;
	}
}

fn CreateProcessGroup( Logger &mut logger ) : ust::box_nullable</ProcessGroupInterface/>
{
	ust::ignore_unused(logger);
	return ust::make_box( ProcessGroup() );
}

class Process
{
public:
	// Run process.
	// Returns empty optional on error.
	fn Run(
		Logger &mut logger,
		ProcessGroupInterface::ProcessId id,
		ust::string_view8 exe_path,
		ust::array_view_imut</ust::string_view8/> command_line ) : ust::optional</Process/>
	{
		var [ i32, 2 ] mut pipe_fd= zero_init;
		if( unsafe( ::pipe( $<(pipe_fd[0]) ) ) != 0 )
		{
			logger.LogError( ust::concat( "pipe error: ", ust::to_string8( BKGetErrno() ) ) );
			return ust::null_optional;
		}
		var i32 pipe_read_end= pipe_fd[0];
		var i32 pipe_write_end= pipe_fd[1];

		var ust::string8 mut exe_path_null_terminated= ust::concat( exe_path, "\0" );

		var ust::vector</ust::string8/> mut args_null_terminated;
		args_null_terminated.push_back( exe_path_null_terminated );
		foreach( &arg : command_line )
		{
			args_null_terminated.push_back( ust::concat( arg, "\0" ) );
		}

		var ust::vector</$(char8)/> mut argv_vec;
		foreach( &mut arg_null_terminated : args_null_terminated )
		{
			argv_vec.push_back( unsafe( arg_null_terminated.data() ) );
		}
		argv_vec.push_back( ust::nullptr</char8/>() ); // This vector itself is null-terminated.

		var posix_spawn_file_actions_t mut file_actions= zero_init;
		if( unsafe( posix_spawn_file_actions_init( $<(file_actions ) ) ) != 0 )
		{
			logger.LogError( ust::concat( "posix_spawn_file_actions_init error: ", ust::to_string8( BKGetErrno() ) ) );
			unsafe( ::close( pipe_read_end ) );
			unsafe( ::close( pipe_write_end ) );
			return ust::null_optional;
		}

		// Close pipe read end in child process - it's unnecessary there.
		unsafe( ::posix_spawn_file_actions_addclose( $<(file_actions), pipe_read_end ) );
		// Redirect in child process stdin and stdout into the pipe.
		unsafe( ::posix_spawn_file_actions_adddup2( $<(file_actions), pipe_write_end, g_stdout_fd ) );
		unsafe( ::posix_spawn_file_actions_adddup2( $<(file_actions), pipe_write_end, g_stderr_fd ) );
		// Redirect stdin to /dev/null.
		auto mut dev_null_name_nt= "/dev/null\0";
		unsafe( ::posix_spawn_file_actions_addopen( $<(file_actions), g_stdin_fd, $<(dev_null_name_nt[0]), O_RDONLY, 0u ) );

		var posix_spawnattr_t mut spawn_attributes= zero_init;
		if( unsafe( ::posix_spawnattr_init( $<(spawn_attributes) ) ) != 0 )
		{
			logger.LogError( ust::concat( "posix_spawnattr_init error: ", ust::to_string8( BKGetErrno() ) ) );
			unsafe( ::posix_spawn_file_actions_destroy( $<(file_actions) ) );
			unsafe( ::close( pipe_read_end ) );
			unsafe( ::close( pipe_write_end ) );
			return ust::null_optional;
		}

		var pid_t mut pid= zero_init;

		auto spawn_res =
			unsafe( ::posix_spawn(
				$<(pid),
				exe_path_null_terminated.data(),
				$<(file_actions),
				$<(spawn_attributes),
				argv_vec.data(),
				BKGetEnvironment() ) );

		if( spawn_res != 0 )
		{
			logger.LogError( ust::concat( "posix_spawn error: ", ust::to_string8( BKGetErrno() ) ) );
			unsafe( ::posix_spawnattr_destroy( $<(spawn_attributes) ) );
			unsafe( ::posix_spawn_file_actions_destroy( $<(file_actions) ) );
			unsafe( ::close( pipe_read_end ) );
			unsafe( ::close( pipe_write_end ) );
			return ust::null_optional;
		}

		unsafe( ::posix_spawnattr_destroy( $<(spawn_attributes) ) );
		unsafe( ::posix_spawn_file_actions_destroy( $<(file_actions) ) );

		// Close pipe write end in parent process - it's unnecessary.
		unsafe( ::close( pipe_write_end ) );

		return unsafe( Process( id, pid, pipe_read_end ) );
	}

	fn constructor() = delete;

	// Constructor for internal usage.
	fn constructor( ProcessGroupInterface::ProcessId id, pid_t pid, i32 pipe_read_fd ) unsafe
		( id_= id, pid_= pid, pipe_read_fd_= pipe_read_fd, buf_= zero_init )
	{
		debug_assert( pid_ != -1 );
		debug_assert( pipe_read_fd_ != -1 );
	}

	fn destructor()
	{
		if( pipe_read_fd_ != -1 )
		{
			unsafe( ::close( pipe_read_fd_ ) );
		}
		if( pid_ != -1 )
		{
			var i32 mut status= 99999;
			auto wait_res= unsafe( ::waitpid( pid_, $<(status), 0 ) );
			// Can't return status from destructor.
			ust::ignore_unused( wait_res );
		}
	}

	// Finish this process, returning output if is fine.
	// May block if pipe is still opened.
	fn Finish( byval mut this, Logger &mut logger ) : ust::optional</ust::string8/>
	{
		// If pipe wasn't closed before - read until it isn't closed.
		while( IsPipeOpened() )
		{
			PipeRead();
		}

		var i32 mut status= 99999;
		auto wait_res= unsafe( ::waitpid( pid_, $<(status), 0 ) );
		if( wait_res != pid_ )
		{
			logger.LogError( ust::concat( "waitpid error: ", ust::to_string8( BKGetErrno() ) ) );
			pid_= -1;
			return ust::null_optional;
		}
		pid_= -1; // Reset pid in order to avoid calling waitpid in destructor again.

		return take(process_out_);
	}

	// Read a portion of data from the communication pipe.
	// May block if pipe isn't closed, but empty.
	fn PipeRead( mut this )
	{
		var ssize_type read_res= unsafe( ::read( pipe_read_fd_, $<( buf_[0] ), c_buf_size ) );
		if( read_res > ssize_type(0) )
		{
			// Append buffer contents to stdout.
			// TODO - limit internal buffer size, in case if a process produces too much output.
			for( auto mut i= 0s; i < size_type(read_res); ++i )
			{
				process_out_.push_back( char8( buf_[i] ) );
			}
		}
		else
		{
			// If can't read more - close the pipe.
			// Normalyl this happens only if process finishes and closes its pipe end.
			// TODO - handle read error.
			unsafe( ::close( pipe_read_fd_ ) );
			pipe_read_fd_= -1;
		}
	}

	// TODO - rename?
	fn IsPipeOpened( this ) : bool
	{
		return pipe_read_fd_ != -1;
	}

	// Get pipe file descriptor. User should not attempt to close it or read from it.
	fn GetPipeFD( this ) unsafe : i32
	{
		return pipe_read_fd_;
	}

	fn GetId( this ) : ProcessGroupInterface::ProcessId
	{
		return id_;
	}

private:
	auto c_buf_size= 1024s;

private:
	ProcessGroupInterface::ProcessId imut id_;
	pid_t pid_;
	i32 pipe_read_fd_;
	ust::string8 process_out_;
	[ byte8, c_buf_size ] buf_; // TODO - avoid storing this buffer inline.
}

class ProcessGroup final : ProcessGroupInterface
{
public: // ProcessGroupInterface
	fn virtual final RunProcess(
		mut this,
		Logger &mut logger,
		ProcessId process_id,
		ust::string_view8 exe_path,
		ust::array_view_imut</ust::string_view8/> command_line ) : bool
	{
		auto mut process_opt= Process::Run( logger, process_id, exe_path, command_line );
		if( process_opt.empty() )
		{
			return false;
		}

		running_processes_.push_back( process_opt.try_take() );

		return true;
	}

	fn virtual final DoWork( mut this, Logger &mut logger ) : bool
	{
		var pollfd zero_poll_fd= zero_init;

		scoped_array pollfd mut poll_fds[ running_processes_.size() ]( zero_poll_fd );

		for( auto mut i= 0s; i < running_processes_.size(); ++i )
		{
			var pollfd& mut poll_fd= poll_fds[i];
			poll_fd.fd= unsafe( running_processes_[i].GetPipeFD() );
			poll_fd.events= i16( POLLIN | POLLPRI );
			poll_fd.revents= i16(0);
		}

		// Wait until there is at least one pipe to read.
		auto ppoll_res=
			unsafe( ::ppoll(
				poll_fds.data(),
				nfds_t(poll_fds.size()),
				ust::nullptr</timespec/>(),
				ust::nullptr</ü__sigset_t/>() ) );
		if( ppoll_res < 0 )
		{
			logger.LogError( ust::concat( "ppoll error: ", ust::to_string8( BKGetErrno() ) ) );
			return false;
		}

		// Read from ready pipes.
		for( auto mut i= 0s; i < running_processes_.size(); ++i )
		{
			if( poll_fds[i].revents != i16(0) )
			{
				running_processes_[i].PipeRead();
			}
		}

		// Find finished processes and remove them from the list.
		for( auto mut i= 0s; i < running_processes_.size(); )
		{
			if( !running_processes_[i].IsPipeOpened() )
			{
				auto s= running_processes_.size();
				running_processes_.swap( i, s - 1s );
				var Process mut last= running_processes_.pop_back();
				var ProcessId id= last.GetId();
				if_var( &out : move(last).Finish( logger ) )
				{
					logger.LogInfo( out );
					finished_processes_.push_back( id );
				}
				else
				{
					return false;
				}
			}
			else
			{
				++i;
			}
		}

		return true;
	}

	fn virtual final TakeFinishedProcess( mut this ) : ust::optional</ProcessId/>
	{
		if( !finished_processes_.empty() )
		{
			return finished_processes_.pop_back();
		}
		return ust::null_optional;
	}

	fn virtual final GetNumberOfRunningProcesses( mut this ) : size_type
	{
		return running_processes_.size();
	}

private:
	ust::vector</Process/> running_processes_;
	ust::vector</ProcessId/> finished_processes_;
}

} // namespace BK

auto g_stdin_fd= 0;
auto g_stdout_fd= 1;
auto g_stderr_fd= 2;

fn nomangle pipe( $(i32) ü__pipedes ) unsafe : i32;

fn nomangle ppoll( $(pollfd) ü__fds, nfds_t ü__nfds, $(timespec) ü__timeout, $(ü__sigset_t) ü__ss ) unsafe : i32;

struct pollfd ordered
{
	i32 fd;
	i16 events;
	i16 revents;
}

type nfds_t = u64;

auto constexpr POLLIN = 1;
auto constexpr POLLPRI = 2;

// TODO - remove copypaste.
fn nomangle close( i32 fd ) unsafe : i32;
fn nomangle read( i32 fd, $(byte8) buf, size_type count ) unsafe : ssize_type;

auto constexpr O_RDONLY = 0o0;
