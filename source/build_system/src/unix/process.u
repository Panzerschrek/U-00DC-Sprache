import "/assert.u"
import "/string_conversions.u"
import "/vector.u"
import "../process.uh"
import "errno.uh"
import "process.uh"

namespace BK
{

fn RunExecutable( Logger &mut logger, ust::string_view8 exe_path, ust::array_view_imut</ust::string_view8/> command_line ) : bool
{
	auto mut process_opt= Process::Run( logger, exe_path, command_line );
	if( process_opt.empty() )
	{
		return false;
	}

	if_var( &out : process_opt.try_take().Finish( logger ) )
	{
		logger.LogInfo( out );
		return true;
	}
	else
	{
		return false;
	}
}

class Process
{
public:
	// Run process.
	// Returns empty optional on error.
	fn Run(
		Logger &mut logger,
		ust::string_view8 exe_path,
		ust::array_view_imut</ust::string_view8/> command_line ) : ust::optional</Process/>
	{
		var [ i32, 2 ] mut pipe_fd= zero_init;
		if( unsafe( ::pipe( $<(pipe_fd[0]) ) ) != 0 )
		{
			logger.LogError( ust::concat( "pipe error: ", ust::to_string8( BKGetErrno() ) ) );
			return ust::null_optional;
		}
		var i32 pipe_read_end= pipe_fd[0];
		var i32 pipe_write_end= pipe_fd[1];

		var ust::string8 mut exe_path_null_terminated= ust::concat( exe_path, "\0" );

		var ust::vector</ust::string8/> mut args_null_terminated;
		args_null_terminated.push_back( exe_path_null_terminated );
		foreach( &arg : command_line )
		{
			args_null_terminated.push_back( ust::concat( arg, "\0" ) );
		}

		var ust::vector</$(char8)/> mut argv_vec;
		foreach( &mut arg_null_terminated : args_null_terminated )
		{
			argv_vec.push_back( unsafe( arg_null_terminated.data() ) );
		}
		argv_vec.push_back( ust::nullptr</char8/>() ); // This vector itself is null-terminated.

		var posix_spawn_file_actions_t mut file_actions= zero_init;
		if( unsafe( posix_spawn_file_actions_init( $<(file_actions ) ) ) != 0 )
		{
			logger.LogError( ust::concat( "posix_spawn_file_actions_init error: ", ust::to_string8( BKGetErrno() ) ) );
			unsafe( ::close( pipe_read_end ) );
			unsafe( ::close( pipe_write_end ) );
			return ust::null_optional;
		}

		// Close pipe read end in child process - it's unnecessary there.
		unsafe( ::posix_spawn_file_actions_addclose( $<(file_actions), pipe_read_end ) );
		// Redirect in child process stdin and stdout into the pipe.
		unsafe( ::posix_spawn_file_actions_adddup2( $<(file_actions), pipe_write_end, g_stdout_fd ) );
		unsafe( ::posix_spawn_file_actions_adddup2( $<(file_actions), pipe_write_end, g_stderr_fd ) );
		// Redirect stdin to /dev/null.
		auto mut dev_null_name_nt= "/dev/null\0";
		unsafe( ::posix_spawn_file_actions_addopen( $<(file_actions), g_stdin_fd, $<(dev_null_name_nt[0]), O_RDONLY, 0u ) );

		var posix_spawnattr_t mut spawn_attributes= zero_init;
		if( unsafe( ::posix_spawnattr_init( $<(spawn_attributes) ) ) != 0 )
		{
			logger.LogError( ust::concat( "posix_spawnattr_init error: ", ust::to_string8( BKGetErrno() ) ) );
			unsafe( ::posix_spawn_file_actions_destroy( $<(file_actions) ) );
			unsafe( ::close( pipe_read_end ) );
			unsafe( ::close( pipe_write_end ) );
			return ust::null_optional;
		}

		var pid_t mut pid= zero_init;

		auto spawn_res =
			unsafe( ::posix_spawn(
				$<(pid),
				exe_path_null_terminated.data(),
				$<(file_actions),
				$<(spawn_attributes),
				argv_vec.data(),
				BKGetEnvironment() ) );

		if( spawn_res != 0 )
		{
			logger.LogError( ust::concat( "posix_spawn error: ", ust::to_string8( BKGetErrno() ) ) );
			unsafe( ::posix_spawnattr_destroy( $<(spawn_attributes) ) );
			unsafe( ::posix_spawn_file_actions_destroy( $<(file_actions) ) );
			unsafe( ::close( pipe_read_end ) );
			unsafe( ::close( pipe_write_end ) );
			return ust::null_optional;
		}

		unsafe( ::posix_spawnattr_destroy( $<(spawn_attributes) ) );
		unsafe( ::posix_spawn_file_actions_destroy( $<(file_actions) ) );

		// Close pipe write end in parent process - it's unnecessary.
		unsafe( ::close( pipe_write_end ) );

		return unsafe( Process( pid, pipe_read_end ) );
	}

	fn constructor() = delete;

	// Constructor for internal usage.
	fn constructor( pid_t pid, i32 pipe_read_fd ) unsafe
		( pid_(pid), pipe_read_fd_(pipe_read_fd), buf_= zero_init )
	{
		debug_assert( pid_ != -1 );
		debug_assert( pipe_read_fd_ != -1 );
	}

	fn destructor()
	{
		if( pipe_read_fd_ != -1 )
		{
			unsafe( ::close( pipe_read_fd_ ) );
		}
		if( pid_ != -1 )
		{
			var i32 mut status= 99999;
			auto wait_res= unsafe( ::waitpid( pid_, $<(status), 0 ) );
			// Can't return status from destructor.
			ust::ignore_unused( wait_res );
		}
	}

	// Finish this process, returning output if is fine.
	// May block if pipe is still opened.
	fn Finish( byval mut this, Logger &mut logger ) : ust::optional</ust::string8/>
	{
		// If pipe wasn't closed before - read until it isn't closed.
		while( IsPipeOpened() )
		{
			PipeRead();
		}

		var i32 mut status= 99999;
		auto wait_res= unsafe( ::waitpid( pid_, $<(status), 0 ) );
		if( wait_res != pid_ )
		{
			logger.LogError( ust::concat( "waitpid error: ", ust::to_string8( BKGetErrno() ) ) );
			pid_= -1;
			return ust::null_optional;
		}
		pid_= -1; // Reset pid in order to avoid calling waitpid in destructor again.

		return take(process_out_);
	}

	// Read a portion of data from the communication pipe.
	// May block if pipe isn't closed, but empty.
	fn PipeRead( mut this )
	{
		var ssize_type read_res= unsafe( ::read( pipe_read_fd_, $<( buf_[0] ), c_buf_size ) );
		if( read_res > ssize_type(0) )
		{
			// Append buffer contents to stdout.
			// TODO - limit internal buffer size, in case if a process produces too much output.
			for( auto mut i= 0s; i < size_type(read_res); ++i )
			{
				process_out_.push_back( char8( buf_[i] ) );
			}
		}
		else
		{
			// If can't read more - close the pipe.
			// Normalyl this happens only if process finishes and closes its pipe end.
			// TODO - handle read error.
			unsafe( ::close( pipe_read_fd_ ) );
			pipe_read_fd_= -1;
		}
	}

	fn IsPipeOpened( this ) : bool
	{
		return pipe_read_fd_ != -1;
	}

private:
	auto c_buf_size= 1024s;

private:
	pid_t pid_;
	i32 pipe_read_fd_;
	ust::string8 process_out_;
	[ byte8, c_buf_size ] buf_;
}

} // namespace BK

auto g_stdin_fd= 0;
auto g_stdout_fd= 1;
auto g_stderr_fd= 2;

fn nomangle pipe( $(i32) Ã¼__pipedes ) unsafe : i32;

// TODO - remove copypaste.
fn nomangle close( i32 fd ) unsafe : i32;
fn nomangle read( i32 fd, $(byte8) buf, size_type count ) unsafe : ssize_type;

auto constexpr O_RDONLY = 0o0;
