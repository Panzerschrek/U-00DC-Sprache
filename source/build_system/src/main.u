import "/sort.u"
import "/string_conversions.u"
import "/stdout.u"
import "../imports/build_system_interface.uh"
import "build_graph_serialization.uh"
import "build_system_paths.uh"
import "configuration_options.uh"
import "entry.uh"
import "filesystem.uh"
import "include_directories.uh"
import "init_command.uh"
import "language_server_workspace_info.uh"
import "make_dep_file.uh"
import "options.uh"
import "package_transformation.uh"
import "path.uh"
import "process.uh"
import "proc.uh"
import "shared_library.uh"
import "string_utils.uh"
import "target_triple.uh"
import "version_unification.uh"

namespace BK
{

// Place actual "main" code inside the "BK" namespace.
fn Main( ust::string_view8 exe_path, ust::array_view_imut</ust::string_view8/> args ) : i32
{
	var ust::optional</Options/> options_opt= ParseOptions( args );
	if( options_opt.empty() )
	{
		ust::stderr_print( "Failed to parse options.\n" );
		return -1;
	}

	var Options& options= options_opt.try_deref();

	if( options.command == Options::Command::Help || options.help )
	{
		ust::stdout_print( GetHelpMessage() );
		return 0;
	}

	var Logger mut logger(
		( options.verbose
			? Logger::Level::Verbose
			: ( options.quiet ? Logger::Level::Quiet : Logger::Level::Normal ) ) );

	logger.LogInfo( "Bürokratie - the Ü build system!" );

	if( options.command == Options::Command::Init )
	{
		auto project_directory= NormalizePath( MakePathAbsolute( options.root_package_directory ) );
		return ( InitProjectStub( logger, project_directory ) ? 0 : 1 );
	}

	var TargetTriple host_target_triple= GetHostTargetTriple();

	var TargetTriple mut target_triple;
	if( !options.target_triple.empty() )
	{
		auto mut target_triple_opt= ParseTargetTriple( options.target_triple );
		if( target_triple_opt.empty() )
		{
			logger.LogError( "Failed to parse target triple!\n" );
			return -1;
		}
		target_triple= target_triple_opt.try_take();
	}
	else
	{
		// By default build for the host target triple.
		target_triple= host_target_triple;
	}

	var ConfigurationOptions mut configuration_options;
	if( !options.configuration_options_file.empty() )
	{
		auto mut configuration_options_opt= LoadConfigurationOptions( logger, options.configuration_options_file );
		if( configuration_options_opt.empty() )
		{
			ust::stderr_print( "Failed to load configuration options!\n" );
			return -1;
		}
		configuration_options= configuration_options_opt.try_take();
	}

	var ust::string8 exe_directory = MakePathAbsolute( GetParentPath( exe_path ) );

	logger.LogVerbose( ust::concat( "Build system executable directory path: \"", exe_directory, "\"" ) );

	var BuildSystemPaths mut build_system_paths
	{
		.compiler_executable_path= NormalizePath(
			( options.compiler_executable_path.empty()
				? ( exe_directory + "/Compiler1" ) // For now use "Compiler1" as compiler default. TODO - allow to tune it.
				: MakePathAbsolute(options.compiler_executable_path) ) ),
		.ustlib_path= NormalizePath(
			( options.ustlib_path.empty()
				? ( exe_directory + "/../ustlib" ) // "ustlib" is located in the root of the Ü package.
				: MakePathAbsolute(options.ustlib_path) ) ),
		.build_system_imports_path= NormalizePath(
			( options.build_system_imports_path.empty()
				? ( exe_directory + "/../build_system/imports" ) // Build system imports are located in "/build_system/imports".
				: MakePathAbsolute(options.build_system_imports_path) ) ),
		.packages_repository_directory=
			NormalizePath(
				MakePathAbsolute(
					( options.packages_repository_directory.empty()
						? options.root_package_directory
						: options.packages_repository_directory ) ) ),
		// If "options.root_package_directory" is empty this will become current directory.
		.root_package_source_directory= NormalizePath( MakePathAbsolute( options.root_package_directory ) ),
	};

	// By default use "build" directory within root package directory.
	var ust::string8 root_package_build_directory_base =
		( options.build_directory.empty()
			? ( build_system_paths.root_package_source_directory + "/build" )
			: NormalizePath( MakePathAbsolute( options.build_directory ) ) );

	// Create, if necessary, subdirectory for target triple.
	// Do it only if this target triple isn't equal to host triple.
	var ust::string8 mut root_package_build_directory = root_package_build_directory_base;
	if( target_triple != GetHostTargetTriple() )
	{
		root_package_build_directory+= "/";
		root_package_build_directory+= TargetTripleToString( target_triple );
	}

	// Create a subdirectory for configuration specified.
	root_package_build_directory+= "/";
	root_package_build_directory+= BuildConfigurationToString( options.build_configuration );

	if( !EnsureDirectoryExists( logger, root_package_build_directory ) )
	{
		logger.LogError( "Can't create build directory." );
		return -1;
	}

	logger.LogVerbose( ust::concat( "Build project in \"", build_system_paths.root_package_source_directory, "\" using build directory \"", root_package_build_directory, "\"" ) );

	// Build host packages within directory of target system/build configuration.
	// Technically it may be possible to share host packages build across different target systems, but for now don't do this to avoid possible mistakes.
	//
	// Also we create this directory and perform proper building of host system worspace,
	// even if host target triple is equal to target triple of the target system.
	// There are some reasons to do this.
	// First, it's necessary in order to prevent possible mistakes in packages wrongly assuming host=target.
	// We prevent writing such packages by forcing target/host workspaces separation.
	// Second, compilation options may be incompatible - we may want to build for targets with SSE4 (for example),
	// on a host with no SSE4 support. In such case we need two separate build trees with two different set of compilation options.
	var ust::string8 host_packages_root_build_directory =
		ust::concat(
			root_package_build_directory,
			"/",
			"host.build" /* use name with dots in order to avoid name conflicts */ );

	var BuildSystemInterfaceImplementation mut bsi(
		move(logger),
		options.build_configuration,
		move(configuration_options),
		move(build_system_paths) );

	var PackagesMap mut target_packages_map, mut host_packages_map;

	var ust::vector</PackageAbsoluteName/> mut target_packages_queue, mut host_packages_queue;

	// Push root package.
	target_packages_queue.push_back( PackageAbsoluteName{ .name_base= PackageAbsoluteName::RootPackage{}, .path= "" } );

	// Process target packages queue.
	bsi.SetTargetTriple( target_triple );
	bsi.SetRootPackageBuildDirectory( root_package_build_directory );
	// Use index-based iterations, because this list is populated within the loop.
	for( auto mut i= 0s; i < target_packages_queue.size(); ++i )
	{
		var PackageAbsoluteName package_name= target_packages_queue[i];
		if( target_packages_map.exists( package_name ) )
		{
			continue; // Already loaded this package.
		}

		// Tweak build system interface for current package.
		bsi.SetCurrentPackageName( package_name );

		var ust::optional</PackageInfo/> mut package_info_opt=
			ObtainPackageInfo(
				bsi,
				options.host_sysroot,
				package_name,
				// Output build script into base build directory, ignoring build configuration and target triple.
				// Doing so we allow reusing build script for different configuration and target systems.
				root_package_build_directory_base );

		if( package_info_opt.empty() )
		{
			return -1;
		}

		// Add dependencies to the queue.
		foreach( &dependency : package_info_opt.try_deref().package_dependencies )
		{
			auto mut dependency_package_absolute_name=
				ResolvePackageAbsoluteName( bsi.logger_, package_name, dependency.name );
			if( dependency_package_absolute_name.empty() )
			{
				bsi.logger_.LogError( ust::concat( "Failed to find package dependency within package \"", package_name.path, "\"!" ) );
				return -1;
			}
			switch( dependency.required_system )
			{
				PackageDependency::RequiredSystem::Target ->
				{
					target_packages_queue.push_back( dependency_package_absolute_name.try_take() );
				},
				PackageDependency::RequiredSystem::Host ->
				{
					host_packages_queue.push_back( dependency_package_absolute_name.try_take() );
				},
				PackageDependency::RequiredSystem::Both ->
				{
					target_packages_queue.push_back( dependency_package_absolute_name.try_deref() );
					host_packages_queue.push_back( dependency_package_absolute_name.try_take() );
				},
			}
		}

		target_packages_map.insert( package_name, package_info_opt.try_take() );
	}

	// Process host packages queue.
	bsi.SetTargetTriple( host_target_triple );
	bsi.SetRootPackageBuildDirectory( host_packages_root_build_directory );
	// Use index-based iterations, because this list is populated within the loop.
	for( auto mut i= 0s; i < host_packages_queue.size(); ++i )
	{
		var PackageAbsoluteName package_name= host_packages_queue[i];
		if( host_packages_map.exists( package_name ) )
		{
			continue; // Already loaded this package.
		}
		// Tweak build system interface for current package.
		bsi.SetCurrentPackageName( package_name );

		var ust::optional</PackageInfo/> mut package_info_opt=
			ObtainPackageInfo(
				bsi,
				options.host_sysroot,
				package_name,
				// Use same base path for build scripts of host and target system packages.
				// Doing so we allow reusing build scripts for packages which are compiled both for host and target systems.
				root_package_build_directory_base );

		if( package_info_opt.empty() )
		{
			return -1;
		}

		// Add dependencies to the queue.
		foreach( &dependency : package_info_opt.try_deref().package_dependencies )
		{
			auto mut dependency_package_absolute_name=
				ResolvePackageAbsoluteName( bsi.logger_, package_name, dependency.name );
			if( dependency_package_absolute_name.empty() )
			{
				bsi.logger_.LogError( ust::concat( "Failed to find package dependency within package \"", package_name.path, "\"!" ) );
				return -1;
			}
			// All dependencies of host packages are host packages.
			host_packages_queue.push_back( dependency_package_absolute_name.try_take() );
		}

		host_packages_map.insert( package_name, package_info_opt.try_take() );
	}

	auto target_workspace_opt= CreateWorkspace( bsi.logger_, target_packages_map, root_package_build_directory );
	if( target_workspace_opt.empty() )
	{
		return -1;
	}
	var WorkspaceInfo& target_workspace= target_workspace_opt.try_deref();

	auto host_workspace_opt= CreateWorkspace( bsi.logger_, host_packages_map, host_packages_root_build_directory );
	if( host_workspace_opt.empty() )
	{
		return -1;
	}
	var WorkspaceInfo& host_workspace= host_workspace_opt.try_deref();

	// Check if build target names used in custom build steps of target workspace are present in host workspace.
	// Perform the same check for host workspace too.
	if( !CheckHostSystemBuildTargetsArePresent( bsi.logger_, target_workspace, host_workspace ) ||
		!CheckHostSystemBuildTargetsArePresent( bsi.logger_, host_workspace, host_workspace ) )
	{
		return -1;
	}

	if( !CreateWorkspaceBuildDirectories( bsi.logger_, target_workspace, root_package_build_directory ) ||
		!CreateWorkspaceBuildDirectories( bsi.logger_, host_workspace, host_packages_root_build_directory ) )
	{
		return -1;
	}

	// Write a helper file to be used by Ü language server.
	// Do not fail the build if failed to write it.
	WriteLanguageServerWorkspaceInfoFile(
		bsi.logger_,
		bsi.build_system_paths_,
		target_workspace,
		root_package_build_directory,
		host_workspace,
		host_packages_root_build_directory );

	var ust::string8 build_graph_state_file_path= root_package_build_directory + "/build_graph.json";

	// Load previous build graph state.
	var ust::optional</BuildGraph/> mut prev_build_graph;
	if_var( &prev_build_graph_file : ReadFile( build_graph_state_file_path ) )
	{
		prev_build_graph= DeserializeBuildGraph( prev_build_graph_file );
		if( prev_build_graph.empty() )
		{
			bsi.logger_.LogError( "Failed to deserialize previous build graph state" );
		}
	}
	else
	{
		bsi.logger_.LogInfo( "Can't load previous build graph state" );
	}

	// Construct the build graph for the whole project.
	var BuildGraph mut build_graph;

	CreateWorkspaceBuildTargetsGraphNodes(
		bsi.build_system_paths_,
		options.sysroot,
		root_package_build_directory,
		bsi.build_configuration_,
		target_triple,
		target_workspace,
		build_graph );

	// Custom build steps list should have stable order, since it's populated previously in packages stable order.
	foreach( &custom_build_step : target_workspace.custom_build_steps )
	{
		CreateCustomBuildStepBuildGraphNodes( host_target_triple, host_packages_root_build_directory, custom_build_step, build_graph );
	}

	CreateWorkspaceBuildTargetsGraphNodes(
		bsi.build_system_paths_,
		options.host_sysroot,
		host_packages_root_build_directory,
		bsi.build_configuration_,
		host_target_triple,
		host_workspace,
		build_graph );

	// Custom build steps list should have stable order, since it's populated previously in packages stable order.
	foreach( &custom_build_step : host_workspace.custom_build_steps )
	{
		CreateCustomBuildStepBuildGraphNodes( host_target_triple, host_packages_root_build_directory, custom_build_step, build_graph );
	}

	var i32 mut main_result= 0;

	var u32 max_number_of_parallel_jobs=
		ust::max( 1u, ust::min( ( options.number_of_jobs == 0u ? GetNumberOfCPUs() : options.number_of_jobs ), 128u ) );
	bsi.LogVerbose( ust::concat( "Building using ", ust::to_string8(max_number_of_parallel_jobs), " threads." ) );

	// This executes the build.
	if( !PerformGraphBuild( bsi.logger_, build_graph, prev_build_graph.as_ref(), max_number_of_parallel_jobs ) )
	{
		bsi.logger_.LogError( "Build failed." );
		main_result= -1;
		// Do not return here, save build graph in case of build fail to reuse parts which were susscessfully built.
	}
	else
	{
		bsi.logger_.LogInfo( "Successfully finished the build!" );
	}

	if( prev_build_graph.empty() || prev_build_graph.try_deref() != build_graph )
	{
		// If build graph on disk is equal to what we have now, avoid re-writing it.

		bsi.logger_.LogVerbose( "Build graph seems to be updated. Rewrite it." );

		// TODO - maybe fail the build if failed to serialize the build graph?
		WriteFile(
			bsi.logger_,
			build_graph_state_file_path,
			SerializeBuildGraph( build_graph ) );
	}
	else
	{
		bsi.logger_.LogVerbose( "Skip updating on-disk build graph state." );
	}

	return main_result;
}

fn ObtainPackageInfo(
	BuildSystemInterfaceImplementation &mut bsi,
	ust::string_view8 host_sysroot,
	PackageAbsoluteName& package_name,
	ust::string_view8 packages_build_directory ) : ust::optional</PackageInfo/>
{
	// TODO - customize it based on package name?
	auto constexpr entry_func_name = "GetPackageInfoImpl";

	auto shared_library_opt = BuildAndLoadPackageBuildScript(
		bsi.logger_,
		bsi.build_system_paths_,
		host_sysroot,
		GetPackageSourceDirectory( bsi.build_system_paths_, package_name ),
		GetPackageBuildDirectory( packages_build_directory, package_name ),
		entry_func_name );
	if( shared_library_opt.empty() )
	{
		bsi.logger_.LogError( "Failed to load/build the build script shared library." );
		return ust::null_optional;
	}

	auto mut func_raw_ptr= shared_library_opt.try_deref().LoadSymbol( bsi.logger_, entry_func_name );

	// This must match what build sctipt file wrapper produces!
	type GetPackageInfoFunctionType = fn( BuildSystemInterface &mut build_system_interface ) : ust::optional</PackageInfo/>;

	// A hacky way to cast byte8 pointer to a function pointer.
	var GetPackageInfoFunctionType mut func_ptr= zero_init;
	unsafe( ust::memory_copy(
		ust::ptr_cast_to_byte8( $<(func_ptr) ),
		ust::ptr_cast_to_byte8( $<(func_raw_ptr) ),
		typeinfo</ typeof(func_ptr) />.size_of ) );

	if( ust::is_nullptr(func_ptr) )
	{
		bsi.logger_.LogError( "Failed to load function " + entry_func_name );
		return ust::null_optional;
	}

	// Obtain package info by calling a shared library function.
	var ust::optional</PackageInfo/> mut package_info_opt= func_ptr( bsi );
	if( package_info_opt.empty() )
	{
		bsi.logger_.LogError( ust::concat( "Failed to get package info for package \"", package_name.path, "\"- build script returned empty optional." ) );
		return ust::null_optional;
	}
	return package_info_opt;
}

fn BuildAndLoadPackageBuildScript(
	Logger &mut logger,
	BuildSystemPaths& build_system_paths,
	ust::string_view8 host_sysroot,
	ust::string_view8 package_source_directory,
	ust::string_view8 package_build_directory,
	ust::string_view8 entry_func_name ) : ust::optional</SharedLibrary/>
{
	// TODO - select more catchy name for root build script file.
	auto constexpr build_script_file= "build.u";

	var ust::string8 build_script_file_full_path= ust::concat(package_source_directory, "/", build_script_file );

	// TODO - do we need to have this check here?
	if( GetFileModificationTime( build_script_file_full_path ).empty() )
	{
		logger.LogError( ust::concat( "Can not get modification time for \"", build_script_file_full_path, "\" - file does not exist?" ) );
		return ust::null_optional;
	}

	var ust::string8 result_shared_library_path= ust::concat( package_build_directory, "/build.", GetNativeSharedLibraryExtension() );

	var ust::string8 result_shared_library_dependency_file_path = GetDependencyFilePath( result_shared_library_path );

	// TODO - check also if compilation options were changed (including import directories).
	if( CheckRebuildIsNeededBasedOnDepFile( logger, result_shared_library_dependency_file_path ) )
	{
		logger.LogVerbose( ust::concat( "Building \"", result_shared_library_path, "\"." ) );

		var ust::string8 build_script_wrapper_file_directory= ust::concat( package_build_directory, "/build_script_wrapper_sources" );
		if( ! EnsureDirectoryExists( logger, build_script_wrapper_file_directory ) )
		{
			return ust::null_optional;
		}

		var ust::string8 build_script_wrapper_header_file_directory= ust::concat( package_build_directory, "/build_script_wrapper_headers" );
		if( ! EnsureDirectoryExists( logger, build_script_wrapper_header_file_directory ) )
		{
			return ust::null_optional;
		}

		var ust::string8 build_script_wrapper_file_path= ust::concat( build_script_wrapper_file_directory, "/", "build_script_wrapper.u" );
		var ust::string8 build_script_header_file_path= ust::concat( build_script_wrapper_header_file_directory, "/", "build_script_header.uh" );

		// Create our own wrapper file to ensure that the function exported from the shared library has proper type.
		{
			var ust::string8 contents = ust::concat(
				"import \"/",
				build_script_file,
				"\"\n",
				"import \"/build_script_header.uh\"\n\n",
				"fn nomangle ",
				entry_func_name,
				"( BK::BuildSystemInterface &mut build_system_interface ) : ust::optional</BK::PackageInfo/>\n",
				// "GetPackageInfo" function itself may return "BK::PackageInfo", not optional of this type.
				"{\n\treturn GetPackageInfo( build_system_interface );\n}\n" );

			if( !WriteFile( logger, build_script_wrapper_file_path, contents ) )
			{
				logger.LogError( "Can't write build script wrapper file." );
				return ust::null_optional;
			}
		}

		// Create also header file. We need it to export entry function properly.
		{
			var ust::string8 contents = ust::concat(
				"import \"/build_system.uh\"\n\n",
				"fn nomangle ",
				entry_func_name,
				"( BK::BuildSystemInterface &mut build_system_interface ) : ust::optional</BK::PackageInfo/>;\n" );

			if( !WriteFile( logger, build_script_header_file_path, contents ) )
			{
				logger.LogError( "Can't write build script wrapper header file." );
				return ust::null_optional;
			}
		}


		var ust::vector</ust::string8/> mut compiler_args;

		// Use host sysroot for building build script shared library for host system.
		if( !host_sysroot.empty() )
		{
			compiler_args.push_back( "--sysroot" );
			compiler_args.push_back( host_sysroot );
		}

		// Add path to the package directory in order to import "build.u" inside the wrapper.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( package_source_directory );
		// Provide standard library imports.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( build_system_paths.ustlib_path );
		// Provide path to declarations of the build system interface.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( build_system_paths.build_system_imports_path );
		// Provide path to build script wrapper headers.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( build_script_wrapper_header_file_directory );

		compiler_args.push_back( build_script_wrapper_file_path );  // The file to buld.

		// Output.
		compiler_args.push_back( "-o" );
		compiler_args.push_back( result_shared_library_path );

		// Produce also a dependency file.
		compiler_args.push_back( "-MF" );
		compiler_args.push_back( result_shared_library_dependency_file_path );

		// Provide path to the directory with input file, in order to allow importing it.
		compiler_args.push_back( "--source-dir" );
		compiler_args.push_back( build_script_wrapper_file_directory );

		// Forbid importing anything outside include directories and source directories.
		compiler_args.push_back( "--prevent-imports-outside-given-directories" );

		// This requires compiler to be built with internal LLD (for now we don't support external linkers).
		compiler_args.push_back( "-filetype=dll" );
		// Run internalization in order to export only entry function.
		compiler_args.push_back( "--internalize" );
		compiler_args.push_back( ust::concat( "--internalize-preserve=", entry_func_name ) );

		// Use optimization level which was used to compile the build system executable.
		compiler_args.push_back( ust::concat( "-O", ust::single_element_array_view( compiler::options::optimization_level ) ) );

		// If the build system executable was compiled with debug information - generate it for the shared library too.
		if( compiler::options::generate_debug_info )
		{
			compiler_args.push_back( "-g" );
		}

		// Use the same target parameters for the shared library as for the build system executable.

		compiler_args.push_back( "--target-arch" );
		compiler_args.push_back( compiler::target::arch );

		compiler_args.push_back( "--target-vendor" );
		compiler_args.push_back( compiler::target::vendor );

		compiler_args.push_back( "--target-os" );
		compiler_args.push_back( compiler::target::os );

		compiler_args.push_back( "--target-environment" );
		compiler_args.push_back( compiler::target::environment );

		if( ust::string_view8( compiler::target::os ) != "windows" )
		{
			// It seems that position-independent code is always enabled on systems except Windows.
			// So, use this option for building the shared library.
			compiler_args.push_back( "--relocation-model" );
			compiler_args.push_back( "pic" );
		}

		if( ust::string_view8( compiler::target::os ) != "windows" ||
			ust::string_view8( compiler::target::environment ) == "gnu" )
		{
			// Put symbols into sections and remove unnecessary ones.
			compiler_args.push_back( "--function-sections" );
			compiler_args.push_back( "--data-sections" );
			compiler_args.push_back( "-Wl,--gc-sections" );
		}

		if( ust::string_view8( compiler::target::environment ) == "msvc" )
		{
			// Do not generate ".lib" file - it's unnecessary, since we load the DLL dynamically.
			compiler_args.push_back( "-Wl,/NOIMPLIB" );
		}

		// Perform verification just to be sure nothing is broken.
		compiler_args.push_back( "--verify-module" );

		if( !RunExecutable( logger, build_system_paths.compiler_executable_path, compiler_args ) )
		{
			logger.LogError( "Compiler execution failed." );
			return ust::null_optional;
		}
	}
	else
	{
		logger.LogVerbose( ust::concat( "Skip building \"", result_shared_library_path,  "\"." ) );
	}

	logger.LogVerbose( ust::concat( "Loading \"", result_shared_library_path, "\"" ) );

	auto shared_library_opt = LoadSharedLibrary( logger, result_shared_library_path );
	if( shared_library_opt.empty() )
	{
		logger.LogError( "Failed to load build script shared library." );
		return ust::null_optional;
	}

	return shared_library_opt;
}

fn CheckRebuildIsNeededBasedOnDepFile( Logger &mut logger, ust::string_view8 dep_file_path ) : bool
{
	var ust::optional</ust::string8/> file_contents= ReadFile( dep_file_path );
	if( file_contents.empty() )
	{
		// Dep file is not created yet.
		logger.LogVerbose( ust::concat( "No dependency file \"", dep_file_path, "\" - perform the build." ) );
		return true;
	}

	var ust::optional</MakeDepFile/> dep_file_opt= ParseMakeDepFileContents( file_contents.try_deref() );
	if( dep_file_opt.empty() )
	{
		logger.LogError( ust::concat( "Failed to parse dep file \"", dep_file_path, "\"" ) );
		return true;
	}

	var MakeDepFile& dep_file= dep_file_opt.try_deref();

	var ust::optional</FileModificationTime/> dst_modification_time_opt= GetFileModificationTime( dep_file.destination );
	if( dst_modification_time_opt.empty() )
	{
		// Destination deosn't exist.
		logger.LogVerbose( ust::concat( "No destination file \"", dep_file.destination, "\" - perform the build." ) );
		return true;
	}

	auto dst_modification_time = dst_modification_time_opt.try_deref();

	foreach( &dependency : dep_file.dependencies )
	{
		var ust::optional</FileModificationTime/> src_modification_time_opt= GetFileModificationTime( dependency );
		if( src_modification_time_opt.empty() )
		{
			// This source file is missing.
			// In some cases it's ok, like if an imported file was deleted together with deletion of the corresponding "import" directive.
			logger.LogVerbose( ust::concat( "No source file \"", dependency, "\" - perform the build." ) );
			return true;
		}
		if( src_modification_time_opt.try_deref() >= dst_modification_time )
		{
			logger.LogVerbose( ust::concat( "Source file \"", dependency, "\" is newer than the destination - perform the build." ) );
			return true;
		}
	}

	// Rebuild is not required if we reached this point.
	logger.LogVerbose( ust::concat( "No rebuild is required for dependency of the dep file \"", dep_file_path, "\"." ) );
	return false;
}

fn GetNativeSharedLibraryExtension() : ust::string_view8
{
	return( ust::string_view8( compiler::target::os ) == "windows" ? ust::string_view8("dll") : ust::string_view8("so") );
}

fn GetDependencyFilePath( ust::string_view8 path ) : ust::string8
{
	return ust::concat( path, ".d" );
}

type PackagesMap= ust::unordered_map</PackageAbsoluteName, PackageInfo/>;

// Returns empty optional on error.
fn CreateWorkspace(
	Logger &mut logger,
	PackagesMap& packages_map,
	ust::string_view8 root_package_build_directory ) : ust::optional</WorkspaceInfo/>
{
	// Collect and sort a list of package names,
	// then iterate in this sorted order - to avoid processing packages in non-deterministic hashtable order.
	var ust::vector</PackageAbsoluteName/> mut package_names;
	foreach( &pair : packages_map )
	{
		package_names.push_back( pair.key() );
	}
	ust::sort( package_names );

	var WorkspaceInfo mut workspace;

	var bool mut has_package_transformation_errors= false;
	foreach( &package_name : package_names )
	{
		if( !TransformAndValidatePackageInfo( logger, packages_map[ package_name ], package_name, workspace ) )
		{
			logger.LogError( ust::concat( "Package \"", package_name.path, "\" is invald." ) );
			has_package_transformation_errors= true;
		}
	}

	if( has_package_transformation_errors )
	{
		return ust::null_optional;
	}

	if( !CheckWorkspaceDependencyGraphIsValid( logger, workspace ) ||
		!CheckWorkspaceCustomBuildStepsAreValid( logger, workspace, root_package_build_directory ) ||
		!UnifyDependenciesOnGlobalVersionedPackages( logger, workspace ) ||
		!RetrieveAndCheckWorkspaceTransitiveDependencies( logger, workspace ) )
	{
		logger.LogError( "Project dependencies aren't valid!" );
		return ust::null_optional;
	}

	return workspace;
}

// returns true on success.
fn CreateWorkspaceBuildDirectories(
	Logger &mut logger, WorkspaceInfo& workspace, ust::string_view8 root_package_build_directory ) : bool
{
	// Create directories for generated sources, if necessary.
	foreach( &target_pair : workspace.build_targets )
	{
		auto& build_target_name= target_pair.key();
		auto& build_target= target_pair.value();
		if( !build_target.generated_source_files.empty() || !build_target.generated_private_header_files.empty() )
		{
			if( !EnsureDirectoryExists( logger, GetBuildTargetGeneratedSourcesDirectory( root_package_build_directory, build_target_name ) ) )
			{
				return false;
			}
		}
	}

	return true;
}

fn CreateWorkspaceBuildTargetsGraphNodes(
	BuildSystemPaths& build_system_paths,
	ust::string_view8 sysroot,
	ust::string_view8 root_package_build_directory,
	BuildConfiguration build_configuration,
	TargetTriple& target_triple,
	WorkspaceInfo& workspace,
	BuildGraph &mut build_graph )
{
	// Collect and sort a list of build target names,
	// then iterate in this sorted order - to avoid generating build graph in non-deterministic hashtable order.
	var ust::vector</BuildTargetAbsoluteName/> mut build_target_names;
	foreach( &build_target_pair : workspace.build_targets )
	{
		build_target_names.push_back( build_target_pair.key() );
	}
	ust::sort( build_target_names );

	foreach( &build_target_name : build_target_names )
	{
		CreatePackageTargetBuildGraphNodes(
			build_system_paths,
			sysroot,
			root_package_build_directory,
			build_configuration,
			target_triple,
			workspace,
			build_target_name,
			build_graph );
	}
}

fn CreatePackageTargetBuildGraphNodes(
	BuildSystemPaths& build_system_paths,
	ust::string_view8 sysroot,
	ust::string_view8 root_package_build_directory,
	BuildConfiguration build_configuration,
	TargetTriple& target_triple,
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& target_name,
	BuildGraph &mut build_graph )
{
	var WorkspaceInfo::BuildTarget& target= workspace.build_targets[target_name];

	var ust::string8 package_source_directory=
		GetPackageSourceDirectory( build_system_paths, target_name.package_name );

	var ust::string8 package_build_directory=
		GetPackageBuildDirectory( root_package_build_directory, target_name.package_name );

	var ust::string8 target_build_files_directory=
		GetBuildTargetBuildFilesDirectory( root_package_build_directory, target_name );

	// Retrieve include directories.
	var ust::vector</ust::string8/> mut include_directories_prefixed=
		ExtractBuildTargetIncludeDirectories( workspace, build_system_paths, target_name, target );

	var ust::string8 sources_dir=
		( target.source_files.empty()
			? ust::string8()
			: NormalizePath( ust::concat( package_source_directory, "/", target.sources_directory ) ) );

	var ust::string8 generated_sources_dir=
		( ( target.generated_source_files.empty() && target.generated_private_header_files.empty() )
			? ust::string8()
			: GetBuildTargetGeneratedSourcesDirectory( root_package_build_directory, target_name ) );

	var ust::vector</ust::string8/> mut generated_headers_dependencies;

	// Get generated private headers of this build target.
	foreach( &generated_private_header : target.generated_private_header_files )
	{
		generated_headers_dependencies.push_back( NormalizePath( ust::concat( generated_sources_dir, "/", generated_private_header ) ) );
	}

	// Get generated public headers of this build target and all dependencies of this build target.
	foreach( &build_target_name :
		ust::single_element_array_view( target_name ).iter()
		.chain( target.public_dependencies_including_transitive.iter() )
		.chain( (target.private_dependencies_including_transitive_public_dependencies.iter() ) ) )
	{
		auto& dependency_target = workspace.build_targets[ build_target_name ];
		if( !dependency_target.generated_public_header_files.empty() )
		{
			var ust::string8 generated_public_headers_dir= GetBuildTargetGeneratedPublicHeadersDirectory( root_package_build_directory, build_target_name );
			foreach( &generated_public_header : dependency_target.generated_public_header_files )
			{
				generated_headers_dependencies.push_back( NormalizePath( ust::concat( generated_public_headers_dir, "/", generated_public_header ) ) );
			}

			include_directories_prefixed.push_back( ust::concat( generated_public_headers_dir, g_include_dir_prefix_separator, build_target_name.name ) );
		}
	}

	// Create nodes for compilation of each source file into a ".bc" file.
	var ust::vector</SourceFileToCompile/> mut source_files_to_compile;

	foreach( &source_file : target.source_files )
	{
		source_files_to_compile.push_back(
			SourceFileToCompile
			{
				.source_file_full_path= NormalizePath( ust::concat( package_source_directory, "/", source_file ) ),
				.bc_file_full_path=  NormalizePath( ust::concat( target_build_files_directory, "/", source_file, ".bc" ) ),
				.comment= source_file + ".bc",
			} );
	}

	if( !target.generated_source_files.empty() )
	{
		var ust::string8 generated_sources_build_dir=
			GetBuildTargetGeneratedSourcesBuildDirectory( root_package_build_directory, target_name );

		foreach( &generated_source_file : target.generated_source_files )
		{
			source_files_to_compile.push_back(
				SourceFileToCompile
				{
					.source_file_full_path= NormalizePath( ust::concat( generated_sources_dir, "/", generated_source_file ) ),
					// Place "bc" files in separate build directory.
					.bc_file_full_path= NormalizePath( ust::concat( generated_sources_build_dir, "/", generated_source_file, ".bc" ) ),
					.comment= generated_source_file + ".bc",
				} );
		}
	}

	foreach( &source_file_to_compile : source_files_to_compile )
	{
		var BuildGraph::Node mut node
		{
			.program= build_system_paths.compiler_executable_path,
			// Use a dep-file to track changes in imported files and trigger rebuild if one of them is changed.
			.dep_file= GetDependencyFilePath( source_file_to_compile.bc_file_full_path ),
			.input_files= ust::make_array( source_file_to_compile.source_file_full_path ),
			.output_files= ust::make_array( source_file_to_compile.bc_file_full_path ),
			.comment= source_file_to_compile.comment,
		};

		// Add dependencies on generated headers of this build target and generated public headers of dependencies.
		// Do this in order to ensure headers are generated before this source file is compiled.
		node.input_files.append( generated_headers_dependencies.iter() );

		node.command_line.push_back( source_file_to_compile.source_file_full_path );

		if( !sysroot.empty() )
		{
			node.command_line.push_back( "--sysroot" );
			node.command_line.push_back( sysroot );
		}

		node.command_line.push_back( "-o" );
		node.command_line.push_back( source_file_to_compile.bc_file_full_path );

		// Produce also a dependency file.
		node.command_line.push_back( "-MF" );
		node.command_line.push_back( node.dep_file );


		foreach( &include_dir_prefixed : include_directories_prefixed )
		{
			node.command_line.push_back( "--include-dir" );
			node.command_line.push_back( include_dir_prefixed );
		}

		// Provide path to source directory (directories), in order to allow relative imports.
		if( !sources_dir.empty() )
		{
			node.command_line.push_back( "--source-dir" );
			node.command_line.push_back( sources_dir );
		}

		if( !generated_sources_dir.empty() )
		{
			node.command_line.push_back( "--source-dir" );
			node.command_line.push_back( generated_sources_dir );
		}

		if( !sources_dir.empty() )
		{
			// Allow importing files from sources directory using target name-prefixed path.
			node.command_line.push_back( "--include-dir" );
			node.command_line.push_back( ust::concat( sources_dir, g_include_dir_prefix_separator, target_name.name ) );
		}

		if( !generated_sources_dir.empty() )
		{
			// Allow importing files from generated sources directory using target name-prefixed path.
			node.command_line.push_back( "--include-dir" );
			node.command_line.push_back( ust::concat( generated_sources_dir, g_include_dir_prefix_separator, target_name.name ) );
		}

		// Forbid importing anything outside include directories and source directories.
		node.command_line.push_back( "--prevent-imports-outside-given-directories" );

		// Produce an LLVM bitcode file.
		node.command_line.push_back( "-filetype=bc" );

		// TODO - disable "pic" by default for windows target.
		node.command_line.push_back( "--relocation-model" );
		node.command_line.push_back( "pic" );

		// Build configuration-dependent options.
		switch( build_configuration )
		{
			BuildConfiguration::Debug ->
			{
				// Generate debug information.
				node.command_line.push_back( "-g" );
				// No optimization at all - optimization makes debugging hard.
				node.command_line.push_back( "-O0" );
				// No LTO is used for debug builds.
			},
			BuildConfiguration::Release ->
			{
				// Run full optimization, but not by using O3 - it isn't much better than O2.
				node.command_line.push_back( "-O2" );
				// Prepare for LTO.
				node.command_line.push_back( "--lto-mode=prelink" );
			},
		}

		AddTargetTripleCompilerFlags( target_triple, node.command_line );

		// Perform verification just to be sure nothing is broken.
		node.command_line.push_back( "--verify-module" );

		build_graph.nodes.push_back( move(node) );
	}

	// Combine multiple ".bc" files into single result.

	var bool target_is_windows = target_triple.operating_system == "windows";

	var ust::string8 mut result_target_file_path= package_build_directory;
	result_target_file_path+= "/";
	result_target_file_path+= target_name.name;

	switch( target.target_type )
	{
		BuildTargetType::Executable ->
		{
			if( target_is_windows )
			{
				result_target_file_path+= ".exe";
			}
		},
		BuildTargetType::Library ->
		{
			result_target_file_path+= ".bc";
		},
		BuildTargetType::SharedLibrary ->
		{
			if( target_is_windows )
			{
				result_target_file_path+= ".dll";
			}
			else
			{
				result_target_file_path+= ".so";
			}
		},
		BuildTargetType::ObjectFile ->
		{
			result_target_file_path+= ".o";
		},
	}

	result_target_file_path= NormalizePath( result_target_file_path );

	var BuildGraph::Node mut node
	{
		.program= build_system_paths.compiler_executable_path,
		// Dep-files are needed only for cases where dependencies can't be specified statically, like for imports.
		// For an end-target like an executable dep-files isn't necessary.
		.dep_file= "",
		.output_files= ust::make_array( result_target_file_path ),
		.comment= target_name.name, // TODO - prefix with package name/path
	};

	if( !sysroot.empty() )
	{
		node.command_line.push_back( "--sysroot" );
		node.command_line.push_back( sysroot );
	}

	if( target.target_type == BuildTargetType::SharedLibrary )
	{
		if( target_is_windows )
		{
			// Add also ".lib" file to outputs.
			// This file is implicitly created by the linker.
			var ust::string8 lib_name = NormalizePath( ust::concat( package_build_directory, "/", target_name.name, ".lib" ) );
			node.output_files.push_back( lib_name );

			if( target_triple.environment == "gnu" )
			{
				// MinGW linker requires a special option to produce such library.
				node.command_line.push_back( "-Wl,--out-implib," + lib_name );
			}
		}
		else
		{
			// Specify soname, in order to load libraries using only name and not the full path to the library provided to the linker.
			node.command_line.push_back( ust::concat( "-Wl,-soname,", target_name.name, ".so" ) );
		}
	}

	foreach( &source_file_to_compile : source_files_to_compile )
	{
		node.command_line.push_back( source_file_to_compile.bc_file_full_path );
		node.input_files.push_back( source_file_to_compile.bc_file_full_path );
	}

	// Link public dependencies.
	switch( target.target_type )
	{
		BuildTargetType::Executable,
		BuildTargetType::SharedLibrary,
		BuildTargetType::ObjectFile ->
		{
			// For executables, shared libraries and object files perform linking with all public dependency libraries.
			foreach( &public_dependency : target.public_dependencies_including_transitive )
			{
				if( IsPublicDependencyOfDirectPublicSharedLibraryDependency( workspace, target, public_dependency ) )
				{
					// An optimization for result binary size.
					// If this dependency is also a public dependency of a direct shared library dependency,
					// we don't need to link this dependency, since all symbols of this dependency will be exposed and obtained from such shared library.
					// Generally a deeper analysis is required here to remove unnecessary libraries in all cases.
					continue;
				}

				if( workspace.build_targets[ public_dependency ].target_type == BuildTargetType::Library )
				{
					var ust::string8 mut lib_file=
						NormalizePath( ust::concat(
							GetPackageBuildDirectory( root_package_build_directory, public_dependency.package_name ),
							"/",
							public_dependency.name,
							".bc" ) );

					node.command_line.push_back( lib_file );
					node.input_files.push_back( move(lib_file) );
				}
			}
		},
		BuildTargetType::Library ->
		{
			// Do not link public dependencies in libraries.
			// Instead propatage them to the terminal target - executable or shared library.
		},
	}

	// For all build target types link private library dependencies.
	// Link also all transitive public dependencies of these private dependencies.
	// Exception are libraries which are also public dependencies of this build target, they are not listed here.
	foreach( &private_dependency : target.private_dependencies_including_transitive_public_dependencies )
	{
		if( IsPublicDependencyOfSomeLinkedSharedLibrary( workspace, target, private_dependency ) )
		{
			// An optimization for result binary size.
			// If this dependency is also a public dependency of some shared library, which is linked against this build target,
			// we don't need to link this dependency, since all symbols of this dependency will be exposed and obtained from such shared library.
			continue;
		}

		if( workspace.build_targets[ private_dependency ].target_type == BuildTargetType::Library )
		{
			var ust::string8 mut lib_file=
				NormalizePath( ust::concat(
					GetPackageBuildDirectory( root_package_build_directory, private_dependency.package_name ),
					"/",
					private_dependency.name,
					".bc" ) );

			node.command_line.push_back( lib_file );
			node.input_files.push_back( lib_file );

			// Internalize all symbols from private dependencies.
			node.command_line.push_back( "--internalize-symbols-from" );
			node.command_line.push_back( move(lib_file) );
		}
	}

	// Link shared library dependencies.
	// Libraries linking.
	switch( target.target_type )
	{
		BuildTargetType::Executable,
		BuildTargetType::SharedLibrary ->
		{
			foreach( &shared_library_dependency : target.shared_library_dependencies_to_link )
			{
				var ust::string8 mut file_to_link= ust::concat(
					GetPackageBuildDirectory( root_package_build_directory, shared_library_dependency.package_name ),
					"/",
					shared_library_dependency.name );

				if( target_is_windows )
				{
					// Windows dynamic libraries aren't linked directly, a proxy static library is used instead.
					var ust::string8 mut lib_file= NormalizePath( file_to_link + ".lib" );
					node.command_line.push_back( "-Wl," + lib_file );
					node.input_files.push_back( move(lib_file) );
				}
				else
				{
					// Unix shared libraries are specified directly.
					var ust::string8 mut so_file= NormalizePath( file_to_link + ".so" );
					node.command_line.push_back( "-Wl," + so_file );
					node.input_files.push_back( move(so_file) );
				}
			}

			if( !target.shared_library_dependencies_to_link.empty() && !target_is_windows )
			{
				// For now set "rpath" to origin - in order to have possibility to load shared libraries from common directory with all build targets.
				node.command_line.push_back( "-Wl,-rpath,$ORIGIN" );
			}
		},
		BuildTargetType::Library -> {}, // No need to link Ü libraries against shared libraries.
		BuildTargetType::ObjectFile -> {}, // No need to link object files against shared libraries.
	}

	// Link external library dependencies.
	switch( target.target_type )
	{
		BuildTargetType::Executable,
		BuildTargetType::SharedLibrary ->
		{
			foreach( &external_library : target.all_external_libraries_to_link )
			{
				node.command_line.push_back( "-Wl," + external_library );
				if( IsAbsolutePath( external_library ) )
				{
					node.input_files.push_back( external_library );
				}
				else
				{
					// Assume that non-absolute external libraries are system libraries loaded from known system directories.
					// Examples are "pthread", "kernel32".
					// In such case we don't need to track changes in these files - assume they are immutable and thus no needed to be listed in input files.
				}
			}
		},
		BuildTargetType::Library -> {}, // No need to link Ü libraries against external libraries.
		BuildTargetType::ObjectFile -> {}, // No need to link object files against external libraries.
	}

	node.command_line.push_back( "-o" );
	node.command_line.push_back( result_target_file_path );

	// Read LLVM bitcode files (use the Ü compiler as bitcode files compiler).
	node.command_line.push_back( "--input-filetype=bc" );

	switch( target.target_type )
	{
		BuildTargetType::Executable ->
		{
			// This requires compiler to be built with internal LLD (for now we don't support external linkers).
			node.command_line.push_back( "-filetype=exe" );
		},
		BuildTargetType::Library ->
		{
			// Produce bitcode file.
			node.command_line.push_back( "-filetype=bc" );
		},
		BuildTargetType::SharedLibrary ->
		{
			// Produce shared librart file.
			// This requires compiler to be built with internal LLD (for now we don't support external linkers).
			node.command_line.push_back( "-filetype=dll" );
		},
		BuildTargetType::ObjectFile ->
		{
			// Produce object file.
			node.command_line.push_back( "-filetype=obj" );
		},
	}

	// Internalization.
	switch( target.target_type )
	{
		BuildTargetType::Executable ->
		{
			// Run full internalization in order to export only "main".
			node.command_line.push_back( "--internalize" );
		},
		BuildTargetType::Library ->
		{
			// Internalize hidden symbols - to hide functions/variables which shouldn't be available outside this library.
			node.command_line.push_back( "--internalize-hidden" );
		},
		BuildTargetType::SharedLibrary ->
		{
			// Run internalization of hidden symbols, preserve others in order to export them.
			node.command_line.push_back( "--internalize-hidden" );
		},
		BuildTargetType::ObjectFile ->
		{
			// Run internalization of hidden symbols, preserve others, in order to access them by external code using this object file.
			node.command_line.push_back( "--internalize-hidden" );
		},
	}

	// TODO - disable "pic" by default for windows target.
	node.command_line.push_back( "--relocation-model" );
	node.command_line.push_back( "pic" );

	// Build configuration-dependent options.
	switch( build_configuration )
	{
		BuildConfiguration::Debug ->
		{
			// Generate debug information.
			node.command_line.push_back( "-g" );
			// No optimization at all - optimization makes debugging hard.
			node.command_line.push_back( "-O0" );
			// No LTO is used for debug builds.
		},
		BuildConfiguration::Release ->
		{
			if( target.target_type == BuildTargetType::Library )
			{
				// Do not run optimization for library targets.
				// Individual optimization of their source files was performed earlier.
				// Full optimization will be performed while using this library in some other target kind, like in executable.
			}
			else
			{
				// Run full optimization, but not by using O3 - it isn't much better than O2.
				node.command_line.push_back( "-O2" );
				// Also run LTO.
				node.command_line.push_back( "--lto-mode=link" );

				if( !target_is_windows || target_triple.environment == "gnu" )
				{
					// Put symbols into sections and remove unnecessary ones.
					node.command_line.push_back( "--function-sections" );
					node.command_line.push_back( "--data-sections" );
					node.command_line.push_back( "-Wl,--gc-sections" );
				}
			}
		},
	}

	AddTargetTripleCompilerFlags( target_triple, node.command_line );

	// Perform verification just to be sure nothing is broken.
	node.command_line.push_back( "--verify-module" );

	build_graph.nodes.push_back( move(node) );
}

struct SourceFileToCompile
{
	ust::string8 source_file_full_path;
	ust::string8 bc_file_full_path;
	ust::string8 comment;
}

fn AddTargetTripleCompilerFlags( TargetTriple& target_triple, ust::vector</ust::string8/> &mut compiler_flags )
{
	compiler_flags.push_back( "--target-arch" );
	compiler_flags.push_back( target_triple.architecture );

	compiler_flags.push_back( "--target-vendor" );
	compiler_flags.push_back( target_triple.vendor );

	compiler_flags.push_back( "--target-os" );
	compiler_flags.push_back( target_triple.operating_system );

	compiler_flags.push_back( "--target-environment" );
	compiler_flags.push_back( target_triple.environment );
}

fn CreateCustomBuildStepBuildGraphNodes(
	TargetTriple& host_target_triple,
	ust::string_view8 host_packages_root_build_directory,
	WorkspaceInfo::CustomBuildStep& custom_build_step,
	BuildGraph &mut build_graph )
{
	// Paths should be already normalized.
	var BuildGraph::Node mut node
	{
		.input_files= custom_build_step.input_files,
		.output_files= custom_build_step.output_files,
		.comment= custom_build_step.comment,
		// TODO - add possibility to set dep-file
	};

	if_var( &exe_command : custom_build_step.command.get</ CustomBuildStep::ExeCommand />() )
	{
		node.program= exe_command.exe_path;
		node.command_line= exe_command.command_line;
	}
	else if_var( &host_build_target_exe_command : custom_build_step.command.get</ WorkspaceInfo::CustomBuildStep::HostBuildTargetExeCommand />() )
	{
		// Existence of the corresponding build target in the host workspace should be checked previously.
		node.program=
			NormalizePath( ust::concat(
				GetPackageBuildDirectory( host_packages_root_build_directory, host_build_target_exe_command.name.package_name ),
				"/",
				host_build_target_exe_command.name.name,
				( host_target_triple.operating_system == "windows" ? ust::string_view8(".exe") : ust::string_view8() ) ) );
		node.command_line= host_build_target_exe_command.command_line;
	}
	else if_var( &copy_command : custom_build_step.command.get</ CustomBuildStep::CopyCommand />() )
	{
		node.program= SpecialBuildCommands::copy_file;
		node.command_line= ust::make_array( copy_command.destination_path, copy_command.source_path );
	}
	else if_var( &generate_command : custom_build_step.command.get</ CustomBuildStep::GenerateFileCommand />() )
	{
		node.program= SpecialBuildCommands::generate_file;
		node.command_line= ust::make_array( generate_command.destination_path, generate_command.contents );
	}
	else
	{
		// Unhadled kind of command.
		halt;
	}

	build_graph.nodes.push_back( move(node) );
}

fn IsPublicDependencyOfDirectPublicSharedLibraryDependency(
	WorkspaceInfo& workspace,
	WorkspaceInfo::BuildTarget& build_target,
	BuildTargetAbsoluteName& dependency ) : bool
{
	foreach( &public_dependency : build_target.public_dependencies )
	{
		auto& public_dependency_build_target = workspace.build_targets[ public_dependency ];
		if( public_dependency_build_target.target_type == BuildTargetType::SharedLibrary )
		{
			foreach( &shared_library_public_dependency : public_dependency_build_target.public_dependencies_including_transitive )
			{
				if( dependency == shared_library_public_dependency )
				{
					return true;
				}
			}
		}
	}

	return false;
}

fn IsPublicDependencyOfSomeLinkedSharedLibrary(
	WorkspaceInfo& workspace,
	WorkspaceInfo::BuildTarget& build_target,
	BuildTargetAbsoluteName& dependency ) : bool
{
	foreach( &shared_library_dependency : build_target.shared_library_dependencies_to_link )
	{
		foreach( &shared_library_public_dependency : workspace.build_targets[ shared_library_dependency ].public_dependencies_including_transitive )
		{
			if( dependency == shared_library_public_dependency )
			{
				return true;
			}
		}
	}

	return false;
}

class BuildSystemInterfaceImplementation final : BuildSystemInterface
{
public:
	fn constructor(
		Logger mut logger,
		BuildConfiguration build_configuration,
		ConfigurationOptions mut configuration_options,
		BuildSystemPaths mut build_system_paths )
			(
				logger_= move(logger),
				build_configuration_= build_configuration,
				configuration_options_= move(configuration_options),
				build_system_paths_= move(build_system_paths),
			)
	{}

	fn SetTargetTriple( mut this, TargetTriple mut target_triple )
	{
		target_triple_= move(target_triple);
	}

	fn SetRootPackageBuildDirectory( mut this, ust::string8 mut root_package_build_directory )
	{
		root_package_build_directory_= move(root_package_build_directory);
	}

	fn SetCurrentPackageName( mut this, PackageAbsoluteName mut name )
	{
		current_package_name_= move(name);
	}

public: // BuildSystemInterface
	fn virtual final GetBuildConfiguration(this) : BuildConfiguration
	{
		return build_configuration_;
	}

	fn virtual final GetTargetTriple(this) : TargetTriple
	{
		return target_triple_;
	}

	fn virtual final LogVerbose( mut this, ust::string_view8 message )
	{
		logger_.LogVerbose( message );
	}

	fn virtual final LogInfo( mut this, ust::string_view8 message )
	{
		logger_.LogInfo( message );
	}

	fn virtual final LogError( mut this, ust::string_view8 message )
	{
		logger_.LogError( message );
	}

	fn virtual final GetCompilerExecutablePath( this ) : ust::string8
	{
		return build_system_paths_.compiler_executable_path;
	}

	fn virtual final GetConfigurationOption( this, ust::string_view8 name ) : ust::optional</ust::string8/>
	{
		if_var( &option_value : configuration_options_.find(name) )
		{
			return option_value;
		}
		return ust::null_optional;
	}

	fn virtual final GetCurrentPackageSourceDirectory( this ) : ust::string8
	{
		return GetPackageSourceDirectory( build_system_paths_, current_package_name_ );
	}

	fn virtual final GetCurrentPackageBuildDirectory( this ) : ust::string8
	{
		return GetPackageBuildDirectory( root_package_build_directory_, current_package_name_ );
	}

	fn virtual final GetCurrentPackageBuildTargetGeneratedSourcesDirectory( this, ust::string_view8 build_target_name ): ust::string8
	{
		return
			GetBuildTargetGeneratedSourcesDirectory(
				root_package_build_directory_,
				BuildTargetAbsoluteName{ .package_name= current_package_name_, .name= build_target_name } );
	}

	fn virtual final GetCurrentPackageBuildTargetGeneratedPublicHeadersDirectory( this, ust::string_view8 build_target_name ) : ust::string8
	{
		return
			GetBuildTargetGeneratedPublicHeadersDirectory(
				root_package_build_directory_,
				BuildTargetAbsoluteName{ .package_name= current_package_name_, .name= build_target_name } );
	}

public: // Provide direct access for some fields where it's safe to use them directly.
	Logger logger_;

	BuildConfiguration imut build_configuration_;
	BuildSystemPaths imut build_system_paths_;

private:
	ConfigurationOptions imut configuration_options_;

	TargetTriple target_triple_; // May be changed because of target/host system switching.
	ust::string8 root_package_build_directory_; // May be changed because of target/host system switching.

	PackageAbsoluteName current_package_name_;
}

} // namespace BK
