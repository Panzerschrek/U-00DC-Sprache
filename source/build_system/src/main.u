import "/main_wrapper.u"
import "/path_utils.u"
import "/sort.u"
import "/string_conversions.u"
import "/stdout.u"
import "/thread.u"
import "../imports/build_system_interface.uh"
import "abort_signal_handler.uh"
import "build_graph_serialization.uh"
import "build_system_paths.uh"
import "configuration_options.uh"
import "filesystem.uh"
import "include_directories.uh"
import "init_command.uh"
import "language_server_workspace_info.uh"
import "make_dep_file.uh"
import "options.uh"
import "package_transformation.uh"
import "process.uh"
import "shared_library.uh"
import "target_triple.uh"
import "version_unification.uh"

pretty_main
{
	return BK::Main( args.front(), args.subrange_start( 1s ) );
}

namespace BK
{

// Place actual "main" code inside the "BK" namespace.
fn nodiscard Main( ust::string_view8& first_arg, ust::array_view_imut</ust::string_view8/> args_excluding_first ) : i32
{
	SetupAbortSignalHandler();

	var ust::optional</Options/> options_opt= ParseOptions( args_excluding_first );

	if( options_opt.empty() )
	{
		ust::stderr_print( "Failed to parse options.\n" );
		return -1;
	}

	var Options& options= options_opt.try_deref();

	if( options.command == Options::Command::Help || options.help )
	{
		ust::stdout_print( GetHelpMessage() );
		return 0;
	}

	var Logger mut logger(
		( options.verbose
			? Logger::Level::Verbose
			: ( options.quiet ? Logger::Level::Quiet : Logger::Level::Normal ) ) );

	logger.LogInfo( "Bürokratie - the Ü build system!" );

	if( options.command == Options::Command::Init )
	{
		auto project_directory= ust::path::normalize( MakePathAbsolute( options.root_package_directory ) );
		return ( InitProjectStub( logger, project_directory ) ? 0 : 1 );
	}

	var TargetTriple host_target_triple= GetHostTargetTriple();

	var TargetTriple mut target_triple;
	if( !options.target_triple.empty() )
	{
		auto mut target_triple_opt= ParseTargetTriple( options.target_triple );
		if( target_triple_opt.empty() )
		{
			logger.LogError( "Failed to parse target triple!\n" );
			return -1;
		}
		target_triple= target_triple_opt.try_take();
	}
	else
	{
		// By default build for the host target triple.
		target_triple= host_target_triple;
	}

	var ConfigurationOptions mut configuration_options;
	if( !options.configuration_options_file.empty() )
	{
		auto mut configuration_options_opt= LoadConfigurationOptions( logger, options.configuration_options_file );
		if( configuration_options_opt.empty() )
		{
			ust::stderr_print( "Failed to load configuration options!\n" );
			return -1;
		}
		configuration_options= configuration_options_opt.try_take();
	}

	var ust::filesystem_path current_executable= GetCurrentExecutablePath( first_arg );

	var ust::filesystem_path exe_directory = MakePathAbsolute( ust::path::get_parent_path( current_executable ).deref_or( "" ) );

	logger.LogVerbose( ust::concat( "Build system executable directory path: \"", exe_directory, "\"" ) );

	var BuildSystemPaths mut build_system_paths
	{
		.build_system_executable_path= ust::path::normalize( MakePathAbsolute( current_executable ) ),
		.compiler_executable_path= ust::path::normalize(
			( options.compiler_executable_path.empty()
				// For now use "Compiler1" as compiler default. TODO - use compiler generation used for building this buld system executable.
				? ust::path::join( exe_directory, "u.._compiler1" )
				: MakePathAbsolute(options.compiler_executable_path) ) ),
		.ustlib_path= ust::path::normalize(
			( options.ustlib_path.empty()
				? ust::path::join( exe_directory, "../ustlib" ) // "ustlib" is located in the root of the Ü package.
				: MakePathAbsolute(options.ustlib_path) ) ),
		.build_system_imports_path= ust::path::normalize(
			( options.build_system_imports_path.empty()
				? ust::path::join( exe_directory, "../build_system/imports" ) // Build system imports are located in "/build_system/imports".
				: MakePathAbsolute(options.build_system_imports_path) ) ),
		.packages_repository_directory=
			ust::path::normalize(
				MakePathAbsolute(
					( options.packages_repository_directory.empty()
						? options.root_package_directory
						: options.packages_repository_directory ) ) ),
		// If "options.root_package_directory" is empty this will become current directory.
		.root_package_source_directory= ust::path::normalize( MakePathAbsolute( options.root_package_directory ) ),
	};

	EnsureHasExeExtension( build_system_paths.build_system_executable_path );

	// Make sure compiler executable on Windows has "exe" extension - this is necessary for later checking of its file timestamp.
	EnsureHasExeExtension( build_system_paths.compiler_executable_path );
	logger.LogVerbose( ust::concat( "Compiler executable path: \"", build_system_paths.compiler_executable_path, "\"" ) );

	if( options.command == Options::Command::BuildSingle )
	{
		var bool ok =
			BuildSingleFileProgram(
				logger,
				options.single_file_to_build,
				build_system_paths,
				options.sysroot,
				// Build in specified build directory or in current directory if it's empty.
				MakePathAbsolute( options.build_directory ),
				options.build_configuration_extended,
				target_triple,
				options.target_cpu );
		return ( ok ? 0 : -1 );
	}

	// By default use "build" directory within root package directory.
	var ust::filesystem_path root_package_build_directory_base =
		( options.build_directory.empty()
			? ust::path::join( build_system_paths.root_package_source_directory, "build" )
			: ust::path::normalize( MakePathAbsolute( options.build_directory ) ) );

	// Create, if necessary, subdirectory for target triple.
	// Do it only if this target triple isn't equal to host triple.
	var ust::filesystem_path mut root_package_build_directory = root_package_build_directory_base;
	if( target_triple != GetHostTargetTriple() )
	{
		ust::path::append( root_package_build_directory, TargetTripleToString( target_triple ) );
	}

	// Create a subdirectory for configuration specified.
	ust::path::append( root_package_build_directory, BuildConfigurationToString( options.build_configuration_extended.build_configuration ) );

	if( !EnsureDirectoryExists( logger, root_package_build_directory ) )
	{
		logger.LogError( "Can't create build directory." );
		return -1;
	}

	logger.LogVerbose( ust::concat( "Build project in \"", build_system_paths.root_package_source_directory, "\" using build directory \"", root_package_build_directory, "\"" ) );

	// Build host packages within directory of target system/build configuration.
	// Technically it may be possible to share host packages build across different target systems, but for now don't do this to avoid possible mistakes.
	//
	// Also we create this directory and perform proper building of host system worspace,
	// even if host target triple is equal to target triple of the target system.
	// There are some reasons to do this.
	// First, it's necessary in order to prevent possible mistakes in packages wrongly assuming host=target.
	// We prevent writing such packages by forcing target/host workspaces separation.
	// Second, compilation options may be incompatible - we may want to build for targets with SSE4 (for example),
	// on a host with no SSE4 support. In such case we need two separate build trees with two different set of compilation options.
	var ust::filesystem_path host_packages_root_build_directory =
		ust::path::join(
			root_package_build_directory,
			"host.build" /* use name with dots in order to avoid name conflicts */ );

	// Compile "ustlib" used in build scripts. Do it before compiling any of them.
	// Perform the build in the root build directory,
	// since the only possible configuration and target triple is confuguration and triple of this build system executable.
	if( !BuildUstlibForBuildScripts(
		logger, build_system_paths, options.host_sysroot, root_package_build_directory_base ) )
	{
		logger.LogError( "Failed to build \"ustlib\" for build scripts." );
		return -1;
	}

	var BuildSystemInterfaceImplementation mut bsi(
		move(logger),
		options.build_configuration_extended,
		move(configuration_options),
		move(build_system_paths) );

	var PackagesMap mut target_packages_map, mut host_packages_map;

	var ust::vector</PackageAbsoluteName/> mut target_packages_queue, mut host_packages_queue;

	// Push root package.
	target_packages_queue.push_back( PackageAbsoluteName{ .name_base= PackageAbsoluteName::RootPackage{}, .path= "" } );

	// Process target packages queue.
	bsi.SetTargetTriple( target_triple );
	bsi.SetRootPackageBuildDirectory( root_package_build_directory );
	// Use index-based iterations, because this list is populated within the loop.
	for( auto mut i= 0s; i < target_packages_queue.size(); ++i )
	{
		var PackageAbsoluteName package_name= target_packages_queue[i];
		if( target_packages_map.exists( package_name ) )
		{
			continue; // Already loaded this package.
		}

		// Tweak build system interface for current package.
		bsi.SetCurrentPackageName( package_name );

		var ust::optional</PackageInfo/> mut package_info_opt=
			ObtainPackageInfo(
				bsi,
				options.host_sysroot,
				package_name,
				// Output build script into base build directory, ignoring build configuration and target triple.
				// Doing so we allow reusing build script for different configuration and target systems.
				root_package_build_directory_base );

		if( package_info_opt.empty() )
		{
			return -1;
		}

		// Add dependencies to the queue.
		foreach( &dependency : package_info_opt.try_deref().package_dependencies )
		{
			auto mut dependency_package_absolute_name=
				ResolvePackageAbsoluteName( bsi.logger_, package_name, dependency.name );
			if( dependency_package_absolute_name.empty() )
			{
				bsi.logger_.LogError( ust::concat( "Failed to find package dependency within package \"", package_name.path, "\"!" ) );
				return -1;
			}
			switch( dependency.required_system )
			{
				PackageDependency::RequiredSystem::Target ->
				{
					target_packages_queue.push_back( dependency_package_absolute_name.try_take() );
				},
				PackageDependency::RequiredSystem::Host ->
				{
					host_packages_queue.push_back( dependency_package_absolute_name.try_take() );
				},
				PackageDependency::RequiredSystem::Both ->
				{
					target_packages_queue.push_back( dependency_package_absolute_name.try_deref() );
					host_packages_queue.push_back( dependency_package_absolute_name.try_take() );
				},
			}
		}

		target_packages_map.insert_new( package_name, package_info_opt.try_take() );
	}

	// Process host packages queue.
	bsi.SetTargetTriple( host_target_triple );
	bsi.SetRootPackageBuildDirectory( host_packages_root_build_directory );
	// Use index-based iterations, because this list is populated within the loop.
	for( auto mut i= 0s; i < host_packages_queue.size(); ++i )
	{
		var PackageAbsoluteName package_name= host_packages_queue[i];
		if( host_packages_map.exists( package_name ) )
		{
			continue; // Already loaded this package.
		}
		// Tweak build system interface for current package.
		bsi.SetCurrentPackageName( package_name );

		var ust::optional</PackageInfo/> mut package_info_opt=
			ObtainPackageInfo(
				bsi,
				options.host_sysroot,
				package_name,
				// Use same base path for build scripts of host and target system packages.
				// Doing so we allow reusing build scripts for packages which are compiled both for host and target systems.
				root_package_build_directory_base );

		if( package_info_opt.empty() )
		{
			return -1;
		}

		// Add dependencies to the queue.
		foreach( &dependency : package_info_opt.try_deref().package_dependencies )
		{
			auto mut dependency_package_absolute_name=
				ResolvePackageAbsoluteName( bsi.logger_, package_name, dependency.name );
			if( dependency_package_absolute_name.empty() )
			{
				bsi.logger_.LogError( ust::concat( "Failed to find package dependency within package \"", package_name.path, "\"!" ) );
				return -1;
			}
			// All dependencies of host packages are host packages.
			host_packages_queue.push_back( dependency_package_absolute_name.try_take() );
		}

		host_packages_map.insert_new( package_name, package_info_opt.try_take() );
	}

	auto target_workspace_opt= CreateWorkspace( bsi.logger_, target_packages_map, root_package_build_directory );
	if( target_workspace_opt.empty() )
	{
		return -1;
	}
	var WorkspaceInfo& target_workspace= target_workspace_opt.try_deref();

	auto host_workspace_opt= CreateWorkspace( bsi.logger_, host_packages_map, host_packages_root_build_directory );
	if( host_workspace_opt.empty() )
	{
		return -1;
	}
	var WorkspaceInfo& host_workspace= host_workspace_opt.try_deref();

	// Check if build target names used in custom build steps of target workspace are present in host workspace.
	// Perform the same check for host workspace too.
	if( !CheckHostSystemBuildTargetsArePresent( bsi.logger_, target_workspace, host_workspace ) ||
		!CheckHostSystemBuildTargetsArePresent( bsi.logger_, host_workspace, host_workspace ) )
	{
		return -1;
	}

	if( !CreateWorkspaceBuildDirectories( bsi.logger_, target_workspace, root_package_build_directory ) ||
		!CreateWorkspaceBuildDirectories( bsi.logger_, host_workspace, host_packages_root_build_directory ) )
	{
		return -1;
	}

	// Write a helper file to be used by Ü language server.
	// Do not fail the build if failed to write it.
	var bool workspace_info_file_write_ok=
		WriteLanguageServerWorkspaceInfoFile(
			bsi.logger_,
			bsi.build_system_paths_,
			target_workspace,
			root_package_build_directory,
			host_workspace,
			host_packages_root_build_directory );
	ust::ignore_unused( workspace_info_file_write_ok );

	var ust::filesystem_path build_graph_state_file_path= ust::path::join( root_package_build_directory, "build_graph.json" );

	// Load previous build graph state.
	var ust::optional</BuildGraph/> mut prev_build_graph;
	if_var( &prev_build_graph_file : ReadFile( build_graph_state_file_path ) )
	{
		prev_build_graph= DeserializeBuildGraph( prev_build_graph_file );
		if( prev_build_graph.empty() )
		{
			bsi.logger_.LogError( "Failed to deserialize previous build graph state" );
		}
	}
	else
	{
		bsi.logger_.LogInfo( "Can't load previous build graph state" );
	}

	// Construct the build graph for the whole project.
	var BuildGraph mut build_graph;

	CreateWorkspaceBuildTargetsGraphNodes(
		bsi.build_system_paths_,
		options.sysroot,
		root_package_build_directory,
		bsi.build_configuration_extended_,
		target_triple,
		options.target_cpu,
		target_workspace,
		build_graph );

	// Custom build steps list should have stable order, since it's populated previously in packages stable order.
	foreach( &custom_build_step : target_workspace.custom_build_steps )
	{
		CreateCustomBuildStepBuildGraphNodes( host_target_triple, host_packages_root_build_directory, custom_build_step, build_graph );
	}

	CreateWorkspaceBuildTargetsGraphNodes(
		bsi.build_system_paths_,
		options.host_sysroot,
		host_packages_root_build_directory,
		bsi.build_configuration_extended_,
		host_target_triple,
		"", // Set no target CPU for host build targets.
		host_workspace,
		build_graph );

	// Custom build steps list should have stable order, since it's populated previously in packages stable order.
	foreach( &custom_build_step : host_workspace.custom_build_steps )
	{
		CreateCustomBuildStepBuildGraphNodes( host_target_triple, host_packages_root_build_directory, custom_build_step, build_graph );
	}

	var i32 mut main_result= 0;

	var u32 max_number_of_parallel_jobs=
		ust::max( 1u, ust::min( ( options.number_of_jobs == 0u ? ust::get_number_of_available_cpus() : options.number_of_jobs ), 128u ) );
	bsi.LogVerbose( ust::concat( "Building using ", ust::to_string8(max_number_of_parallel_jobs), " threads." ) );

	// This executes the build.
	if( !PerformGraphBuild( bsi.logger_, build_graph, prev_build_graph.as_ref(), max_number_of_parallel_jobs ) )
	{
		bsi.logger_.LogError( "Build failed." );
		main_result= -1;
		// Do not return here, save build graph in case of build fail to reuse parts which were susscessfully built.
	}
	else
	{
		bsi.logger_.LogInfo( "Successfully finished the build!" );
	}

	if( prev_build_graph.empty() || prev_build_graph.try_deref() != build_graph )
	{
		// If build graph on disk is equal to what we have now, avoid re-writing it.

		bsi.logger_.LogVerbose( "Build graph seems to be updated. Rewrite it." );

		// TODO - maybe fail the build if failed to serialize the build graph?
		var bool build_graph_write_is_ok=
			WriteFile(
				bsi.logger_,
				build_graph_state_file_path,
				SerializeBuildGraph( build_graph ) );
		ust::ignore_unused( build_graph_write_is_ok );
	}
	else
	{
		bsi.logger_.LogVerbose( "Skip updating on-disk build graph state." );
	}

	return main_result;
}

fn EnsureHasExeExtension( ust::string8 &mut executable_path )
{
	if( ust::string_view8( compiler::target::os ) != g_os_windows )
	{
		// Non-windows executables usually have no extension.
		return;
	}

	// Check if already has ".exe", ".EXE" or something with mixed case.
	var size_type s= executable_path.size();
	if( s >= 4s )
	{
		var char8 c0= executable_path[ s - 4s ];
		var char8 c1= executable_path[ s - 3s ];
		var char8 c2= executable_path[ s - 2s ];
		var char8 c3= executable_path[ s - 1s ];

		if( c0 == '.' &&
			( c1 == 'e' || c1 == 'E' ) &&
			( c2 == 'x' || c2 == 'X' ) &&
			( c3 == 'e' || c3 == 'E' ) )
		{
			return;
		}
	}

	// Extension seems to be missing - add it.
	executable_path+= ".exe";
}

fn ObtainPackageInfo(
	BuildSystemInterfaceImplementation &mut bsi,
	ust::filesystem_path_view host_sysroot,
	PackageAbsoluteName& package_name,
	ust::filesystem_path_view packages_build_directory ) : ust::optional</PackageInfo/>
{
	auto constexpr entry_func_name = "GetPackageInfoImpl";

	auto shared_library_opt = BuildAndLoadPackageBuildScript(
		bsi.logger_,
		bsi.build_system_paths_,
		host_sysroot,
		GetPackageSourceDirectory( bsi.build_system_paths_, package_name ),
		GetPackageBuildDirectory( packages_build_directory, package_name ),
		GetCompiledForBuildScriptsUstlibPath( packages_build_directory ),
		entry_func_name );
	if( shared_library_opt.empty() )
	{
		bsi.logger_.LogError( "Failed to load/build the build script shared library." );
		return ust::null_optional;
	}

	auto mut func_raw_ptr= shared_library_opt.try_deref().LoadSymbol( bsi.logger_, entry_func_name );

	// This must match what build sctipt file wrapper produces!
	type GetPackageInfoFunctionType = fn( BuildSystemInterface &mut build_system_interface ) : ust::optional</PackageInfo/>;

	// A hacky way to cast byte8 pointer to a function pointer.
	var GetPackageInfoFunctionType mut func_ptr= zero_init;
	unsafe( ust::memory_copy(
		ust::ptr_cast_to_byte8( $<(func_ptr) ),
		ust::ptr_cast_to_byte8( $<(func_raw_ptr) ),
		typeinfo</ typeof(func_ptr) />.size_of ) );

	if( ust::is_nullptr(func_ptr) )
	{
		bsi.logger_.LogError( "Failed to load function " + entry_func_name );
		return ust::null_optional;
	}

	// Obtain package info by calling a shared library function.
	var ust::optional</PackageInfo/> mut package_info_opt= func_ptr( bsi );
	if( package_info_opt.empty() )
	{
		bsi.logger_.LogError( ust::concat( "Failed to get package info for package \"", package_name.path, "\"- build script returned empty optional." ) );
		return ust::null_optional;
	}
	return package_info_opt;
}

fn BuildAndLoadPackageBuildScript(
	Logger &mut logger,
	BuildSystemPaths& build_system_paths,
	ust::filesystem_path_view host_sysroot,
	ust::filesystem_path_view package_source_directory,
	ust::filesystem_path_view package_build_directory,
	ust::filesystem_path_view ustlib_compiled_for_build_scripts_path,
	ust::string_view8 entry_func_name ) : ust::optional</SharedLibrary/>
{
	// TODO - select more catchy name for root build script file.
	auto constexpr build_script_file= "build.u";

	var ust::filesystem_path build_script_file_full_path= ust::path::join(package_source_directory, build_script_file );

	// TODO - do we need to have this check here?
	if( GetFileModificationTime( build_script_file_full_path ).empty() )
	{
		logger.LogError( ust::concat( "Can not get modification time for \"", build_script_file_full_path, "\" - file does not exist?" ) );
		return ust::null_optional;
	}

	var ust::filesystem_path result_shared_library_path= ust::concat( package_build_directory, "/build.", GetNativeSharedLibraryExtension() );

	var ust::filesystem_path result_shared_library_dependency_file_path = GetDependencyFilePath( result_shared_library_path );

	// Check only dependencies. No need to check compilation options, since they are always the same.
	if( CheckRebuildIsNeededBasedOnDepFile( logger, result_shared_library_dependency_file_path ) )
	{
		logger.LogVerbose( ust::concat( "Building \"", result_shared_library_path, "\"." ) );

		var ust::filesystem_path build_script_wrapper_file_directory= ust::path::join( package_build_directory, "build_script_wrapper_sources" );
		if( ! EnsureDirectoryExists( logger, build_script_wrapper_file_directory ) )
		{
			return ust::null_optional;
		}

		var ust::filesystem_path build_script_wrapper_header_file_directory= ust::path::join( package_build_directory, "build_script_wrapper_headers" );
		if( ! EnsureDirectoryExists( logger, build_script_wrapper_header_file_directory ) )
		{
			return ust::null_optional;
		}

		var ust::filesystem_path build_script_wrapper_file_path= ust::path::join( build_script_wrapper_file_directory, "build_script_wrapper.u" );
		var ust::filesystem_path build_script_header_file_path= ust::path::join( build_script_wrapper_header_file_directory, "build_script_header.uh" );

		// Create our own wrapper file to ensure that the function exported from the shared library has proper type.
		{
			var ust::string8 contents = ust::concat(
				"import \"/",
				build_script_file,
				"\"\n",
				"import \"/build_script_header.uh\"\n\n",
				"fn nomangle ",
				entry_func_name,
				"( BK::BuildSystemInterface &mut build_system_interface ) : ust::optional</BK::PackageInfo/>\n",
				// "GetPackageInfo" function itself may return "BK::PackageInfo", not optional of this type.
				"{\n\treturn GetPackageInfo( build_system_interface );\n}\n" );

			if( !WriteFile( logger, build_script_wrapper_file_path, contents ) )
			{
				logger.LogError( "Can't write build script wrapper file." );
				return ust::null_optional;
			}
		}

		// Create also header file. We need it to export entry function properly.
		{
			var ust::string8 contents = ust::concat(
				"import \"/build_system.uh\"\n\n",
				"fn nomangle ",
				entry_func_name,
				"( BK::BuildSystemInterface &mut build_system_interface ) : ust::optional</BK::PackageInfo/>;\n" );

			if( !WriteFile( logger, build_script_header_file_path, contents ) )
			{
				logger.LogError( "Can't write build script wrapper header file." );
				return ust::null_optional;
			}
		}

		var ust::vector</ust::string8/> mut compiler_args;

		// Use host sysroot for building build script shared library for host system.
		if( !host_sysroot.empty() )
		{
			compiler_args.push_back( "--sysroot" );
			compiler_args.push_back( host_sysroot );
		}

		// Add path to the package directory in order to import "build.u" inside the wrapper.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( package_source_directory );
		// Provide standard library imports.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( ust::path::join( build_system_paths.ustlib_path, g_ustlib_imports_subpath ) );
		// Provide path to declarations of the build system interface.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( build_system_paths.build_system_imports_path );
		// Provide path to build script wrapper headers.
		compiler_args.push_back( "--include-dir" );
		compiler_args.push_back( build_script_wrapper_header_file_directory );

		compiler_args.push_back( build_script_wrapper_file_path );  // The file to buld.

		// Link against "ustlib" previously built into an object file.
		compiler_args.push_back( ust::concat( "-Wl,", ustlib_compiled_for_build_scripts_path ) );

		var TargetTriple host_target_triple= GetHostTargetTriple();

		foreach( &lib : GetUstlibSystemLibrariesToLink( host_target_triple ) )
		{
			compiler_args.push_back( "-Wl," + lib );
		}

		// Output.
		compiler_args.push_back( "-o" );
		compiler_args.push_back( result_shared_library_path );

		// Produce also a dependency file.
		compiler_args.push_back( "-MF" );
		compiler_args.push_back( result_shared_library_dependency_file_path );

		// Provide path to the directory with input file, in order to allow importing it.
		compiler_args.push_back( "--source-dir" );
		compiler_args.push_back( build_script_wrapper_file_directory );

		// Forbid importing anything outside include directories and source directories.
		compiler_args.push_back( "--prevent-imports-outside-given-directories" );

		// This requires compiler to be built with internal LLD (for now we don't support external linkers).
		compiler_args.push_back( "-filetype=dll" );
		// Run internalization in order to export only entry function.
		compiler_args.push_back( "--internalize" );
		compiler_args.push_back( ust::concat( "--internalize-preserve=", entry_func_name ) );

		// Use "abort-based" halt mode - in order to handle halts in build scripts gracefully.
		// It's fine if this mode differs from halt mode in build system executable.
		compiler_args.push_back( "--halt-mode=abort" );

		// Use optimization level which was used to compile the build system executable.
		compiler_args.push_back( ust::concat( "-O", ust::single_element_array_view( compiler::options::optimization_level ) ) );

		// If the build system executable was compiled with debug information - generate it for the shared library too.
		if( compiler::options::generate_debug_info )
		{
			compiler_args.push_back( "-g" );
		}

		// Use the same target parameters for the shared library as for the build system executable.

		compiler_args.push_back( "--target-arch" );
		compiler_args.push_back( compiler::target::arch );

		compiler_args.push_back( "--target-vendor" );
		compiler_args.push_back( compiler::target::vendor );

		compiler_args.push_back( "--target-os" );
		compiler_args.push_back( compiler::target::os );

		compiler_args.push_back( "--target-environment" );
		compiler_args.push_back( compiler::target::environment );

		if( ust::string_view8( compiler::target::os ) != g_os_windows )
		{
			// It seems that position-independent code is always enabled on systems except Windows.
			// So, use this option for building the shared library.
			compiler_args.push_back( "--relocation-model" );
			compiler_args.push_back( "pic" );
		}

		// Put symbols into sections and remove unnecessary ones.
		AddGCSectionsCompilerFlags( host_target_triple, compiler_args );

		if( ust::string_view8( compiler::target::environment ) == g_environment_msvc )
		{
			// Do not generate ".lib" file - it's unnecessary, since we load the DLL dynamically.
			compiler_args.push_back( "-Wl,/NOIMPLIB" );
		}

		// Perform verification just to be sure nothing is broken.
		compiler_args.push_back( "--verify-module" );

		if( !RunExecutable( logger, build_system_paths.compiler_executable_path, compiler_args ) )
		{
			logger.LogError( "Compiler execution failed." );
			return ust::null_optional;
		}
	}
	else
	{
		logger.LogVerbose( ust::concat( "Skip building \"", result_shared_library_path,  "\"." ) );
	}

	logger.LogVerbose( ust::concat( "Loading \"", result_shared_library_path, "\"" ) );

	auto shared_library_opt = LoadSharedLibrary( logger, result_shared_library_path );
	if( shared_library_opt.empty() )
	{
		logger.LogError( "Failed to load build script shared library." );
		return ust::null_optional;
	}

	return shared_library_opt;
}

fn CheckRebuildIsNeededBasedOnDepFile( Logger &mut logger, ust::filesystem_path_view dep_file_path ) : bool
{
	var ust::optional</ust::string8/> file_contents= ReadFile( dep_file_path );
	if( file_contents.empty() )
	{
		// Dep file is not created yet.
		logger.LogVerbose( ust::concat( "No dependency file \"", dep_file_path, "\" - perform the build." ) );
		return true;
	}

	var ust::optional</MakeDepFile/> dep_file_opt= ParseMakeDepFileContents( file_contents.try_deref() );
	if( dep_file_opt.empty() )
	{
		logger.LogError( ust::concat( "Failed to parse dep file \"", dep_file_path, "\"" ) );
		return true;
	}

	var MakeDepFile& dep_file= dep_file_opt.try_deref();

	var ust::optional</FileModificationTime/> dst_modification_time_opt= GetFileModificationTime( dep_file.destination );
	if( dst_modification_time_opt.empty() )
	{
		// Destination deosn't exist.
		logger.LogVerbose( ust::concat( "No destination file \"", dep_file.destination, "\" - perform the build." ) );
		return true;
	}

	auto dst_modification_time = dst_modification_time_opt.try_deref();

	foreach( &dependency : dep_file.dependencies )
	{
		var ust::optional</FileModificationTime/> src_modification_time_opt= GetFileModificationTime( dependency );
		if( src_modification_time_opt.empty() )
		{
			// This source file is missing.
			// In some cases it's ok, like if an imported file was deleted together with deletion of the corresponding "import" directive.
			logger.LogVerbose( ust::concat( "No source file \"", dependency, "\" - perform the build." ) );
			return true;
		}
		if( src_modification_time_opt.try_deref() >= dst_modification_time )
		{
			logger.LogVerbose( ust::concat( "Source file \"", dependency, "\" is newer than the destination - perform the build." ) );
			return true;
		}
	}

	// Rebuild is not required if we reached this point.
	logger.LogVerbose( ust::concat( "No rebuild is required for dependency of the dep file \"", dep_file_path, "\"." ) );
	return false;
}

fn GetNativeSharedLibraryExtension() : ust::string_view8
{
	if( ust::string_view8( compiler::target::os ) == g_os_windows )
	{
		return "dll";
	}
	if( ust::string_view8( compiler::target::vendor ) == g_vendor_apple )
	{
		return "dylib";
	}
	return "so";
}

fn GetDependencyFilePath( ust::filesystem_path_view path ) : ust::filesystem_path
{
	return ust::concat( path, ".d" );
}

type PackagesMap= ust::hash_map</PackageAbsoluteName, PackageInfo/>;

// Returns empty optional on error.
fn CreateWorkspace(
	Logger &mut logger,
	PackagesMap& packages_map,
	ust::filesystem_path_view root_package_build_directory ) : ust::optional</WorkspaceInfo/>
{
	// Collect and sort a list of package names,
	// then iterate in this sorted order - to avoid processing packages in non-deterministic hashtable order.
	var ust::vector</PackageAbsoluteName/> mut package_names;
	foreach( &pair : packages_map )
	{
		package_names.push_back( pair.key() );
	}
	ust::sort( package_names );

	var WorkspaceInfo mut workspace;

	var bool mut has_package_transformation_errors= false;
	foreach( &package_name : package_names )
	{
		if( !TransformAndValidatePackageInfo( logger, packages_map[ package_name ], package_name, workspace ) )
		{
			logger.LogError( ust::concat( "Package \"", package_name.path, "\" is invald." ) );
			has_package_transformation_errors= true;
		}
	}

	if( has_package_transformation_errors )
	{
		return ust::null_optional;
	}

	if( !CheckWorkspaceDependencyGraphIsValid( logger, workspace ) ||
		!CheckWorkspaceCustomBuildStepsAreValid( logger, workspace, root_package_build_directory ) ||
		!UnifyDependenciesOnGlobalVersionedPackages( logger, workspace ) ||
		!RetrieveAndCheckWorkspaceTransitiveDependencies( logger, workspace ) )
	{
		logger.LogError( "Project dependencies aren't valid!" );
		return ust::null_optional;
	}

	return workspace;
}

// returns true on success.
fn nodiscard CreateWorkspaceBuildDirectories(
	Logger &mut logger, WorkspaceInfo& workspace, ust::filesystem_path_view root_package_build_directory ) : bool
{
	// Create directories for generated sources and headers, if necessary.
	foreach( &target_pair : workspace.build_targets )
	{
		auto& build_target_name= target_pair.key();
		auto& build_target= target_pair.value();
		if( !build_target.generated_source_files.empty() || !build_target.generated_private_header_files.empty() )
		{
			if( !EnsureDirectoryExists( logger, GetBuildTargetGeneratedSourcesDirectory( root_package_build_directory, build_target_name ) ) )
			{
				return false;
			}
		}
		if( !build_target.generated_public_header_files.empty() )
		{
			if( !EnsureDirectoryExists( logger, GetBuildTargetGeneratedPublicHeadersDirectory( root_package_build_directory, build_target_name ) ) )
			{
				return false;
			}
		}
	}

	return true;
}

fn CreateWorkspaceBuildTargetsGraphNodes(
	BuildSystemPaths& build_system_paths,
	ust::filesystem_path_view sysroot,
	ust::filesystem_path_view root_package_build_directory,
	BuildConfigurationExtended& build_configuration_extended,
	TargetTriple& target_triple,
	ust::string_view8 target_cpu,
	WorkspaceInfo& workspace,
	BuildGraph &mut build_graph )
{
	if( !workspace.build_targets.empty() )
	{
		// Build "ustlib" only if we have some build targets.
		CreateUstlibBuildGraphNodes(
			build_system_paths,
			sysroot,
			root_package_build_directory,
			build_configuration_extended,
			target_triple,
			target_cpu,
			build_graph );
	}

	// Collect and sort a list of build target names,
	// then iterate in this sorted order - to avoid generating build graph in non-deterministic hashtable order.
	var ust::vector</BuildTargetAbsoluteName/> mut build_target_names;
	foreach( &build_target_pair : workspace.build_targets )
	{
		build_target_names.push_back( build_target_pair.key() );
	}
	ust::sort( build_target_names );

	foreach( &build_target_name : build_target_names )
	{
		CreatePackageTargetBuildGraphNodes(
			build_system_paths,
			sysroot,
			root_package_build_directory,
			build_configuration_extended,
			target_triple,
			target_cpu,
			workspace,
			build_target_name,
			build_graph );
	}
}

fn CreatePackageTargetBuildGraphNodes(
	BuildSystemPaths& build_system_paths,
	ust::filesystem_path_view sysroot,
	ust::filesystem_path_view root_package_build_directory,
	BuildConfigurationExtended& build_configuration_extended,
	TargetTriple& target_triple,
	ust::string_view8 target_cpu,
	WorkspaceInfo& workspace,
	BuildTargetAbsoluteName& target_name,
	BuildGraph &mut build_graph )
{
	var bool target_is_windows = target_triple.operating_system == g_os_windows;

	var WorkspaceInfo::BuildTarget& target= workspace.build_targets[target_name];

	var ust::filesystem_path package_source_directory=
		GetPackageSourceDirectory( build_system_paths, target_name.package_name );

	var ust::filesystem_path package_build_directory=
		GetPackageBuildDirectory( root_package_build_directory, target_name.package_name );

	var ust::filesystem_path target_build_files_directory=
		GetBuildTargetBuildFilesDirectory( root_package_build_directory, target_name );

	// Retrieve include directories.
	var ust::vector</ust::string8/> mut include_directories_prefixed=
		ExtractBuildTargetIncludeDirectories( workspace, build_system_paths, target_name, target );

	var ust::filesystem_path sources_dir=
		( target.source_files.empty()
			? ust::filesystem_path()
			: ust::path::normalize( ust::path::join( package_source_directory, target.sources_directory ) ) );

	var ust::filesystem_path generated_sources_dir=
		( ( target.generated_source_files.empty() && target.generated_private_header_files.empty() )
			? ust::filesystem_path()
			: GetBuildTargetGeneratedSourcesDirectory( root_package_build_directory, target_name ) );

	var ust::vector</ust::filesystem_path/> mut generated_headers_dependencies;

	// Get generated private headers of this build target.
	foreach( &generated_private_header : target.generated_private_header_files )
	{
		generated_headers_dependencies.push_back( ust::path::normalize( ust::path::join( generated_sources_dir, generated_private_header ) ) );
	}

	// Get generated public headers of this build target and all dependencies of this build target.
	foreach( &build_target_name :
		ust::single_element_array_view( target_name ).iter()
		.chain( target.public_dependencies_including_transitive.iter() )
		.chain( (target.private_dependencies_including_transitive_public_dependencies.iter() ) ) )
	{
		auto& dependency_target = workspace.build_targets[ build_target_name ];
		if( !dependency_target.generated_public_header_files.empty() )
		{
			var ust::filesystem_path generated_public_headers_dir= GetBuildTargetGeneratedPublicHeadersDirectory( root_package_build_directory, build_target_name );
			foreach( &generated_public_header : dependency_target.generated_public_header_files )
			{
				generated_headers_dependencies.push_back( ust::path::normalize( ust::path::join( generated_public_headers_dir, generated_public_header ) ) );
			}

			include_directories_prefixed.push_back( ust::concat( generated_public_headers_dir, g_include_dir_prefix_separator, build_target_name.name ) );
		}
	}

	// Create nodes for compilation of each source file into a ".bc" file.
	var ust::vector</SourceFileToCompile/> mut source_files_to_compile;

	foreach( &source_file : target.source_files )
	{
		source_files_to_compile.push_back(
			SourceFileToCompile
			{
				.source_file_full_path= ust::path::normalize( ust::path::join( package_source_directory, source_file ) ),
				.bc_file_full_path=  ust::path::normalize( ust::concat( target_build_files_directory, "/", source_file, ".bc" ) ),
				.comment= source_file + ".bc",
			} );
	}

	if( !target.generated_source_files.empty() )
	{
		var ust::filesystem_path generated_sources_build_dir=
			GetBuildTargetGeneratedSourcesBuildDirectory( root_package_build_directory, target_name );

		foreach( &generated_source_file : target.generated_source_files )
		{
			source_files_to_compile.push_back(
				SourceFileToCompile
				{
					.source_file_full_path= ust::path::normalize( ust::path::join( generated_sources_dir, generated_source_file ) ),
					// Place "bc" files in separate build directory.
					.bc_file_full_path= ust::path::normalize( ust::concat( generated_sources_build_dir, "/", generated_source_file, ".bc" ) ),
					.comment= generated_source_file + ".bc",
				} );
		}
	}

	foreach( &source_file_to_compile : source_files_to_compile )
	{
		var BuildGraph::Node mut node
		{
			.program= build_system_paths.compiler_executable_path,
			// Use a dep-file to track changes in imported files and trigger rebuild if one of them is changed.
			.dep_file= GetDependencyFilePath( source_file_to_compile.bc_file_full_path ),
			.input_files= ust::make_array( source_file_to_compile.source_file_full_path ),
			.output_files= ust::make_array( source_file_to_compile.bc_file_full_path ),
			.comment= source_file_to_compile.comment,
		};

		// Add dependencies on generated headers of this build target and generated public headers of dependencies.
		// Do this in order to ensure headers are generated before this source file is compiled.
		node.input_files.append( generated_headers_dependencies.iter() );

		node.command_line.push_back( source_file_to_compile.source_file_full_path );

		if( !sysroot.empty() )
		{
			node.command_line.push_back( "--sysroot" );
			node.command_line.push_back( sysroot );
		}

		node.command_line.push_back( "-o" );
		node.command_line.push_back( source_file_to_compile.bc_file_full_path );

		// Produce also a dependency file.
		node.command_line.push_back( "-MF" );
		node.command_line.push_back( node.dep_file );


		foreach( &include_dir_prefixed : include_directories_prefixed )
		{
			node.command_line.push_back( "--include-dir" );
			node.command_line.push_back( include_dir_prefixed );
		}

		// Provide path to source directory (directories), in order to allow relative imports.
		if( !sources_dir.empty() )
		{
			node.command_line.push_back( "--source-dir" );
			node.command_line.push_back( sources_dir );
		}

		if( !generated_sources_dir.empty() )
		{
			node.command_line.push_back( "--source-dir" );
			node.command_line.push_back( generated_sources_dir );
		}

		if( !sources_dir.empty() )
		{
			// Allow importing files from sources directory using target name-prefixed path.
			node.command_line.push_back( "--include-dir" );
			node.command_line.push_back( ust::concat( sources_dir, g_include_dir_prefix_separator, target_name.name ) );
		}

		if( !generated_sources_dir.empty() )
		{
			// Allow importing files from generated sources directory using target name-prefixed path.
			node.command_line.push_back( "--include-dir" );
			node.command_line.push_back( ust::concat( generated_sources_dir, g_include_dir_prefix_separator, target_name.name ) );
		}

		// Forbid importing anything outside include directories and source directories.
		node.command_line.push_back( "--prevent-imports-outside-given-directories" );

		// Produce an LLVM bitcode file.
		node.command_line.push_back( "-filetype=bc" );

		if( !target_is_windows )
		{
			node.command_line.push_back( "--relocation-model" );
			node.command_line.push_back( "pic" );
		}

		// Build configuration-dependent options.
		switch( build_configuration_extended.build_configuration )
		{
			BuildConfiguration::Debug ->
			{
				// Generate debug information.
				node.command_line.push_back( "-g" );
				// No optimization at all - optimization makes debugging hard.
				node.command_line.push_back( "-O0" );
				// No LTO is used for debug builds.
			},
			BuildConfiguration::Release ->
			{
				// Run full optimization.
				switch( build_configuration_extended.release_optimization_level )
				{
					BuildConfigurationExtended::ReleaseOptimisationLevel::O2 -> { node.command_line.push_back( "-O2" ); },
					BuildConfigurationExtended::ReleaseOptimisationLevel::O3 -> { node.command_line.push_back( "-O3" ); },
				}
				// Prepare for LTO.
				node.command_line.push_back( "--lto-mode=prelink" );
			},
			BuildConfiguration::MinSizeRelease ->
			{
				// Run full optimization for size.
				switch( build_configuration_extended.min_size_release_optimization_level )
				{
					BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Os -> { node.command_line.push_back( "-Os" ); },
					BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Oz -> { node.command_line.push_back( "-Oz" ); },
				}
				// Prepare for LTO.
				node.command_line.push_back( "--lto-mode=prelink" );
			},
		}

		AddTargetTripleCompilerFlags( target_triple, node.command_line );
		SetTargetCPU( target_cpu, node.command_line );
		SetHaltMode( build_configuration_extended.halt_mode, node.command_line );

		// Perform verification just to be sure nothing is broken.
		node.command_line.push_back( "--verify-module" );

		build_graph.nodes.push_back( move(node) );
	}

	// Combine multiple ".bc" files into single result.

	var ust::filesystem_path mut result_target_file_path= package_build_directory;
	ust::path::append( result_target_file_path, target_name.name );

	switch( target.target_type )
	{
		BuildTargetType::Executable ->
		{
			if( target_is_windows )
			{
				result_target_file_path+= ".exe";
			}
		},
		BuildTargetType::Library ->
		{
			result_target_file_path+= ".bc";
		},
		BuildTargetType::SharedLibrary ->
		{
			if( target_is_windows )
			{
				result_target_file_path+= ".dll";
			}
			else if( target_triple.vendor == g_vendor_apple )
			{
				result_target_file_path+= ".dylib";
			}
			else
			{
				result_target_file_path+= ".so";
			}
		},
		BuildTargetType::ObjectFile ->
		{
			result_target_file_path+= ".o";
		},
	}

	result_target_file_path= ust::path::normalize( result_target_file_path );

	var BuildGraph::Node mut node
	{
		.program= build_system_paths.compiler_executable_path,
		// Dep-files are needed only for cases where dependencies can't be specified statically, like for imports.
		// For an end-target like an executable dep-files isn't necessary.
		.dep_file= "",
		.output_files= ust::make_array( result_target_file_path ),
		.comment= target_name.name, // TODO - prefix with package name/path
	};

	if( !sysroot.empty() )
	{
		node.command_line.push_back( "--sysroot" );
		node.command_line.push_back( sysroot );
	}

	if( target.target_type == BuildTargetType::SharedLibrary )
	{
		if( target_is_windows )
		{
			// Add also ".lib" file to outputs.
			// This file is implicitly created by the linker.
			var ust::filesystem_path lib_name = ust::path::normalize( ust::concat( package_build_directory, "/", target_name.name, ".lib" ) );
			node.output_files.push_back( lib_name );

			if( target_triple.environment == g_environment_gnu )
			{
				// MinGW linker requires a special option to produce such library.
				node.command_line.push_back( "-Wl,--out-implib," + lib_name );
			}
		}
		else if( target_triple.vendor == g_vendor_apple )
		{
			// Specify install name with "@rpath" prefix, so that this prefixed name is used in result executables/dynamic libraries, which depend on this shared library.
			node.command_line.push_back( ust::concat( "-Wl,-dylib_install_name,@rpath/", target_name.name, ".dylib" ) );
		}
		else
		{
			// Specify soname, in order to load libraries using only name and not the full path to the library provided to the linker.
			node.command_line.push_back( ust::concat( "-Wl,-soname,", target_name.name, ".so" ) );
		}
	}

	foreach( &source_file_to_compile : source_files_to_compile )
	{
		node.command_line.push_back( source_file_to_compile.bc_file_full_path );
		node.input_files.push_back( source_file_to_compile.bc_file_full_path );
	}

	// Link public dependencies.
	switch( target.target_type )
	{
		BuildTargetType::Executable,
		BuildTargetType::SharedLibrary,
		BuildTargetType::ObjectFile ->
		{
			// For executables, shared libraries and object files perform linking with all public dependency libraries.
			foreach( &public_dependency : target.public_dependencies_including_transitive )
			{
				if( IsPublicDependencyOfDirectPublicSharedLibraryDependency( workspace, target, public_dependency ) )
				{
					// An optimization for result binary size.
					// If this dependency is also a public dependency of a direct shared library dependency,
					// we don't need to link this dependency, since all symbols of this dependency will be exposed and obtained from such shared library.
					// Generally a deeper analysis is required here to remove unnecessary libraries in all cases.
					continue;
				}

				if( workspace.build_targets[ public_dependency ].target_type == BuildTargetType::Library )
				{
					var ust::filesystem_path mut lib_file=
						ust::path::normalize( ust::concat(
							GetPackageBuildDirectory( root_package_build_directory, public_dependency.package_name ),
							"/",
							public_dependency.name,
							".bc" ) );

					node.command_line.push_back( lib_file );
					node.input_files.push_back( move(lib_file) );
				}
			}
		},
		BuildTargetType::Library ->
		{
			// Do not link public dependencies in libraries.
			// Instead propatage them to the terminal target - executable or shared library.
		},
	}

	// For all build target types link private library dependencies.
	// Link also all transitive public dependencies of these private dependencies.
	// Exception are libraries which are also public dependencies of this build target, they are not listed here.
	foreach( &private_dependency : target.private_dependencies_including_transitive_public_dependencies )
	{
		if( IsPublicDependencyOfSomeLinkedSharedLibrary( workspace, target, private_dependency ) )
		{
			// An optimization for result binary size.
			// If this dependency is also a public dependency of some shared library, which is linked against this build target,
			// we don't need to link this dependency, since all symbols of this dependency will be exposed and obtained from such shared library.
			continue;
		}

		if( workspace.build_targets[ private_dependency ].target_type == BuildTargetType::Library )
		{
			var ust::filesystem_path mut lib_file=
				ust::path::normalize( ust::concat(
					GetPackageBuildDirectory( root_package_build_directory, private_dependency.package_name ),
					"/",
					private_dependency.name,
					".bc" ) );

			node.command_line.push_back( lib_file );
			node.input_files.push_back( lib_file );

			// Internalize all functions from private dependencies.
			node.command_line.push_back( "--internalize-functions-from" );
			node.command_line.push_back( move(lib_file) );
		}
	}

	// Link ustlib.
	switch( target.target_type )
	{
		BuildTargetType::Executable, BuildTargetType::SharedLibrary, BuildTargetType::ObjectFile ->
		{
			// Link ustlib into build targets with binary code.
			var ust::filesystem_path mut bc_file= GetCompiledUstlibPath( root_package_build_directory );
			node.command_line.push_back( bc_file );
			node.input_files.push_back( bc_file );
			// Internalize all functions from ustlib.
			node.command_line.push_back( "--internalize-functions-from" );
			node.command_line.push_back( move(bc_file) );
		},
		BuildTargetType::Library -> { /* It's not necessary to link bitcode libraries against ustlib. */ },
	}

	// Link against system libraries required by "ustlib".
	switch( target.target_type )
	{
		BuildTargetType::Executable, BuildTargetType::SharedLibrary ->
		{
			foreach( &lib : GetUstlibSystemLibrariesToLink( target_triple ) )
			{
				node.command_line.push_back( "-Wl," + lib );
			}
		},
		BuildTargetType::Library, BuildTargetType::ObjectFile -> {},
	}

	// Link shared library dependencies.
	switch( target.target_type )
	{
		BuildTargetType::Executable,
		BuildTargetType::SharedLibrary ->
		{
			foreach( &shared_library_dependency : target.shared_library_dependencies_to_link )
			{
				var ust::filesystem_path mut file_to_link= ust::path::join(
					GetPackageBuildDirectory( root_package_build_directory, shared_library_dependency.package_name ),
					shared_library_dependency.name );

				if( target_is_windows )
				{
					// Windows dynamic libraries aren't linked directly, a proxy static library is used instead.
					var ust::filesystem_path mut lib_file= ust::path::normalize( file_to_link + ".lib" );
					node.command_line.push_back( "-Wl," + lib_file );
					node.input_files.push_back( move(lib_file) );
				}
				else if( target_triple.vendor == g_vendor_apple )
				{
					// Darwin shared libraries are specified directly.
					var ust::filesystem_path mut dylib_file= ust::path::normalize( file_to_link + ".dylib" );
					node.command_line.push_back( "-Wl," + dylib_file );
					node.input_files.push_back( move(dylib_file) );
				}
				else
				{
					// Unix shared libraries are specified directly.
					var ust::filesystem_path mut so_file= ust::path::normalize( file_to_link + ".so" );
					node.command_line.push_back( "-Wl," + so_file );
					node.input_files.push_back( move(so_file) );
				}
			}

			if( !target.shared_library_dependencies_to_link.empty() )
			{
				if( target_is_windows )
				{
					// Windows doesn't support "rpath".
				}
				else if( target_triple.vendor == g_vendor_apple )
				{
					// For now set "rpath" to loader_path - in order to have possibility to load shared libraries from common directory with all build targets.
					node.command_line.push_back( "-Wl,-rpath,@loader_path" );
				}
				else
				{
					// For now set "rpath" to origin - in order to have possibility to load shared libraries from common directory with all build targets.
					node.command_line.push_back( "-Wl,-rpath,$ORIGIN" );
				}
			}
		},
		BuildTargetType::Library -> {}, // No need to link Ü libraries against shared libraries.
		BuildTargetType::ObjectFile -> {}, // No need to link object files against shared libraries.
	}

	// Link external library dependencies.
	switch( target.target_type )
	{
		BuildTargetType::Executable,
		BuildTargetType::SharedLibrary ->
		{
			foreach( &external_library : target.all_external_libraries_to_link )
			{
				node.command_line.push_back( "-Wl," + external_library );
				if( ust::path::is_absolute( external_library ) )
				{
					node.input_files.push_back( external_library );
				}
				else
				{
					// Assume that non-absolute external libraries are system libraries loaded from known system directories.
					// Examples are "pthread", "kernel32".
					// In such case we don't need to track changes in these files - assume they are immutable and thus no needed to be listed in input files.
				}
			}
		},
		BuildTargetType::Library -> {}, // No need to link Ü libraries against external libraries.
		BuildTargetType::ObjectFile -> {}, // No need to link object files against external libraries.
	}

	node.command_line.push_back( "-o" );
	node.command_line.push_back( result_target_file_path );

	// Read LLVM bitcode files (use the Ü compiler as bitcode files compiler).
	node.command_line.push_back( "--input-filetype=bc" );

	switch( target.target_type )
	{
		BuildTargetType::Executable ->
		{
			// This requires compiler to be built with internal LLD (for now we don't support external linkers).
			node.command_line.push_back( "-filetype=exe" );
		},
		BuildTargetType::Library ->
		{
			// Produce bitcode file.
			node.command_line.push_back( "-filetype=bc" );
		},
		BuildTargetType::SharedLibrary ->
		{
			// Produce shared librart file.
			// This requires compiler to be built with internal LLD (for now we don't support external linkers).
			node.command_line.push_back( "-filetype=dll" );
		},
		BuildTargetType::ObjectFile ->
		{
			// Produce object file.
			node.command_line.push_back( "-filetype=obj" );
		},
	}

	// Internalization.
	switch( target.target_type )
	{
		BuildTargetType::Executable ->
		{
			// Run full internalization in order to export only "main".
			node.command_line.push_back( "--internalize" );
		},
		BuildTargetType::Library ->
		{
			// Internalize hidden functions - to hide functions which shouldn't be available outside this library.
			node.command_line.push_back( "--internalize-hidden-functions" );
		},
		BuildTargetType::SharedLibrary ->
		{
			// Run internalization of hidden functions, preserve others in order to export them.
			node.command_line.push_back( "--internalize-hidden-functions" );
		},
		BuildTargetType::ObjectFile ->
		{
			// Run internalization of hidden functions, preserve others, in order to access them by external code using this object file.
			node.command_line.push_back( "--internalize-hidden-functions" );
		},
	}

	if( !target_is_windows )
	{
		node.command_line.push_back( "--relocation-model" );
		node.command_line.push_back( "pic" );
	}

	// Build configuration-dependent options.
	switch( build_configuration_extended.build_configuration )
	{
		BuildConfiguration::Debug ->
		{
			// Generate debug information.
			node.command_line.push_back( "-g" );
			// No optimization at all - optimization makes debugging hard.
			node.command_line.push_back( "-O0" );
			// No LTO is used for debug builds.
		},
		BuildConfiguration::Release ->
		{
			if( target.target_type == BuildTargetType::Library )
			{
				// Do not run optimization for library targets.
				// Individual optimization of their source files was performed earlier.
				// Full optimization will be performed while using this library in some other target kind, like in executable.
			}
			else
			{
				// Run full optimization.
				switch( build_configuration_extended.release_optimization_level )
				{
					BuildConfigurationExtended::ReleaseOptimisationLevel::O2 -> { node.command_line.push_back( "-O2" ); },
					BuildConfigurationExtended::ReleaseOptimisationLevel::O3 -> { node.command_line.push_back( "-O3" ); },
				}
				// Also run LTO.
				node.command_line.push_back( "--lto-mode=link" );

				// Put symbols into sections and remove unnecessary ones.
				AddGCSectionsCompilerFlags( target_triple, node.command_line );
			}
		},
		BuildConfiguration::MinSizeRelease ->
		{
			if( target.target_type == BuildTargetType::Library )
			{
				// Do not run optimization for library targets.
				// Individual optimization of their source files was performed earlier.
				// Full optimization will be performed while using this library in some other target kind, like in executable.
			}
			else
			{
				// Run full optimization for size.
				switch( build_configuration_extended.min_size_release_optimization_level )
				{
					BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Os -> { node.command_line.push_back( "-Os" ); },
					BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Oz -> { node.command_line.push_back( "-Oz" ); },
				}
				// Also run LTO.
				node.command_line.push_back( "--lto-mode=link" );

				// Put symbols into sections and remove unnecessary ones.
				AddGCSectionsCompilerFlags( target_triple, node.command_line );
			}
		},
	}

	AddTargetTripleCompilerFlags( target_triple, node.command_line );
	SetTargetCPU( target_cpu, node.command_line );
	SetHaltMode( build_configuration_extended.halt_mode, node.command_line );

	// Perform verification just to be sure nothing is broken.
	node.command_line.push_back( "--verify-module" );

	build_graph.nodes.push_back( move(node) );
}

struct SourceFileToCompile
{
	ust::filesystem_path source_file_full_path;
	ust::filesystem_path bc_file_full_path;
	ust::string8 comment;
}

fn GetCompiledUstlibPath( ust::filesystem_path_view root_package_build_directory ) : ust::filesystem_path
{
	return ust::path::normalize( ust::path::join( root_package_build_directory, "ustlib.bc" ) );
}

// Returns list of relative paths.
fn GetUstlibSourcesList( TargetTriple& target_triple ) : ust::vector</ust::filesystem_path/>
{
	// Hardcode all files that we need to compile. There is no other way to do this.
	// It's not possible to use a usual build script for ustlib, since building it requires building ustlib first.

	var [ ust::filesystem_path_view, 7 ] sources_common
	[
		"arena_allocator.u",
		"file_helpers.u",
		"inet_address.u",
		"integer_parsing.u",
		"stdin.u",
		"string_conversions.u",
		"utf.u",
	];

	var [ ust::filesystem_path_view, 19 ] sources_windows
	[
		"windows/barrier_impl.u",
		"windows/condition_variable_impl.u",
		"windows/environment.u",
		"windows/filesystem.u",
		"windows/inet_address_resolve.u",
		"windows/main_wrapper.u",
		"windows/math_missing_functions.u",
		"windows/mutex_impl.u",
		"windows/path_utils.u",
		"windows/rwlock_impl.u",
		"windows/semaphore_impl.u",
		"windows/sleep.u",
		"windows/socket.u",
		"windows/stdout.u",
		"windows/system_time.u",
		"windows/tcp_listener.u",
		"windows/tcp_stream.u",
		"windows/thread_impl.u",
		"windows/udp_socket.u",
	];

	var [ ust::filesystem_path_view, 19 ] sources_unix
	[
		"unix/barrier_impl.u",
		"unix/condition_variable_impl.u",
		"unix/environment.u",
		"unix/errno.u",
		"unix/filesystem.u",
		"unix/inet_address_resolve.u",
		"unix/main_wrapper.u",
		"unix/mutex_impl.u",
		"unix/path_utils.u",
		"unix/rwlock_impl.u",
		"unix/semaphore_impl.u",
		"unix/sleep.u",
		"unix/socket.u",
		"unix/stdout.u",
		"unix/system_time.u",
		"unix/tcp_listener.u",
		"unix/tcp_stream.u",
		"unix/thread_impl.u",
		"unix/udp_socket.u",
	];

	var ust::vector</ust::filesystem_path/> mut res;
	foreach( &s : sources_common )
	{
		res.push_back(s);
	}

	if( target_triple.operating_system == g_os_windows )
	{
		foreach( &s : sources_windows )
		{
			res.push_back(s);
		}
	}
	else
	{
		foreach( &s : sources_unix )
		{
			res.push_back(s);
		}
	}

	return res;
}

fn GetUstlibSystemLibrariesToLink( TargetTriple& target_triple ) : ust::vector</ust::string8/>
{
	if( target_triple.operating_system == g_os_windows )
	{
		return ust::make_array</ust::string8/>( "Ws2_32.lib" );
	}
	else
	{
		return ust::make_array</ust::string8/>( "-lpthread" );
	}
}

fn CreateUstlibBuildGraphNodes(
	BuildSystemPaths& build_system_paths,
	ust::filesystem_path_view sysroot,
	ust::filesystem_path_view root_package_build_directory,
	BuildConfigurationExtended& build_configuration_extended,
	TargetTriple& target_triple,
	ust::string_view8 target_cpu,
	BuildGraph &mut build_graph )
{
	var ust::filesystem_path out_file= GetCompiledUstlibPath( root_package_build_directory );

	var BuildGraph::Node mut node
	{
		.program= build_system_paths.compiler_executable_path,
		.output_files= ust::make_array( out_file ),
		.dep_file= GetDependencyFilePath( out_file ),
		.comment= "ustlib",
	};

	node.command_line.push_back( "-o" );
	node.command_line.push_back( out_file );
	node.command_line.push_back( "-filetype=bc" );

	node.command_line.push_back( "-MF" );
	node.command_line.push_back( node.dep_file );

	node.command_line.push_back( "--source-dir" );
	node.command_line.push_back( build_system_paths.ustlib_path );

	// Forbid importing anything outside include directories and source directories.
	node.command_line.push_back( "--prevent-imports-outside-given-directories" );

	// Just compile all sources in one compile invocation.
	// Since ustlib is usually never changes, it's easier to do this, complared to separate compilation of each source file.
	foreach( &source : GetUstlibSourcesList( target_triple ) )
	{
		var ust::filesystem_path file_path= ust::path::normalize( ust::path::join( build_system_paths.ustlib_path, g_ustlib_sources_subpath, source ) );
		node.input_files.push_back( file_path );
		node.command_line.push_back( file_path );
	}

	if( target_triple.operating_system != g_os_windows )
	{
		node.command_line.push_back( "--relocation-model" );
		node.command_line.push_back( "pic" );
	}

	// Build configuration-dependent options.
	switch( build_configuration_extended.build_configuration )
	{
		BuildConfiguration::Debug ->
		{
			// Generate debug information.
			node.command_line.push_back( "-g" );
			// No optimization at all - optimization makes debugging hard.
			node.command_line.push_back( "-O0" );
			// No LTO is used for debug builds.
		},
		BuildConfiguration::Release ->
		{
			// Run full optimizations.
			switch( build_configuration_extended.release_optimization_level )
			{
				BuildConfigurationExtended::ReleaseOptimisationLevel::O2 -> { node.command_line.push_back( "-O2" ); },
				BuildConfigurationExtended::ReleaseOptimisationLevel::O3 -> { node.command_line.push_back( "-O3" ); },
			}
			// Also prepare for further LTO.
			node.command_line.push_back( "--lto-mode=prelink" );
		},
		BuildConfiguration::MinSizeRelease ->
		{
			// Run full optimization for size.
			switch( build_configuration_extended.min_size_release_optimization_level )
			{
				BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Os -> { node.command_line.push_back( "-Os" ); },
				BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Oz -> { node.command_line.push_back( "-Oz" ); },
			}
			// Also prepare for further LTO.
			node.command_line.push_back( "--lto-mode=prelink" );
		},
	}

	if( !sysroot.empty() )
	{
		node.command_line.push_back( "--sysroot" );
		node.command_line.push_back( sysroot );
	}

	AddTargetTripleCompilerFlags( target_triple, node.command_line );
	SetTargetCPU( target_cpu, node.command_line );
	SetHaltMode( build_configuration_extended.halt_mode, node.command_line );

	// Perform verification just to be sure nothing is broken.
	node.command_line.push_back( "--verify-module" );

	build_graph.nodes.push_back( move(node) );
}

fn AddTargetTripleCompilerFlags( TargetTriple& target_triple, ust::vector</ust::string8/> &mut compiler_flags )
{
	compiler_flags.push_back( "--target-arch" );
	compiler_flags.push_back( target_triple.architecture );

	compiler_flags.push_back( "--target-vendor" );
	compiler_flags.push_back( target_triple.vendor );

	compiler_flags.push_back( "--target-os" );
	compiler_flags.push_back( target_triple.operating_system );

	compiler_flags.push_back( "--target-environment" );
	compiler_flags.push_back( target_triple.environment );
}

fn SetTargetCPU( ust::string_view8 target_cpu, ust::vector</ust::string8/> &mut compiler_flags )
{
	if( !target_cpu.empty() )
	{
		compiler_flags.push_back( ust::concat( "-mcpu=", target_cpu ) );
	}
}

fn SetHaltMode( BuildConfigurationExtended::HaltMode halt_mode, ust::vector</ust::string8/> &mut compiler_flags )
{
	switch( halt_mode )
	{
		BuildConfigurationExtended::HaltMode::trap -> { compiler_flags.push_back( "--halt-mode=trap" ); },
		BuildConfigurationExtended::HaltMode::abort -> { compiler_flags.push_back( "--halt-mode=abort" ); },
		BuildConfigurationExtended::HaltMode::configurable_handler -> { compiler_flags.push_back( "--halt-mode=configurable_handler" ); },
		BuildConfigurationExtended::HaltMode::unreachable -> { compiler_flags.push_back( "--halt-mode=unreachable" ); },
	}
}

fn AddGCSectionsCompilerFlags( TargetTriple& target_triple, ust::vector</ust::string8/> &mut compiler_flags )
{
	compiler_flags.push_back( "--function-sections" );
	compiler_flags.push_back( "--data-sections" );
	if( target_triple.operating_system != g_os_windows || target_triple.environment == g_environment_gnu )
	{
		if( target_triple.vendor != g_vendor_apple )
		{
			compiler_flags.push_back( "-Wl,--gc-sections" );
		}
	}
}

fn CreateCustomBuildStepBuildGraphNodes(
	TargetTriple& host_target_triple,
	ust::filesystem_path_view host_packages_root_build_directory,
	WorkspaceInfo::CustomBuildStep& custom_build_step,
	BuildGraph &mut build_graph )
{
	// Paths should be already normalized.
	var BuildGraph::Node mut node
	{
		.input_files= custom_build_step.input_files,
		.output_files= custom_build_step.output_files,
		.comment= custom_build_step.comment,
		// TODO - add possibility to set dep-file
	};

	if_var( &exe_command : custom_build_step.command.get</ CustomBuildStep::ExeCommand />() )
	{
		node.program= exe_command.exe_path;
		node.command_line= exe_command.command_line;
	}
	else if_var( &host_build_target_exe_command : custom_build_step.command.get</ WorkspaceInfo::CustomBuildStep::HostBuildTargetExeCommand />() )
	{
		// Existence of the corresponding build target in the host workspace should be checked previously.
		node.program=
			ust::path::normalize( ust::concat(
				GetPackageBuildDirectory( host_packages_root_build_directory, host_build_target_exe_command.name.package_name ),
				"/",
				host_build_target_exe_command.name.name,
				( host_target_triple.operating_system == g_os_windows ? ust::string_view8(".exe") : ust::string_view8() ) ) );
		node.command_line= host_build_target_exe_command.command_line;
	}
	else if_var( &copy_command : custom_build_step.command.get</ CustomBuildStep::CopyCommand />() )
	{
		node.program= SpecialBuildCommands::copy_file;
		node.command_line= ust::make_array( copy_command.destination_path, copy_command.source_path );
	}
	else if_var( &generate_command : custom_build_step.command.get</ CustomBuildStep::GenerateFileCommand />() )
	{
		node.program= SpecialBuildCommands::generate_file;
		node.command_line= ust::make_array( generate_command.destination_path, generate_command.contents );
	}
	else
	{
		// Unhadled kind of command.
		halt;
	}

	build_graph.nodes.push_back( move(node) );
}

fn IsPublicDependencyOfDirectPublicSharedLibraryDependency(
	WorkspaceInfo& workspace,
	WorkspaceInfo::BuildTarget& build_target,
	BuildTargetAbsoluteName& dependency ) : bool
{
	foreach( &public_dependency : build_target.public_dependencies )
	{
		auto& public_dependency_build_target = workspace.build_targets[ public_dependency ];
		if( public_dependency_build_target.target_type == BuildTargetType::SharedLibrary )
		{
			foreach( &shared_library_public_dependency : public_dependency_build_target.public_dependencies_including_transitive )
			{
				if( dependency == shared_library_public_dependency )
				{
					return true;
				}
			}
		}
	}

	return false;
}

fn IsPublicDependencyOfSomeLinkedSharedLibrary(
	WorkspaceInfo& workspace,
	WorkspaceInfo::BuildTarget& build_target,
	BuildTargetAbsoluteName& dependency ) : bool
{
	foreach( &shared_library_dependency : build_target.shared_library_dependencies_to_link )
	{
		foreach( &shared_library_public_dependency : workspace.build_targets[ shared_library_dependency ].public_dependencies_including_transitive )
		{
			if( dependency == shared_library_public_dependency )
			{
				return true;
			}
		}
	}

	return false;
}

fn GetCompiledForBuildScriptsUstlibPath( ust::filesystem_path_view build_directory_base ) : ust::filesystem_path
{
	return ust::path::normalize( ust::path::join( build_directory_base, "ustlib.o" ) );
}

fn nodiscard BuildUstlibForBuildScripts(
	Logger &mut logger,
	BuildSystemPaths& build_system_paths,
	ust::filesystem_path_view host_sysroot,
	ust::filesystem_path_view build_directory_base ) : bool
{
	var ust::filesystem_path out_file_path= GetCompiledForBuildScriptsUstlibPath( build_directory_base );
	var ust::filesystem_path out_dep_file_path = GetDependencyFilePath( out_file_path );

	if( CheckRebuildIsNeededBasedOnDepFile( logger, out_dep_file_path ) )
	{
		var TargetTriple host_target_triple= GetHostTargetTriple();

		logger.LogVerbose( ust::concat( "Building \"", out_file_path, "\"." ) );

		var ust::vector</ust::string8/> mut compiler_args;

		compiler_args.push_back( "-o" );
		compiler_args.push_back( out_file_path );

		compiler_args.push_back( "-MF" );
		compiler_args.push_back( out_dep_file_path );

		// Build into an object file, to simplify building of build script shared libraries.
		// Such an object file may be simply linked by internal LLD.
		// It's suboptimal, since no inlining can be performed, but still fine for build scripts, where a lot of performance isn't necessary.
		compiler_args.push_back( "-filetype=obj" );

		foreach( &source : GetUstlibSourcesList( host_target_triple ) )
		{
			compiler_args.push_back( ust::path::join( build_system_paths.ustlib_path, g_ustlib_sources_subpath, source ) );
		}

		compiler_args.push_back( "--source-dir" );
		compiler_args.push_back( build_system_paths.ustlib_path );

		// Forbid importing anything outside include directories and source directories.
		compiler_args.push_back( "--prevent-imports-outside-given-directories" );

		// Use "abort-based" halt mode - in order to handle halts in build scripts gracefully.
		// It's fine if this mode differs from halt mode in build system executable.
		SetHaltMode( BuildConfigurationExtended::HaltMode::abort, compiler_args );

		// Use optimization level which was used to compile the build system executable.
		compiler_args.push_back( ust::concat( "-O", ust::single_element_array_view( compiler::options::optimization_level ) ) );

		// If the build system executable was compiled with debug information - generate it for ustlib for build scripts too.
		if( compiler::options::generate_debug_info )
		{
			compiler_args.push_back( "-g" );
		}

		// Use the same target parameters for compilation of ustlib for build scripts as for the build system executable.
		compiler_args.push_back( "--target-arch" );
		compiler_args.push_back( compiler::target::arch );

		compiler_args.push_back( "--target-vendor" );
		compiler_args.push_back( compiler::target::vendor );

		compiler_args.push_back( "--target-os" );
		compiler_args.push_back( compiler::target::os );

		compiler_args.push_back( "--target-environment" );
		compiler_args.push_back( compiler::target::environment );

		if( ust::string_view8( compiler::target::os ) != g_os_windows )
		{
			// It seems that position-independent code is always enabled on systems except Windows.
			// So, use this option for building the shared library.
			compiler_args.push_back( "--relocation-model" );
			compiler_args.push_back( "pic" );
		}

		// Put symbols into sections in order to allow removing unnecessary ones.
		AddGCSectionsCompilerFlags( host_target_triple, compiler_args );

		// Use host sysroot for building ustlib for build scripts.
		if( !host_sysroot.empty() )
		{
			compiler_args.push_back( "--sysroot" );
			compiler_args.push_back( host_sysroot );
		}

		return RunExecutable( logger, build_system_paths.compiler_executable_path, compiler_args );
	}
	else
	{
		logger.LogVerbose( ust::concat( "Skip building \"", out_file_path,  "\"." ) );
		return true;
	}
}

fn nodiscard BuildSingleFileProgram(
	Logger &mut logger,
	ust::filesystem_path_view source_file_path,
	BuildSystemPaths& build_system_paths,
	ust::filesystem_path_view sysroot,
	ust::filesystem_path_view build_directory,
	BuildConfigurationExtended& build_configuration_extended,
	TargetTriple& target_triple,
	ust::string_view8 target_cpu ) : bool
{
	var bool target_is_windows = target_triple.operating_system == g_os_windows;

	var ust::filesystem_path source_file_path_absolute= MakePathAbsolute( source_file_path );

	var ust::optional</ust::filesystem_path_view/> source_file_name= ust::path::get_file_name( source_file_path_absolute );
	if( source_file_name.empty() )
	{
		logger.LogError( ust::concat( "No file name can be extracted for \"", source_file_path_absolute, "\"!" ) );
		return false;
	}

	var ust::filesystem_path_view base_name= ust::path::get_path_without_extension( source_file_name.try_deref() );

	var ust::filesystem_path mut out_file_path= ust::path::normalize( ust::path::join( build_directory, base_name ) );
	if( target_is_windows )
	{
		out_file_path+= ".exe";
	}

	logger.LogInfo( ust::concat( "Building single source \"", source_file_path_absolute, "\" into \"", out_file_path, "\"." ) );

	var ust::vector</ust::string8/> mut compiler_args;

	compiler_args.push_back( source_file_path_absolute );

	// Compile also all "ustlib" sources in the same compiler invocation.
	foreach( &source : GetUstlibSourcesList( target_triple ) )
	{
		compiler_args.push_back( ust::path::join( build_system_paths.ustlib_path, g_ustlib_sources_subpath, source ) );
	}

	// Link against system libraries required by "ustlib".
	foreach( &lib : GetUstlibSystemLibrariesToLink( target_triple ) )
	{
		compiler_args.push_back( "-Wl," + lib );
	}

	// The only include directory that we require is "ustlib".
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( ust::path::join( build_system_paths.ustlib_path, g_ustlib_imports_subpath ) );

	// Don't bother limiting imports in single-source programs.
	// Also don't care about source directory specifying - it's unnecessary, since we internalize all symbols anyway.

	compiler_args.push_back( "-o" );
	compiler_args.push_back( move(out_file_path) );

	compiler_args.push_back( "-filetype=exe" );

	if( !target_is_windows )
	{
		compiler_args.push_back( "--relocation-model" );
		compiler_args.push_back( "pic" );
	}

	// Internalize - make all symbols except "main" private.
	compiler_args.push_back( "--internalize" );

	AddTargetTripleCompilerFlags( target_triple, compiler_args );
	SetTargetCPU( target_cpu, compiler_args );
	SetHaltMode( build_configuration_extended.halt_mode, compiler_args );

	switch( build_configuration_extended.build_configuration )
	{
		BuildConfiguration::Debug ->
		{
			compiler_args.push_back( "-O0" );
			compiler_args.push_back( "-g" );
		},
		BuildConfiguration::Release ->
		{
			switch( build_configuration_extended.release_optimization_level )
			{
				BuildConfigurationExtended::ReleaseOptimisationLevel::O2 -> { compiler_args.push_back( "-O2" ); },
				BuildConfigurationExtended::ReleaseOptimisationLevel::O3 -> { compiler_args.push_back( "-O3" ); },
			}
		},
		BuildConfiguration::MinSizeRelease ->
		{
			switch( build_configuration_extended.min_size_release_optimization_level )
			{
				BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Os -> { compiler_args.push_back( "-Os" ); },
				BuildConfigurationExtended::MinSizeReleaseOptimizationLevel::Oz -> { compiler_args.push_back( "-Oz" ); },
			}
		},
	}

	if( !sysroot.empty() )
	{
		compiler_args.push_back( "--sysroot" );
		compiler_args.push_back( sysroot );
	}

	return RunExecutable( logger, build_system_paths.compiler_executable_path, compiler_args );
}

class BuildSystemInterfaceImplementation final : BuildSystemInterface
{
public:
	fn constructor(
		Logger mut logger,
		BuildConfigurationExtended build_configuration_extended,
		ConfigurationOptions mut configuration_options,
		BuildSystemPaths mut build_system_paths )
			(
				logger_= move(logger),
				build_configuration_extended_= build_configuration_extended,
				configuration_options_= move(configuration_options),
				build_system_paths_= move(build_system_paths),
			)
	{}

	fn SetTargetTriple( mut this, TargetTriple mut target_triple )
	{
		target_triple_= move(target_triple);
	}

	fn SetRootPackageBuildDirectory( mut this, ust::filesystem_path mut root_package_build_directory )
	{
		root_package_build_directory_= move(root_package_build_directory);
	}

	fn SetCurrentPackageName( mut this, PackageAbsoluteName mut name )
	{
		current_package_name_= move(name);
	}

public: // BuildSystemInterface
	fn virtual final GetBuildConfiguration(this) : BuildConfiguration
	{
		return build_configuration_extended_.build_configuration;
	}

	fn virtual final GetTargetTriple(this) : TargetTriple
	{
		return target_triple_;
	}

	fn virtual final LogVerbose( mut this, ust::string_view8 message )
	{
		logger_.LogVerbose( message );
	}

	fn virtual final LogInfo( mut this, ust::string_view8 message )
	{
		logger_.LogInfo( message );
	}

	fn virtual final LogError( mut this, ust::string_view8 message )
	{
		logger_.LogError( message );
	}

	fn virtual final GetBuildSystemExecutablePath( this ) : ust::filesystem_path
	{
		return build_system_paths_.build_system_executable_path;
	}

	fn virtual final GetCompilerExecutablePath( this ) : ust::filesystem_path
	{
		return build_system_paths_.compiler_executable_path;
	}

	fn virtual final GetConfigurationOption( this, ust::string_view8 name ) : ust::optional</ust::string8/>
	{
		if_var( &option_value : configuration_options_.find(name) )
		{
			return option_value;
		}
		return ust::null_optional;
	}

	fn virtual final GetCurrentPackageSourceDirectory( this ) : ust::filesystem_path
	{
		return GetPackageSourceDirectory( build_system_paths_, current_package_name_ );
	}

	fn virtual final GetCurrentPackageBuildDirectory( this ) : ust::filesystem_path
	{
		return GetPackageBuildDirectory( root_package_build_directory_, current_package_name_ );
	}

	fn virtual final GetCurrentPackageBuildTargetGeneratedSourcesDirectory( this, ust::string_view8 build_target_name ): ust::filesystem_path
	{
		return
			GetBuildTargetGeneratedSourcesDirectory(
				root_package_build_directory_,
				BuildTargetAbsoluteName{ .package_name= current_package_name_, .name= build_target_name } );
	}

	fn virtual final GetCurrentPackageBuildTargetGeneratedPublicHeadersDirectory( this, ust::string_view8 build_target_name ) : ust::filesystem_path
	{
		return
			GetBuildTargetGeneratedPublicHeadersDirectory(
				root_package_build_directory_,
				BuildTargetAbsoluteName{ .package_name= current_package_name_, .name= build_target_name } );
	}

public: // Provide direct access for some fields where it's safe to use them directly.
	Logger logger_;

	BuildConfigurationExtended imut build_configuration_extended_;
	BuildSystemPaths imut build_system_paths_;

private:
	ConfigurationOptions imut configuration_options_;

	TargetTriple target_triple_; // May be changed because of target/host system switching.
	ust::filesystem_path root_package_build_directory_; // May be changed because of target/host system switching.

	PackageAbsoluteName current_package_name_;
}

} // namespace BK
