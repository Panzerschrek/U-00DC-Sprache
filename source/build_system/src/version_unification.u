import "/sort.u"
import "/unordered_set.u"
import "version_unification.uh"

namespace BK
{

fn UnifyDependenciesOnGlobalVersionedPackages( Logger &mut logger, WorkspaceInfo &mut workspace ) : bool
{
	// Collect list of build targets of global versioned packages first.
	var ust::vector</GlobalPackageBuildTargetName/> mut global_packages_build_targets;

	foreach( &pair : workspace.build_targets )
	{
		var BuildTargetAbsoluteName& build_target_name= pair.key();
		// TODO - ignore executable build targets?
		if_var( &global_versioned_package_name : build_target_name.package_name.name_base.get</GlobalVersionedPackageName/>() )
		{
			global_packages_build_targets.push_back(
				GlobalPackageBuildTargetName
				{
					.package_name= global_versioned_package_name.name,
					.subpackage_path= build_target_name.package_name.path,
					.build_target_name= build_target_name.name,
				} );
		}
	}

	// Sort and deduplicate list of build targets dependencies on which should be unified.
	// Sorting is necessary in order to process build targets in some stable order.
	// Deduplication is necessary since we may have build targets from different package versions.
	ust::sort( global_packages_build_targets );
	global_packages_build_targets.remove_adjacent_duplicates();

	foreach( &build_target_name : global_packages_build_targets )
	{
		logger.LogVerbose( ust::concat(
			"Consider build target \"",
			build_target_name.build_target_name,
			"\" of a global package \"",
			build_target_name.package_name,
			"::",
			build_target_name.subpackage_path,
			"\" for unification." ) );
	}

	// Unify versions for each build target where it's necessary.
	// TODO - repeat this loop multiple times, since version unification may introduce new dependencies or remove old one.
	foreach( &build_target_name : global_packages_build_targets )
	{
		// Build a helper index containing backward edges in dependency graph to simplify later processing.
		var WorkspaceBuildTargetsUsers workspace_build_targets_users= BuildWorkspaceBuildTargetsUsers( workspace );

		var BuildTargetUsersSet build_target_users=
			BuildBuildTargetUsersSet( workspace_build_targets_users, build_target_name );

		logger.LogVerbose( ust::concat( "Users of \"", build_target_name.build_target_name, "\" are: " ) );
		foreach( &user : build_target_users )
		{
			logger.LogVerbose( ust::concat( "\t", user.name ) );
		}
	}

	return true;
}

// Do not store here version.
struct GlobalPackageBuildTargetName
{
	ust::string8 package_name;
	ust::string8 subpackage_path;
	ust::string8 build_target_name;

	op<=>( GlobalPackageBuildTargetName& l, GlobalPackageBuildTargetName& r ) : i32
	{
		auto package_name_comp= l.package_name <=> r.package_name;
		if( package_name_comp != 0 )
		{
			return package_name_comp;
		}
		auto subpackage_path_comp= l.subpackage_path <=> r.subpackage_path;
		if( subpackage_path_comp != 0 )
		{
			return subpackage_path_comp;
		}
		return l.build_target_name <=> r.build_target_name;
	}
}

// A helper structure - store for a build target names of build targets which they use.
struct BuildTargetUsers
{
	// Build targets which use this build target as direct public dependency.
	ust::vector</BuildTargetAbsoluteName/> public_users;
	// Build targets which use this build target as direct private dependency.
	ust::vector</BuildTargetAbsoluteName/> private_users;
}

type WorkspaceBuildTargetsUsers= ust::unordered_map</BuildTargetAbsoluteName, BuildTargetUsers/>;

fn BuildWorkspaceBuildTargetsUsers( WorkspaceInfo& workspace ) : WorkspaceBuildTargetsUsers
{
	var WorkspaceBuildTargetsUsers mut result;

	foreach( &pair : workspace.build_targets )
	{
		var BuildTargetAbsoluteName& build_target_full_name= pair.key();
		var WorkspaceInfo::BuildTarget& build_target= pair.value();

		foreach( &public_dependency_name : build_target.public_dependencies )
		{
			if( !result.exists( public_dependency_name ) )
			{
				result.insert( public_dependency_name, BuildTargetUsers{} );
			}
			result[ public_dependency_name ].public_users.push_back( build_target_full_name );
		}

		foreach( &private_dependency_name : build_target.private_dependencies )
		{
			// For private dependencies check if they aren't already lusted in public dependencies and if so - ignore them.
			var bool mut exists_in_public_dependencies= false;
			foreach( &public_dependency_name : build_target.public_dependencies )
			{
				if( private_dependency_name == public_dependency_name )
				{
					exists_in_public_dependencies= true;
					break;
				}
			}

			if( exists_in_public_dependencies )
			{
				continue;
			}

			if( !result.exists( private_dependency_name ) )
			{
				result.insert( private_dependency_name, BuildTargetUsers{} );
			}
			result[ private_dependency_name ].private_users.push_back( build_target_full_name );
		}
	}

	// TODO - sort lists of users?

	return move(result);
}

type BuildTargetUsersSet= ust::unordered_set</BuildTargetAbsoluteName/>;

// Build set of all build targets which depend on given build target as public or private dependency or as transitive public depenency.
fn BuildBuildTargetUsersSet(
	WorkspaceBuildTargetsUsers& build_target_users,
	GlobalPackageBuildTargetName& build_target_name ) : BuildTargetUsersSet
{
	var BuildTargetUsersSet mut result;

	// Search for all build targets with same package name/path/target name and possible different versions.
	foreach( &pair : build_target_users )
	{
		var BuildTargetAbsoluteName& n= pair.key();
		if_var( &global_versioned_package_name : n.package_name.name_base.get</GlobalVersionedPackageName/>() )
		{
			if( global_versioned_package_name.name == build_target_name.package_name &&
				n.package_name.path == build_target_name.subpackage_path &&
				n.name == build_target_name.build_target_name )
			{
				var BuildTargetUsers& users= pair.value();
				foreach( &public_user : users.public_users )
				{
					BuildBuildTargetUsersSet_r( build_target_users, public_user, result );
				}
				foreach( &private_user : users.private_users )
				{
					// Insert this private user, but don't go further - for users of this private user given build target is hidden.
					result.insert( private_user );
				}
			}
		}
	}

	return result;
}

fn BuildBuildTargetUsersSet_r(
	WorkspaceBuildTargetsUsers& build_target_users,
	BuildTargetAbsoluteName& user_library,
	BuildTargetUsersSet &mut out_set )
{
	if( out_set.exists( user_library ) )
	{
		return;
	}
	out_set.insert( user_library );

	var BuildTargetUsers& users= build_target_users[ user_library ];
	foreach( &public_user : users.public_users )
	{
		BuildBuildTargetUsersSet_r( build_target_users, public_user, out_set );
	}
	foreach( &private_user : users.private_users )
	{
		// Insert this private user, but don't go further - for users of this private user given build target is hidden.
		out_set.insert( private_user );
	}
}

} // namespace BK
