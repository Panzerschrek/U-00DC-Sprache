import "/scoped_array.u"
import "/unordered_map.u"
import "build_graph.uh"
import "filesystem.uh"
import "make_dep_file.uh"
import "process.uh"


namespace BK
{

fn PerformGraphBuild( Logger &mut logger, BuildGraph& build_graph ) : bool
{
	// Collect dep-files.
	scoped_array ust::optional</MakeDepFile/> mut nodes_dep_files[ build_graph.nodes.size() ];
	foreach( pair : build_graph.nodes.iter().zip( nodes_dep_files.iter() ) )
	{
		pair.second= LoadAndParseDepFile( logger, pair.first.dep_file );
	}

	// Collect and deduplicate all files.
	var ust::unordered_map</ ust::string8, ust::optional</FileModificationTime/> /> mut files_with_modification_time;

	foreach( &node : build_graph.nodes )
	{
		foreach( &file : node.input_files )
		{
			files_with_modification_time.insert( file, ust::null_optional );
		}
		foreach( &file : node.output_files )
		{
			files_with_modification_time.insert( file, ust::null_optional );
		}
	}

	foreach( &dep_file_opt : nodes_dep_files )
	{
		if_var( &dep_file : dep_file_opt )
		{
			// TODO - normalize paths read from dependency files.
			files_with_modification_time.insert( dep_file.destination, ust::null_optional );
			foreach( &dependency : dep_file.dependencies )
			{
				files_with_modification_time.insert( dependency, ust::null_optional );
			}
		}
	}

	// Get modification times for all files.
	foreach( &mut map_value : files_with_modification_time )
	{
		var ust::optional</FileModificationTime/> modification_time = GetFileModificationTime( map_value.key() );
		map_value.value() = modification_time;
	}

	// Mark nodes to rebuild.
	scoped_array bool mut nodes_to_rebuild[ build_graph.nodes.size() ]( false );
	for( auto mut i= 0s; i < build_graph.nodes.size(); ++i ) label nodes_loop
	{
		var BuildGraph::Node& node= build_graph.nodes[i];
		var ust::optional</MakeDepFile/>& dep_file_opt= nodes_dep_files[i];

		var bool &mut need_to_rebuild = nodes_to_rebuild[i];

		if( !node.dep_file.empty() && dep_file_opt.empty() )
		{
			// No dep file where it shoud be - rebuild is needed.
			logger.LogVerbose( "No dep file for command \"" + node.comment + "\" - mark for rebuild." );
			need_to_rebuild= true;
			continue label nodes_loop;
		}

		if_var( &dep_file : dep_file_opt )
		{
			if( files_with_modification_time[dep_file.destination].empty() )
			{
				logger.LogVerbose( "No output file \"" + dep_file.destination + "\" for command \"" + node.comment + "\" - mark for rebuild." );
				need_to_rebuild= true;
				continue label nodes_loop;
			}
			foreach( &dependency : dep_file.dependencies )
			{
				if( files_with_modification_time[dependency].empty() )
				{
					logger.LogVerbose( "No input file \"" + dependency + "\" for command \"" + node.comment + "\" - mark for rebuild." );
					need_to_rebuild= true;
					continue label nodes_loop;
				}
			}
		}

		foreach( &input_file : node.input_files )
		{
			if( files_with_modification_time[input_file].empty() )
			{
				logger.LogVerbose( "No input file \"" + input_file + "\" for command \"" + node.comment + "\" - mark for rebuild." );
				need_to_rebuild= true;
				continue label nodes_loop;
			}
		}

		foreach( &output_file : node.output_files )
		{
			if( files_with_modification_time[output_file].empty() )
			{
				logger.LogVerbose( "No output file \"" + output_file + "\" for command \"" + node.comment + "\" - mark for rebuild." );
				need_to_rebuild= true;
				continue label nodes_loop;
			}
		}

		// At this point we have all files needed present. Compare their timesmaps.

		var FileModificationTime mut min_output_modification_time(0);
		--min_output_modification_time; // Trigger underflow to maximum value.

		var FileModificationTime mut max_input_modification_time(0);

		foreach( &output_file : node.output_files )
		{
			min_output_modification_time= ust::min( min_output_modification_time, files_with_modification_time[output_file].try_deref() );
		}

		foreach( &input_file : node.input_files )
		{
			max_input_modification_time= ust::max( max_input_modification_time, files_with_modification_time[input_file].try_deref() );
		}

		if_var( &dep_file : dep_file_opt )
		{
			min_output_modification_time= ust::min( min_output_modification_time, files_with_modification_time[dep_file.destination].try_deref() );
			foreach( &dependency : dep_file.dependencies )
			{
				max_input_modification_time= ust::max( max_input_modification_time, files_with_modification_time[dependency].try_deref() );
			}
		}

		// Rebuild is requiret if the newest changed input file is newer than the oldest changed output file.
		// Use >= instead of > in order to handle case with not enough precision in timestamps.
		need_to_rebuild = max_input_modification_time >= min_output_modification_time;
		if( need_to_rebuild )
		{
			logger.LogVerbose( "One of input files of the command \"" + node.comment + "\" is newer than one of output files - mark for rebuild." );
		}
	}

	// TODO - check also previous build graph.
	// If a node is new - command/command line and/or input/output files were changed - require rebuild for this node.

	// Mark also nodes for rebuild if their dependent nodes are needed to be rebuilt.
	{
		// Create a map for graph traversal speed-up.
		var ust::unordered_map</ust::string8, ust::vector</size_type/>/> mut input_file_to_node_id_map;
		for( auto mut i = 0s; i < build_graph.nodes.size(); ++i )
		{
			var BuildGraph::Node& node= build_graph.nodes[i];
			var ust::optional</MakeDepFile/>& dep_file_opt= nodes_dep_files[i];

			foreach( &input_file : node.input_files )
			{
				if( input_file_to_node_id_map.exists( input_file ) )
				{
					input_file_to_node_id_map[input_file].push_back(i);
				}
				else
				{
					input_file_to_node_id_map.insert( input_file, ust::make_array(i) );
				}
			}

			if_var( &dep_file : dep_file_opt )
			{
				foreach( &dependency : dep_file.dependencies )
				{
					if( input_file_to_node_id_map.exists( dependency ) )
					{
						input_file_to_node_id_map[dependency].push_back(i);
					}
					else
					{
						input_file_to_node_id_map.insert( dependency, ust::make_array(i) );
					}
				}
			}
		}

		// Push initial nodes to rebuild to stack.
		var ust::vector</size_type/> mut stack;
		for( auto mut i = 0s; i < build_graph.nodes.size(); ++i )
		{
			if( nodes_to_rebuild[i] )
			{
				logger.LogVerbose( "Push node \"" + build_graph.nodes[i].comment + "\" to search stack." );
				stack.push_back(i);
			}
		}

		// Since we mark visited nodes and thus visit them only once, infinite loop isn't possible here - in case of bad graph with cycles.
		scoped_array bool mut visited_nodes[ build_graph.nodes.size() ]( false );
		while( !stack.empty() )
		{
			var size_type node_id= stack.pop_back();

			if( visited_nodes[node_id] )
			{
				continue;
			}
			visited_nodes[node_id]= true;

			var BuildGraph::Node& node= build_graph.nodes[node_id];
			var ust::optional</MakeDepFile/>& dep_file_opt= nodes_dep_files[node_id];

			logger.LogVerbose( "Visit node \"" + node.comment + "\"." );

			if( !nodes_to_rebuild[node_id] )
			{
				nodes_to_rebuild[node_id]= true;

				logger.LogVerbose( "Mark command \"" + node.comment + "\" for rebuild, since one of its dependencies is also marked for rebuild." );
			}

			// If this node is marked for rebuild - mark for rebuild also nodes which use outputs of this node as inputs.

			foreach( &output_file : node.output_files )
			{
				if_var( &nodes : input_file_to_node_id_map.find( output_file ) )
				{
					stack.append( nodes.iter() );
				}
			}

			if_var( &dep_file : dep_file_opt )
			{
				if_var( &nodes : input_file_to_node_id_map.find( dep_file.destination ) )
				{
					stack.append( nodes.iter() );
				}
			}
		}
	}

	// Perform rebuild.
	{
		// Create a map for graph traversal speed-up.
		var ust::unordered_map</ust::string8, ust::vector</size_type/>/> mut output_file_to_node_id_map;
		for( auto mut i = 0s; i < build_graph.nodes.size(); ++i )
		{
			var BuildGraph::Node& node= build_graph.nodes[i];
			var ust::optional</MakeDepFile/>& dep_file_opt= nodes_dep_files[i];

			foreach( &output_file : node.output_files )
			{
				if( output_file_to_node_id_map.exists( output_file ) )
				{
					output_file_to_node_id_map[output_file].push_back(i);
				}
				else
				{
					output_file_to_node_id_map.insert( output_file, ust::make_array(i) );
				}
			}

			if_var( &dep_file : dep_file_opt )
			{
				if( output_file_to_node_id_map.exists( dep_file.destination ) )
				{
					output_file_to_node_id_map[dep_file.destination].push_back(i);
				}
				else
				{
					output_file_to_node_id_map.insert( dep_file.destination, ust::make_array(i) );
				}
			}
		}

		scoped_array BuildGraphNodeState mut nodes_state[ build_graph.nodes.size() ]( BuildGraphNodeState::Ready );
		for( auto mut i= 0s; i < build_graph.nodes.size(); ++i )
		{
			nodes_state[i] = ( nodes_to_rebuild[i] ? BuildGraphNodeState::RebuildRequired : BuildGraphNodeState::Ready );
		}

		loop
		{
			// Select a node to rebuild - which dependencies are all ready.
			// TODO - speed-up this, replace linear search with something more satisfying.
			var size_type mut node_to_rebuild_index = build_graph.nodes.size();
			for( auto mut i= 0s; i < build_graph.nodes.size(); ++i )
			{
				if( nodes_state[i] == BuildGraphNodeState::RebuildRequired )
				{
					var BuildGraph::Node& node= build_graph.nodes[i];
					var ust::optional</MakeDepFile/>& dep_file_opt= nodes_dep_files[i];

					var bool mut can_start_rebuild= true;

					foreach( &input_file : node.input_files )
					{
						if_var( &input_nodes : output_file_to_node_id_map.find( input_file ) )
						{
							foreach( input_node : input_nodes )
							{
								can_start_rebuild &= nodes_state[input_node] == BuildGraphNodeState::Ready;
							}
						}
					}

					if_var( &dep_file : dep_file_opt )
					{
						foreach( &dependency : dep_file.dependencies )
						{
							if_var( &input_nodes : output_file_to_node_id_map.find( dependency ) )
							{
								foreach( input_node : input_nodes )
								{
									can_start_rebuild &= nodes_state[input_node] == BuildGraphNodeState::Ready;
								}
							}
						}
					}

					if( can_start_rebuild )
					{
						node_to_rebuild_index= i;
						break;
					}
				}
			}

			if( node_to_rebuild_index >= build_graph.nodes.size() )
			{
				// Nothing left to rebuild or we have dependency loops (check them later).
				break;
			}

			nodes_state[node_to_rebuild_index]= BuildGraphNodeState::RebuildInProgress;

			var BuildGraph::Node& node_to_rebuild = build_graph.nodes[node_to_rebuild_index];

			var ust::vector</ust::string_view8/> mut command_line;

			// Hack to prevent "ReferencePollutionOfOuterLoopVariable" error.
			if(false)
			{
				command_line.push_back( node_to_rebuild.command_line.front() );
			}
			for( auto mut i= 0s; i < node_to_rebuild.command_line.size(); ++i )
			{
				command_line.push_back( node_to_rebuild.command_line[i] );
			}

			logger.LogInfo( "Building \"" + node_to_rebuild.comment + "\"." );

			if( !RunExecutable( node_to_rebuild.program, command_line ) )
			{
				logger.LogError( "Command \"" + node_to_rebuild.comment + "\" execution failed." );
				return false;
			}

			nodes_state[node_to_rebuild_index]= BuildGraphNodeState::Ready;
		}

		// Last check to be sure all was really built (may not be true for bad graphs with cycles).
		for( auto mut i= 0s; i < build_graph.nodes.size(); ++i )
		{
			if( nodes_state[i] != BuildGraphNodeState::Ready )
			{
				logger.LogError( "Broken build graph - node \"" + build_graph.nodes[i].comment + "\" was not built." );
				return false;
			}
		}
	}

	// Succcessfuly performed the build.
	return true;
}

fn LoadAndParseDepFile( Logger &mut logger, ust::string_view8 dep_file_path ) : ust::optional</MakeDepFile/>
{
	if( dep_file_path.empty() )
	{
		return ust::null_optional;

	}
	var ust::optional</ust::string8/> file_contents= ReadFile( dep_file_path );
	if( file_contents.empty() )
	{
		// Dep file is not created yet.
		logger.LogVerbose( "No dependency file \"" + ust::string8(dep_file_path) + "\"." );
		return ust::null_optional;
	}

	var ust::optional</MakeDepFile/> dep_file_opt= ParseMakeDepFileContents( file_contents.try_deref() );
	if( dep_file_opt.empty() )
	{
		logger.LogError( "Failed to parse dep file \"" + ust::string8(dep_file_path) + "\"" );
	}
	return dep_file_opt;
}

enum BuildGraphNodeState
{
	Ready,
	RebuildRequired,
	RebuildInProgress,
}

} // namespace BK
