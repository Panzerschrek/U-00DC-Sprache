import "/string_conversions.u"
import "json.uh"

namespace BK
{

fn JsonValue::conversion_constructor( Null null_value )
{
	contents_= null_value;
}

fn JsonValue::conversion_constructor( Bool bool_value )
{
	contents_= bool_value;
}

fn JsonValue::conversion_constructor( Number number_value )
{
	contents_= number_value;
}

fn JsonValue::conversion_constructor( String mut string_value )
{
	contents_= move(string_value);
}

fn JsonValue::conversion_constructor( ust::string_view8 string_value )
{
	contents_= String(string_value);
}

fn JsonValue::conversion_constructor( Array mut array_value )
{
	contents_= ust::make_box( move(array_value) );
}

fn JsonValue::conversion_constructor( Object mut object_value )
{
	contents_= ust::make_box( move(object_value) );
}

fn JsonValue::AsNull(  mut this ) : ust::optional_ref_mut </Null/> @( return_inner_references )
{
	return contents_.get</Null/>();
}

fn JsonValue::AsNull( imut this ) : ust::optional_ref_imut</Null/> @( return_inner_references )
{
	return contents_.get</Null/>();
}


fn JsonValue::AsBool(  mut this ) : ust::optional_ref_mut </Bool/> @( return_inner_references )
{
	return contents_.get</Bool/>();
}

fn JsonValue::AsBool( imut this ) : ust::optional_ref_imut</Bool/> @( return_inner_references )
{
	return contents_.get</Bool/>();
}

fn JsonValue::AsNumber(  mut this ) : ust::optional_ref_mut </Number/> @( return_inner_references )
{
	return contents_.get</Number/>();
}

fn JsonValue::AsNumber( imut this ) : ust::optional_ref_imut</Number/> @( return_inner_references )
{
	return contents_.get</Number/>();
}

fn JsonValue::AsString(  mut this ) : ust::optional_ref_mut </String/> @( return_inner_references )
{
	return contents_.get</String/>();
}

fn JsonValue::AsString( imut this ) : ust::optional_ref_imut</String/> @( return_inner_references )
{
	return contents_.get</String/>();
}

fn JsonValue::AsArray(  mut this ) : ust::optional_ref_mut </Array/> @( return_inner_references )
{
	if_var( &mut arr : contents_.get</ ust::box</Array/> />() )
	{
		return arr.deref();
	}
	return ust::null_optional_ref;
}

fn JsonValue::AsArray( imut this ) : ust::optional_ref_imut</Array/> @( return_inner_references )
{
	if_var( &arr : contents_.get</ ust::box</Array/> />() )
	{
		return arr.deref();
	}
	return ust::null_optional_ref;
}


fn JsonValue::AsObject(  mut this ) : ust::optional_ref_mut </Object/> @( return_inner_references )
{
	if_var( &mut obj : contents_.get</ ust::box</Object/> />() )
	{
		return obj.deref();
	}
	return ust::null_optional_ref;
}

fn JsonValue::AsObject( imut this ) : ust::optional_ref_imut</Object/> @( return_inner_references )
{
	if_var( &obj : contents_.get</ ust::box</Object/> />() )
	{
		return obj.deref();
	}
	return ust::null_optional_ref;
}

fn SerializeJsonValue( JsonValue& value ) : ust::string8
{
	var ust::string8 mut res;
	SerializeJsonValue( res, value );
	return res;
}

fn SerializeJsonValue( ust::string8 &mut out, JsonValue& value )
{
	if_var( &null_value : value.AsNull() )
	{
		SerializeJsonValueImpl( out, null_value );
	}
	else if_var( &bool_value : value.AsBool() )
	{
		SerializeJsonValueImpl( out, bool_value );
	}
	else if_var( &number_value : value.AsNumber() )
	{
		SerializeJsonValueImpl( out, number_value );
	}
	else if_var( &string_value : value.AsString() )
	{
		SerializeJsonValueImpl( out, string_value );
	}
	else if_var( &array_value : value.AsArray() )
	{
		SerializeJsonValueImpl( out, array_value );
	}
	else if_var( &object_value : value.AsObject() )
	{
		SerializeJsonValueImpl( out, object_value );
	}
}

fn SerializeJsonValueImpl( ust::string8 &mut out, JsonValue::Null null_value )
{
	ust::ignore_unused( null_value );
	out+= "null";
}

fn SerializeJsonValueImpl( ust::string8 &mut out, JsonValue::Bool bool_value )
{
	if( bool_value )
	{
		out+= "true";
	}
	else
	{
		out+= "false";
	}
}

fn SerializeJsonValueImpl( ust::string8 &mut out, JsonValue::Number number_value )
{
	// TODO - perform proper float serialization.
	out+= ust::to_string8( i64(number_value) );
}

fn SerializeJsonValueImpl( ust::string8 &mut out, JsonValue::String& string_value )
{
	SerializeJsonString( out, string_value );
}

fn SerializeJsonValueImpl( ust::string8 &mut out, JsonValue::Array& array_value )
{
	out.push_back( "["c8 );

	foreach( &sub_value : array_value )
	{
		SerializeJsonValue( out, sub_value );
		out.push_back( ","c8 );
	}

	if( !array_value.empty() )
	{
		out.pop_back(); // Remove trailing comma
	}

	out.push_back( "]"c8 );
}

fn SerializeJsonValueImpl( ust::string8 &mut out, JsonValue::Object& object_value )
{
	out.push_back( "{"c8 );

	foreach( &pair : object_value )
	{
		SerializeJsonString( out, pair.key() );
		out.push_back( ":"c8 );
		SerializeJsonValue( out, pair.value() );
		out.push_back( ","c8 );
	}

	if( !object_value.empty() )
	{
		out.pop_back(); // Remove trailing comma
	}

	out.push_back( "}"c8 );
}

fn SerializeJsonString( ust::string8 &mut out, JsonValue::String& string_value )
{
	out.push_back( "\""c8 );

	foreach( c : string_value )
	{
		switch(c)
		{
			"\""c8, "\\"c8, "/"c8, "\b"c8, "\f"c8, "\n"c8, "\r"c8, "\t"c8 -> { out.push_back( "\\"c8 ); },
			default -> {}
		}
		 out.push_back(c);
	}

	out.push_back( "\""c8 );
}

} // namespace BK
