import "/sort.u"
import "package_transformation.uh"
import "path.uh"

namespace BK
{

fn TransformAndValidatePackageInfo( Logger &mut logger, PackageInfo& package_info )
	: ust::optional</PackageInfoTransformed/>
{
	var PackageInfoTransformed mut out_package_info;

	var bool mut ok= true;

	var ust::vector</ ust::vector</ust::string8 /> /> mut prev_targets_directories;

	foreach( &build_target : package_info.build_targets )
	{
		var ust::string8& target_name= build_target.name;

		if( !TargetNameIsValid( target_name ) )
		{
			logger.LogError( "Error, invalid build target name \"" + target_name + "\"!" );
			ok= false;
		}

		if( out_package_info.build_targets.exists( target_name ) )
		{
			logger.LogError( "Error, duplicated build target \"" + target_name + "\"!" );
			ok= false;
		}

		var PackageInfoTransformed::BuildTarget mut out_build_target{ .target_type= build_target.target_type };

		// Process sources.

		if( !build_target.source_files.empty() )
		{
			// Check each source - if it's correct.
			foreach( &source_name : build_target.source_files )
			{
				if( !TargetSourceNameIsValid( source_name ) )
				{
					logger.LogError( "Invalid, source name \"" + source_name + "\" of build target \"" + target_name + "\"!" );
					ok= false;
					continue;
				}


				out_build_target.source_files.push_back( NormalizePath( source_name ) );
			}

			// Normalize list of sources and remove duplicates.
			ust::sort( out_build_target.source_files );
			for( auto mut i = 1s; i < out_build_target.source_files.size(); ++i )
			{
				if( cast_imut(out_build_target).source_files[ i - 1s ] == cast_imut(out_build_target).source_files[i] )
				{
					logger.LogError( "Error, duplicated source file \"" + out_build_target.source_files[i] + "\" of the build target \"" + target_name + "\"!" );
					ok= false;
				}
			}

			var ust::vector</ust::string8/> mut sources_directory= CalculateBuildTargetSourceFilesCommonDirectory( out_build_target.source_files  );

			foreach( &component : sources_directory )
			{
				out_build_target.sources_directory+= component;
				out_build_target.sources_directory+= "/";
			}

			logger.LogVerbose( "All sources of the build target \"" + target_name + "\" are located within directory \"" + out_build_target.sources_directory + "\"." );

			// Check for source directory conflict.
			foreach( &prev_source_directory : prev_targets_directories )
			{
				if( prev_source_directory == sources_directory )
				{
					logger.LogError( "Source directory \"" + out_build_target.sources_directory + "\" of the build target \"" + target_name + "\" is already in use." );
					ok= false;
				}
				else if( sources_directory.size() < prev_source_directory.size() &&
					sources_directory == prev_source_directory.range().subrange_end( sources_directory.size() ) )
				{
					logger.LogError( "Source directory \"" + out_build_target.sources_directory + "\" of the build target \"" + target_name + "\" is a prefix of another used directory." );
					ok= false;
				}
				else if( sources_directory.size() > prev_source_directory.size() &&
					prev_source_directory == cast_imut(sources_directory).range().subrange_end( prev_source_directory.size() ) )
				{
					logger.LogError( "Source directory \"" + out_build_target.sources_directory + "\" of the build target \"" + target_name + "\" is located within another used directory." );
					ok= false;
				}
			}

			prev_targets_directories.push_back( move(sources_directory) );
		}

		// Process public include directories.

		if( build_target.target_type == BuildTargetType::Executable && !build_target.public_include_directories.empty() )
		{
			// For now forbid specifying public include directories for executables.
			// It's useless, since exporting symbols from executables isn't supported.
			ok= false;
			logger.LogError( "Non-empty public include directories list for an executable build target \"" + build_target.name + "\"." );
		}

		foreach( &public_include_directory : build_target.public_include_directories )
		{
			if( !TargetSourceNameIsValid( public_include_directory ) )
			{
				logger.LogError( "Invalid path of a public source directory \"" + public_include_directory + "\" of the build target \"" + target_name + "\"." );
				ok= false;
				continue;
			}
			auto mut public_include_directory_component_splitted=
				ust::vector</ust::string8/>::from_iterator( SplitPathIntoComponents( public_include_directory ).iter() );

			// Check for directory conflict.
			foreach( &prev_source_directory : prev_targets_directories )
			{
				if( prev_source_directory == public_include_directory_component_splitted )
				{
					logger.LogError( "Public include directory \"" + public_include_directory + "\" of the build target \"" + target_name + "\" is already in use." );
					ok= false;
				}
				else if( public_include_directory_component_splitted.size() < prev_source_directory.size() &&
					public_include_directory_component_splitted == prev_source_directory.range().subrange_end( public_include_directory_component_splitted.size() ) )
				{
					logger.LogError( "Public include directory \"" + public_include_directory + "\" of the build target \"" + target_name + "\" is a prefix of another used directory." );
					ok= false;
				}
				else if( public_include_directory_component_splitted.size() > prev_source_directory.size() &&
					prev_source_directory == cast_imut(public_include_directory_component_splitted).range().subrange_end( prev_source_directory.size() ) )
				{
					logger.LogError( "Public include directory \"" + public_include_directory + "\" of the build target \"" + target_name + "\" is located within another used directory." );
					ok= false;
				}
			}

			var ust::string8 mut directory_normalized;
			foreach( &component : public_include_directory_component_splitted )
			{
				directory_normalized+= component;
				directory_normalized+= "/";
			}
			out_build_target.public_include_directories.push_back( move(directory_normalized) );

			prev_targets_directories.push_back( move(public_include_directory_component_splitted) );
		}

		ust::sort( out_build_target.public_include_directories );

		// Process public dependencies.

		if( build_target.target_type == BuildTargetType::Executable && !build_target.public_dependencies.empty() )
		{
			// For now forbid specifying public dependencies for executables.
			// It's useless, since exporting symbols from executables isn't supported.
			ok= false;
			logger.LogError( "Non-empty public dependencies list for an executable build target \"" + build_target.name + "\"." );
		}

		out_build_target.public_dependencies= build_target.public_dependencies;
		ust::sort( out_build_target.public_dependencies );
		out_build_target.public_dependencies.remove_adjacent_duplicates();

		// Process private dependencies.

		out_build_target.private_dependencies= build_target.private_dependencies;
		ust::sort( out_build_target.private_dependencies );
		out_build_target.private_dependencies.remove_adjacent_duplicates();

		out_package_info.build_targets.insert( target_name, move( out_build_target ) );
	}

	// After finishing building build targets map can perform dependency graph-based checks and transformations.
	//

	// Check for dependency loops.
	foreach( &build_target : package_info.build_targets )
	{
		ok&= CheckForDependencyLoops( logger, out_package_info, build_target.name );
	}

	// Perform public dependencies retrieval.
	foreach( &build_target : package_info.build_targets )
	{
		if_var( &mut dependencies : GetAllTargetPublicDependencies( logger, out_package_info, build_target.name ) )
		{
			if_var( &mut out_build_target : out_package_info.build_targets.find( build_target.name ) )
			{
				out_build_target.public_dependencies_including_transitive= take(dependencies);
			}
		}
		else
		{
			ok= false;
		}
	}

	// Perform private dependencies retrieval.
	foreach( &build_target : package_info.build_targets )
	{
		if_var( &dependencies : GetAllTargetPrivateAndTheirTransitivePublicDependencies( logger, out_package_info, build_target.name ) )
		{
			if_var( &mut out_build_target : out_package_info.build_targets.find( build_target.name ) )
			{
				// Remove private dependencies which are also public dependencies.

				auto& public_dependencies= out_build_target.public_dependencies_including_transitive;
				auto is_not_in_public_dependencies=
					lambda[&]( BuildTargetFullName& target_name ) : bool
					{
						foreach( &dependency : public_dependencies )
						{
							if( target_name == dependency )
							{
								return false;
							}
						}
						return true;
					};

				out_build_target.private_dependencies_including_transitive_public_dependencies.append(
					dependencies.iter().filter( is_not_in_public_dependencies ) );
			}
		}
		else
		{
			ok= false;
		}
	}

	// Perform shared libraries to link retrieval.
	foreach( &build_target : package_info.build_targets )
	{
		auto mut dependencies= GetAllTargetSharedLibraryDependenciesToLink( out_package_info, build_target.name );
		if_var( &mut out_build_target : out_package_info.build_targets.find( build_target.name ) )
		{
			out_build_target.shared_library_dependencies_to_link= move(dependencies);
		}
		else
		{
			move(dependencies);
		}
	}

	if( !ok )
	{
		return ust::null_optional;
	}

	return move(out_package_info);
}

fn TargetNameIsValid( ust::string_view8 name ) : bool
{
	if( name.empty() )
	{
		return false;
	}

	if( name.back() == " "c8 )
	{
		return false; // Prevent names ending with space (Windows limitation).
	}
	if( name.front() == " "c8 )
	{
		return false; // Just to be sure prevent leading spaces.
	}

	foreach( c : name )
	{
		// Prevent symbols which may have special meaning in paths.
		switch(c)
		{
			// Dots are allowed in paths, but in target names they may be confusing.
			// Using dots is legal for file extension, but we don't need they in target names.
			"."c8,
			"/"c8,
			"\\"c8,
			":"c8,
			"\""c8,
			"'"c8,
			"<"c8,
			">"c8,
			"|"c8,
			"?"c8,
			"*"c8,
			char8(0) ... char8(31) // Forbid binary null and all control characters.
			-> { return false; },
			default -> {}
		}
	}

	return true;
}

fn TargetSourceNameIsValid( ust::string_view8 name ) : bool
{
	if( name.empty() )
	{
		return false;
	}

	if( name.front() == "/"c8 || name.front() == "\\"c8 )
	{
		// Do not allow absolute paths.
		return false;
	}

	if( name.size() >= 2s && name[0s] >= "A"c8 && name[0s] <= "Z"c8 && name[1s] == ":"c8 )
	{
		// Do not allow absolute Windows paths.
		return false;
	}

	// Disable "." and ".." in source file names.
	foreach( &component : SplitPathIntoComponents( name ) )
	{
		if( component == "." || component == ".." )
		{
			return false;
		}
	}

	// Further checks aren't really necessary.
	// If for example file name is invalid, it will not be found and build will fail.

	return true;
}

fn CalculateBuildTargetSourceFilesCommonDirectory( ust::array_view_imut</ust::string8/> sources ) : ust::vector</ust::string8/>
{
	if( sources.empty() )
	{
		return ust::vector</ust::string8/>();
	}

	var ust::vector</ust::vector</ust::string8/>/> mut sources_splitted_per_component;
	foreach( &source : sources )
	{
		sources_splitted_per_component.push_back( SplitPathIntoComponents(source).iter().collect</ ust::vector</ ust::string8 /> />() );
	}

	if( sources_splitted_per_component.size() == 1s )
	{
		// Special case with only one file - remove last component (presumably file name) and return it.
		var ust::vector</ust::string8/> mut result= sources_splitted_per_component.pop_back();
		if( !result.empty() )
		{
			result.drop_back();
		}
		return result;
	}

	var ust::vector</ust::string8/> mut result;

	// Calculate common prefix for all files.

	for( auto mut i= 0s; ; ++i ) label component_loop
	{
		var ust::vector</ust::string8/>& first_source= sources_splitted_per_component.front();
		if( i >= first_source.size() )
		{
			break label component_loop;
		}
		var ust::string8& first_source_component= first_source[i];

		foreach( & source_splitted : cast_imut(sources_splitted_per_component) )
		{
			if( i >= source_splitted.size() || source_splitted[i] != first_source_component )
			{
				break label component_loop;
			}
		}

		result.push_back( first_source_component );
	}

	return result;
}

// Returns "true: if has NO dependency loops.
fn CheckForDependencyLoops(
	Logger &mut logger,
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name ) : bool
{
	var ust::vector</BuildTargetFullName/> mut call_stack;
	return CheckForDependencyLoops_r( logger, package_info, build_target_name, call_stack );
}

fn CheckForDependencyLoops_r(
	Logger &mut logger,
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name,
	ust::vector</BuildTargetFullName/> &mut call_stack ) : bool
{
	for( auto mut i= 0s; i < call_stack.size(); ++i )
	{
		if( build_target_name == call_stack[i].name )
		{
			var ust::string8 mut message= "Dependency loop detected: ";
			for( auto mut j= i; j < call_stack.size(); ++j )
			{
				message += "\"";
				message += call_stack[j].name;
				message += "\"";
				message += " -> ";
			}
			message += "\"";
			message += build_target_name;
			message += "\"";

			logger.LogError( message );

			return false;
		}
	}

	call_stack.push_back( BuildTargetFullName{ .name= build_target_name } );

	var bool mut ok= true;

	if_var( &build_target : package_info.build_targets.find( build_target_name ) )
	{
		foreach( &public_dependency : build_target.public_dependencies )
		{
			ok&= CheckForDependencyLoops_r( logger, package_info, public_dependency.name, call_stack );
		}
		foreach( &private_dependency : build_target.private_dependencies )
		{
			ok&= CheckForDependencyLoops_r( logger, package_info, private_dependency.name, call_stack );
		}
	}

	call_stack.pop_back();
	return ok;
}

fn GetAllTargetPublicDependencies(
	Logger &mut logger,
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name ) : ust::optional</ust::vector</BuildTargetFullName/>/>
{
	var ust::vector</BuildTargetFullName/> mut result;
	if( !GetAllTargetPublicDependencies_r( logger, package_info, build_target_name, result ) )
	{
		return ust::null_optional;
	}

	// Remove possible duplicates and normalize.
	ust::sort( result );
	result.remove_adjacent_duplicates();

	return move(result);
}

fn GetAllTargetPrivateAndTheirTransitivePublicDependencies(
	Logger &mut logger,
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name ) : ust::optional</ust::vector</BuildTargetFullName/>/>
{
	auto build_target_opt= package_info.build_targets.find( build_target_name );
	if( build_target_opt.empty() )
	{
		logger.LogError( "Dependency \"" + build_target_name + "\" not found." );
		return ust::null_optional;
	}

	var ust::vector</BuildTargetFullName/> mut result;

	var bool mut ok= true;
	foreach( &private_dependency : build_target_opt.try_deref().private_dependencies )
	{
		if( private_dependency.name == build_target_name )
		{
			logger.LogError( "Build target \"" + build_target_name + "\" depends on itself." );
			ok= false;
			continue;
		}

		if_var( &dependent_build_target : package_info.build_targets.find( private_dependency.name ) )
		{
			if( !( dependent_build_target.target_type == BuildTargetType::Library || dependent_build_target.target_type == BuildTargetType::SharedLibrary ) )
			{
				logger.LogError( "Build target \"" + build_target_name + "\" depends on non-library build target \"" + private_dependency.name + "\"." );
				ok= false;
			}
		}

		ok&= GetAllTargetPublicDependencies_r( logger, package_info, private_dependency.name, result );
		result.push_back( private_dependency );
	}

	if( !ok )
	{
		return ust::null_optional;
	}

	// Remove possible duplicates and normalize.
	ust::sort( result );
	result.remove_adjacent_duplicates();

	return move(result);
}

// Returns true on success.
fn GetAllTargetPublicDependencies_r(
	Logger &mut logger,
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name,
	ust::vector</BuildTargetFullName/> &mut result ) : bool
{
	foreach( &prev_dependency : result )
	{
		if( prev_dependency.name == build_target_name )
		{
			// Already visited.
			// This check prevents infinite recursion in case of circular dependencies.
			return true;
		}
	}

	var bool mut ok= true;

	if_var( &build_target : package_info.build_targets.find( build_target_name ) )
	{
		foreach( &public_dependency : build_target.public_dependencies )
		{
			if( public_dependency.name == build_target_name )
			{
				logger.LogError( "Build target \"" + build_target_name + "\" depends on itself." );
				ok= false;
				continue;
			}

			if_var( &dependent_build_target : package_info.build_targets.find( public_dependency.name ) )
			{
				if( !( dependent_build_target.target_type == BuildTargetType::Library || dependent_build_target.target_type == BuildTargetType::SharedLibrary ) )
				{
					logger.LogError( "Build target \"" + build_target_name + "\" depends on non-library build target \"" + public_dependency.name + "\"." );
					ok= false;
				}
			}

			ok&= GetAllTargetPublicDependencies_r( logger, package_info, public_dependency.name, result );
			result.push_back(public_dependency);
		}
	}
	else
	{
		ok= false;
		logger.LogError( "Dependency \"" + build_target_name + "\" not found." );
	}

	return ok;
}

fn GetAllTargetSharedLibraryDependenciesToLink(
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name ) : ust::vector</BuildTargetFullName/>
{
	var ust::vector</BuildTargetFullName/> mut result;
	GetAllTargetSharedLibraryDependenciesToLink_r( package_info, build_target_name, result );

	// Remove possible duplicates and normalize.
	ust::sort( result );
	result.remove_adjacent_duplicates();

	return result;
}

fn GetAllTargetSharedLibraryDependenciesToLink_r(
	PackageInfoTransformed& package_info,
	ust::string8& build_target_name,
	ust::vector</BuildTargetFullName/> &mut result )
{
	// TODO - prevent recursion in case of dependency loops.
	auto build_target_opt = package_info.build_targets.find( build_target_name );
	if( build_target_opt.empty() )
	{
		return; // Missing dependencies are checked before.
	}

	var PackageInfoTransformed::BuildTarget& build_target= build_target_opt.try_deref();

	// Iterate over both public and private dependencies.
	foreach( &dependency : build_target.public_dependencies.iter().chain( build_target.private_dependencies.iter() ) )
	{
		if_var( &dependent_build_target : package_info.build_targets.find( dependency.name ) )
		{
			switch( dependent_build_target.target_type )
			{
				BuildTargetType::Executable -> {}, // This should be checked before.
				BuildTargetType::Library ->
				{
					// Extrach shared library dependencies of library dependencies.
					GetAllTargetSharedLibraryDependenciesToLink_r( package_info, dependency.name, result );
				},
				BuildTargetType::SharedLibrary ->
				{
					result.push_back( dependency ); // Depend on this shared library dependency.

					if_var( &shared_library_build_target : package_info.build_targets.find( dependency.name ) )
					{
						// Extract also shared library dependencies of public dependencies of this shared library dependency.
						// But DO NOT extract shared library dependencies of private dependencies.
						foreach( &shared_library_public_dependency : shared_library_build_target.public_dependencies )
						{
							GetAllTargetSharedLibraryDependenciesToLink_r( package_info, shared_library_public_dependency.name, result );
						}
					}
				},
			}
		}
	}
}

} // namespace BK
