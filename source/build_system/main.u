import "/stdout.u"
import "/string.u"
import "/string_conversions.u"
import "/vector.u"
import "filesystem.uh"
import "shared_library.uh"
import "process.uh"
import "imports/build_system.uh"


fn nomangle main( i32 argc, $($(char8)) argv ) : i32
{
	auto args= unsafe( BK::ArgsToStringView( argc, argv ) );
	return BK::Main( args.front(), args.range().subrange_start(1s) );
}

namespace BK
{

fn ArgsToStringView( i32 argc, $($(char8)) argv ) unsafe : ust::vector</ust::string_view8/>
{
	var ust::vector</ust::string_view8/> mut res;
	for( auto mut i= 0; i < argc; ++i )
	{
		res.push_back( unsafe( NullTerminatedStringToStringView( $>( argv + i ) ) ) );
	}

	return res;
}

fn NullTerminatedStringToStringView( $(char8) ptr ) unsafe : ust::string_view8
{
	unsafe
	{
		auto mut p= ptr;
		while( $>(p) != "\0"c8 )
		{
			++p;
		}

		return ust::string_view8( ptr, size_type( p - ptr ) );
	}
}

// Place actual "main" code inside a "BK" namespace.
fn Main( ust::string_view8 exe_path, ust::array_view_imut</ust::string_view8/> args ) : i32
{
	ust::stdout_print( "Bürokratie - the Ü build system!\n" );

	var ust::optional</Options/> options_opt= ParseOptions( args );
	if( options_opt.empty() )
	{
		ust::stderr_print( "Failed to parse options.\n" );
		return -1;
	}

	var Options& options= options_opt.try_deref();

	if( !EnsureDirectoryExists( options.build_directory ) )
	{
		ust::stderr_print( "Can't create build directory.\n" );
		return -1;
	}

	// TODO - select more catchy name for root build script file.
	auto constexpr build_script_file= "build.u";

	auto constexpr entry_func_name = "GetProjectInfoImpl";

	var ust::string8 build_script_wrapper_path= options.build_directory + "/" + "build_script_wrapper.u";

	// Create our own wrapper file to ensure that the function exported from the shared library has proper type.
	{
		var ust::string8 mut build_script_wrapper_contents = "import \"/" + build_script_file + "\"\n\n";
		build_script_wrapper_contents+= "fn nomangle ";
		build_script_wrapper_contents+= entry_func_name;
		build_script_wrapper_contents+= "() : BK::ProjectInfo { return GetProjectInfo(); }";

		if( !WriteFile( build_script_wrapper_path, build_script_wrapper_contents ) )
		{
			ust::stderr_print( "Can't write build script wrapper file.\n" );
			return -1;
		}
	}

	// TODO - use platform-dependent file extension.
	var ust::string8 result_shared_library_path= options.build_directory + "/" + "build.so";

	var ust::string8 internalize_preserve_option = "--internalize-preserve=" + entry_func_name;

	var [ ust::string_view8, 15 ] compiler_args
	[
		"--include-dir", options.root_project_directory,
		"--include-dir", options.ustlib_path,
		"--include-dir", options.build_system_imports_path,
		build_script_wrapper_path,
		"-o", result_shared_library_path,
		"-filetype=dll",
		// Run internalization in order to export only entry function.
		"--internalize",
		internalize_preserve_option,
		"--relocation-model", "pic",
		// Run optimizations in order to make result shared library smaller.
		"-O2",
	];

	if( !RunExecutable( options.compiler_executable_path, compiler_args ) )
	{
		ust::stderr_print( "Compiler execution failed.\n" );
		return -1;
	}

	ust::stdout_print( "Loading " + result_shared_library_path + "\n" );
	auto shared_library_opt = LoadSharedLibrary( result_shared_library_path );
	if( shared_library_opt.empty() )
	{
		ust::stderr_print( "Faild to load build script shared library\n" );
		return -1;
	}

	auto mut func_raw_ptr= unsafe( shared_library_opt.try_deref().LoadSymbol( entry_func_name ) );
	if( ust::is_nullptr(func_raw_ptr) )
	{
		ust::stderr_print( "Faild to load function " + entry_func_name +  "\n" );
		return -1;
	}

	var GetProjectInfoFunctionType mut func_ptr= zero_init;
	unsafe( ust::memory_copy(
		ust::ptr_cast_to_byte8( $<(func_ptr) ),
		ust::ptr_cast_to_byte8( $<(func_raw_ptr) ),
		typeinfo</ typeof(func_ptr) />.size_of ) );

	var ProjectInfo project_info= func_ptr();

	ust::stdout_print( "Num build targets: " + ust::to_string8( project_info.build_targets.size() ) + "\n" );
	foreach( &build_target : project_info.build_targets )
	{
		ust::stdout_print( "Target " + build_target.name + ": " );
		foreach( &source_file : build_target.source_files )
		{
			ust::stdout_print( source_file + " " );
		}
		ust::stdout_print( "\n" );
	}

	return 0;
}

struct Options
{
	ust::string8 compiler_executable_path;
	ust::string8 build_directory;
	ust::string8 root_project_directory;
	ust::string8 ustlib_path;
	ust::string8 build_system_imports_path;
}

fn ParseOptions( ust::array_view_imut</ust::string_view8/> args ) : ust::optional</Options/>
{
	var Options mut res = MakeDefaultOptions();

	for( auto mut i= 0s; i < args.size(); )
	{
		if( args[i] == "--compiler-executable" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--compiler-executable\".\n" );
				return ust::null_optional;
			}
			res.compiler_executable_path= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--build-directory" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--build-directory\".\n" );
				return ust::null_optional;
			}
			res.build_directory= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--project-directory" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--project-directory\".\n" );
				return ust::null_optional;
			}
			res.root_project_directory= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--ustlib-path" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--ustlib-path\".\n" );
				return ust::null_optional;
			}
			res.ustlib_path= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--build-system-imports-path" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--build-system-imports-path\".\n" );
				return ust::null_optional;
			}
			res.build_system_imports_path= args[i + 1s];
			i+= 2s;
		}
		else
		{
			ust::stderr_print( "Error, unrecognized option \"" + ust::string8(args[i]) + "\".\n" );
			return ust::null_optional;
		}
	}

	return move(res);
}

fn MakeDefaultOptions() : Options
{
	var Options mut res;

	// TODO - select more catchy name for a build directory.
	res.build_directory= "build";

	// TODO - find a proper compiler executable in current executable directory.
	res.compiler_executable_path= "Compiler1";

	// Default option is to use current directory.
	res.root_project_directory= ".";

	// TODO - set some default.
	res.ustlib_path= "";

	// TODO - set some default.
	res.build_system_imports_path= "";

	return res;
}

} // namespace BK
