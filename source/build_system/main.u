import "/stdout.u"
import "/string_conversions.u"
import "/vector.u"
import "filesystem.uh"
import "logger.uh"
import "shared_library.uh"
import "string_utils.uh"
import "process.uh"
import "imports/build_system.uh"


fn nomangle main( i32 argc, $($(char8)) argv ) : i32
{
	auto args= unsafe( BK::MainArgsToStringView( argc, argv ) );
	return BK::Main( args.front(), args.range().subrange_start(1s) );
}

namespace BK
{

// Place actual "main" code inside the "BK" namespace.
fn Main( ust::string_view8 exe_path, ust::array_view_imut</ust::string_view8/> args ) : i32
{
	var ust::optional</Options/> options_opt= ParseOptions( args );
	if( options_opt.empty() )
	{
		ust::stderr_print( "Failed to parse options.\n" );
		return -1;
	}

	var Options& options= options_opt.try_deref();

	var Logger mut logger( ( options.quiet ? Logger::Level::Quiet : Logger::Level::Normal ) );

	logger.LogInfo( "Bürokratie - the Ü build system!" );

	var ust::string8 exe_directory_path = MakePathAbsolute( ExtractExeDirectoryPath( exe_path ) );

	logger.LogInfo( "Build system executable directory path: \"" + exe_directory_path + "\"" );

	// For now use "Compiler1" as compiler default. TODO - allow to tune it.
	var ust::string8 default_compiler_executable_path = exe_directory_path + "/Compiler1";
	// "ustlib" is located in the root of the Üpackage.
	var ust::string8 default_ustlib_path = exe_directory_path + "../ustlib";
	// Build system imports are located in "/build_system/imports"
	var ust::string8 default_build_system_imports_path = exe_directory_path + "../build_system/imports";

	var BuildSystemPaths build_system_paths
	{
		.compiler_executable_path=
			( options.compiler_executable_path.empty()
				? default_compiler_executable_path
				: MakePathAbsolute(options.compiler_executable_path) ),
		.ustlib_path=
			( options.ustlib_path.empty()
				? default_ustlib_path
				: MakePathAbsolute(options.ustlib_path) ),
		.build_system_imports_path=
			( options.build_system_imports_path.empty()
				? default_build_system_imports_path
				: MakePathAbsolute(options.build_system_imports_path) ),
	};

	// If "options.root_package_directory" is empty this will become current directory.
	var ust::string8 package_source_directory = MakePathAbsolute( options.root_package_directory );

	// By default use "build" directory within root package directory.
	var ust::string8 package_build_directory =
		( options.build_directory.empty()
			? ( package_source_directory + "/build" )
			: MakePathAbsolute( options.build_directory ) );

	logger.LogInfo( "Build project in \"" + package_source_directory + "\" using build directory \"" + package_build_directory + "\"" );

	if( !EnsureDirectoryExists( package_build_directory ) )
	{
		logger.LogError( "Can't create build directory." );
		return -1;
	}

	// TODO - customize it based on package name?
	auto constexpr entry_func_name = "GetPackageInfoImpl";

	auto shared_library_opt = BuildAndLoadPackageBuildScript(
		logger,
		build_system_paths,
		package_source_directory,
		package_build_directory,
		entry_func_name );
	if( shared_library_opt.empty() )
	{
		logger.LogError( "Failed to load/build the build script shared library." );
		return -1;
	}

	auto mut func_raw_ptr= shared_library_opt.try_deref().LoadSymbol( entry_func_name );
	if( ust::is_nullptr(func_raw_ptr) )
	{
		logger.LogError( "Failed to load function " + entry_func_name );
		return -1;
	}

	var GetPackageInfoFunctionType mut func_ptr= zero_init;
	unsafe( ust::memory_copy(
		ust::ptr_cast_to_byte8( $<(func_ptr) ),
		ust::ptr_cast_to_byte8( $<(func_raw_ptr) ),
		typeinfo</ typeof(func_ptr) />.size_of ) );

	var PackageInfo package_info= func_ptr();

	if( !CheckPackageIsOk( logger, package_info ) )
	{
		logger.LogError( "Package is invald." );
		return -1;
	}

	foreach( &build_target : package_info.build_targets )
	{
		if( !PerformPackageTargetBuild(
			logger,
			build_system_paths,
			package_source_directory,
			package_build_directory,
			build_target ) )
		{
			logger.LogError( "Failed to build target " + build_target.name + "!" );
			return -1;
		}
	}

	logger.LogInfo( "Successfully finished the build!" );

	return 0;
}

struct Options
{
	bool quiet = false;
	ust::string8 compiler_executable_path;
	ust::string8 build_directory;
	ust::string8 root_package_directory;
	ust::string8 ustlib_path;
	ust::string8 build_system_imports_path;
}

fn ParseOptions( ust::array_view_imut</ust::string_view8/> args ) : ust::optional</Options/>
{
	var Options mut res;

	for( auto mut i= 0s; i < args.size(); )
	{
		if( args[i] == "-q" )
		{
			res.quiet= true;
			++i;
		}
		else if( args[i] == "--compiler-executable" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--compiler-executable\".\n" );
				return ust::null_optional;
			}
			res.compiler_executable_path= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--build-directory" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--build-directory\".\n" );
				return ust::null_optional;
			}
			res.build_directory= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--project-directory" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--project-directory\".\n" );
				return ust::null_optional;
			}
			res.root_package_directory= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--ustlib-path" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--ustlib-path\".\n" );
				return ust::null_optional;
			}
			res.ustlib_path= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--build-system-imports-path" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--build-system-imports-path\".\n" );
				return ust::null_optional;
			}
			res.build_system_imports_path= args[i + 1s];
			i+= 2s;
		}
		else
		{
			ust::stderr_print( "Error, unrecognized option \"" + ust::string8(args[i]) + "\".\n" );
			return ust::null_optional;
		}
	}

	return move(res);
}

fn ExtractExeDirectoryPath( ust::string_view8 exe_path ) : ust::string_view8 @( ust::reference_notation::return_inner_references::param0_inner_reference0 )
{
	var ust::string_view8 mut p = exe_path;
	while( !p.empty() && !( p.back() == "/"c8 || p.back() == "\\"c8 ) )
	{
		p.drop_back();
	}

	return p;
}

struct BuildSystemPaths
{
	ust::string8 compiler_executable_path;
	ust::string8 ustlib_path;
	ust::string8 build_system_imports_path;
}

fn BuildAndLoadPackageBuildScript(
	Logger &mut logger,
	BuildSystemPaths& build_system_paths,
	ust::string_view8 package_source_directory,
	ust::string_view8 package_build_directory,
	ust::string_view8 entry_func_name ) : ust::optional</SharedLibrary/>
{
	// TODO - select more catchy name for root build script file.
	auto constexpr build_script_file= "build.u";

	var ust::string8 build_script_wrapper_file_path= ust::string8(package_build_directory) + "/" + "build_script_wrapper.u";

	// Create our own wrapper file to ensure that the function exported from the shared library has proper type.
	{
		var ust::string8 mut build_script_wrapper_contents = "import \"/";
		build_script_wrapper_contents+= build_script_file;
		build_script_wrapper_contents+= "\"\n\n";
		build_script_wrapper_contents+= "fn nomangle ";
		build_script_wrapper_contents+= entry_func_name;
		build_script_wrapper_contents+= "() : BK::PackageInfo { return GetPackageInfo(); }";
		build_script_wrapper_contents+= "\n";

		if( !WriteFile( build_script_wrapper_file_path, build_script_wrapper_contents ) )
		{
			logger.LogError( "Can't write build script wrapper file." );
			return ust::null_optional;
		}
	}

	var ust::string8 mut result_shared_library_path= package_build_directory;
	result_shared_library_path+= "/build.";
	result_shared_library_path+= GetNativeSharedLibraryExtension();

	var ust::string8 internalize_preserve_option = ust::string8("--internalize-preserve=") + entry_func_name;

	// Use optimization level which was used to compile the build system executable.
	var ust::string8 mut optimization_level= "-O";
	optimization_level.push_back( compiler::options::optimization_level );

	var ust::vector</ust::string_view8/> mut compiler_args;
	// Add path to the package directory in order to import "build.u" inside the wrapper.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( package_source_directory );
	// Provide standard library imports.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( build_system_paths.ustlib_path );
	// Provide path to declarations of the build system interface.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( build_system_paths.build_system_imports_path );
	compiler_args.push_back( build_script_wrapper_file_path );  // The file to buld.
	compiler_args.push_back( "-o" );
	compiler_args.push_back( result_shared_library_path );
	compiler_args.push_back( "-filetype=dll" );
	// Run internalization in order to export only entry function.
	compiler_args.push_back( "--internalize" );
	compiler_args.push_back( internalize_preserve_option );
	compiler_args.push_back( optimization_level );

	// If the build system executable was compiled with debug information - generate it for the shared library too.
	if( compiler::options::generate_debug_info )
	{
		compiler_args.push_back( "-g" );
	}

	// Use the same target parameters for the shared library as for the build system executable.
	// TODO - set also architecture.

	compiler_args.push_back( "--target-vendor" );
	compiler_args.push_back( compiler::target::vendor );

	compiler_args.push_back( "--target-os" );
	compiler_args.push_back( compiler::target::os );

	compiler_args.push_back( "--target-environment" );
	compiler_args.push_back( compiler::target::environment );

	if( ust::string_view8( compiler::target::os ) != "windows" )
	{
		// It seems that position-independent code is always enabled on systems except Windows.
		// So, use this option for building the shared library.
		compiler_args.push_back( "--relocation-model" );
		compiler_args.push_back( "pic" );
	}

	if( ust::string_view8( compiler::target::environment ) == "msvc" )
	{
		// Do not generate ".lib" file - it's unnecessary, since we load the DLL dynamically.
		compiler_args.push_back( "-Wl,/NOIMPLIB" );
	}

	if( !RunExecutable( build_system_paths.compiler_executable_path, compiler_args ) )
	{
		logger.LogError( "Compiler execution failed." );
		return ust::null_optional;
	}

	logger.LogInfo( "Loading " + result_shared_library_path );

	auto shared_library_opt = LoadSharedLibrary( result_shared_library_path );
	if( shared_library_opt.empty() )
	{
		logger.LogError( "Failed to load build script shared library." );
		return ust::null_optional;
	}

	return shared_library_opt;
}

fn GetNativeSharedLibraryExtension() : ust::string_view8
{
	return( ust::string_view8( compiler::target::os ) == "windows" ? ust::string_view8("dll") : ust::string_view8("so") );
}

fn CheckPackageIsOk( Logger &mut logger, PackageInfo& package_info ) : bool
{
	var bool mut ok= true;
	for( auto mut i= 0s; i < package_info.build_targets.size(); ++i )
	{
		var BuildTarget& build_target= package_info.build_targets[i];
		auto& current_name= build_target.name;
		for( auto mut j= 0s; j < i; ++j )
		{
			if( current_name == package_info.build_targets[j].name )
			{
				logger.LogError( "Error, duplicated build target \"" + current_name + "\"!" );
				ok= false;
			}
		}

		for( auto mut m= 0s; m < build_target.source_files.size(); ++m )
		{
			for( auto mut n= 0s; n < m; ++n )
			{
				if( build_target.source_files[m] == build_target.source_files[n] )
				{
					logger.LogError( "Error, duplicated source file \"" + build_target.source_files[m] + "\" of the build target \"" + current_name + "\"!" );
					ok= false;
				}
			}
		}
	}

	return ok;
}

// Returns true on success.
fn PerformPackageTargetBuild(
	Logger &mut logger,
	BuildSystemPaths& build_system_paths,
	ust::string_view8 package_source_directory,
	ust::string_view8 package_build_directory,
	BuildTarget& target) : bool
{
	// TODO - fix this check, do not use host OS.
	var bool target_is_windows = ust::string_view8(compiler::target::os) == "windows";

	var ust::string8 mut result_target_file_path = ust::string8(package_build_directory) + "/" + target.name;

	if( target_is_windows )
	{
		result_target_file_path+= ".exe";
	}

	// For now just build all files together into result executable.
	// TODO - compile each source file individually and support incremental building.

	var ust::vector</ust::string8/> mut source_files_absolute;
	foreach( &source_file : target.source_files )
	{
		source_files_absolute.push_back( ust::string8(package_source_directory) + "/" + source_file );
	}

	var ust::vector</ust::string_view8/> mut compiler_args;
	// Provide standard library imports.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( build_system_paths.ustlib_path );

	// Hack to prevent "ReferencePollutionOfOuterLoopVariable" error.
	if(false)
	{
		compiler_args.push_back( cast_imut(source_files_absolute).front() );
	}

	for( auto mut i = 0s; i < source_files_absolute.size(); ++i )
	{
		compiler_args.push_back( cast_imut(source_files_absolute)[i] );
	}

	compiler_args.push_back( "-o" );
	compiler_args.push_back( result_target_file_path );

	// TODO - support other target types.
	compiler_args.push_back( "-filetype=exe" );

	// Run internalization in order to export only "main".
	compiler_args.push_back( "--internalize" );

	// TODO - disable "pic" by default for windows target.
	compiler_args.push_back( "--relocation-model" );
	compiler_args.push_back( "pic" );

	// TODO - select optimization level based on configuration.
	compiler_args.push_back( "-O2" );


	logger.LogInfo( "Building \"" + result_target_file_path + "\"" );

	if( !RunExecutable( build_system_paths.compiler_executable_path, compiler_args ) )
	{
		logger.LogError( "Compiler execution failed." );
		return false;
	}

	return true;
}

} // namespace BK
