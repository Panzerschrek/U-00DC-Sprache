import "/stdout.u"
import "/string.u"
import "/string_conversions.u"
import "/vector.u"
import "filesystem.uh"
import "shared_library.uh"
import "process.uh"
import "imports/build_system.uh"


fn nomangle main( i32 argc, $($(char8)) argv ) : i32
{
	auto args= unsafe( BK::ArgsToStringView( argc, argv ) );
	return BK::Main( args.front(), args.range().subrange_start(1s) );
}

namespace BK
{

fn ArgsToStringView( i32 argc, $($(char8)) argv ) unsafe : ust::vector</ust::string_view8/>
{
	var ust::vector</ust::string_view8/> mut res;
	for( auto mut i= 0; i < argc; ++i )
	{
		res.push_back( unsafe( NullTerminatedStringToStringView( $>( argv + i ) ) ) );
	}

	return res;
}

fn NullTerminatedStringToStringView( $(char8) ptr ) unsafe : ust::string_view8
{
	unsafe
	{
		auto mut p= ptr;
		while( $>(p) != "\0"c8 )
		{
			++p;
		}

		return ust::string_view8( ptr, size_type( p - ptr ) );
	}
}

// Place actual "main" code inside the "BK" namespace.
fn Main( ust::string_view8 exe_path, ust::array_view_imut</ust::string_view8/> args ) : i32
{
	ust::stdout_print( "Bürokratie - the Ü build system!\n" );

	var ust::optional</Options/> options_opt= ParseOptions( args );
	if( options_opt.empty() )
	{
		ust::stderr_print( "Failed to parse options.\n" );
		return -1;
	}

	var Options& options= options_opt.try_deref();

	if( !EnsureDirectoryExists( options.build_directory ) )
	{
		ust::stderr_print( "Can't create build directory.\n" );
		return -1;
	}

	// TODO - customize it based on package name?
	auto constexpr entry_func_name = "GetPackageInfoImpl";

	auto shared_library_opt = BuildAndLoadBuildScript( options, entry_func_name );
	if( shared_library_opt.empty() )
	{
		ust::stderr_print( "Faild to load/build the build script shared library.\n" );
		return -1;
	}

	auto mut func_raw_ptr= shared_library_opt.try_deref().LoadSymbol( entry_func_name );
	if( ust::is_nullptr(func_raw_ptr) )
	{
		ust::stderr_print( "Faild to load function " + entry_func_name + "\n" );
		return -1;
	}

	var GetPackageInfoFunctionType mut func_ptr= zero_init;
	unsafe( ust::memory_copy(
		ust::ptr_cast_to_byte8( $<(func_ptr) ),
		ust::ptr_cast_to_byte8( $<(func_raw_ptr) ),
		typeinfo</ typeof(func_ptr) />.size_of ) );

	var PackageInfo package_info= func_ptr();

	foreach( &build_target : package_info.build_targets )
	{
		if( !PerformTargetBuild( build_target, options ) )
		{
			ust::stderr_print( "Failed to build target " + build_target.name + "!\n" );
			return -1;
		}
	}

	ust::stdout_print( "Successfully finished the build!\n" );
	return 0;
}

struct Options
{
	ust::string8 compiler_executable_path;
	ust::string8 build_directory;
	ust::string8 root_package_directory;
	ust::string8 ustlib_path;
	ust::string8 build_system_imports_path;
}

fn ParseOptions( ust::array_view_imut</ust::string_view8/> args ) : ust::optional</Options/>
{
	var Options mut res = MakeDefaultOptions();

	for( auto mut i= 0s; i < args.size(); )
	{
		if( args[i] == "--compiler-executable" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--compiler-executable\".\n" );
				return ust::null_optional;
			}
			res.compiler_executable_path= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--build-directory" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--build-directory\".\n" );
				return ust::null_optional;
			}
			res.build_directory= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--project-directory" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--project-directory\".\n" );
				return ust::null_optional;
			}
			res.root_package_directory= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--ustlib-path" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--ustlib-path\".\n" );
				return ust::null_optional;
			}
			res.ustlib_path= args[i + 1s];
			i+= 2s;
		}
		else if( args[i] == "--build-system-imports-path" )
		{
			if( i + 1s >= args.size() )
			{
				ust::stderr_print( "Error, missing an argument after \"--build-system-imports-path\".\n" );
				return ust::null_optional;
			}
			res.build_system_imports_path= args[i + 1s];
			i+= 2s;
		}
		else
		{
			ust::stderr_print( "Error, unrecognized option \"" + ust::string8(args[i]) + "\".\n" );
			return ust::null_optional;
		}
	}

	return move(res);
}

fn MakeDefaultOptions() : Options
{
	var Options mut res;

	// TODO - select more catchy name for a build directory.
	res.build_directory= "build";

	// TODO - find a proper compiler executable in current executable directory.
	res.compiler_executable_path= "Compiler1";

	// Default option is to use current directory.
	res.root_package_directory= ".";

	// TODO - set some default.
	res.ustlib_path= "";

	// TODO - set some default.
	res.build_system_imports_path= "";

	return res;
}

fn BuildAndLoadBuildScript( Options& options, ust::string_view8 entry_func_name ) : ust::optional</SharedLibrary/>
{
	// TODO - select more catchy name for root build script file.
	auto constexpr build_script_file= "build.u";

	var ust::string8 build_script_wrapper_file_path= options.build_directory + "/" + "build_script_wrapper.u";

	// Create our own wrapper file to ensure that the function exported from the shared library has proper type.
	{
		var ust::string8 mut build_script_wrapper_contents = "import \"/";
		build_script_wrapper_contents+= build_script_file;
		build_script_wrapper_contents+= "\"\n\n";
		build_script_wrapper_contents+= "fn nomangle ";
		build_script_wrapper_contents+= entry_func_name;
		build_script_wrapper_contents+= "() : BK::PackageInfo { return GetPackageInfo(); }";
		build_script_wrapper_contents+= "\n";

		if( !WriteFile( build_script_wrapper_file_path, build_script_wrapper_contents ) )
		{
			ust::stderr_print( "Can't write build script wrapper file.\n" );
			return ust::null_optional;
		}
	}

	var ust::string8 mut result_shared_library_path= options.build_directory;
	result_shared_library_path+= "/build.";
	result_shared_library_path+= GetNativeSharedLibraryExtension();

	var ust::string8 internalize_preserve_option = ust::string8("--internalize-preserve=") + entry_func_name;

	var ust::vector</ust::string_view8/> mut compiler_args;
	// Add path to the package directory in order to import "build.u" inside the wrapper.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( options.root_package_directory );
	// Provide standard library imports.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( options.ustlib_path );
	// Provide path to declarations of the build system interface.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( options.build_system_imports_path );
	compiler_args.push_back( build_script_wrapper_file_path );  // The file to buld.
	compiler_args.push_back( "-o" );
	compiler_args.push_back( result_shared_library_path );
	compiler_args.push_back( "-filetype=dll" );
	// Run internalization in order to export only entry function.
	compiler_args.push_back( "--internalize" );
	compiler_args.push_back( internalize_preserve_option );
	// TODO - use optimization, codegen and options which were used to build this executable.
	compiler_args.push_back( "--relocation-model" );
	compiler_args.push_back( "pic" );
	compiler_args.push_back( "-O2" );

	if( ust::string_view8( compiler::target::environment ) == "msvc" )
	{
		// Do not generate ".lib" file - it's unnecessary, since we load the DLL dynamically.
		compiler_args.push_back( "-Wl,/NOIMPLIB" );
	}

	if( !RunExecutable( options.compiler_executable_path, compiler_args ) )
	{
		ust::stderr_print( "Compiler execution failed.\n" );
		return ust::null_optional;
	}

	ust::stdout_print( "Loading " + result_shared_library_path + "\n" );
	auto shared_library_opt = LoadSharedLibrary( result_shared_library_path );
	if( shared_library_opt.empty() )
	{
		ust::stderr_print( "Faild to load build script shared library\n" );
		return ust::null_optional;
	}

	return shared_library_opt;
}

fn GetNativeSharedLibraryExtension() : ust::string_view8
{
	return( ust::string_view8( compiler::target::os ) == "windows" ? ust::string_view8("dll") : ust::string_view8("so") );
}

// Returns true on success.
fn PerformTargetBuild( BuildTarget& target, Options& options ) : bool
{
	// TODO - add target platform-specific extension.
	var ust::string8 result_target_file_path = options.build_directory + "/" + target.name;

	// For now just build all files together into result executable.
	// TODO - compile each source file individually and support incremental building.

	var ust::vector</ust::string8/> mut source_files_absolute;
	foreach( &source_file : target.source_files )
	{
		// TODO - perform actual file path canonisation.
		source_files_absolute.push_back( options.root_package_directory + "/" + source_file );
	}

	var ust::vector</ust::string_view8/> mut compiler_args;
	// Provide standard library imports.
	compiler_args.push_back( "--include-dir" );
	compiler_args.push_back( options.ustlib_path );

	// Hack to prevent "ReferencePollutionOfOuterLoopVariable" error.
	if(false)
	{
		compiler_args.push_back( cast_imut(source_files_absolute).front() );
	}

	for( auto mut i = 0s; i < source_files_absolute.size(); ++i )
	{
		compiler_args.push_back( cast_imut(source_files_absolute)[i] );
	}

	compiler_args.push_back( "-o" );
	compiler_args.push_back( result_target_file_path );

	// TODO - support other target types.
	compiler_args.push_back( "-filetype=exe" );

	// Run internalization in order to export only "main".
	compiler_args.push_back( "--internalize" );

	// TODO - select position independent code only where necessary.
	compiler_args.push_back( "--relocation-model" );
	compiler_args.push_back( "pic" );

	// TODO - select optimization level based on configuration.
	compiler_args.push_back( "-O2" );

	ust::stdout_print( "Building \"" + result_target_file_path + "\"\n" );

	if( !RunExecutable( options.compiler_executable_path, compiler_args ) )
	{
		ust::stderr_print( "Compiler execution failed.\n" );
		return false;
	}

	return true;
}

} // namespace BK
