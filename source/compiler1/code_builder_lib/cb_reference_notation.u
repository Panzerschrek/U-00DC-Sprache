import "/sort.u"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::EvaluateReferenceFieldTag( mut this, NamesScopePtr& names_scope, Synt::Expression& expression ) : ust::optional</u8/>
{
	var VariableLite variable= EvaluateReferenceNotationExpression( names_scope, expression );
	var SrcLoc src_loc= Synt::GetSrcLoc( expression );

	var FundamentalType expected_type( U_FundamentalType::char8_, fundamental_llvm_types_.char8_ );
	if( variable.t != expected_type )
	{
		REPORT_ERROR( TypesMismatch, names_scope, src_loc, Type(expected_type), variable.t )
		return ust::null_optional;
	}
	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( ExpectedConstantExpression, names_scope, src_loc )
		return ust::null_optional;
	}

	var u64 value= unsafe( LLVMConstIntGetZExtValue( variable.constexpr_value ) );
	if( value >= u64( "a"c8 ) && value <= u64( "z"c8 ) )
	{
		return u8( value - u64( "a"c8 ) );
	}
	else
	{
		REPORT_ERROR( InvalidInnerReferenceTagName, names_scope, src_loc, value )
		return ust::null_optional;
	}
}

fn CodeBuilder::EvaluateReferenceFieldInnerTags( mut this, NamesScopePtr& names_scope, Synt::Expression& expression ) : ust::optional</ust::vector</u8/>/>
{
	var VariableLite variable= EvaluateReferenceNotationExpression( names_scope, expression );
	var SrcLoc src_loc= Synt::GetSrcLoc( expression );
	if_var( &array_type : variable.t.GetArrayType() )
	{
		var FundamentalType expected_type( U_FundamentalType::char8_, fundamental_llvm_types_.char8_ );
		if( array_type.element_type != expected_type )
		{
			REPORT_ERROR( TypesMismatch, names_scope, src_loc, Type(expected_type), variable.t )
			return ust::null_optional;
		}
		if( variable.constexpr_value == LLVMValueRef::Null )
		{
			REPORT_ERROR( ExpectedConstantExpression, names_scope, src_loc )
			return ust::null_optional;
		}

		var ust::vector</u8/> mut result;
		result.resize( size_type(array_type.element_count), 0u8 );

		for( auto mut i= 0u64; i < array_type.element_count; ++i )
		{
			var u64 value= unsafe( LLVMConstIntGetZExtValue( LLVMGetAggregateElement( variable.constexpr_value, u32(i) ) ) );
			if( value >= u64( "a"c8 ) && value <= u64( "z"c8 ) )
			{
				result[i]= u8( value - u64( "a"c8 ) );
			}
			else
			{
				REPORT_ERROR( InvalidInnerReferenceTagName, names_scope, src_loc, value )
				return ust::null_optional;
			}
		}
		return move(result);
	}
	else
	{
		REPORT_ERROR( TypesMismatch, names_scope, src_loc, "array of char8", variable.t )
		return ust::null_optional;
	}
}

fn CodeBuilder::EvaluateFunctionReferencePollution( mut this, NamesScopePtr& names_scope, Synt::Expression& expression ) : ust::vector</FunctionType::ReferencePollution/>
{
	var ust::vector</FunctionType::ReferencePollution/> mut result;

	var VariableLite variable= EvaluateReferenceNotationExpression( names_scope, expression );
	var SrcLoc src_loc= Synt::GetSrcLoc( expression );

	if_var( &array_type : variable.t.GetArrayType() )
	{
		if( array_type.element_type != reference_notation_pollution_element_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, src_loc, reference_notation_pollution_element_type_, variable.t )
			return result;
		}
		if( variable.constexpr_value == LLVMValueRef::Null )
		{
			REPORT_ERROR( ExpectedConstantExpression, names_scope, src_loc )
			return result;
		}

		for( auto mut i= 0u64; i < array_type.element_count; ++i )
		{
			auto constant= unsafe( LLVMGetAggregateElement( variable.constexpr_value, u32(i) ) );
			auto dst_reference= ParseEvaluatedParamReference( unsafe( LLVMGetAggregateElement( constant, 0u ) ), names_scope, src_loc );
			auto src_reference= ParseEvaluatedParamReference( unsafe( LLVMGetAggregateElement( constant, 1u ) ), names_scope, src_loc );
			if( dst_reference.empty() || src_reference.empty() )
			{
				continue;
			}

			var FunctionType::ReferencePollution pollution
			{
				.dst= dst_reference.try_deref(),
				.src= src_reference.try_deref(),
			};

			if( pollution.dst.reference_index == FunctionType::c_param_reference_number )
			{
				REPORT_ERROR( ArgReferencePollution, names_scope, src_loc )
				continue;
			}

			if( pollution.dst == pollution.src )
			{
				REPORT_ERROR( SelfReferencePollution, names_scope, src_loc )
				continue;
			}

			result.push_back( pollution );
		}

		ust::sort( result.range() );
		return result;
	}
	else
	{
		REPORT_ERROR( TypesMismatch, names_scope, src_loc, "array of " + reference_notation_pollution_element_type_.ToString(), variable.t )
		return result;
	}
}

fn CodeBuilder::EvaluateFunctionReturnReferences( mut this, NamesScopePtr& names_scope, Synt::Expression& expression ) : FunctionType::ParamReferences
{
	var FunctionType::ParamReferences mut result;

	var VariableLite variable= EvaluateReferenceNotationExpression( names_scope, expression );
	var SrcLoc src_loc= Synt::GetSrcLoc( expression );

	return move(result);
}

fn CodeBuilder::EvaluateFunctionReturnInnerReferences( mut this, NamesScopePtr& names_scope, Synt::Expression& expression ) : ust::vector</ FunctionType::ParamReferences />
{
	var ust::vector</ FunctionType::ParamReferences /> mut result;

	var VariableLite variable= EvaluateReferenceNotationExpression( names_scope, expression );
	var SrcLoc src_loc= Synt::GetSrcLoc( expression );

	return result;
}

fn ParseEvaluatedParamReference( LLVMValueRef constant, NamesScopePtr& names_scope, SrcLoc& src_loc ) : ust::optional</ FunctionType::ParamReference />
{
	var u64 param= unsafe( LLVMConstIntGetZExtValue( LLVMGetAggregateElement( constant, 0u ) ) );
	var u64 ref= unsafe( LLVMConstIntGetZExtValue( LLVMGetAggregateElement( constant, 1u ) ) );

	if( !( param >= u64( "0"c8 ) && param <= u64( "9"c8 ) ) )
	{
		REPORT_ERROR( InvalidParamNumber, names_scope, src_loc, param )
		return ust::null_optional;
	}

	if( !( ( ref >= u64( "a"c8 ) && ref <= u64( "z"c8 ) ) || ref == u64( "_"c8 ) ) )
	{
		REPORT_ERROR( InvalidInnerReferenceTagName, names_scope, src_loc, ref )
		return ust::null_optional;
	}

	var FunctionType::ParamReference result
	{
		.param_index= u8( param - u64( "0"c8 ) ),
		.reference_index= select( ref == u64( "_"c8 ) ? FunctionType::c_param_reference_number : u8( ref - u64( "a"c8 ) ) )
	};

	return result;
}

fn CodeBuilder::EvaluateReferenceNotationExpression( mut this, NamesScopePtr& names_scope, Synt::Expression& expression ) : VariableLite
{
	auto mut function_context= CreateGlobalFunctionContext();
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();
		return BuildExpressionCodeEnsureVariable( names_scope, function_context, expression ).lock_imut().deref();
	}
}

} // namespace U1
