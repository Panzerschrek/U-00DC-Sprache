import "/string_conversions.u"
import "../lex_synt_lib/keywords.uh"
import "mangling.uh"

namespace U
{

struct MangleGraphNode
{
	ust::string8 prefix;
	ust::vector</ ust::box</MangleGraphNode/> /> childs;
	ust::string8 postfix;
	bool cachable= true;
}

fn Base36Digit( size_type mut value ) : char8
{
	value %= 36s;
	if( value < 10s )
	{
		return char8(size_type("0"c8) + value);
	}
	else
	{
		return char8(size_type("A"c8) + ( value - 10s ) );
	}
}

class NamesCache
{
public:
	fn AddName( mut this, ust::string8 mut name )
	{
		foreach( & candidate : names_container_ )
		{
			if( candidate == name )
			{
				return;
			}
		}
		names_container_.push_back( name );
	}

	fn GetReplacement( this, ust::string8& name ) : ust::optional</ust::string8/>
	{
		for( auto mut index= 0s; index < names_container_.size(); ++index )
		{
			auto& candidate= names_container_[index];
			if( name == candidate )
			{
				if( index == 0s )
				{
					return ust::string8("S_");
				}
				if( index == 1s )
				{
					return ust::string8("S0_");
				}

				var ust::string8 mut result, mut digit;
				for( auto mut n= index - 1s; n > 0s; n/= 36s ) // Converto to 36-base number representation.
				{
					digit.push_back( Base36Digit( n ) );
					result= digit + result;
					digit.clear();
				}

				return "S" + result + "_";
			}
		}

		return ust::optional</ust::string8/>();
	}

private:
	ust::vector</ust::string8/> names_container_;
}

struct NamePair
{
	ust::string8 full;
	ust::string8 compressed;
}

fn MangleGraphFinalize_r( NamesCache &mut names_cache, MangleGraphNode& node ) : NamePair
{
	var NamePair mut result;

	result.full+= node.prefix;
	result.compressed+= node.prefix;
	foreach( &child_node : node.childs )
	{
		var NamePair child_node_result= MangleGraphFinalize_r( names_cache, child_node.get_ref() );
		result.full+= child_node_result.full;
		result.compressed+= child_node_result.compressed;
	}
	result.full+= node.postfix;
	result.compressed+= node.postfix;

	if( node.cachable )
	{
		auto replacement = names_cache.GetReplacement( result.full );
		if( !replacement.empty() )
		{
			result.compressed= replacement.get_ref();
		}
		else
		{
			names_cache.AddName( result.full );
		}
	}

	return move(result);
}

fn MangleGraphFinalize( MangleGraphNode& node ) : ust::string8
{
	var NamesCache mut names_cache;
	return MangleGraphFinalize_r( names_cache, node ).compressed;
}

fn GetNestedName( ust::string8& name, NamesScope& parent_scope, bool no_name_num_prefix ) : MangleGraphNode
{
	var MangleGraphNode mut res;

	auto num_prefix= select( no_name_num_prefix ? ust::string8() : ust::to_string8(name.size()) );
	if( !parent_scope.GetParent().empty() )
	{
		res.prefix+= "N";
		res.childs.push_back( ust::box</MangleGraphNode/>( GetNamespacePrefix_r( parent_scope ) ) );
		res.postfix+= num_prefix;
		res.postfix+= name;
		res.postfix+= "E";
	}
	else
	{
		res.prefix+= num_prefix;
		res.prefix+= name;
	}
	return move(res);
}

fn GetNestedName( ust::string8& name, NamesScope& names_scope ) : MangleGraphNode
{
	return GetNestedName( name, names_scope, false );
}

fn MangleFundamentalTypeName( U_FundamentalType t ) : ust::string8
{
	if( t == U_FundamentalType::InvalidType ){ return ust::string8(); }
	if( t == U_FundamentalType::LastType	){ return ust::string8(		); }
	if( t == U_FundamentalType::void_		){ return ust::string8( "v"	); }
	if( t == U_FundamentalType::bool_		){ return ust::string8( "b"	); }
	if( t == U_FundamentalType::i8_			){ return ust::string8( "a"	); } // C++ signed char
	if( t == U_FundamentalType::u8_			){ return ust::string8( "h"	); } // C++ unsigned char
	if( t == U_FundamentalType::i16_		){ return ust::string8( "s"	); }
	if( t == U_FundamentalType::u16_		){ return ust::string8( "t"	); }
	if( t == U_FundamentalType::i32_		){ return ust::string8( "i"	); }
	if( t == U_FundamentalType::u32_		){ return ust::string8( "j"	); }
	if( t == U_FundamentalType::i64_		){ return ust::string8( "x"	); }
	if( t == U_FundamentalType::u64_		){ return ust::string8( "y"	); }
	if( t == U_FundamentalType::i128_		){ return ust::string8( "n"	); }
	if( t == U_FundamentalType::u128_		){ return ust::string8( "o"	); }
	if( t == U_FundamentalType::f32_		){ return ust::string8( "f"	); }
	if( t == U_FundamentalType::f64_		){ return ust::string8( "d"	); }
	if( t == U_FundamentalType::char8_		){ return ust::string8( "c"	); }
	if( t == U_FundamentalType::char16_		){ return ust::string8( "Ds"); }
	if( t == U_FundamentalType::char32_		){ return ust::string8( "Di"); }
	return ust::string8();
}

fn GetTemplateClassName( ClassType& class_type ) : MangleGraphNode
{
	var MangleGraphNode mut name_node;
	auto& class_name= class_type.base_template.get_ref().class_template.get_ref().syntax_element.get_ref().name;
	name_node.postfix+= ust::to_string8( class_name.size() );
	name_node.postfix+= class_name;

	// Skip template parameters namespace.
	auto parent= class_type.members.lock_imut().get_ref().GetParent().lock_imut().get_ref().GetParent();
	if( !parent.lock_imut().get_ref().GetThisNamespaceName().empty() )
	{
		name_node.childs.push_back( ust::box</MangleGraphNode/>( GetNamespacePrefix_r( parent.lock_imut().get_ref() ) ) );
	}

	auto mut params_node= MangleTemplateArgsImpl( class_type.base_template.get_ref().signature_args );

	var MangleGraphNode mut result;
	result.childs.push_back( ust::box</MangleGraphNode/>( move( name_node ) ) );
	result.childs.push_back( ust::box</MangleGraphNode/>( move( params_node ) ) );
	return move(result);
}

fn MangleTypeImpl( Type& t ) : MangleGraphNode
{
	if_var( fundamental_type : t.GetFundamentalType() )
	{
		var MangleGraphNode mut res;
		res.prefix= MangleFundamentalTypeName( fundamental_type.fundamental_type );
		res.cachable= false;
		return move(res);
	}
	if_var( array_type : t.GetArrayType() )
	{
		var MangleGraphNode mut res;
		res.prefix= "A";
		res.prefix+= ust::to_string8(array_type.element_count);
		res.prefix+= "_";
		res.childs.push_back( ust::box</MangleGraphNode/>( MangleTypeImpl( array_type.element_type.get_ref() ) ) );
		return move(res);
	}
	if_var( class_type_ptr : t.GetClassType() )
	{
		auto class_lock= class_type_ptr.lock_imut();
		auto& class_type= class_lock.get_ref();
		auto class_members= class_type.members;
		auto class_members_lock= class_members.lock_imut();
		auto& class_members_ref= class_members_lock.get_ref();

		if( !class_type.base_template.empty() )
		{
			auto mut res= GetTemplateClassName( class_type );

			auto t= class_type.base_template.get_ref().class_template;
			auto t_namespace= t.get_ref().parent_names_scope.lock();
			if( !t_namespace.empty() && !t_namespace.lock_imut().get_ref().GetParent().empty() )
			{
				res.prefix= "N";
				res.postfix= "E";
			}
			return move(res);
		}
		else
		{
			return GetNestedName( class_members_ref.GetThisNamespaceName(), class_members_ref.GetParent().lock_imut().get_ref() );
		}
	}
	if_var( enum_type : t.GetEnumType() )
	{
		auto enum_members= enum_type.lock_imut().get_ref().names_scope;
		auto enum_members_lock= enum_members.lock_imut();
		auto& enum_members_ref= enum_members_lock.get_ref();

		return GetNestedName( enum_members_ref.GetThisNamespaceName(), enum_members_ref.GetParent().lock_imut().get_ref() );
	}

	return MangleGraphNode();
}

fn GetNamespacePrefix_r( NamesScope& names_scope ) : MangleGraphNode
{
	auto& name= names_scope.GetThisNamespaceName();

	// Process separately class templates.
	auto class_ptr= names_scope.GetClass();
	if( !class_ptr.empty() )
	{
		auto class_lock= class_ptr.lock_imut();
		auto& class_= class_lock.get_ref();
		if( !class_.base_template.empty() )
		{
			return GetTemplateClassName( class_ );
		}
	}

	var MangleGraphNode mut res;

	auto parent= names_scope.GetParent();
	if( !parent.empty() )
	{
		auto parent_lock= parent.lock_imut();
		auto& parent_ref= parent_lock.get_ref();
		if( !parent_ref.GetThisNamespaceName().empty() )
		{
			res.childs.push_back( ust::box</MangleGraphNode/>( GetNamespacePrefix_r( parent_ref ) ) );
		}
	}

	res.postfix+= ust::to_string8( name.size() );
	res.postfix+= name;

	return move(res);
}

fn MangleTemplateArgsImpl( TemplateArgsFinished& template_args ) : MangleGraphNode
{
	var MangleGraphNode mut result;
	result.prefix= "I";

	foreach( &arg : template_args )
	{
		if_var( &t : arg.get</Type/>() )
		{
			result.childs.push_back( ust::box</MangleGraphNode/>( MangleTypeImpl( t ) ) );
		}
		if_var( &v : arg.get</Variable/>() )
		{
			var MangleGraphNode mut variable_param_node;
			variable_param_node.prefix= "L";
			variable_param_node.childs.push_back( ust::box</MangleGraphNode/>( MangleTypeImpl( v.t ) ) );

			auto mut is_signed= false;
			if_var( fundamental_type : v.t.GetFundamentalType() )
			{
				is_signed= IsSignedInteger( fundamental_type.fundamental_type );
			}
			if_var( enum_type : v.t.GetEnumType() )
			{
				is_signed= IsSignedInteger( enum_type.lock_imut().get_ref().underlaying_type.fundamental_type );
			}

			if( v.constexpr_value != LLVMValueRef::Null )
			{
				unsafe
				{
					if( is_signed )
					{
						auto num= LLVMConstIntGetSExtValue( v.constexpr_value );
						if( num >= 0i64 )
						{
							variable_param_node.postfix+= ust::to_string8( num );
						}
						else
						{
							variable_param_node.postfix+= "n";
							variable_param_node.postfix+= ust::to_string8( -num );
						}
					}
					else
					{
						variable_param_node.postfix+= ust::to_string8( LLVMConstIntGetZExtValue( v.constexpr_value ) );
					}
				}
			}

			variable_param_node.postfix+= "E";
			variable_param_node.cachable= false;
			result.childs.push_back( ust::box</MangleGraphNode/>( move( variable_param_node ) ) );
		}
	}

	result.postfix= "E";

	result.cachable= false;
	return move(result);
}

fn DecodeOperator( ust::string8& o ) : ust::array_view_imut</ char8 />
{
	if( o == "+" ){ return "pl"; }
	if( o == "-" ){ return "mi"; }
	if( o == "*" ){ return "ml"; }
	if( o == "/" ){ return "dv"; }
	if( o == "%" ){ return "rm"; }

	if( o == "==" ){ return "eq"; }
	if( o == "!=" ){ return "ne"; }
	if( o == ">"  ){ return "gt"; }
	if( o == ">=" ){ return "ge"; }
	if( o == "<"  ){ return "lt"; }
	if( o == "<=" ){ return "le"; }

	if( o == "&" ){ return "an"; }
	if( o == "|" ){ return "or"; }
	if( o == "^" ){ return "eo"; }

	if( o == "<<" ){ return "ls"; }
	if( o == ">>" ){ return "rs"; }

	if( o == "+=" ){ return "pL"; }
	if( o == "-=" ){ return "mI"; }
	if( o == "*=" ){ return "mL"; }
	if( o == "/=" ){ return "dV"; }
	if( o == "%=" ){ return "rM"; }

	if( o == "&=" ){ return "aN"; }
	if( o == "|=" ){ return "oR"; }
	if( o == "^=" ){ return "eO"; }

	if( o == "<<=" ){ return "lS"; }
	if( o == ">>=" ){ return "rS"; }

	if( o == "!" ){ return "nt"; }
	if( o == "~" ){ return "co"; }

	if( o == "=" ){ return "aS"; }
	if( o == "++" ){ return "pp"; }
	if( o == "--" ){ return "mm"; }

	if( o == "()" ){ return "cl"; }
	if( o == "[]" ){ return "ix"; }

	return "";
}

fn MangleFunction(
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type ) : ust::string8
{
	var MangleGraphNode mut res;

	auto op_decoded= DecodeOperator( name );
	if( !op_decoded.empty() )
	{
		res.childs.push_back( ust::box</MangleGraphNode/>( GetNestedName( op_decoded, parent_scope, true ) ) );
	}
	else
	{
		res.childs.push_back( ust::box</MangleGraphNode/>( GetNestedName( name, parent_scope, false ) ) );
	}

	res.childs.back().get_ref().cachable= false;

	foreach( &arg : function_type.args )
	{
		var MangleGraphNode mut arg_node= MangleTypeImpl( arg.arg_type.get_ref() );
		if( !arg.is_mutable && arg.is_reference ) // push "Konst" for reference immutable arguments
		{
			var MangleGraphNode mut konst_node;
			konst_node.prefix= "K";
			konst_node.childs.push_back( ust::box</MangleGraphNode/>( take( arg_node ) ) );
			arg_node= move( konst_node );
		}
		if( arg.is_reference )
		{
			var MangleGraphNode mut ref_node;
			ref_node.prefix= "R";
			ref_node.childs.push_back( ust::box</MangleGraphNode/>( take( arg_node ) ) );
			arg_node= move( ref_node );
		}

		res.childs.push_back( ust::box</MangleGraphNode/>( move(arg_node) ) );
	}
	if( function_type.args.empty() )
	{
		var MangleGraphNode mut empty_args_node;
		empty_args_node.postfix= "v";
		res.childs.push_back( ust::box</MangleGraphNode/>( move( empty_args_node ) ) );
	}

	var ust::string8 mut str= "_Z";
	str+= MangleGraphFinalize(res);
	str+= "\0";
	return move(str);
}

fn MangleGlobalVariable( NamesScope& parent_scope, ust::string8& variable_name ) : ust::string8
{
	// Variables inside global namespace have simple names.
	if( parent_scope.GetParent().empty() )
	{
		return variable_name + "\0";
	}

	var ust::string8 mut res= "_Z";
	res+= MangleGraphFinalize( GetNestedName( variable_name, parent_scope ) );
	res+= "\0";
	return move(res);
}

fn MangleType( Type& t ) : ust::string8
{
	auto mut str= MangleGraphFinalize(MangleTypeImpl(t));
	str+= "\0";
	return move(str);
}

fn MangleTemplateArgs( TemplateArgsFinished& template_args ) : ust::string8
{
	auto mut str= MangleGraphFinalize(MangleTemplateArgsImpl(template_args));
	str+= "\0";
	return move(str);
}

} // namespace U
