import "/string_conversions.u"
import "/keywords.uh"
import "mangling.uh"
?macro <? ADD_NODE:block( ?mangling_state:ident ) ?b:block?>
->
<?
	{
		var ManglerState::NodeHolder ??node( ?mangling_state );
		auto &mut ?mangling_state= ??node.GetManglerState();
		?b
	}
?>

namespace U1
{

fn Base36Digit( size_type mut value ) : char8
{
	value %= 36s;
	if( value < 10s )
	{
		return char8(size_type("0"c8) + value);
	}
	else
	{
		return char8(size_type("A"c8) + ( value - 10s ) );
	}
}

// TODO - implement library method for range comparing.

fn StringViewEq( ust::array_view_imut</char8/> s0, ust::array_view_imut</char8/> s1 ) : bool
{
	if( s0.size() != s1.size() )
	{
		return false;
	}

	for( auto mut i= 0s; i < s0.size(); ++i )
	{
		if( s0[i] != s1[i] )
		{
			return false;
		}
	}

	return true;
}

class ManglerState
{
public:
	fn Push( mut this, char8 c );
	fn Push( mut this, ust::array_view_imut</char8/> name );
	fn PushLengthPrefixed( mut this, ust::array_view_imut</char8/> name );

	fn TakeResult( mut this ) : ust::string8;

public:
	class NodeHolder
	{
	public:
		fn constructor( mut this'a', ManglerState &'b mut state ) ' a <- b '
			( state_(state), start_= state_.GetCurrentPos(), compressed_start_= state_.GetCurrentCompressedPos() )
		{}

		fn destructor()
		{
			state_.FinalizePart( start_, compressed_start_ );
		}

		fn GetManglerState( this'x' ) : ManglerState &'x mut
		{
			return state_;
		}

	private:
		ManglerState &mut state_;
		size_type imut start_;
		size_type imut compressed_start_;
	}

private:
	fn GetCurrentPos( this ) : size_type;
	fn GetCurrentCompressedPos( this ) : size_type;
	fn FinalizePart( mut this, size_type start, size_type compressed_start );

private:
	type LenType= u16;
	struct Substitution
	{
		LenType start;
		LenType size;
	}

private:
	ust::vector</Substitution/> substitutions_;
	ust::string8 result_full_;
	ust::string8 result_compressed_;
}

fn ManglerState::Push( mut this, char8 c )
{
	result_full_.push_back( c );
	result_compressed_.push_back( c );
}

fn ManglerState::Push( mut this, ust::array_view_imut</char8/> name )
{
	result_full_+= name;
	result_compressed_+= name;
}

fn ManglerState::PushLengthPrefixed( mut this, ust::array_view_imut</char8/> name )
{
	Push( ust::to_string8(name.size()).range() );
	Push( name );
}

fn ManglerState::TakeResult( mut this ) : ust::string8
{
	// Take copy for result. This allows us to re-use internal buffer for mangling of next name.
	result_compressed_.push_back( "\0"c8 );
	var ust::string8 mut result= result_compressed_;

	substitutions_.clear();
	result_full_.clear();
	result_compressed_.clear();

	return move(result);
}

fn ManglerState::GetCurrentPos( this ) : size_type
{
	return result_full_.size();
}

fn ManglerState::GetCurrentCompressedPos( this ) : size_type
{
	return result_compressed_.size();
}

fn ManglerState::FinalizePart( mut this, size_type start, size_type compressed_start )
{
	auto size= result_full_.size() - start;

	// Search for replacement.
	for( auto mut i= 0s; i < substitutions_.size(); ++i )
	{
		var Substitution substitution= substitutions_[i];
		if( StringViewEq(
			cast_imut(result_full_).range().subrange( start, size ),
			cast_imut(result_full_).range().subrange( size_type(substitution.start), size_type(substitution.size) ) ) )
		{
			result_compressed_.resize( compressed_start, "\0"c8 );
			result_compressed_.push_back( "S"c8 );

			if( i > 0s )
			{
				auto n= i - 1s;
				if( n < 36s )
				{
					result_compressed_.push_back( Base36Digit( n ) );
				}
				else if( n < 36s * 36s )
				{
					result_compressed_.push_back( Base36Digit( n / 36s ) );
					result_compressed_.push_back( Base36Digit( n % 36s ) );
				}
				else if( n < 36s * 36s * 36s )
				{
					result_compressed_.push_back( Base36Digit( n / ( 36s * 36s ) ) );
					result_compressed_.push_back( Base36Digit( n / 36s % 36s ) );
					result_compressed_.push_back( Base36Digit( n % 36s ) );
				}
				else { halt; } // Too much substitutions.
			}
			result_compressed_.push_back( "_"c8 );
			return;
		}
	}

	// Not found replacement - add new substitution.
	var Substitution substitution{ .start= LenType(start), .size= LenType(size) };
	substitutions_.push_back( substitution );
}

fn GetNestedName( ManglerState &mut mangler_state, ust::string8& name, NamesScope& parent_scope )
{
	ADD_NODE( mangler_state )
	{
		if( !parent_scope.GetParent().empty() )
		{
			mangler_state.Push( "N" );
			GetNamespacePrefix_r( mangler_state, parent_scope );
			mangler_state.PushLengthPrefixed( name.range() );
			mangler_state.Push( "E" );
		}
		else
		{
			mangler_state.PushLengthPrefixed( name.range() );
		}
	}
}

fn MangleFundamentalTypeName( U_FundamentalType t ) : ust::string8
{
	if( t == U_FundamentalType::InvalidType ){ return ust::string8(); }
	if( t == U_FundamentalType::LastType	){ return ust::string8(		); }
	if( t == U_FundamentalType::void_		){ return ust::string8( "v"	); }
	if( t == U_FundamentalType::bool_		){ return ust::string8( "b"	); }
	if( t == U_FundamentalType::i8_			){ return ust::string8( "a"	); } // C++ signed char
	if( t == U_FundamentalType::u8_			){ return ust::string8( "h"	); } // C++ unsigned char
	if( t == U_FundamentalType::i16_		){ return ust::string8( "s"	); }
	if( t == U_FundamentalType::u16_		){ return ust::string8( "t"	); }
	if( t == U_FundamentalType::i32_		){ return ust::string8( "i"	); }
	if( t == U_FundamentalType::u32_		){ return ust::string8( "j"	); }
	if( t == U_FundamentalType::i64_		){ return ust::string8( "x"	); }
	if( t == U_FundamentalType::u64_		){ return ust::string8( "y"	); }
	if( t == U_FundamentalType::i128_		){ return ust::string8( "n"	); }
	if( t == U_FundamentalType::u128_		){ return ust::string8( "o"	); }
	if( t == U_FundamentalType::f32_		){ return ust::string8( "f"	); }
	if( t == U_FundamentalType::f64_		){ return ust::string8( "d"	); }
	if( t == U_FundamentalType::char8_		){ return ust::string8( "c"	); }
	if( t == U_FundamentalType::char16_		){ return ust::string8( "Ds"); }
	if( t == U_FundamentalType::char32_		){ return ust::string8( "Di"); }
	return ust::string8();
}

fn EncodeTemplateClassName( ManglerState& mut mangler_state, ClassType& class_type )
{
	ADD_NODE( mangler_state )
	{
		auto& class_name= class_type.base_template.get_ref().class_template.get_ref().syntax_element.get_ref().name;
		mangler_state.PushLengthPrefixed( class_name.range() );

		// Skip template parameters namespace.
		auto parent= class_type.members.lock_imut().get_ref().GetParent().lock_imut().get_ref().GetParent();
		if( !parent.lock_imut().get_ref().GetThisNamespaceName().empty() )
		{
			GetNamespacePrefix_r( mangler_state, parent.lock_imut().get_ref() );
		}
	}

	MangleTemplateArgsImpl( mangler_state, class_type.base_template.get_ref().signature_args );
}


fn EncodeFunctionParam( ManglerState& mut mangler_state, FunctionType::Param& param )
{
	if( param.is_reference )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "R" );
			if( param.is_mutable )
			{
				MangleTypeImpl( mangler_state, param.t );
			}
			else
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( "K" );
					MangleTypeImpl( mangler_state, param.t );
				}
			}
		}
	}
	else
	{
		MangleTypeImpl( mangler_state, param.t );
	}
}

fn EncodeFunctionParams( ManglerState& mut mangler_state, ust::vector</FunctionType::Param/>& params )
{
	foreach( &param : params )
	{
		EncodeFunctionParam( mangler_state, param );
	}
	if( params.empty() )
	{
		mangler_state.Push( "v" );
	}
}

fn GetTemplateClassName( ManglerState &mut mangler_state, ClassType& class_type )
{
	ADD_NODE( mangler_state )
	{
		// Skip template parameters namespace.
		auto parent= class_type.members.lock_imut().get_ref().GetParent().lock_imut().get_ref().GetParent();
		if( !parent.lock_imut().get_ref().GetThisNamespaceName().empty() )
		{
			GetNamespacePrefix_r( mangler_state, parent.lock_imut().get_ref() );
		}

		auto& class_name= class_type.base_template.get_ref().class_template.get_ref().syntax_element.get_ref().name;
		mangler_state.PushLengthPrefixed( class_name.range() );
	}

	MangleTemplateArgsImpl( mangler_state, class_type.base_template.get_ref().signature_args );
}

fn MangleTypeImpl( ManglerState& mut mangler_state, Type& t )
{
	if_var( fundamental_type : t.GetFundamentalType() )
	{
		mangler_state.Push( MangleFundamentalTypeName( fundamental_type.fundamental_type ).range() );
		return;
	}
	if_var( array_type : t.GetArrayType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "A" );
			mangler_state.Push( ust::to_string8(array_type.element_count).range() );
			mangler_state.Push( "_" );
			MangleTypeImpl( mangler_state, array_type.element_type );
		}
		return;
	}
	if_var( tuple_type : t.GetTupleType() )
	{
		ADD_NODE( mangler_state )
		{
			ADD_NODE( mangler_state )
			{
				mangler_state.PushLengthPrefixed( KeywordToString( Keyword::tup_ ) );
			}

			mangler_state.Push( "I" );
			foreach( &element_type : tuple_type.element_types )
			{
				MangleTypeImpl( mangler_state, element_type );
			}
			mangler_state.Push( "E" );
		}
	}
	if_var( class_type_ptr : t.GetClassType() )
	{
		auto class_lock= class_type_ptr.lock_imut();
		auto& class_type= class_lock.get_ref();
		auto class_members= class_type.members;
		auto class_members_lock= class_members.lock_imut();
		auto& class_members_ref= class_members_lock.get_ref();

		if( !class_type.typeinfo_src_type_.empty() )
		{
			ADD_NODE( mangler_state )
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.PushLengthPrefixed( class_type.members.lock_imut().get_ref().GetThisNamespaceName().range() );
				}
				ADD_NODE( mangler_state )
				{
					var TemplateArgsFinished mut typeinfo_args;
					typeinfo_args.push_back( class_type.typeinfo_src_type_.get_ref() );
					MangleTemplateArgsImpl( mangler_state, typeinfo_args );
				}
			}
		}
		else if( !class_type.base_template.empty() )
		{
			ADD_NODE( mangler_state )
			{
				auto t= class_type.base_template.get_ref().class_template;
				auto t_namespace= t.get_ref().parent_names_scope.lock();
				if( !t_namespace.empty() && !t_namespace.lock_imut().get_ref().GetParent().empty() )
				{
					mangler_state.Push( "N" );
					GetTemplateClassName( mangler_state, class_type );
					mangler_state.Push( "E" );
				}
				else
				{
					GetTemplateClassName( mangler_state, class_type );
				}
			}
		}
		else
		{
			GetNestedName( mangler_state, class_members_ref.GetThisNamespaceName(), class_members_ref.GetParent().lock_imut().get_ref() );
		}
		return;
	}
	if_var( enum_type : t.GetEnumType() )
	{
		auto enum_members= enum_type.lock_imut().get_ref().names_scope;
		auto enum_members_lock= enum_members.lock_imut();
		auto& enum_members_ref= enum_members_lock.get_ref();

		GetNestedName( mangler_state, enum_members_ref.GetThisNamespaceName(), enum_members_ref.GetParent().lock_imut().get_ref() );
		return;
	}
	if_var( &raw_poiter_type : t.GetRawPointerType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "P" );
			MangleTypeImpl( mangler_state, raw_poiter_type.element_type );
		}
		return;
	}
	if_var( &function_pointer_type : t.GetFunctionPointerType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "P" );
			MangleTypeImpl( mangler_state, function_pointer_type.function_type );
		}
		return;
	}
	if_var( &function_type : t.GetFunctionType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "F" );

			{
				var FunctionType::Param ret_param
				{
					.t( function_type.return_type ),
					.is_mutable= function_type.return_value_is_mutable,
					.is_reference= function_type.return_value_is_reference,
				};
				EncodeFunctionParam( mangler_state, ret_param );
			}

			EncodeFunctionParams( mangler_state, function_type.params );

			if( !function_type.return_references.empty() )
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( "_RR" );

					halt if( function_type.return_references.size() >= 36s );
					mangler_state.Push( Base36Digit(function_type.return_references.size()) );

					foreach( &param_reference : function_type.return_references )
					{
						halt if( param_reference.param_index >= 36u8 );
						halt if( param_reference.reference_index >= 36u8 && param_reference.reference_index != FunctionType::c_param_reference_number );

						mangler_state.Push( Base36Digit( size_type(param_reference.param_index) ) );
						mangler_state.Push( select(
							param_reference.reference_index == FunctionType::c_param_reference_number
							? "_"c8
							: Base36Digit( size_type(param_reference.reference_index) ) ) );
					}
				}
			}
			if( !function_type.references_pollution.empty() )
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( "_RP" );

					halt if( function_type.references_pollution.size() >= 36s );
					mangler_state.Push( Base36Digit(function_type.references_pollution.size()) );

					foreach( &pollution : function_type.references_pollution )
					{
						halt if( pollution.dst.param_index >= 36u8 );
						halt if( pollution.dst.reference_index >= 36u8 && pollution.dst.reference_index != FunctionType::c_param_reference_number );
						halt if( pollution.src.param_index >= 36u8 );
						halt if( pollution.src.reference_index >= 36u8 && pollution.src.reference_index != FunctionType::c_param_reference_number );

						mangler_state.Push( Base36Digit( size_type(pollution.dst.param_index) ) );
						mangler_state.Push( select(
							pollution.dst.reference_index == FunctionType::c_param_reference_number
							? "_"c8
							: Base36Digit( size_type(pollution.dst.reference_index) ) ) );
						mangler_state.Push( Base36Digit( size_type(pollution.src.param_index) ) );
						mangler_state.Push( select(
							pollution.src.reference_index == FunctionType::c_param_reference_number
							? "_"c8
							: Base36Digit( size_type(pollution.src.reference_index) ) ) );
					}
				}
			}
			if( function_type.is_unsafe )
			{
				mangler_state.Push( "unsafe" );
			}

			mangler_state.Push( "E" );
		}
		return;
	}

	halt;
}

fn GetNamespacePrefix_r( ManglerState& mut mangler_state, NamesScope& names_scope )
{
	var ust::string8& name= names_scope.GetThisNamespaceName();

	// Process separately class templates.
	auto class_ptr= names_scope.GetClass();
	if( !class_ptr.empty() )
	{
		auto class_lock= class_ptr.lock_imut();
		auto& class_= class_lock.get_ref();
		if( !class_.base_template.empty() )
		{
			ADD_NODE( mangler_state )
			{
				GetTemplateClassName( mangler_state, class_ );
			}
			return;
		}
	}

	ADD_NODE( mangler_state )
	{
		auto parent= names_scope.GetParent();
		if( !parent.empty() )
		{
			auto parent_lock= parent.lock_imut();
			auto& parent_ref= parent_lock.get_ref();
			if( !parent_ref.GetThisNamespaceName().empty() )
			{
				 GetNamespacePrefix_r( mangler_state, parent_ref );
			}
		}

		mangler_state.PushLengthPrefixed( name.range() );
	}
}

fn MangleTemplateArgsImpl( ManglerState &mut mangler_state, TemplateArgsFinished& template_args )
{
	mangler_state.Push( "I" );

	foreach( &arg : template_args )
	{
		if_var( &t : arg.get</Type/>() )
		{
			MangleTypeImpl( mangler_state, t );
		}
		if_var( &v : arg.get</Variable/>() )
		{
			mangler_state.Push( "L" );
			MangleTypeImpl( mangler_state, v.t );

			auto mut is_signed= false;
			if_var( fundamental_type : v.t.GetFundamentalType() )
			{
				is_signed= IsSignedInteger( fundamental_type.fundamental_type );
			}
			if_var( enum_type : v.t.GetEnumType() )
			{
				is_signed= IsSignedInteger( enum_type.lock_imut().get_ref().underlaying_type.fundamental_type );
			}

			if( v.constexpr_value != LLVMValueRef::Null )
			{
				unsafe
				{
					if( is_signed )
					{
						auto num= LLVMConstIntGetSExtValue( v.constexpr_value );
						if( num >= 0i64 )
						{
							mangler_state.Push( ust::to_string8( num ).range() );
						}
						else
						{
							mangler_state.Push( "n" );
							mangler_state.Push( ust::to_string8( -num ).range() );
						}
					}
					else
					{
						mangler_state.Push( ust::to_string8( LLVMConstIntGetZExtValue( v.constexpr_value ) ).range() );
					}
				}
			}

			mangler_state.Push( "E" );
		}
	}

	mangler_state.Push( "E" );
}

fn DecodeOperator( ust::string8& o ) : ust::array_view_imut</ char8 />
{
	if( o == "+" ){ return "pl"; }
	if( o == "-" ){ return "mi"; }
	if( o == "*" ){ return "ml"; }
	if( o == "/" ){ return "dv"; }
	if( o == "%" ){ return "rm"; }

	if( o == "==" ){ return "eq"; }
	if( o == "!=" ){ return "ne"; }
	if( o == ">"  ){ return "gt"; }
	if( o == ">=" ){ return "ge"; }
	if( o == "<"  ){ return "lt"; }
	if( o == "<=" ){ return "le"; }

	if( o == "&" ){ return "an"; }
	if( o == "|" ){ return "or"; }
	if( o == "^" ){ return "eo"; }

	if( o == "<<" ){ return "ls"; }
	if( o == ">>" ){ return "rs"; }

	if( o == "+=" ){ return "pL"; }
	if( o == "-=" ){ return "mI"; }
	if( o == "*=" ){ return "mL"; }
	if( o == "/=" ){ return "dV"; }
	if( o == "%=" ){ return "rM"; }

	if( o == "&=" ){ return "aN"; }
	if( o == "|=" ){ return "oR"; }
	if( o == "^=" ){ return "eO"; }

	if( o == "<<=" ){ return "lS"; }
	if( o == ">>=" ){ return "rS"; }

	if( o == "!" ){ return "nt"; }
	if( o == "~" ){ return "co"; }

	if( o == "=" ){ return "aS"; }
	if( o == "++" ){ return "pp"; }
	if( o == "--" ){ return "mm"; }

	if( o == "()" ){ return "cl"; }
	if( o == "[]" ){ return "ix"; }

	return "";
}

fn MangleFunctionImpl(
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type,
	ust::optional_ref</TemplateArgsFinished, false/> template_args ) : ust::string8
{
	var ManglerState mut mangler_state;
	mangler_state.Push( "_Z" );

	var ust::string8 mut name_prefixed= DecodeOperator( name );
	if( name_prefixed.empty() )
	{
		name_prefixed= ust::to_string8( name.size() );
		name_prefixed+= name;
	}

	if( !template_args.empty() )
	{
		ADD_NODE( mangler_state )
		{
			if( !parent_scope.GetParent().empty() )
			{
				mangler_state.Push( "N" );
				ADD_NODE( mangler_state )
				{
					GetNamespacePrefix_r( mangler_state, parent_scope );
					mangler_state.Push( name_prefixed.range() );
				}

				MangleTemplateArgsImpl( mangler_state, template_args.get_ref() );
				mangler_state.Push( "Ev" );
			}
			else
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( name_prefixed.range() );
				}

				MangleTemplateArgsImpl( mangler_state, template_args.get_ref() );
				mangler_state.Push( "v" );
			}
		}
	}
	else
	{
		if( !parent_scope.GetParent().empty() )
		{
			mangler_state.Push( "N" );
			GetNamespacePrefix_r( mangler_state, parent_scope );
			mangler_state.Push( name_prefixed.range() );
			mangler_state.Push( "E" );
		}
		else
		{
			mangler_state.Push( name_prefixed.range() );
		}
	}

	EncodeFunctionParams( mangler_state, function_type.params );

	return mangler_state.TakeResult();
}

fn MangleFunction(
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type ) : ust::string8
{
	return MangleFunctionImpl( parent_scope, name, function_type, ust::optional_ref</TemplateArgsFinished, false/>() );
}

fn MangleFunction(
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type,
	TemplateArgsFinished& template_args ) : ust::string8
{
	return MangleFunctionImpl( parent_scope, name, function_type, ust::optional_ref</TemplateArgsFinished, false/>(template_args) );
}


fn MangleGlobalVariable( NamesScope& parent_scope, ust::string8& variable_name ) : ust::string8
{
	// Variables inside global namespace have simple names.
	if( parent_scope.GetParent().empty() )
	{
		return variable_name + "\0";
	}

	var ManglerState mut mangler_state;
	mangler_state.Push( "_Z" );
	GetNestedName( mangler_state, variable_name, parent_scope );
	return mangler_state.TakeResult();
}

fn MangleType( Type& t ) : ust::string8
{
	var ManglerState mut mangler_state;
	MangleTypeImpl(mangler_state, t);
	return mangler_state.TakeResult();
}

fn MangleTemplateArgs( TemplateArgsFinished& template_args ) : ust::string8
{
	var ManglerState mut mangler_state;
	MangleTemplateArgsImpl( mangler_state, template_args );
	return mangler_state.TakeResult();
}

fn MangleVirtualTable( Type& t ) : ust::string8
{
	var ManglerState mut mangler_state;
	mangler_state.Push( "_ZTV" );
	MangleTypeImpl( mangler_state, t );
	return mangler_state.TakeResult();
}

} // namespace U1
