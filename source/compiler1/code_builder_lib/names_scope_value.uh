import "/shared/shared_ptr_mut.u"
import "/shared/shared_ptr_nullable_mut.u"
import "../lex_synt_lib/syntax_elements.uh"
import "llvm.uh"
import "type.uh"

namespace U
{

struct NamesScopeVariable
{
	Type t;
	bool is_mutable = false;
	LLVMValueRef llvm_value= LLVMValueRef::Null;
}

struct FunctionVariable
{
	Type t; // FunctionType 100%
	LLVMValueRef llvm_function= LLVMValueRef::Null;

	ust::shared_ptr_final</ Synt::Function /> syntax_element;
}

// Set of functions and function templates with same name in one scope
struct FunctionsSet
{
	ust::vector</FunctionVariable/> functions;

	// Is incomplete, if there are some syntax elements in containers.
	ust::vector</ ust::shared_ptr_final</ Synt::Function /> /> syntax_elements;
}

class NamesScopeValue
{
public:
	fn constructor( mut this, NamesScopeValue &imut other ) = default;
	op=( mut this, NamesScopeValue &imut other ) = default;

	// TODO - add method for deep copy

	template</ type T />
	fn conversion_constructor( T mut t )
		( something_( ust::shared_ptr_mut</T/>(move(t))) )
	{}

	template</type T/>
	fn Get( imut this ) : ust::shared_ptr_nullable_mut</T/>
	{
		auto x= something_.get</ ust::shared_ptr_mut</T/> />();
		if( x.empty() )
		{
			return ust::shared_ptr_nullable_mut</T/>();
		}
		return ust::shared_ptr_nullable_mut</T/>(x.get_ref());
	}

private:
	ust::variant</ tup[
		ust::shared_ptr_mut</Type/>,
		ust::shared_ptr_mut</NamesScopeVariable/>,
		ust::shared_ptr_mut</FunctionsSet/>
	] /> something_;
}

} // namespace U
