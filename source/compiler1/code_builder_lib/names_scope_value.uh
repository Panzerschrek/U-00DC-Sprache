import "/shared/shared_ptr_mut.u"
import "/shared/shared_ptr_nullable_mut.u"
import "value.uh"

namespace U
{

struct NamesScopeVariable
{
	Type t;
	bool is_mutable = false;
	LLVMValueRef llvm_value= LLVMValueRef::Null;
}

struct NamesScopeFunctionsSet
{
	FunctionsSet functions_set;

	// Is incomplete, if there are some syntax elements in containers.
	ust::vector</ ust::shared_ptr_final</ Synt::Function /> /> syntax_elements;
}

class NamesScopeValue
{
public:
	fn constructor( mut this, NamesScopeValue &imut other ) = default;
	op=( mut this, NamesScopeValue &imut other ) = default;

	// TODO - add method for deep copy

	template</ type T />
	fn conversion_constructor( T mut t )
		( something_( ust::shared_ptr_mut</T/>(move(t))) )
	{}

	template</type T/>
	fn Get( imut this ) : ust::shared_ptr_nullable_mut</T/>
	{
		auto x= something_.get</ ust::shared_ptr_mut</T/> />();
		if( x.empty() )
		{
			return ust::shared_ptr_nullable_mut</T/>();
		}
		return ust::shared_ptr_nullable_mut</T/>(x.get_ref());
	}

private:
	ust::variant</ tup[
		ust::shared_ptr_mut</Type/>,
		ust::shared_ptr_mut</NamesScopeVariable/>,
		ust::shared_ptr_mut</NamesScopeFunctionsSet/>
	] /> something_;
}

} // namespace U
