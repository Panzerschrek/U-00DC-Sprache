import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildExpressionCodeEnsureVariable( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable
{
	var Value mut value= BuildExpressionCode( names_scope, function_context, expression );

	if_var( &mut v : value.get</Variable/>())
	{
		return take(v);
	}

	var Variable mut dummy;
	dummy.t= FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ );
	unsafe{  dummy.llvm_value= LLVMGetUndef( fundamental_llvm_types_.invalid_type_ );  }
	return move(dummy);
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value
{
	variant_visit( &el : expression )
	{
		return BuildExpressionCode( names_scope, function_context, el );
	}

	halt;
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value
{
	// "EmptyVariant" used only as stub during expression building in syntax analyzer. It should never be in final result.
	halt;
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value
{
	var ust::array_view_imut</char8/> mut type_suffix( numeric_constant.num.type_suffix );
	while( !type_suffix.empty() && type_suffix.back() == "\0"c8 )
	{
		type_suffix.drop_back();
	}

	auto mut t= U_FundamentalType::InvalidType;
	if( type_suffix.empty() )
	{
		t= select( numeric_constant.num.has_fractional_point ? U_FundamentalType::f64_ : U_FundamentalType::i32_ );
	}
	else if( type_suffix == ust::string8("u") )
	{
		t= U_FundamentalType::u32_;
	}
	// TODO -size_type
	else if( type_suffix == ust::string8("f") )
	{
		t= U_FundamentalType::f32_;
	}
	else
	{
		t= GetFundamentalTypeByName( type_suffix );
	}

	if( t == U_FundamentalType::InvalidType )
	{
		REPORT_ERROR( UnknownNumericConstantType, names_scope, numeric_constant.file_pos, ust::string8(type_suffix) )
		return Value( ErrorValue() );
	}

	var Variable mut res;
	res.t= Type( FundamentalType( t, GetFundamentalLLVMType(t) ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe
	{
		if( IsFloatingPoint( t ) )
		{
			res.llvm_value= LLVMConstReal( res.t.GetLLVMType(), numeric_constant.num.value_double );
		}
		else if( IsSignedInteger( t ) )
		{
			res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::True  );
		}
		else if( IsUnsignedInteger( t ) )
		{
			res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::False );
		}
		else{ halt; }
	}

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value
{
	var Variable mut res;
	res.t= Type( FundamentalType( U_FundamentalType::bool_ , fundamental_llvm_types_.bool_ ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe{ res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), select( boolean_constant.value ? 1u64 : 0u64 ), LLVMBool::True ); }

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value
{
	return ResolveValue( names_scope, named_operand );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	var Variable l= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.get_ref() );
	auto l_in_register= CreateMoveToLLVMRegisterInstruction( l, function_context );

	var Variable r= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.get_ref() );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

	// TODO - check types.

	var Variable mut res;
	res.t= l.t;
	res.location= Variable::Location::LLVMRegister;

	unsafe
	{
		if( binary_operator.operator == BinaryOperatorType::Add )
		{
			res.llvm_value= LLVMBuildAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
		}
		if( binary_operator.operator == BinaryOperatorType::Sub )
		{
			res.llvm_value= LLVMBuildSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
		}
		if( binary_operator.operator == BinaryOperatorType::Mul )
		{
			res.llvm_value= LLVMBuildMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
		}
		if( binary_operator.operator == BinaryOperatorType::Div )
		{
			// TODO - select signed/unsigned
			res.llvm_value= LLVMBuildSDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
		}
	}

	return Value(move(res));
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BracketExpression& bracket_expression ) : Value
{
	return BuildExpressionCode( names_scope, function_context, bracket_expression.expr.get_ref() );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.value.get_ref() );
	auto index= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.index.get_ref() );

	if_var( &variable_array_type : variable.t.GetArrayType() )
	{
		if_var( &index_fundamental_type : index.t.GetFundamentalType() )
		{
			// TODO - add runtime index check
			// TODO - forbid non-constexpr signed indexes
			if( IsInteger( index_fundamental_type.fundamental_type ) )
			{
				if( variable.location != Variable::Location::Pointer )
				{
					// TODO - Strange variable location.
					return Value(ErrorValue());
				}

				var Variable mut result
				{
					.t= variable_array_type.element_type.get_ref(),
					.location= Variable::Location::Pointer,
				};

				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes
					[
						GetZeroGEPIndex(),
						CreateMoveToLLVMRegisterInstruction( index, function_context ),
					];

					result.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
				}

				return Value( move(result) );
			}
			else
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, index.t )
			}
		}
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, index.t )
	}

	REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, variable.t )

	return Value(ErrorValue());
}

} // namespace U
