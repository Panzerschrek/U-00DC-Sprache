import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildExpressionCodeEnsureVariable( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable
{
	var Value mut value= BuildExpressionCode( names_scope, function_context, expression );

	// TODO - fill dummy value if not variable.
	return value.get</Variable/>().get_ref();
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value
{
	variant_visit( &el : expression )
	{
		return BuildExpressionCode( names_scope, function_context, el );
	}

	halt;
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value
{
	// "EmptyVariant" used only as stub during expression building in syntax analyzer. It should never be in final result.
	halt;
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value
{
	var ust::array_view_imut</char8/> mut type_suffix( numeric_constant.num.type_suffix );
	while( !type_suffix.empty() && type_suffix.back() == "\0"c8 )
	{
		type_suffix.drop_back();
	}

	auto mut t= U_FundamentalType::InvalidType;
	if( type_suffix.empty() )
	{
		t= select( numeric_constant.num.has_fractional_point ? U_FundamentalType::f64_ : U_FundamentalType::i32_ );
	}
	else if( type_suffix == ust::string8("u") )
	{
		t= U_FundamentalType::u32_;
	}
	// TODO -size_type
	else if( type_suffix == ust::string8("f") )
	{
		t= U_FundamentalType::f32_;
	}
	else
	{
		t= GetFundamentalTypeByName( type_suffix );
	}

	if( t == U_FundamentalType::InvalidType )
	{
		REPORT_ERROR( UnknownNumericConstantType, names_scope, numeric_constant.file_pos, ust::string8(type_suffix) )
		return Value( ErrorValue() );
	}

	var Variable mut res;
	res.t= Type( FundamentalType( t, GetFundamentalLLVMType(t) ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe
	{
		if( IsFloatingPoint( t ) )
		{
			res.llvm_value= LLVMConstReal( res.t.GetLLVMType(), numeric_constant.num.value_double );
		}
		else if( IsSignedInteger( t ) )
		{
			res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::True  );
		}
		else if( IsUnsignedInteger( t ) )
		{
			res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::False );
		}
		else{ halt; }
	}

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value
{
	var Variable mut res;
	res.t= Type( FundamentalType( U_FundamentalType::bool_ , fundamental_llvm_types_.bool_ ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe{ res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), select( boolean_constant.value ? 1u64 : 0u64 ), LLVMBool::True ); }

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value
{
	return ResolveValue( names_scope, named_operand );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	var Variable l= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.get_ref() );
	auto l_in_register= CreateMoveToLLVMRegisterInstruction( l, function_context );

	var Variable r= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.get_ref() );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

	// TODO - check types.

	var Variable mut res;
	res.t= l.t;
	res.location= Variable::Location::LLVMRegister;

	unsafe
	{
		if( binary_operator.operator == BinaryOperatorType::Add )
		{
			res.llvm_value= LLVMBuildAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
		}
		if( binary_operator.operator == BinaryOperatorType::Sub )
		{
			res.llvm_value= LLVMBuildSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
		}
		if( binary_operator.operator == BinaryOperatorType::Mul )
		{
			res.llvm_value= LLVMBuildMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
		}
		if( binary_operator.operator == BinaryOperatorType::Div )
		{
			// TODO - select signed/unsigned
			res.llvm_value= LLVMBuildSDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
		}
	}

	return Value(move(res));
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BracketExpression& bracket_expression ) : Value
{
	return BuildExpressionCode( names_scope, function_context, bracket_expression.expr.get_ref() );
}

} // namespace U
