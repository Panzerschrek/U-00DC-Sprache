import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildExpressionCodeEnsureVariable( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable
{
	var Value mut value= BuildExpressionCode( names_scope, function_context, expression );

	if_var( &mut v : value.get</Variable/>())
	{
		return take(v);
	}

	var Variable mut dummy;
	dummy.t= FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ );
	dummy.location= Variable::Location::LLVMRegister;
	unsafe{  dummy.llvm_value= LLVMGetUndef( fundamental_llvm_types_.invalid_type_ );  }
	return move(dummy);
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value
{
	variant_visit( &el : expression )
	{
		return BuildExpressionCode( names_scope, function_context, el );
	}

	halt;
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value
{
	// "EmptyVariant" used only as stub during expression building in syntax analyzer. It should never be in final result.
	halt;
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value
{
	var ust::array_view_imut</char8/> mut type_suffix( numeric_constant.num.type_suffix );
	while( !type_suffix.empty() && type_suffix.back() == "\0"c8 )
	{
		type_suffix.drop_back();
	}

	auto mut t= U_FundamentalType::InvalidType;
	if( type_suffix.empty() )
	{
		t= select( numeric_constant.num.has_fractional_point ? U_FundamentalType::f64_ : U_FundamentalType::i32_ );
	}
	else if( type_suffix == ust::string8("u") )
	{
		t= U_FundamentalType::u32_;
	}
	// TODO -size_type
	else if( type_suffix == ust::string8("f") )
	{
		t= U_FundamentalType::f32_;
	}
	else
	{
		t= GetFundamentalTypeByName( type_suffix );
	}

	if( t == U_FundamentalType::InvalidType )
	{
		REPORT_ERROR( UnknownNumericConstantType, names_scope, numeric_constant.file_pos, ust::string8(type_suffix) )
		return Value( ErrorValue() );
	}

	var Variable mut res;
	res.t= Type( FundamentalType( t, GetFundamentalLLVMType(t) ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe
	{
		if( IsFloatingPoint( t ) )
		{
			res.llvm_value= LLVMConstReal( res.t.GetLLVMType(), numeric_constant.num.value_double );
		}
		else if( IsSignedInteger( t ) )
		{
			res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::True  );
		}
		else if( IsUnsignedInteger( t ) )
		{
			res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::False );
		}
		else{ halt; }
	}

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value
{
	var Variable mut res;
	res.t= Type( FundamentalType( U_FundamentalType::bool_ , fundamental_llvm_types_.bool_ ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe{ res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), select( boolean_constant.value ? 1u64 : 0u64 ), LLVMBool::True ); }

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value
{
	return ResolveValue( names_scope, named_operand );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	var Variable l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.get_ref() );
	auto l_in_register= CreateMoveToLLVMRegisterInstruction( l_var, function_context );

	var Variable r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.get_ref() );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r_var, function_context );

	var Type& l_type= l_var.t;
	var Type& r_type= r_var.t;
	auto l_fundamental_type= l_type.GetFundamentalType();
	auto r_fundamental_type= r_type.GetFundamentalType();

	if(
		binary_operator.operator == BinaryOperatorType::Add ||
		binary_operator.operator == BinaryOperatorType::Sub ||
		binary_operator.operator == BinaryOperatorType::Mul ||
		binary_operator.operator == BinaryOperatorType::Div ||
		binary_operator.operator == BinaryOperatorType::Rem )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, binary_operator.file_pos, r_type, l_type, BinaryOperatorToString( binary_operator.operator ) )
			return Value(ErrorValue());
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}

		var bool is_float= IsFloatingPoint( l_fundamental_type.get_ref().fundamental_type );
		if( !( IsInteger( l_fundamental_type.get_ref().fundamental_type  ) || is_float ) )
		{
			// this operations allowed only for integer and floating point operands.
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}

		var bool is_signed= IsSignedInteger( l_fundamental_type.get_ref().fundamental_type );

		var Variable mut res;
		res.t= l_type;
		res.location= Variable::Location::LLVMRegister;

		unsafe
		{
				 if( binary_operator.operator == BinaryOperatorType::Add )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
				}
				else
				{
					res.llvm_value =LLVMBuildAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::Sub )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::Mul )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
				}
				else
				{
					res.llvm_value=LLVMBuildMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::Div )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value=LLVMBuildSDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
				}
				else
				{
					res.llvm_value=LLVMBuildUDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::Rem )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFRem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value=LLVMBuildSRem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
				}
				else
				{
					res.llvm_value=LLVMBuildURem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
				}
			}
		}

		return Value(move(res));
	}
	else if(
		binary_operator.operator == BinaryOperatorType::And ||
		binary_operator.operator == BinaryOperatorType::Or  ||
		binary_operator.operator == BinaryOperatorType::Xor )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, binary_operator.file_pos, r_type, l_type, BinaryOperatorToString( binary_operator.operator ) )
			return Value(ErrorValue());
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}
		if( !( IsInteger( l_fundamental_type.get_ref().fundamental_type ) || l_fundamental_type.get_ref().fundamental_type == U_FundamentalType::bool_ ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}

		var Variable mut res;
		res.t= l_type;
		res.location= Variable::Location::LLVMRegister;

		unsafe
		{
				 if( binary_operator.operator == BinaryOperatorType::And )
			{
				res.llvm_value= LLVMBuildAnd( function_context.llvm_ir_builder, l_in_register, r_in_register, "&\0"[0] );
			}
			else if( binary_operator.operator == BinaryOperatorType::Or  )
			{
				res.llvm_value= LLVMBuildOr ( function_context.llvm_ir_builder, l_in_register, r_in_register, "|\0"[0] );
			}
			else if( binary_operator.operator == BinaryOperatorType::Xor )
			{
				res.llvm_value= LLVMBuildXor( function_context.llvm_ir_builder, l_in_register, r_in_register, "^\0"[0] );
			}
		}

		return Value(move(res));
	}
	else if(
		binary_operator.operator == BinaryOperatorType::Equal ||
		binary_operator.operator == BinaryOperatorType::NotEqual )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, binary_operator.file_pos, r_type, l_type, BinaryOperatorToString( binary_operator.operator ) )
			return Value(ErrorValue());
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}

		var bool if_float= IsFloatingPoint( l_fundamental_type.get_ref().fundamental_type );

		var Variable mut res;
		res.t= bool_type_;
		res.location= Variable::Location::LLVMRegister;

		// Use ordered floating point compare operations, which result is false for NaN, except !=. nan != nan must be true.
		unsafe
		{
				 if( binary_operator.operator == BinaryOperatorType::Equal )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OEQ, l_in_register, r_in_register, "==\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::EQ, l_in_register, r_in_register, "==\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::NotEqual )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::UNE, l_in_register, r_in_register, "!=\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::NE, l_in_register, r_in_register, "!=\0"[0] );
				}
			}
		}

		return Value(move(res));
	}
	else if(
		binary_operator.operator == BinaryOperatorType::Less ||
		binary_operator.operator == BinaryOperatorType::LessEqual ||
		binary_operator.operator == BinaryOperatorType::Greater ||
		binary_operator.operator == BinaryOperatorType::GreaterEqual )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, binary_operator.file_pos, r_type, l_type, BinaryOperatorToString( binary_operator.operator ) )
			return Value(ErrorValue());
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}

		var bool if_float= IsFloatingPoint( l_fundamental_type.get_ref().fundamental_type );
		var bool is_char= IsChar( l_fundamental_type.get_ref().fundamental_type );
		var bool is_signed= !is_char && IsSignedInteger( l_fundamental_type.get_ref().fundamental_type );
		if( !( IsInteger( l_fundamental_type.get_ref().fundamental_type ) || if_float || is_char ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, binary_operator.file_pos, l_type )
			return Value(ErrorValue());
		}

		var Variable mut res;
		res.t= bool_type_;
		res.location= Variable::Location::LLVMRegister;

		unsafe
		{
				 if( binary_operator.operator == BinaryOperatorType::Less )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLT, l_in_register, r_in_register, "<\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLT, l_in_register, r_in_register, "<\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULT, l_in_register, r_in_register, "<\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::LessEqual )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLE, l_in_register, r_in_register, "<=\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLE, l_in_register, r_in_register, "<=\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULE, l_in_register, r_in_register, "<=\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::Greater )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGT, l_in_register, r_in_register, ">\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGT, l_in_register, r_in_register, ">\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGT, l_in_register, r_in_register, ">\0"[0] );
				}
			}
			else if( binary_operator.operator == BinaryOperatorType::GreaterEqual )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGE, l_in_register, r_in_register, ">=\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGE, l_in_register, r_in_register, ">=\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGE, l_in_register, r_in_register, ">=\0"[0] );
				}
			}
		}

		return Value(move(res));
	}
	else
	{
		halt;
	}
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BracketExpression& bracket_expression ) : Value
{
	return BuildExpressionCode( names_scope, function_context, bracket_expression.expr.get_ref() );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.value.get_ref() );
	auto index= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.index.get_ref() );

	if_var( &variable_array_type : variable.t.GetArrayType() )
	{
		if_var( &index_fundamental_type : index.t.GetFundamentalType() )
		{
			// TODO - add runtime index check
			// TODO - forbid non-constexpr signed indexes
			if( IsInteger( index_fundamental_type.fundamental_type ) )
			{
				if( variable.location != Variable::Location::Pointer )
				{
					// TODO - Strange variable location.
					return Value(ErrorValue());
				}

				var Variable mut result
				{
					.t= variable_array_type.element_type.get_ref(),
					.location= Variable::Location::Pointer,
				};

				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes
					[
						GetZeroGEPIndex(),
						CreateMoveToLLVMRegisterInstruction( index, function_context ),
					];

					result.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
				}

				return Value( move(result) );
			}
			else
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, index.t )
			}
		}
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, index.t )
	}

	REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, variable.t )

	return Value(ErrorValue());
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value
{
	auto function= BuildExpressionCode( names_scope, function_context, call_operator.value.get_ref() );

	if_var( & functions_set : function.get</FunctionsSet/>() )
	{
		if( functions_set.functions.size() != 1s )
		{
			REPORT_ERROR( CouldNotSelectOverloadedFunction, names_scope, call_operator.file_pos )
			return Value(ErrorValue());
		}

		var FunctionVariable& function_variable= functions_set.functions.front();
		var FunctionType& function_type= function_variable.t.GetFunctionType().get_ref();

		if( function_type.args.size() != call_operator.args.size() )
		{
			REPORT_ERROR( CouldNotSelectOverloadedFunction, names_scope, call_operator.file_pos )
			return Value(ErrorValue());
		}

		var ust::vector</LLVMValueRef/> mut llvm_args;

		auto mut arg_n= 0s;
		while( arg_n < call_operator.args.size() )
		{
			var Type& expected_arg_type= function_type.args[arg_n].arg_type.get_ref();
			auto arg= BuildExpressionCodeEnsureVariable( names_scope, function_context, call_operator.args[arg_n].get_ref() );

			if( arg.t != expected_arg_type )
			{
				REPORT_ERROR( TypesMismatch, names_scope, call_operator.file_pos, arg.t, expected_arg_type )
				return Value(ErrorValue());
			}

			llvm_args.push_back( CreateMoveToLLVMRegisterInstruction( arg, function_context ) );

			++arg_n;
		}

		var Variable mut result
		{
			.t= function_type.return_type.get_ref(),
			.location= Variable::Location::LLVMRegister,
		};
		unsafe
		{
			if( llvm_args.empty() )
			{
				auto dummy= LLVMValueRef::Null;
				result.llvm_value= LLVMBuildCall( function_context.llvm_ir_builder, function_variable.llvm_function, dummy, 0u, "\0"[0] );
			}
			else
			{
				// TODO - do not use temporary variable, fix reference protection error.
				auto s= u32(llvm_args.size());
				result.llvm_value= LLVMBuildCall( function_context.llvm_ir_builder, function_variable.llvm_function, llvm_args.front(), s, "\0"[0] );
			}
		}

		return Value(move(result));
	}

	REPORT_ERROR( OperationNotSupportedForThisType, names_scope, call_operator.file_pos, ust::string8("non-function value") )
	return Value(ErrorValue());
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryPlus& unary_plus ) : Value
{
	// Do nothing with unary plus.
	// TODO - maybe check type or do something else?
	return BuildExpressionCode( names_scope, function_context, unary_plus.expr.get_ref() );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, unary_minus.expr.get_ref() );
	auto fundamental_type= variable.t.GetFundamentalType();
	if( fundamental_type.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, unary_minus.file_pos, variable.t )
		return Value(ErrorValue());
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );

	var Variable mut result
	{
		.t= variable.t,
		.location= Variable::Location::LLVMRegister,
	};

	if( IsInteger( fundamental_type.get_ref().fundamental_type ) )
	{
		unsafe{  result.llvm_value= LLVMBuildNeg( function_context.llvm_ir_builder, value_in_register, "-\0"[0] );  }
	}
	else if( IsFloatingPoint( fundamental_type.get_ref().fundamental_type ) )
	{
		unsafe{  result.llvm_value= LLVMBuildFNeg( function_context.llvm_ir_builder, value_in_register, "-\0"[0] );  }
	}
	else
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, unary_minus.file_pos, variable.t )
		return Value(ErrorValue());
	}

	return Value( move(result) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, logical_not.expr.get_ref() );
	if( variable.t != bool_type_ )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, logical_not.file_pos, variable.t )
		return Value(ErrorValue());
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );

	var Variable mut result
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
	};

	unsafe{  result.llvm_value= LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "!\0"[0] );  }

	return Value( move(result) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, bitwise_not.expr.get_ref() );
	auto fundamental_type= variable.t.GetFundamentalType();
	if( fundamental_type.empty() || !IsInteger( fundamental_type.get_ref().fundamental_type ) )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, bitwise_not.file_pos, variable.t )
		return Value(ErrorValue());
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );

	var Variable mut result
	{
		.t= variable.t,
		.location= Variable::Location::LLVMRegister,
	};

	unsafe{  result.llvm_value= LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "~\0"[0] );  }

	return Value( move(result) );
}

} // namespace U
