import "/assert.u"
import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

template</type Dst, type Src/>
fn CastPtr($(Src) src) unsafe : $(Dst)
{
	// Cast reference to pointer to reference to pointer of other type.
	return unsafe( cast_ref_unsafe</$(Dst)/>(src) );
}

fn CodeBuilder::BuildExpressionCodeEnsureVariable( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : VariablePtr
{
	var Value mut value= BuildExpressionCode( names_scope, function_context, expression );

	if_var( &v_ptr : value.get</VariablePtr/>())
	{
		return v_ptr;
	}

	REPORT_ERROR( ExpectedVariable, names_scope, Synt::GetSrcLoc(expression), GetValueKindName(value) )

	var Variable mut dummy
	{
		.t= FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ ),
		.value_type= ValueType::Value,
		.location= Variable::Location::LLVMRegister,
		.llvm_value= unsafe( LLVMGetUndef( fundamental_llvm_types_.invalid_type_ ) ),
		.name= "error value"
	};
	var VariablePtr mut dummy_ptr( move(dummy) );
	function_context.references_graph.AddNode( dummy_ptr );
	return move(dummy_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value
{
	variant_visit( &el : expression )
	{
		return BuildExpressionCode( names_scope, function_context, el );
	}

	halt;
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value
{
	// "EmptyVariant" used only as stub during expression building in syntax analyzer. It should never be in final result.
	halt;
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value
{
	var ust::string_view8 mut type_suffix( numeric_constant.num.type_suffix );
	while( !type_suffix.empty() && type_suffix.back() == "\0"c8 )
	{
		type_suffix.drop_back();
	}

	auto mut t= U_FundamentalType::InvalidType;
	if( type_suffix.empty() )
	{
		t= select( numeric_constant.num.has_fractional_point ? U_FundamentalType::f64_ : U_FundamentalType::i32_ );
	}
	else if( type_suffix == ust::string8("u") )
	{
		t= U_FundamentalType::u32_;
	}
	else if( type_suffix == ust::string8("s") )
	{
		t= size_type_.GetFundamentalType().try_deref().fundamental_type;
	}
	else if( type_suffix == ust::string8("f") )
	{
		t= U_FundamentalType::f32_;
	}
	else if( type_suffix == ust::string8("c8") )
	{
		t= U_FundamentalType::char8_;
	}
	else if( type_suffix == ust::string8("c16") )
	{
		t= U_FundamentalType::char16_;
	}
	else if( type_suffix == ust::string8("c32") )
	{
		t= U_FundamentalType::char32_;
	}
	else
	{
		t= GetFundamentalTypeByName( type_suffix );
	}

	if( t == U_FundamentalType::InvalidType )
	{
		REPORT_ERROR( UnknownNumericConstantType, names_scope, numeric_constant.src_loc, ust::string8(type_suffix) )
		return ErrorValue();
	}

	var Variable mut result
	{
		.t= Type( FundamentalType( t, GetFundamentalLLVMType(t) ) ),
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.name= "numeric constant ",
	};

	unsafe
	{
		if( IsFloatingPoint( t ) )
		{
			result.constexpr_value= LLVMConstReal( result.t.GetLLVMType(), numeric_constant.num.value_double );
		}
		else if( IsSignedInteger( t ) )
		{
			result.constexpr_value= LLVMConstInt( result.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::True  );
		}
		else if( IsUnsignedInteger( t ) || IsChar( t ) )
		{
			result.constexpr_value= LLVMConstInt( result.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::False );
		}
		else{ halt; }
	}
	result.llvm_value= result.constexpr_value;

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value
{
	var Variable mut result
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.constexpr_value= unsafe( LLVMConstInt( fundamental_llvm_types_.bool_, select( boolean_constant.value ? 1u64 : 0u64 ), LLVMBool::True ) ),
		.name= KeywordToString( select( boolean_constant.value ? Keyword::true_ : Keyword::false_ ) ),
	};
	result.llvm_value= result.constexpr_value;

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StringLiteral& string_literal ) : Value
{
	auto mut char_type= U_FundamentalType::InvalidType;
	auto mut is_array= true;

	auto& type_suffix= string_literal.type_suffix;
	if( type_suffix == "" || type_suffix == "u8" )
	{
		char_type= U_FundamentalType::char8_;
		is_array= true;
	}
	else if( type_suffix == "u16" )
	{
		char_type= U_FundamentalType::char16_;
		is_array= true;
	}
	else if( type_suffix == "u32" )
	{
		char_type= U_FundamentalType::char32_;
		is_array= true;
	}
	else if( type_suffix == "c8"  || type_suffix == GetFundamentalTypeName( U_FundamentalType::char8_  ) )
	{
		char_type= U_FundamentalType::char8_ ;
		is_array= false;
	}
	else if( type_suffix == "c16" || type_suffix == GetFundamentalTypeName( U_FundamentalType::char16_ ) )
	{
		char_type= U_FundamentalType::char16_;
		is_array= false;
	}
	else if( type_suffix == "c32" || type_suffix == GetFundamentalTypeName( U_FundamentalType::char32_ ) )
	{
		char_type= U_FundamentalType::char32_;
		is_array= false;
	}
	else
	{
		REPORT_ERROR( UnknownStringLiteralSuffix, names_scope, string_literal.src_loc, string_literal.type_suffix )
		return ErrorValue();
	}

	auto element_llvm_type= GetFundamentalLLVMType(char_type);

	var ust::string8 mut string_literal_value = string_literal.value; // HACK! Create copy of string to fix ReferenceProtection error.
	if( is_array )
	{
		auto mut array_size= 0s;
		auto mut llvm_type= LLVMTypeRef::Null;
		auto mut constexpr_value= LLVMValueRef::Null;
		auto mut global_value= LLVMValueRef::Null;
		unsafe
		{
			if( char_type == U_FundamentalType::char8_ )
			{
				constexpr_value= LLVMConstStringInContext( llvm_context_, string_literal_value.data(), u32(string_literal_value.size()), LLVMBool::True );
				array_size= string_literal_value.size();

				if( string_literals_cache_[0].find( string_literal_value ).empty() )
				{
					global_value= AddGlobalConstantVariable( "str\0", LLVMTypeOf( constexpr_value ), constexpr_value );
					string_literals_cache_[0].insert( string_literal_value, global_value );
				}
				else
				{
					global_value= string_literals_cache_[0].find( string_literal_value ).try_deref();
				}
			}
			else if( char_type == U_FundamentalType::char16_ )
			{
				var ust::string16 mut buff;
				auto buff_size= string_literal_value.size() * 4s;
				buff.resize( buff_size, "\0"c16 ); // Reserve enough space.

				array_size= U1_ConvertUTF8ToUTF16( string_literal_value.data(), string_literal_value.size(), buff.data(), buff_size );
				halt if(array_size > buff.size());
				buff.resize( array_size, "\0"c16 );

				constexpr_value= U1_ConstDataArray( element_llvm_type, CastPtr</char8/>(buff.data()), array_size * typeinfo</char16/>.size_of, array_size );

				if( string_literals_cache_[1].find( buff ).empty() )
				{
					global_value= AddGlobalConstantVariable( "str\0", LLVMTypeOf( constexpr_value ), constexpr_value );
					string_literals_cache_[1].insert( buff, global_value );
				}
				else
				{
					global_value= string_literals_cache_[1].find( buff ).try_deref();
				}
			}
			else if( char_type == U_FundamentalType::char32_ )
			{
				var ust::string32 mut buff;
				auto buff_size= string_literal_value.size() * 4s;
				buff.resize( buff_size, "\0"c32 ); // Reserve enough space.

				array_size= U1_ConvertUTF8ToUTF32( string_literal_value.data(), string_literal_value.size(), buff.data(), buff_size );
				halt if(array_size > buff.size());
				buff.resize( array_size, "\0"c32 );

				constexpr_value= U1_ConstDataArray( element_llvm_type, CastPtr</char8/>(buff.data()), array_size * typeinfo</char32/>.size_of, array_size );

				if( string_literals_cache_[2].find( buff ).empty() )
				{
					global_value= AddGlobalConstantVariable( "str\0", LLVMTypeOf( constexpr_value ), constexpr_value );
					string_literals_cache_[2].insert( buff, global_value );
				}
				else
				{
					global_value= string_literals_cache_[2].find( buff ).try_deref();
				}
			}
			else { halt; }

			llvm_type= LLVMTypeOf( constexpr_value );
		}

		var ArrayType mut array_type
		{
			.element_type= FundamentalType( char_type, element_llvm_type ),
			.element_count= u64(array_size),
			.llvm_type= llvm_type,
		};
		var Variable mut result
		{
			.t= move(array_type),
			.location= Variable::Location::Pointer,
			.value_type= ValueType::ReferenceImut,
			.llvm_value= global_value,
			.constexpr_value= constexpr_value,
			.name= "string literal",
		};
		var VariablePtr mut result_ptr( move(result) );
		function_context.references_graph.AddNode( result_ptr );
		RegisterTemporaryVariable( function_context, result_ptr );
		return move(result_ptr);
	}
	else
	{
		auto mut constexpr_value= LLVMValueRef::Null;
		unsafe
		{
			if( char_type == U_FundamentalType::char8_ )
			{
				if( string_literal_value.size() != 1s )
				{
					REPORT_ERROR( InvalidSizeForCharLiteral, names_scope, string_literal.src_loc, string_literal_value )
					return ErrorValue();
				}

				constexpr_value= LLVMConstInt( element_llvm_type, u64(string_literal_value.front()), LLVMBool::False );
			}
			else if( char_type == U_FundamentalType::char16_ )
			{
				var char16 mut c= zero_init;
				if( string_literal_value.empty() ||
					U1_ConvertUTF8ToUTF16( string_literal_value.data(), string_literal_value.size(), $<(c), 1s ) != 1s )
				{
					REPORT_ERROR( InvalidSizeForCharLiteral, names_scope, string_literal.src_loc, string_literal_value )
					return ErrorValue();
				}

				constexpr_value= LLVMConstInt( element_llvm_type, u64(c), LLVMBool::False );
			}
			else if( char_type == U_FundamentalType::char32_ )
			{
				var char32 mut c= zero_init;
				if( string_literal_value.empty() ||
					U1_ConvertUTF8ToUTF32( string_literal_value.data(), string_literal_value.size(), $<(c), 1s ) != 1s )
				{
					REPORT_ERROR( InvalidSizeForCharLiteral, names_scope, string_literal.src_loc, string_literal_value )
					return ErrorValue();
				}

				constexpr_value= LLVMConstInt( element_llvm_type, u64(c), LLVMBool::False );
			}
			else{ halt; }
		}

		var Variable mut result
		{
			.t= FundamentalType( char_type, element_llvm_type ),
			.location= Variable::Location::LLVMRegister,
			.value_type= ValueType::Value,
			.llvm_value= constexpr_value,
			.constexpr_value= constexpr_value,
			.name= "char literal",
		};
		var VariablePtr mut result_ptr( move(result) );
		function_context.references_graph.AddNode( result_ptr );
		RegisterTemporaryVariable( function_context, result_ptr );
		return move(result_ptr);
	}
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value
{
	auto name_lookup_ref= named_operand.get</Synt::NameLookup/>();
	if( name_lookup_ref.empty() )
	{
		return ResolveValue( names_scope, function_context, named_operand );
	}

	// Process special simple names here.
	var ust::string8& name= name_lookup_ref.try_deref().name;
	var SrcLoc src_loc= name_lookup_ref.try_deref().src_loc;
	if( name == KeywordToString( Keyword::this_ ) )
	{
		if( function_context.this_.empty() || function_context.whole_this_is_unavailable )
		{
			REPORT_ERROR( ThisUnavailable, names_scope, src_loc )
			return ErrorValue();
		}
		return function_context.this_.try_to_non_nullable();
	}
	if( name == KeywordToString( Keyword::base_ ) )
	{
		if( function_context.this_.empty() )
		{
			REPORT_ERROR( BaseUnavailable, names_scope, src_loc )
			return ErrorValue();
		}

		var VariablePtr this_ptr= function_context.this_.try_to_non_nullable();
		auto this_lock= this_ptr.lock_imut();
		var Variable& this_= this_lock.deref();

		auto class_type= this_.t.GetClassType().try_deref();
		auto base_class= class_type.lock_imut().deref().base_class;
		if( base_class.empty() )
		{
			REPORT_ERROR( BaseUnavailable, names_scope, src_loc )
			return ErrorValue();
		}
		var ClassTypePtr base_class_non_null= base_class.try_to_non_nullable();

		if( function_context.whole_this_is_unavailable )
		{
			auto base_field_index= 0s;
			if( ( base_field_index < function_context.initialized_this_fields.size() && !function_context.initialized_this_fields[ base_field_index ] ) ||
				base_class_non_null.lock_imut().deref().kind == ClassType::Kind::Abstract )
			{
				REPORT_ERROR( FieldIsNotInitializedYet, names_scope,src_loc, KeywordToString( Keyword::base_ ) )
				return ErrorValue();
			}
		}

		var Variable mut base_
		{
			.t= base_class_non_null,
			.value_type= this_.value_type,
			.location= Variable::Location::Pointer,
			.llvm_value= CreateReferenceCast( this_.llvm_value, this_.t, base_class_non_null, function_context ),
			.name= KeywordToString( Keyword::base_ ),
		};

		var VariablePtr mut base_ptr( move(base_) );
		function_context.references_graph.AddNode( base_ptr );
		function_context.references_graph.TryAddLink( this_ptr, base_ptr, names_scope, src_loc );

		RegisterTemporaryVariable( function_context, base_ptr );
		return move(base_ptr);
	}

	return ResolveValue( names_scope, function_context, named_operand );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeinfo& typeinfo_ ) : Value
{
	var Type t= PrepareType( names_scope, function_context, typeinfo_.type_name );
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, typeinfo_.src_loc, t.ToString() )
		return ErrorValue();
	}

	var VariablePtr mut result= BuildTypeinfo( t, GetRootNamespace( names_scope ) );
	function_context.references_graph.AddNodeIfNotExists( result );
	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NonSyncExpression& non_sync_expression ) : Value
{
	var Type t= PrepareType( names_scope, function_context, non_sync_expression.type_name );
	var bool is_non_sync= GetTypeNonSync( t, names_scope, non_sync_expression.src_loc );

	var Variable mut result
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.constexpr_value= unsafe( LLVMConstInt( fundamental_llvm_types_.bool_, select( is_non_sync ? 1u64 : 0u64 ), LLVMBool::True ) ),
		.name= KeywordToString( Keyword::non_sync_ ),
	};
	result.llvm_value= result.constexpr_value;

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRef& cast_ref_ ) : Value
{
	return DoReferenceCast( names_scope, function_context, cast_ref_.t, cast_ref_.expression.deref(), cast_ref_.src_loc, false );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRefUnsafe& cast_ref_unsafe_ ) : Value
{
	if( !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( UnsafeReferenceCastOutsideUnsafeBlock, names_scope, cast_ref_unsafe_.src_loc )
	}
	return DoReferenceCast( names_scope, function_context, cast_ref_unsafe_.t, cast_ref_unsafe_.expression.deref(), cast_ref_unsafe_.src_loc, true );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastImut& cast_imut_ ) : Value
{
	var VariablePtr v_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, cast_imut_.expression.deref() );
	auto v_lock= v_ptr.lock_imut();
	var Variable& v= v_lock.deref();

	var Variable mut result
	{
		.t= v.t,
		.value_type= ValueType::ReferenceImut,
		.location= Variable::Location::Pointer,
		.constexpr_value= v.constexpr_value,
		.name= "cast_imut(" + v.name + ")",
	};

	// TODO - maybe forbid reference casting for ValueType::Value?
	if( v.location == Variable::Location::LLVMRegister )
	{
		if( !function_context.is_functionless_context )
		{
			result.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, v.t.GetLLVMType(), g_null_string ) );
			CreateTypedStore( function_context, v.t, v.llvm_value, result.llvm_value );
		}
	}
	else
	{
		result.llvm_value= v.llvm_value;
	}

	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	function_context.references_graph.TryAddLink( v_ptr, result_ptr, names_scope, cast_imut_.src_loc );

	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastMut& cast_mut_ ) : Value
{
	if( !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( MutableReferenceCastOutsideUnsafeBlock, names_scope, cast_mut_.src_loc )
	}

	var VariablePtr v_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, cast_mut_.expression.deref() );
	auto v_lock= v_ptr.lock_imut();
	var Variable& v= v_lock.deref();

	var Variable mut result
	{
		.t= v.t,
		.value_type= ValueType::ReferenceMut,
		.location= Variable::Location::Pointer,
		.name= "cast_mut(" + v.name + ")",
	};

	// TODO - maybe forbid reference casting for ValueType::Value?
	if( v.location == Variable::Location::LLVMRegister )
	{
		if( !function_context.is_functionless_context )
		{
			result.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, v.t.GetLLVMType(), g_null_string ) );
			CreateTypedStore( function_context, v.t, v.llvm_value, result.llvm_value );
		}
	}
	else
	{
		result.llvm_value= v.llvm_value;
	}

	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	function_context.references_graph.TryAddLink( v_ptr, result_ptr, names_scope, cast_mut_.src_loc );

	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SafeExpression& safe_expression ) : Value
{
	auto prev_unsafe= function_context.is_in_unsafe_block;
	function_context.is_in_unsafe_block= false;
	auto mut result= BuildExpressionCode( names_scope, function_context, safe_expression.expression.deref() );
	function_context.is_in_unsafe_block= prev_unsafe;
	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnsafeExpression& unsafe_expression ) : Value
{
	if( function_context.llvm_function == global_llvm_function_ )
	{
		REPORT_ERROR( UnsafeExpressionInGlobalContext, names_scope, unsafe_expression.src_loc )
	}

	// "unsafe" expression usage should prevent function to be "constexpr".
	function_context.have_non_constexpr_operations_inside= true;

	auto prev_unsafe= function_context.is_in_unsafe_block;
	function_context.is_in_unsafe_block= true;
	auto mut result= BuildExpressionCode( names_scope, function_context, unsafe_expression.expression.deref() );
	function_context.is_in_unsafe_block= prev_unsafe;

	// Avoid passing constexpr values trough unsafe expression.
	if_var( &variable_ptr : result.get</VariablePtr/>() )
	{
		auto variable_lock= variable_ptr.lock_imut();
		var Variable& variable= variable_lock.deref();
		if( variable.constexpr_value != LLVMValueRef::Null )
		{
			var Variable mut variable_copy
			{
				.t= variable.t,
				.value_type= variable.value_type,
				.location= variable.location,
				.llvm_value= variable.llvm_value,
				.constexpr_value= LLVMValueRef::Null,
				.name= variable.name,
			};
			var VariablePtr mut variable_copy_ptr( move(variable_copy) );
			function_context.references_graph.AddNode( variable_copy_ptr );
			if( variable.value_type == ValueType::Value )
			{
				var VariableNullablePtr inner_node= function_context.references_graph.GetNodeInnerReference( variable_ptr );
				if( !inner_node.empty() )
				{
					var VariablePtr inner_node_non_null= inner_node.try_to_non_nullable();
					var VariablePtr own_inner_node= function_context.references_graph.CreateNodeInnerReference( variable_copy_ptr, inner_node_non_null.lock_imut().deref().value_type );
					function_context.references_graph.AddLink( inner_node_non_null, own_inner_node );
				}
			}
			else
			{
				function_context.references_graph.TryAddLink( variable_ptr, variable_copy_ptr, names_scope, unsafe_expression.src_loc );
			}
			function_context.references_graph.MoveNode( variable_ptr );

			RegisterTemporaryVariable( function_context, variable_copy_ptr );
			return move(variable_copy_ptr);
		}
	}

	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MoveOperator& move_operator ) : Value
{
	// TODO - avoid creating Synt struct here.
	var Synt::NameLookup name_lookup{ .src_loc= move_operator.src_loc, .name= move_operator.variable_name };
	var Value value= ResolveValue( names_scope, function_context, name_lookup );
	if( value.get</VariablePtr/>().empty() )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.src_loc, GetValueKindName(value) )
		return ErrorValue();
	}

	var VariablePtr variable_reference_ptr= value.get</VariablePtr/>().try_deref();

	if( IsGlobalVariable( variable_reference_ptr ) )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.src_loc, "global variable" )
		return ErrorValue();
	}

	auto variable_reference_lock= variable_reference_ptr.lock_imut();
	var Variable& reference= variable_reference_lock.deref();

	if( reference.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, move_operator.src_loc )
		return ErrorValue();
	}
	if( function_context.references_graph.NodeIsMoved( variable_reference_ptr ) )
	{
		REPORT_ERROR( AccessingMovedVariable, names_scope, move_operator.src_loc, reference.name )
		return ErrorValue();
	}
	if( function_context.references_graph.HaveOutgoingLinks( variable_reference_ptr ) )
	{
		REPORT_ERROR( MovedVariableHaveReferences, names_scope, move_operator.src_loc, reference.name )
		return ErrorValue();
	}

	var ReferencesGraph::NodesSet input_nodes= function_context.references_graph.GetNodeInputLinks( variable_reference_ptr );
	if( input_nodes.size() != 1s )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.src_loc, "wrong reference" )
		return ErrorValue();
	}

	var VariablePtr& variable_for_move= input_nodes.range().front();
	if( variable_for_move.lock_imut().deref().value_type != ValueType::Value )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.src_loc, "wrong reference" )
		return ErrorValue();
	}

	auto mut found_in_variables= false;
	foreach( & frame : function_context.variables_frames ) label variable_frames_loop
	{
		foreach( &frame_variable : frame )
		{
			if( frame_variable == variable_for_move )
			{
				found_in_variables= true;
				break label variable_frames_loop;
			}
		}
	}

	if( !found_in_variables )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.src_loc, "wrong reference" )
		return ErrorValue();
	}

	var Variable mut result
	{
		.t= reference.t,
		.value_type= ValueType::Value,
		.location= reference.location,
		.llvm_value= reference.llvm_value,
		.name= "moved " + reference.name,
	};
	var VariablePtr mut result_ptr( move(result) );

	function_context.references_graph.AddNode( result_ptr );

	SetupReferencesInCopyOrMove( names_scope, function_context, result_ptr, variable_for_move, move_operator.src_loc );

	function_context.references_graph.MoveNode( variable_reference_ptr );
	function_context.references_graph.MoveNode( variable_for_move );

	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TakeOperator& take_operator ) : Value
{
	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, take_operator.expression.deref() );
	auto mut variable_lock= variable_ptr.lock_imut();
	if( variable_lock.deref().value_type == ValueType::Value )
	{
		return variable_ptr; // If it is value - just pass it.
	}

	if( variable_lock.deref().value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, take_operator.src_loc )
		return ErrorValue();
	}
	if( function_context.references_graph.HaveOutgoingLinks( variable_ptr ) )
	{
		REPORT_ERROR( MovedVariableHaveReferences, names_scope, take_operator.src_loc, variable_lock.deref().name )
		return ErrorValue();
	}
	if( variable_lock.deref().t.IsAbstract() )
	{
		REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, take_operator.src_loc, variable_lock.deref().t )
		return ErrorValue();
	}
	if_var( class_type : variable_lock.deref().t.GetClassType() )
	{
		// Do not allow taking values of polymorph non-final classes to avoid calling default constructor of base class in place of derived class.
		// It may break derived class invariants and will overwrite virtual table pointer.
		auto kind= class_type.lock_imut().deref().kind;
		if( kind == ClassType::Kind::Interface || kind == ClassType::Kind::Abstract || kind == ClassType::Kind::PolymorphNonFinal )
		{
			REPORT_ERROR( TakeForNonFinalPolymorphClass, names_scope, take_operator.src_loc, variable_lock.deref().t )
			return ErrorValue();
		}
	}

	var ust::string8 src_variable_name= variable_lock.deref().name;

	var ust::string8 mut variable_name= "taken ";
	variable_name+= src_variable_name;

	var Variable mut result
	{
		.t= variable_lock.deref().t,
		.value_type= ValueType::Value,
		.location= Variable::Location::Pointer,
		.name= variable_name,
	};

	variable_name.push_back( "\0"c8 );
	if( !function_context.is_functionless_context )
	{
		result.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, variable_lock.deref().t.GetLLVMType(), variable_name.front() ) );
		CreateLifetimeStart( function_context, result.llvm_value );
	}

	// Copy content to new variable.
	CopyBytes( result.llvm_value, variable_lock.deref().llvm_value, result.t, function_context );

	move(variable_lock);

	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );

	SetupReferencesInCopyOrMove( names_scope, function_context, result_ptr, variable_ptr, take_operator.src_loc );

	// Apply empty initializer for source variable.
	BuildEmptyInitializer( names_scope, function_context, variable_ptr, src_variable_name, take_operator.src_loc );

	// Register variable for references checking and destruction.
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TernaryOperator& ternary_operator ) : Value
{
	auto mut condition_in_register= LLVMValueRef::Null;
	auto mut condition_constexpr_value= LLVMValueRef::Null;
	with( &condition: BuildExpressionCodeEnsureVariable( names_scope, function_context, ternary_operator.condition.deref() ).lock_imut().deref() )
	{
		if( condition.t != bool_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, ternary_operator.src_loc, bool_type_, condition.t )
			return ErrorValue();
		}

		condition_in_register= CreateMoveToLLVMRegisterInstruction( condition, function_context );
		condition_constexpr_value= condition.constexpr_value;
	}

	// Know type and value type of each branch.
	var [ VariableTypeExtended, 2 ] mut branches_types[ { .value_type= zero_init }, { .value_type= zero_init } ];
	for( auto mut i= 0s; i < 2s; ++i )
	{
		var bool prev_is_functionless_context= function_context.is_functionless_context;
		function_context.is_functionless_context= true;

		auto state= SaveFunctionContextState( function_context );
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			with( &branch_value: BuildExpressionCodeEnsureVariable( names_scope, function_context, ternary_operator.branches[i].deref() ).lock_imut().deref() )
			{
				branches_types[i].t= branch_value.t;
				branches_types[i].value_type= branch_value.value_type;
			}
			DestroyUnusedTemporaryVariables( names_scope, function_context, ternary_operator.src_loc );
		}
		RestoreFunctionContextState( function_context, state );
		function_context.is_functionless_context= prev_is_functionless_context;
	}

	auto& branches_types_imut = branches_types;

	if( branches_types_imut[0].t != branches_types_imut[1].t )
	{
		REPORT_ERROR( TypesMismatch, names_scope, ternary_operator.src_loc, branches_types_imut[0].t, branches_types_imut[1].t )
		return ErrorValue();
	}


	var Type& t= branches_types_imut[0].t;
	auto mut value_type= ValueType::Value;
	auto mut llvm_value= LLVMValueRef::Null;
	if( branches_types_imut[0].value_type == ValueType::Value || branches_types_imut[1].value_type == ValueType::Value )
	{
		value_type= ValueType::Value;

		if( !EnsureTypeComplete( t ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope, ternary_operator.src_loc, t )
			return ErrorValue();
		}
		if( !function_context.is_functionless_context )
		{
			llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), "select_result\0"[0] ) );
			CreateLifetimeStart( function_context, llvm_value );
		}
	}
	else if( branches_types_imut[0].value_type == ValueType::ReferenceImut || branches_types_imut[1].value_type == ValueType::ReferenceImut )
	{
		value_type= ValueType::ReferenceImut;
	}
	else
	{
		value_type= ValueType::ReferenceMut;
	}

	var Variable mut result
	{
		.t= t,
		.value_type= value_type,
		.location= Variable::Location::Pointer,
		.llvm_value= llvm_value,
		.name= KeywordToString( Keyword::select_ ),
	};
	var VariablePtr mut result_ptr( move(result) );

	// Do not forget to remove this node in case of error-return!!!
	function_context.references_graph.AddNode( result_ptr );

	var LLVMBasicBlockRef mut result_block= zero_init;
	var [ LLVMBasicBlockRef, 2 ] mut branches_blocks= zero_init, mut branches_end_blocks= zero_init;
	if( !function_context.is_functionless_context )
	{
		unsafe
		{
			result_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
			branches_blocks[0]= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
			branches_blocks[1]= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

			LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, branches_blocks[0], branches_blocks[1] );
		}
	}

	var ReferencesGraph references_graph_before= take(function_context.references_graph);
	var [ ReferencesGraph, 2 ] mut branches_references_graphs;
	var [ LLVMValueRef, 2 ] mut branches_reference_values= zero_init, mut branches_constexpr_values= zero_init;
	for( auto mut i= 0s; i < 2s; ++i )
	{
		function_context.references_graph= references_graph_before;
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			if( !function_context.is_functionless_context )
			{
				unsafe
				{
					LLVMAppendExistingBasicBlock( function_context.llvm_function, branches_blocks[i] );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, branches_blocks[i] );
				}
			}

			var Synt::Expression& branch_expr= ternary_operator.branches[i].deref();
			var VariablePtr branch_result_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch_expr );
			var VariableLite branch_result= branch_result_ptr.lock_imut().deref();

			branches_constexpr_values[i]= branch_result.constexpr_value;

			if( value_type == ValueType::Value )
			{
				if( t != void_type_ )
				{
					SetupReferencesInCopyOrMove( names_scope, function_context, result_ptr, branch_result_ptr, ternary_operator.src_loc );

					if( branch_result.value_type == ValueType::Value )
					{
						function_context.references_graph.MoveNode( branch_result_ptr );

						if( !function_context.is_functionless_context )
						{
							if( branch_result.location == Variable::Location::Pointer )
							{
								CopyBytes( llvm_value, branch_result.llvm_value, t, function_context );
								CreateLifetimeEnd( function_context, branch_result.llvm_value );
							}
							else
							{
								CreateTypedStore( function_context, t, branch_result.llvm_value, llvm_value );
							}
						}
					}
					else
					{
						if( !t.IsCopyConstructible() )
						{
							REPORT_ERROR( CopyConstructValueOfNoncopyableType, names_scope, ternary_operator.src_loc, t )
						}
						else if( t.IsAbstract() )
						{
							REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, ternary_operator.src_loc, t )
						}
						else if( !function_context.is_functionless_context )
						{
							BuildCopyConstructorPart( names_scope, function_context, llvm_value, branch_result.llvm_value, t, ternary_operator.src_loc );
						}
					}
				}
			}
			else
			{
				branches_reference_values[i]= branch_result.llvm_value;
				function_context.references_graph.TryAddLink( branch_result_ptr, result_ptr, names_scope, ternary_operator.src_loc );
			}

			CallDestructorsForTopVariablesFrame( names_scope, function_context, Synt::GetSrcLoc(branch_expr) );
		}

		if( !function_context.is_functionless_context )
		{
			unsafe
			{
				branches_end_blocks[i]= LLVMGetInsertBlock( function_context.llvm_ir_builder );
				LLVMBuildBr( function_context.llvm_ir_builder, result_block );
			}
		}
		branches_references_graphs[i]= take(function_context.references_graph);
	}

	function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( branches_references_graphs, names_scope, ternary_operator.src_loc );

	if( !function_context.is_functionless_context )
	{
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, result_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, result_block );

			if( value_type != ValueType::Value )
			{
				auto phi_node= LLVMBuildPhi( function_context.llvm_ir_builder, LLVMPointerType( t.GetLLVMType(), 0u ), "select_result\0"[0] );
				LLVMAddIncoming( phi_node, $<(branches_reference_values[0]), $<(branches_end_blocks[0]), 2u );
				with( mut lock : result_ptr.lock_mut() )
				{
					lock.deref().llvm_value= phi_node;
				}
			}
		}
	}

	if( condition_constexpr_value != LLVMValueRef::Null )
	{
		with( mut lock : result_ptr.lock_mut() )
		{
			lock.deref().constexpr_value=
				select( unsafe( LLVMConstIntGetZExtValue( condition_constexpr_value ) ) != 0u64 ? branches_constexpr_values[0] : branches_constexpr_values[1] );
		}
	}

	// Register variable for references checking and destruction.
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReferenceToRawPointerOperator& reference_to_raw_pointer_operator ) : Value
{
	// TODO - maybe allow reference to pointer conversion only in unsafe code?

	var VariablePtr v_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, reference_to_raw_pointer_operator.expression.deref() );
	auto v_lock= v_ptr.lock_imut();
	var Variable& v= v_lock.deref();

	if( v.value_type == ValueType::Value )
	{
		REPORT_ERROR( ValueIsNotReference, names_scope, reference_to_raw_pointer_operator.src_loc )
		return ErrorValue();
	}
	if( v.value_type == ValueType::ReferenceImut )
	{
		// Disable immutable reference to pointer conversion, because pointer dereference produces mutable value.
		REPORT_ERROR( ExpectedReferenceValue, names_scope, reference_to_raw_pointer_operator.src_loc )
		return ErrorValue();
	}

	// Reference to pointer conversion can break functional purity, so, disable such conversions in constexpr functions.
	// For example:
	/*
		fn constexpr GetX(i32& x, i32& y) : size_type // Memory location of reference arguments is unpredictable.
		{
			return $<(x) - $<(y);
		}
	*/
	function_context.have_non_constexpr_operations_inside= true;

	var RawPointerType mut t
	{
		.element_type= v.t,
		.llvm_type= unsafe( LLVMPointerType( v.t.GetLLVMType(), 0u32 ) )
	};
	var Variable mut result
	{
		.t= move(t),
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.llvm_value= v.llvm_value, // llvm value of reference is actually value of pointer
		.name= "$>(" + v.name + ")",
	};

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerToReferenceOperator& raw_pointer_to_reference_operator ) : Value
{
	if( !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( RawPointerToReferenceConversionOutsideUnsafeBlock, names_scope, raw_pointer_to_reference_operator.src_loc )
	}

	var VariablePtr v_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, raw_pointer_to_reference_operator.expression.deref() );
	auto v_lock= v_ptr.lock_imut();
	var Variable& v= v_lock.deref();

	auto pointer_type_ref= v.t.GetRawPointerType();
	if( pointer_type_ref.empty() )
	{
		REPORT_ERROR( ValueIsNotPointer, names_scope, raw_pointer_to_reference_operator.src_loc, v.t )
		return ErrorValue();
	}

	var Variable mut result
	{
		.t= pointer_type_ref.try_deref().element_type,
		.location= Variable::Location::Pointer,
		.value_type= ValueType::ReferenceMut, // Unlike C++ all raw pointers in Ãœ are mutable.
		.llvm_value= CreateMoveToLLVMRegisterInstruction( v, function_context ), // llvm value of reference is actually value of pointer
		.name= "$<(" + v.name + ")",
	};

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	if( binary_operator.operator == BinaryOperatorType::LazyLogicalAnd || binary_operator.operator == BinaryOperatorType::LazyLogicalOr )
	{
		return BuildLazyBinaryOperator( names_scope, function_context, binary_operator );
	}

	auto overloaded_operator= GetOverloadedOperatorForBinaryOperator( binary_operator.operator );

	if_var( &mut res :
		TryCallOverloadedBinaryOperator(
			names_scope,
			function_context,
			overloaded_operator,
			binary_operator.l,
			binary_operator.r,
			ArgsEvaluationOrder::Direct,
			binary_operator.src_loc ) )
	{
		if_var( &variable_ptr : res.get</VariablePtr/>() )
		{
			auto variable_lock= variable_ptr.lock_imut();
			var Variable& variable= variable_lock.deref();
			if( binary_operator.operator == BinaryOperatorType::NotEqual && variable.t == bool_type_ )
			{
				// "!=" is implemented via "==", so, invert result.
				var Variable mut result
				{
					.t= bool_type_,
					.value_type= ValueType::Value,
					.location= Variable::Location::LLVMRegister,
					.name= BinaryOperatorToString( BinaryOperatorType::NotEqual ),
				};

				auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );
				if( value_in_register != LLVMValueRef::Null )
				{
					unsafe
					{
						result.llvm_value= LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "!\0"[0] );
						if( LLVMIsConstant( result.llvm_value ) == LLVMBool::True ){ result.constexpr_value= result.llvm_value; }
					}
				}

				var VariablePtr mut result_ptr( move(result) );
				function_context.references_graph.AddNode( result_ptr );
				RegisterTemporaryVariable( function_context, result_ptr );
				return move(result_ptr);
			}
			else if( overloaded_operator == OverloadedOperator::CompareOrder &&
				binary_operator.operator != BinaryOperatorType::CompareOrder &&
				!variable.t.GetFundamentalType().empty() &&
				IsSignedInteger( variable.t.GetFundamentalType().try_deref().fundamental_type ) )
			{
				var Variable mut result
				{
					.t= bool_type_,
					.value_type= ValueType::Value,
					.location= Variable::Location::LLVMRegister,
					.name= OverloadedOperatorToString( overloaded_operator ),
				};

				var LLVMValueRef value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );
				if( value_in_register != LLVMValueRef::Null )
				{
					unsafe
					{
						auto zero= LLVMConstInt( variable.t.GetLLVMType(), 0u64, LLVMBool::False );
						if( binary_operator.operator == BinaryOperatorType::Less )
						{
							result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLT, value_in_register, zero, "<\0"[0] );
						}
						else if( binary_operator.operator == BinaryOperatorType::LessEqual )
						{
							result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLE, value_in_register, zero, "<=\0"[0] );
						}
						else if( binary_operator.operator == BinaryOperatorType::Greater )
						{
							result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGT, value_in_register, zero, ">\0"[0] );
						}
						else if( binary_operator.operator == BinaryOperatorType::GreaterEqual )
						{
							result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGE, value_in_register, zero, ">=\0"[0] );
						}
						else { halt; }
					}
				}

				if( result.llvm_value != LLVMValueRef::Null && unsafe(LLVMIsConstant( result.llvm_value ) ) == LLVMBool::True )
				{
					result.constexpr_value= result.llvm_value;
				}

				var VariablePtr mut result_ptr( move(result) );
				function_context.references_graph.AddNode( result_ptr );
				RegisterTemporaryVariable( function_context, result_ptr );
				return move(result_ptr);
			}
		}

		return res;
	}

	var VariableLite mut l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.deref() ).lock_imut().deref();
	// Save l_var in register, prevent its modification during r_var calculation.
	l_var.llvm_value= CreateMoveToLLVMRegisterInstruction( l_var, function_context );
	l_var.location= Variable::Location::LLVMRegister;
	l_var.value_type= ValueType::Value;

	// Destroy temporaries of left part.
	DestroyUnusedTemporaryVariables( names_scope, function_context, binary_operator.src_loc );

	var VariableLite r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.deref() ).lock_imut().deref();

	return BuildBinaryOperator( names_scope, function_context, l_var, r_var, binary_operator.operator, binary_operator.src_loc );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value
{
	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.value.deref() );
	var VariableLite variable= variable_ptr.lock_imut().deref();

	if( !variable.t.GetClassType().empty() )
	{
		// Try to call overloaded [] operator for class.
		if_var( &mut res : TryCallOverloadedPostfixOperator( names_scope, function_context, OverloadedOperator::Indexing, variable_ptr, ust::single_element_array_view(indexation_operator.index), indexation_operator.src_loc ) )
		{
			return take(res);
		}
	}

	// This is not a class - process indexation operator for array or tuple.

	if_var( &variable_array_type : variable.t.GetArrayType() )
	{
		// Prevent modification of variable during index calculation.
		// Do not forget to remove this node in case of error-return!!!
		var Variable mut variable_lock_node_variable
		{
			.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			.location= Variable::Location::Pointer,
			.name= "lock []",
		};
		var VariablePtr variable_lock_node( move(variable_lock_node_variable) );
		function_context.references_graph.AddNode( variable_lock_node );
		function_context.references_graph.TryAddLink( variable_ptr, variable_lock_node, names_scope, indexation_operator.src_loc );

		var VariableLite index= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.index.deref() ).lock_imut().deref();

		if_var( &index_fundamental_type : index.t.GetFundamentalType() )
		{
			if( !(
				IsUnsignedInteger( index_fundamental_type.fundamental_type ) ||
				( IsSignedInteger( index_fundamental_type.fundamental_type ) && index.constexpr_value != LLVMValueRef::Null ) ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, indexation_operator.src_loc, ust::string8("any unsigned integer"), index.t )
				function_context.references_graph.RemoveNode( variable_lock_node );
				return ErrorValue();
			}
			if( variable.location != Variable::Location::Pointer )
			{
				// TODO - Strange variable location.
				function_context.references_graph.RemoveNode( variable_lock_node );
				return ErrorValue();
			}

			var LLVMValueRef mut index_value= CreateMoveToLLVMRegisterInstruction( index, function_context );
			DestroyUnusedTemporaryVariables( names_scope, function_context, indexation_operator.src_loc ); // Destroy index.
			if( index.constexpr_value != LLVMValueRef::Null )
			{
				// Statically check index.
				auto index_value_num= unsafe( LLVMConstIntGetZExtValue( index_value ) );
				if( index_value_num >= variable_array_type.element_count )
				{
					REPORT_ERROR( ArrayIndexOutOfBounds, names_scope, indexation_operator.src_loc, index_value_num, variable_array_type.element_count )
					function_context.references_graph.RemoveNode( variable_lock_node );
					return ErrorValue();
				}
			}
			else if( !function_context.is_functionless_context )
			{
				// Dynamically check index.
				unsafe
				{
					auto mut index_value_for_compare= index_value;
					auto index_type_size= index_fundamental_type.GetSize();
					auto size_type_size= size_type_.GetFundamentalType().try_deref().GetSize();
					if( index_type_size > size_type_size )
					{
						index_value_for_compare= LLVMBuildTrunc( function_context.llvm_ir_builder, index_value_for_compare, fundamental_llvm_types_.int_ptr, g_null_string );
					}
					else if( index_type_size < size_type_size )
					{
						index_value_for_compare= LLVMBuildZExt( function_context.llvm_ir_builder, index_value_for_compare, fundamental_llvm_types_.int_ptr, g_null_string );
					}

					auto size_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, variable_array_type.element_count, LLVMBool::False );
					auto condition= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGE, index_value_for_compare, size_value, g_null_string );
					auto halt_block = LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
					auto ok_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

					LLVMBuildCondBr( function_context.llvm_ir_builder, condition, halt_block, ok_block );

					LLVMAppendExistingBasicBlock( function_context.llvm_function, halt_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, halt_block );

					LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(halt_function_), halt_function_, ust::nullptr</LLVMValueRef/>(), 0u, g_null_string );
					LLVMBuildUnreachable( function_context.llvm_ir_builder );

					LLVMAppendExistingBasicBlock( function_context.llvm_function, ok_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, ok_block );
				}
			}

			var Variable mut result
			{
				.t= variable_array_type.element_type,
				.location= Variable::Location::Pointer,
				.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.llvm_value= CreateArrayElementGEP( function_context, variable_array_type, variable.llvm_value, index_value ),
				.name= variable_ptr.lock_imut().deref().name + "[]",
			};

			if( variable.constexpr_value != LLVMValueRef::Null && index.constexpr_value != LLVMValueRef::Null )
			{
				result.constexpr_value= unsafe( LLVMGetAggregateElement( variable.constexpr_value, u32( LLVMConstIntGetZExtValue( index_value ) ) ) );
			}

			var VariablePtr mut result_ptr( move(result) );
			function_context.references_graph.AddNode( result_ptr );
			function_context.references_graph.AddLink( variable_lock_node, result_ptr );
			function_context.references_graph.RemoveNode( variable_lock_node );
			// Register variable for references checking.
			RegisterTemporaryVariable( function_context, result_ptr );
			return move(result_ptr);
		}
		REPORT_ERROR( TypesMismatch, names_scope, indexation_operator.src_loc, ust::string8("any unsigned integer"), index.t )
	}
	else if_var( &tuple_type : variable.t.GetTupleType() )
	{
		var ust::optional</VariableLite/> mut index_opt;
		{ // Create new stack frame to prevent deletion of variable during index calculation.
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			index_opt= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.index.deref() ).lock_imut().deref();
			CallDestructorsForTopVariablesFrame( names_scope, function_context, indexation_operator.src_loc );
		}
		var VariableLite& index= index_opt.try_deref();

		if_var( &index_fundamental_type : index.t.GetFundamentalType() )
		{
			if( !IsInteger( index_fundamental_type.fundamental_type ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, indexation_operator.src_loc, ust::string8("any integer"), index.t )
				return ErrorValue();
			}
			if( index.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, indexation_operator.src_loc )
				return ErrorValue();
			}

			var u64 mut type_index= ~0u64;
			var i64 mut type_index_signed(-1);
			unsafe
			{
				type_index= LLVMConstIntGetZExtValue( index.constexpr_value );
				type_index_signed= LLVMConstIntGetSExtValue( index.constexpr_value );
			}

			if( IsSignedInteger( index_fundamental_type.fundamental_type ) )
			{
				if( type_index_signed >= i64(tuple_type.element_types.size()) || type_index_signed < 0i64 )
				{
					REPORT_ERROR( TupleIndexOutOfBounds, names_scope, indexation_operator.src_loc, type_index_signed, tuple_type.element_types.size() )
					return ErrorValue();
				}
			}
			else
			{
				if( type_index >= u64(tuple_type.element_types.size()) )
				{
					REPORT_ERROR( TupleIndexOutOfBounds, names_scope, indexation_operator.src_loc, type_index, tuple_type.element_types.size() )
					return ErrorValue();
				}
			}

			auto mut lock= variable_ptr.lock_mut();
			var Variable& mut v= lock.deref();

			v.children.resize( tuple_type.element_types.size() );
			{
				var VariableNullablePtr prev_node= v.children[ type_index ];
				if( !prev_node.empty() )
				{
					var VariablePtr mut prev_node_non_null= prev_node.try_to_non_nullable();
					function_context.references_graph.AddNodeIfNotExists( prev_node_non_null );
					return move(prev_node_non_null);
				}
			}

			var Variable mut result
			{
				.t= tuple_type.element_types[type_index],
				.location= Variable::Location::Pointer,
				.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.llvm_value= ForceCreateConstantIndexGEP( function_context, tuple_type.llvm_type, v.llvm_value, u32(type_index) ),
				.name= v.name + "[" + ust::to_string8(type_index) + "]",
				.parent= variable_ptr
			};
			if( variable.constexpr_value != LLVMValueRef::Null )
			{
				result.constexpr_value= unsafe( LLVMGetAggregateElement( variable.constexpr_value, u32(type_index) ) );
			}

			var VariablePtr mut result_ptr( move(result) );
			function_context.references_graph.AddNode( result_ptr );
			v.children[ type_index ]= result_ptr;
			return move(result_ptr);
		}
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.src_loc, index.t )
	}

	REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.src_loc, variable.t )
	return ErrorValue();
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value
{
	auto function= BuildExpressionCode( names_scope, function_context, call_operator.value.deref() );

	var ust::optional_ref_imut</ FunctionsSet /> mut functions_set;
	var VariableNullablePtr mut this_;

	if_var( &t : function.get</Type/>() )
	{
		return BuildTempVariableConstruction( names_scope, function_context, t, call_operator.args, call_operator.src_loc );
	}
	if_var( & in_functions_set : function.get</FunctionsSet/>() )
	{
		functions_set.reset(in_functions_set);
	}
	if_var( & this_methods_set : function.get</ThisMethodsSet/>() )
	{
		functions_set.reset(this_methods_set.functions_set);
		this_= this_methods_set.this_;
	}
	if_var( &variable_ptr : function.get</VariablePtr/>() )
	{
		var VariableLite variable= variable_ptr.lock_imut().deref();

		if_var( &function_pointer_type : variable.t.GetFunctionPointerType() )
		{
			var LLVMValueRef function_value= CreateMoveToLLVMRegisterInstruction( variable, function_context );

			function_context.have_non_constexpr_operations_inside= true; // Call via pointer is not constexpr.

			return DoCallFunction(
				names_scope,
				function_context,
				VariableNullablePtr(),
				function_pointer_type.function_type,
				function_value,
				false, // Call via pointer is not constexpr.
				call_operator.args.range(),
				call_operator.src_loc );
		}

		// Try to call overloaded () operator.
		// Do it here and not call "CallFunctionsSet" to allow non-this-call operator ().
		if_var( &mut res : TryCallOverloadedPostfixOperator( names_scope, function_context, OverloadedOperator::Call, variable_ptr, call_operator.args.range(), call_operator.src_loc ) )
		{
			return take(res);
		}
	}

	if( functions_set.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, call_operator.src_loc, ust::string8("non-function value") )
		return ErrorValue();
	}

	return CallFunctionsSet( names_scope, function_context, this_, functions_set.try_deref(), call_operator.args.range(), call_operator.src_loc );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MemberAccessOperator& member_access_operator ) : Value
{
	if( member_access_operator.member_name == KeywordToString( Keyword::constructor_ ) ||
		member_access_operator.member_name == KeywordToString( Keyword::destructor_ ) )
	{
		if( !function_context.is_in_unsafe_block )
		{
			REPORT_ERROR( ExplicitAccessToThisMethodIsUnsafe, names_scope, member_access_operator.src_loc, member_access_operator.member_name )
		}
	}

	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, member_access_operator.value.deref() );
	var VariableLite variable= variable_ptr.lock_imut().deref();

	if( !EnsureTypeComplete( variable.t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, member_access_operator.src_loc, variable.t )
		return ErrorValue();
	}

	auto class_type_ref= variable.t.GetClassType();
	if( class_type_ref.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, member_access_operator.src_loc, variable.t )
		return ErrorValue();
	}
	var ClassTypePtr class_type= class_type_ref.try_deref();

	auto mut class_member_opt= ResolveClassValue( class_type, member_access_operator.member_name );
	if( class_member_opt.empty() )
	{
		REPORT_ERROR( NameNotFound, names_scope, member_access_operator.src_loc, member_access_operator.member_name )
		return ErrorValue();
	}
	auto& class_member= class_member_opt.try_deref();

	if( u32( names_scope.lock_imut().deref().GetAccessFor( class_type ) ) < u32( class_member[1] ) )
	{
		REPORT_ERROR( AccessingNonpublicClassMember, names_scope, member_access_operator.src_loc, member_access_operator.member_name, variable.t.ToString() )
	}

	auto field_ptr= class_member[0].Get</ClassField/>();
	if( !field_ptr.empty() )
	{
		if( !member_access_operator.template_args.empty() )
		{
			REPORT_ERROR( ValueIsNotTemplate, names_scope, member_access_operator.src_loc )
		}

		return AccessClassField( names_scope, function_context, variable_ptr, field_ptr.try_lock_imut().deref(), member_access_operator.member_name, member_access_operator.src_loc );
	}

	auto functions_set_ptr= class_member[0].Get</NamesScopeFunctionsSet/>();
	if( !functions_set_ptr.empty() )
	{
		BuildFunctionsSet( class_member[2], functions_set_ptr.try_to_non_nullable(), false );

		var ThisMethodsSet mut this_methods_set{ .this_= variable_ptr };

		if( !member_access_operator.template_args.empty() )
		{
			auto functions_set_lock= functions_set_ptr.try_lock_imut();
			auto& functions_set= functions_set_lock.deref().functions_set;

			if( functions_set.function_templates.empty() )
			{
				REPORT_ERROR( ValueIsNotTemplate, names_scope, member_access_operator.src_loc )
				return ErrorValue();
			}

			// Prevent destruction of variable during evaluation of member function template args.
			// Do not forget to remove node in case of error-return!!!
			var Variable mut variable_lock_node_variable
			{
				.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.location= Variable::Location::Pointer,
				.name= variable_ptr.lock_imut().deref().name + " lock",
			};
			var VariablePtr variable_lock_node( move(variable_lock_node_variable) );
			function_context.references_graph.AddNode( variable_lock_node );
			function_context.references_graph.AddLink( variable_ptr, variable_lock_node );

			auto val= ParametrizeTemplateFunctions(
				names_scope,
				function_context,
				functions_set,
				member_access_operator.template_args.try_deref(),
				member_access_operator.src_loc );

			function_context.references_graph.RemoveNode( variable_lock_node );

			if( val.empty() )
			{
				return ErrorValue();
			}

			this_methods_set.functions_set= val.try_deref().Get</NamesScopeFunctionsSet/>().try_lock_imut().deref().functions_set;
		}
		else
		{
			this_methods_set.functions_set= functions_set_ptr.try_lock_imut().deref().functions_set;
		}

		return move(this_methods_set);
	}

	REPORT_ERROR( NotImplemented, names_scope, member_access_operator.src_loc, ust::string8("class members, except fields or methods") )
	return ErrorValue();
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryPlus& unary_plus ) : Value
{
	// Do nothing with unary plus.
	// TODO - maybe check type or do something else?
	return BuildExpressionCode( names_scope, function_context, unary_plus.expr.deref() );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value
{
	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, unary_minus.expr.deref() );
	var VariableLite variable= variable_ptr.lock_imut().deref();

	if_var( &mut res : TryCallOverloadedUnaryOperator( names_scope, function_context, OverloadedOperator::Sub, variable_ptr, unary_minus.src_loc ) )
	{
		return take(res);
	}

	auto fundamental_type= variable.t.GetFundamentalType();
	if( fundamental_type.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, unary_minus.src_loc, variable.t )
		return ErrorValue();
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );
	DestroyUnusedTemporaryVariables( names_scope, function_context, unary_minus.src_loc );

	var Variable mut result
	{
		.t= variable.t,
		.value_type= ValueType::Value,
		.location= Variable::Location::LLVMRegister,
		.name= "-",
	};

	if( IsInteger( fundamental_type.try_deref().fundamental_type ) )
	{
		if( value_in_register != LLVMValueRef::Null )
		{
			result.llvm_value= unsafe( LLVMBuildNeg( function_context.llvm_ir_builder, value_in_register, "-\0"[0] ) );
		}
	}
	else if( IsFloatingPoint( fundamental_type.try_deref().fundamental_type ) )
	{
		if( value_in_register != LLVMValueRef::Null )
		{
			result.llvm_value= unsafe( LLVMBuildFNeg( function_context.llvm_ir_builder, value_in_register, "-\0"[0] ) );
		}
	}
	else
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, unary_minus.src_loc, variable.t )
		return ErrorValue();
	}

	if( result.llvm_value != LLVMValueRef::Null && unsafe( LLVMIsConstant( result.llvm_value ) ) == LLVMBool::True )
	{
		result.constexpr_value= result.llvm_value;
	}

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value
{
	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, logical_not.expr.deref() );
	var VariableLite variable= variable_ptr.lock_imut().deref();

	if_var( &mut res : TryCallOverloadedUnaryOperator( names_scope, function_context, OverloadedOperator::LogicalNot, variable_ptr, logical_not.src_loc ) )
	{
		return take(res);
	}

	if( variable.t != bool_type_ )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, logical_not.src_loc, variable.t )
		return ErrorValue();
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );
	DestroyUnusedTemporaryVariables( names_scope, function_context, logical_not.src_loc );

	var Variable mut result
	{
		.t= bool_type_,
		.value_type= ValueType::Value,
		.location= Variable::Location::LLVMRegister,
		.name= "!",
	};

	if( value_in_register != LLVMValueRef::Null )
	{
		result.llvm_value= unsafe( LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "!\0"[0] ) );
		if( unsafe( LLVMIsConstant( result.llvm_value ) ) == LLVMBool::True )
		{
			result.constexpr_value= result.llvm_value;
		}
	}

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value
{
	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, bitwise_not.expr.deref() );
	var VariableLite variable= variable_ptr.lock_imut().deref();

	if_var( &mut res : TryCallOverloadedUnaryOperator( names_scope, function_context, OverloadedOperator::BitwiseNot, variable_ptr, bitwise_not.src_loc ) )
	{
		return take(res);
	}

	auto fundamental_type= variable.t.GetFundamentalType();
	if( fundamental_type.empty() || !IsInteger( fundamental_type.try_deref().fundamental_type ) )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, bitwise_not.src_loc, variable.t )
		return ErrorValue();
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );
	DestroyUnusedTemporaryVariables( names_scope, function_context, bitwise_not.src_loc );

	var Variable mut result
	{
		.t= variable.t,
		.value_type= ValueType::Value,
		.location= Variable::Location::LLVMRegister,
		.name= "~",
	};

	if( value_in_register != LLVMValueRef::Null )
	{
		result.llvm_value= unsafe( LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "~\0"[0] ) );
		if( unsafe( LLVMIsConstant( result.llvm_value ) ) == LLVMBool::True )
		{
			result.constexpr_value= result.llvm_value;
		}
	}

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Value
{
	return PrepareType( names_scope, function_context, array_type );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Value
{
	return PrepareType( names_scope, function_context, tuple_type );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::RawPointerType/>& raw_pointer_type ) : Value
{
	return PrepareType( names_scope, function_context, raw_pointer_type );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type ) : Value
{
	return PrepareType( names_scope, function_context, function_type );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::GeneratorType/>& generator_type ) : Value
{
	return PrepareType( names_scope, function_context, generator_type );
}

fn CodeBuilder::DoReferenceCast( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name, Synt::Expression& expression, SrcLoc& src_loc, bool allow_unsafe ) : Value
{
	var Type t= PrepareType( names_scope, function_context, type_name );
	var VariablePtr v_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression );
	var VariableLite v= v_ptr.lock_imut().deref();

	var Variable mut result
	{
		.t= t,
		.value_type= select( v.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.name= "casted " + v_ptr.lock_imut().deref().name,
	};

	// TODO - maybe forbid reference casting for ValueType::Value?
	auto mut src_llvm_value= v.llvm_value;
	if( v.location == Variable::Location::LLVMRegister && !function_context.is_functionless_context )
	{
		src_llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, v.t.GetLLVMType(), g_null_string ) );
		CreateTypedStore( function_context, v.t, v.llvm_value, src_llvm_value );
	}

	if( v.t == t )
	{
		result.llvm_value= src_llvm_value;
	}
	else
	{
		// We needs complete types to check reference conversion possibility.
		if( !EnsureTypeComplete( t ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, t )
			return ErrorValue();
		}
		if( !EnsureTypeComplete( v.t ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, v.t )
			return ErrorValue();
		}

		if( v.t.ReferenceIsConvertibleTo( t ) )
		{
			result.llvm_value= CreateReferenceCast( src_llvm_value, v.t, t, function_context );
		}
		else
		{
			if( allow_unsafe )
			{
				if( src_llvm_value != LLVMValueRef::Null )
				{
					unsafe
					{
						auto dst_pointer_type= LLVMPointerType( t.GetLLVMType(), 0u );
						result.llvm_value= LLVMBuildPointerCast( function_context.llvm_ir_builder, src_llvm_value, dst_pointer_type, g_null_string );
					}
				}
			}
			else
			{
				REPORT_ERROR( TypesMismatch, names_scope, src_loc, t, v.t )
				return ErrorValue();
			}
		}
	}

	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	function_context.references_graph.TryAddLink( v_ptr, result_ptr, names_scope, src_loc );

	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::AccessClassBase( mut this, NamesScopePtr& names_scope, FunctionContext& mut function_context, VariablePtr& variable_ptr, SrcLoc& src_loc ) : VariablePtr
{
	var size_type base_field_index(0); // Base is always first field.

	auto mut variable_lock= variable_ptr.lock_mut();
	var Variable &mut variable= variable_lock.deref();

	auto class_type= variable.t.GetClassType().try_deref();
	var LLVMTypeRef class_llvm_type= class_type.lock_imut().deref().llvm_type;

	variable.children.resize( size_type( unsafe( LLVMCountStructElementTypes( class_llvm_type ) ) ) );
	{
		var VariableNullablePtr prev_node= variable.children[ base_field_index ];
		if( !prev_node.empty() )
		{
			var VariablePtr mut prev_node_non_null= prev_node.try_to_non_nullable();
			function_context.references_graph.AddNodeIfNotExists( prev_node_non_null );
			return move(prev_node_non_null);
		}
	}

	var Variable mut base_
	{
		.t= class_type.lock_imut().deref().base_class.try_to_non_nullable(),
		.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.llvm_value= ForceCreateConstantIndexGEP( function_context, class_llvm_type, variable.llvm_value, u32(base_field_index) ),
		.name= variable.name + ".base",
		.parent= variable_ptr,
	};
	var VariablePtr mut base_ptr( move(base_) );

	variable.children[ base_field_index ]= base_ptr;
	function_context.references_graph.AddNode( base_ptr );

	return move(base_ptr);
}

fn CodeBuilder::AccessClassField(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	VariablePtr& variable_ptr,
	ClassField& field,
	ust::string8& field_name,
	SrcLoc& src_loc ) : Value
{
	if( field.index == ~0u ) { return ErrorValue(); }

	var ClassTypePtr class_type= variable_ptr.lock_imut().deref().t.GetClassType().try_deref();

	if( field.source_class != class_type )
	{
		if( !class_type.lock_imut().deref().base_class.empty() )
		{
			var VariablePtr base_= AccessClassBase( names_scope, function_context, variable_ptr, src_loc );
			return AccessClassField( names_scope, function_context, base_, field, field_name, src_loc );
		}

		REPORT_ERROR( AccessOfNonThisClassField, names_scope, src_loc, field_name )
		return ErrorValue();
	}

	return AccessDirectClassField( names_scope, function_context, variable_ptr, field, field_name, src_loc );
}

fn CodeBuilder::AccessDirectClassField(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	VariablePtr& variable_ptr,
	ClassField& field,
	ust::string8& field_name,
	SrcLoc& src_loc ) : VariablePtr
{
	var VariableLite variable= variable_ptr.lock_imut().deref();
	var ClassTypePtr class_type= variable.t.GetClassType().try_deref();
	debug_assert( class_type == field.source_class, "Accessing non-direct class field!" );

	var ust::string8 mut node_name= variable_ptr.lock_imut().deref().name;
	node_name+= ".";
	node_name+= field_name;

	auto op_name_nt= "." + field_name + "\0";

	if( field.is_reference )
	{
		var Variable mut result
		{
			.t= field.t,
			.location= Variable::Location::Pointer,
			.value_type= select( field.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			.name= move(node_name),
		};

		if( variable.constexpr_value != LLVMValueRef::Null )
		{
			// Create constant "extractvalue" instead of "load" for constexpr structs.
			if( EnsureTypeComplete( field.t ) )
			{
				unsafe
				{
					result.llvm_value= LLVMGetAggregateElement( variable.constexpr_value, u32(field.index) );

					// References in constexpr structs should be implementing, using global variables or ConstantGEP for global variables.
					var LLVMValueRef constant_expression= LLVMIsAConstantExpr( result.llvm_value ) ;
					if( constant_expression != LLVMValueRef::Null )
					{
						// Assume constant GEP.
						var LLVMValueRef global_variable= LLVMGetOperand( constant_expression, 0u );
						var i32 num_operands= LLVMGetNumOperands( constant_expression );
						var LLVMValueRef mut element= LLVMGetInitializer( global_variable );
						for( var i32 mut i= 2; i < num_operands; ++i ) // Skip first zero index.
						{
							auto index= u32( LLVMConstIntGetZExtValue( LLVMGetOperand( constant_expression, u32(i) ) ) );
							element= LLVMGetAggregateElement( element, index );
						}
						result.constexpr_value= element;
					}
					else
					{
						if( !class_type.lock_imut().deref().typeinfo_src_type_.empty() && field_name == "type_id" )
						{
							// HACK!
							// LLVM performs constants folding since poiters are not typed. So, we can't obtain full path to GlobalVariable initializer.
							// This is used for type_id in typeinfo classes.
							result.constexpr_value= LLVMGetAggregateElement( LLVMGetAggregateElement( LLVMGetInitializer( result.llvm_value ), 0u ), 0u );
						}
						else
						{
							result.constexpr_value= LLVMGetInitializer( result.llvm_value );
						}
					}
				}
			}
			else
			{
				return variable_ptr; // Actual error will be reported in another place.
			}
		}
		else
		{
			var LLVMValueRef gep_result= CreateClassFieldGEP( function_context, variable, field );
			result.llvm_value= CreateTypedReferenceLoad( function_context, field.t, gep_result );
			MarkLoadInstructionWithNonNullMetadata( result.llvm_value ); // Reference field is never null.
		}

		var VariablePtr mut result_ptr( move(result) );
		function_context.references_graph.AddNode( result_ptr );

		auto inner_nodes= function_context.references_graph.GetAccessibleVariableNodesInnerReferences( variable_ptr );
		foreach( &inner_node : inner_nodes )
		{
			function_context.references_graph.TryAddLink( inner_node, result_ptr, names_scope, src_loc );
		}

		// Register variable for references checking.
		RegisterTemporaryVariable( function_context, result_ptr );
		return move(result_ptr);
	}
	else
	{
		auto mut lock= variable_ptr.lock_mut();
		var Variable& mut v= lock.deref();

		var LLVMTypeRef class_llvm_type= v.t.GetLLVMType();
		v.children.resize( size_type( unsafe( LLVMCountStructElementTypes( class_llvm_type ) ) ) );
		{
			var VariableNullablePtr prev_node= v.children[ size_type(field.index) ];
			if( !prev_node.empty() )
			{
				var VariablePtr mut prev_node_non_null= prev_node.try_to_non_nullable();
				function_context.references_graph.AddNodeIfNotExists( prev_node_non_null );
				return move(prev_node_non_null);
			}
		}

		var Variable mut result
		{
			.t= field.t,
			.location= Variable::Location::Pointer,
			.value_type= select( variable.value_type == ValueType::ReferenceMut && field.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			.llvm_value= ForceCreateConstantIndexGEP( function_context, class_llvm_type, variable.llvm_value, field.index ),
			.name= v.name + "." + field_name,
			.parent= variable_ptr,
		};
		if( variable.constexpr_value != LLVMValueRef::Null )
		{
			result.constexpr_value= unsafe( LLVMGetAggregateElement( variable.constexpr_value, u32(field.index) ) );
		}

		var VariablePtr mut result_ptr( move(result) );
		function_context.references_graph.AddNode( result_ptr );

		v.children[ size_type(field.index) ]= result_ptr;

		return move(result_ptr);
	}
}

fn CodeBuilder::BuildBinaryOperator(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	VariableLite& l_var,
	VariableLite& r_var,
	BinaryOperatorType operator,
	SrcLoc& src_loc ) : Value
{
	auto l_in_register= CreateMoveToLLVMRegisterInstruction( l_var, function_context );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r_var, function_context );

	var Type& l_type= l_var.t;
	var Type& r_type= r_var.t;
	auto l_fundamental_type= l_type.GetFundamentalType();
	auto r_fundamental_type= r_type.GetFundamentalType();
	auto l_raw_pointer_type= l_type.GetRawPointerType();
	auto r_raw_pointer_type= r_type.GetRawPointerType();
	auto l_enum_type= l_type.GetEnumType();

	var bool mut is_float= false, mut is_integer= false, mut is_signed= false, mut is_void= false;
	if( !l_fundamental_type.empty() )
	{
		auto& t= l_fundamental_type.try_deref().fundamental_type;
		is_float= IsFloatingPoint(t);
		is_integer= IsInteger(t);
		is_signed= IsSignedInteger(t);
		is_void= t == U_FundamentalType::void_;
	}
	else if( !l_enum_type.empty() )
	{
		is_signed= IsSignedInteger( l_enum_type.try_deref().lock_imut().deref().underlaying_type.fundamental_type );
	}

	var Variable mut result
	{
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.name= BinaryOperatorToString( operator ),
	};

	if( operator == BinaryOperatorType::Add && ( !l_raw_pointer_type.empty() || !r_raw_pointer_type.empty() ) )
	{
		// Add pointer and integer.
		var u32 pointer_size= size_type_.GetFundamentalType().try_deref().GetSize();
		var u32 mut int_size(0);

		var LLVMValueRef mut ptr_value= LLVMValueRef::Null, mut index_value= LLVMValueRef::Null;
		var U_FundamentalType mut int_type= U_FundamentalType::InvalidType;

		if( r_raw_pointer_type.empty() )
		{
			if( r_fundamental_type.empty() )
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, r_type )
				return ErrorValue();
			}
			int_type= r_fundamental_type.try_deref().fundamental_type;
			int_size= r_fundamental_type.try_deref().GetSize();

			result.t= l_type;
			ptr_value= l_in_register;
			index_value= r_in_register;
		}
		else if( l_raw_pointer_type.empty() )
		{
			if( l_fundamental_type.empty() )
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
				return ErrorValue();
			}
			int_type= l_fundamental_type.try_deref().fundamental_type;
			int_size= l_fundamental_type.try_deref().GetSize();

			result.t= r_type;
			ptr_value= r_in_register;
			index_value= l_in_register;
		}
		else
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		var Type element_type= result.t.GetRawPointerType().try_deref().element_type;
		if( !EnsureTypeComplete( element_type ) )
		{
			// Complete types required for pointer arithmetic.
			REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, element_type )
			return ErrorValue();
		}
		if( !IsInteger( int_type ) || int_size > pointer_size )
		{
			// TODO - maybe generate another error?
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, GetFundamentalTypeName( int_type ) )
			return ErrorValue();
		}

		unsafe
		{
			if( int_size < pointer_size )
			{
				var LLVMTypeRef dst_type= size_type_.GetLLVMType();
				if( IsSignedInteger( int_type ) )
				{
					index_value= LLVMBuildSExt( function_context.llvm_ir_builder, index_value, dst_type, g_null_string );
				}
				else
				{
					index_value= LLVMBuildZExt( function_context.llvm_ir_builder, index_value, dst_type, g_null_string );
				}
			}

			if( !function_context.is_functionless_context )
			{
				result.llvm_value= LLVMBuildGEP2( function_context.llvm_ir_builder, element_type.GetLLVMType(), ptr_value, $<(index_value), 1u, "+\0"[0] );
			}
		}
	}
	else if( operator == BinaryOperatorType::Sub && !l_raw_pointer_type.empty() && !r_raw_pointer_type.empty() )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, src_loc, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}

		var Type& element_type= l_raw_pointer_type.try_deref().element_type;
		if( !EnsureTypeComplete( element_type ) )
		{
			// Complete types required for pointer arithmetic.
			REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, element_type )
			return ErrorValue();
		}

		var u32 pointer_size= size_type_.GetFundamentalType().try_deref().GetSize();
		var U_FundamentalType diff_type= select( pointer_size == 4u ? U_FundamentalType::i32_ : U_FundamentalType::i64_ );
		var LLVMTypeRef diff_llvm_type= GetFundamentalLLVMType( diff_type );

		result.t= FundamentalType( diff_type, diff_llvm_type );

		unsafe
		{
			var u64 element_size= LLVMABISizeOfType( data_layout_, l_raw_pointer_type.try_deref().element_type.GetLLVMType() );

			if( element_size == 0u64 )
			{
				REPORT_ERROR( DifferenceBetweenRawPointersWithZeroElementSize, names_scope, src_loc, l_type )
				return ErrorValue();
			}

			if( !function_context.is_functionless_context )
			{
				var LLVMValueRef
					l_as_int= LLVMBuildPtrToInt( function_context.llvm_ir_builder, l_in_register, diff_llvm_type, g_null_string ),
					r_as_int= LLVMBuildPtrToInt( function_context.llvm_ir_builder, r_in_register, diff_llvm_type, g_null_string ),
					diff= LLVMBuildSub( function_context.llvm_ir_builder, l_as_int, r_as_int, "-\0"[0] ),
					element_size_contant= LLVMConstInt( diff_llvm_type, element_size, LLVMBool::False ),
					diff_divided= LLVMBuildExactSDiv( function_context.llvm_ir_builder, diff, element_size_contant, "/\0"[0] );
				result.llvm_value= diff_divided;
			}
		}
	}
	else if( operator == BinaryOperatorType::Sub && !l_raw_pointer_type.empty() )
	{
		// Subtract integer from pointer.

		if( r_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, r_type )
			return ErrorValue();
		}

		var U_FundamentalType int_type= r_fundamental_type.try_deref().fundamental_type;

		var u32
			int_size= r_fundamental_type.try_deref().GetSize(),
			pointer_size= size_type_.GetFundamentalType().try_deref().GetSize();

		if( !IsInteger( int_type ) || int_size > pointer_size )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, r_type )
			return ErrorValue();
		}

		var Type& element_type= l_raw_pointer_type.try_deref().element_type;
		if( !EnsureTypeComplete( element_type ) )
		{
			// Complete types required for pointer arithmetic.
			REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, element_type )
			return ErrorValue();
		}

		result.t= l_type;

		unsafe
		{
			var LLVMValueRef mut sub_value= r_in_register;
			if( int_size < pointer_size )
			{
				var LLVMTypeRef dst_type= size_type_.GetLLVMType();
				if( IsSignedInteger( int_type ) )
				{
					sub_value= LLVMBuildSExt( function_context.llvm_ir_builder, sub_value, dst_type, g_null_string );
				}
				else
				{
					sub_value= LLVMBuildZExt( function_context.llvm_ir_builder, sub_value, dst_type, g_null_string );
				}
			}
			auto mut index_negative= LLVMBuildNeg( function_context.llvm_ir_builder, sub_value, g_null_string );

			if( !function_context.is_functionless_context )
			{
				result.llvm_value= LLVMBuildGEP2( function_context.llvm_ir_builder, element_type.GetLLVMType(), l_in_register, $<(index_negative), 1u, "-\0"[0] );
			}
		}
	}
	else if(
		operator == BinaryOperatorType::Add ||
		operator == BinaryOperatorType::Sub ||
		operator == BinaryOperatorType::Mul ||
		operator == BinaryOperatorType::Div ||
		operator == BinaryOperatorType::Rem )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, src_loc, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}
		if( l_fundamental_type.try_deref().GetSize() < 4u )
		{
			// Operation supported only for 32 and 64bit operands
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		if( !( is_integer || is_float ) )
		{
			// this operations allowed only for integer and floating point operands.
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		result.t= l_type;

		if( l_in_register != LLVMValueRef::Null && r_in_register != LLVMValueRef::Null )
		{
			unsafe
			{
					 if( operator == BinaryOperatorType::Add )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::Sub )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::Mul )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::Div )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
					}
					else if( is_signed )
					{
						result.llvm_value= LLVMBuildSDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildUDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::Rem )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFRem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
					}
					else if( is_signed )
					{
						result.llvm_value= LLVMBuildSRem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildURem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
					}
				}

				if( LLVMIsConstant( result.llvm_value ) == LLVMBool::True )
				{
					result.constexpr_value= result.llvm_value;

					if( LLVMIsUndef( result.constexpr_value ) == LLVMBool::True )
					{
						result.constexpr_value= LLVMValueRef::Null;
						REPORT_ERROR( ConstantExpressionResultIsUndefined, names_scope, src_loc )
					}
				}
			}
		}
	}
	else if(
		operator == BinaryOperatorType::And ||
		operator == BinaryOperatorType::Or  ||
		operator == BinaryOperatorType::Xor )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, src_loc, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}
		if( !( IsInteger( l_fundamental_type.try_deref().fundamental_type ) || l_fundamental_type.try_deref().fundamental_type == U_FundamentalType::bool_ ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		result.t= l_type;

		if( l_in_register != LLVMValueRef::Null && r_in_register != LLVMValueRef::Null )
		{
			unsafe
			{
					 if( operator == BinaryOperatorType::And )
				{
					result.llvm_value= LLVMBuildAnd( function_context.llvm_ir_builder, l_in_register, r_in_register, "&\0"[0] );
				}
				else if( operator == BinaryOperatorType::Or  )
				{
					result.llvm_value= LLVMBuildOr ( function_context.llvm_ir_builder, l_in_register, r_in_register, "|\0"[0] );
				}
				else if( operator == BinaryOperatorType::Xor )
				{
					result.llvm_value= LLVMBuildXor( function_context.llvm_ir_builder, l_in_register, r_in_register, "^\0"[0] );
				}
			}
		}
	}
	else if( operator == BinaryOperatorType::ShiftLeft || operator == BinaryOperatorType::ShiftRight )
	{
		if( l_fundamental_type.empty() || !is_integer )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}
		if( r_fundamental_type.empty() || !IsUnsignedInteger( r_fundamental_type.try_deref().fundamental_type ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope,src_loc, r_type )
			return ErrorValue();
		}

		auto mut l_value_for_op= l_in_register;
		auto mut r_value_for_op= r_in_register;

		result.t= l_type;

		if( l_in_register != LLVMValueRef::Null && r_in_register != LLVMValueRef::Null )
		{
			unsafe
			{
				// Convert value of shift to type of shifted value. LLVM Reuqired this.
				if( r_fundamental_type.try_deref().GetSize() > l_fundamental_type.try_deref().GetSize() )
				{
					r_value_for_op= LLVMBuildTrunc( function_context.llvm_ir_builder, r_value_for_op, l_type.GetLLVMType(), g_null_string );
				}
				else if( r_fundamental_type.try_deref().GetSize() < l_fundamental_type.try_deref().GetSize() )
				{
					r_value_for_op= LLVMBuildZExt( function_context.llvm_ir_builder, r_value_for_op, l_type.GetLLVMType(), g_null_string );
				}

				// Cut upper bits of shift value to avoid undefined behaviour.
				r_value_for_op =
					LLVMBuildAnd(
						function_context.llvm_ir_builder,
						r_value_for_op,
						LLVMConstInt(
							l_type.GetLLVMType(),
							u64(l_fundamental_type.try_deref().GetSize()) * 8u64 - 1u64,
							LLVMBool::False ),
						g_null_string );

				if( operator == BinaryOperatorType::ShiftLeft )
				{
					result.llvm_value= LLVMBuildShl( function_context.llvm_ir_builder, l_value_for_op, r_value_for_op, g_null_string );
				}
				else if( operator == BinaryOperatorType::ShiftRight )
				{
					if( IsSignedInteger( l_fundamental_type.try_deref().fundamental_type ) )
					{
						result.llvm_value= LLVMBuildAShr( function_context.llvm_ir_builder, l_value_for_op, r_value_for_op, g_null_string );
					}
					else
					{
						result.llvm_value= LLVMBuildLShr( function_context.llvm_ir_builder, l_value_for_op, r_value_for_op, g_null_string );
					}
				}
				else{ halt; }
			}
		}
	}
	else if( operator == BinaryOperatorType::Equal || operator == BinaryOperatorType::NotEqual )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, src_loc, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() && l_enum_type.empty() && l_raw_pointer_type.empty() && l_type.GetFunctionPointerType().empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		result.t= bool_type_;

		if( l_in_register != LLVMValueRef::Null && r_in_register != LLVMValueRef::Null )
		{
			// Use ordered floating point compare operations, which result is false for NaN, except !=. nan != nan must be true.
			unsafe
			{
				// LLVM constants folder produces wrong compare result for function pointers to "unnamed_addr" functions.
				// Perform manual constant functions compare instead.
				auto l_function= LLVMIsAFunction( l_in_register );
				auto r_function= LLVMIsAFunction( r_in_register );

					 if( operator == BinaryOperatorType::Equal )
				{
					if( is_void )
					{
						result.llvm_value= LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False ); // Two "void" values are always equal.
					}
					else if( is_float )
					{
						result.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OEQ, l_in_register, r_in_register, "==\0"[0] );
					}
					else if( l_function != LLVMValueRef::Null && r_function != LLVMValueRef::Null )
					{
						result.llvm_value= LLVMConstInt( fundamental_llvm_types_.bool_, select( l_function == r_function ? 1u64 : 0u64 ), LLVMBool::False );
					}
					else
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::EQ, l_in_register, r_in_register, "==\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::NotEqual )
				{
					if( is_void )
					{
						result.llvm_value= LLVMConstInt( fundamental_llvm_types_.bool_, 0u64, LLVMBool::False );
					}
					else if( is_float )
					{
						result.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::UNE, l_in_register, r_in_register, "!=\0"[0] );
					}
					else if( l_function != LLVMValueRef::Null && r_function != LLVMValueRef::Null )
					{
						result.llvm_value= LLVMConstInt( fundamental_llvm_types_.bool_, select( l_function != r_function ? 1u64 : 0u64 ), LLVMBool::False );
					}
					else
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::NE, l_in_register, r_in_register, "!=\0"[0] );
					}
				}
			}
		}
	}
	else if(
		operator == BinaryOperatorType::Less ||
		operator == BinaryOperatorType::LessEqual ||
		operator == BinaryOperatorType::Greater ||
		operator == BinaryOperatorType::GreaterEqual )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, src_loc, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() && l_raw_pointer_type.empty() && l_enum_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		if( !l_fundamental_type.empty() && !( is_integer || is_float || IsChar( l_fundamental_type.try_deref().fundamental_type ) ) )
		{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
				return ErrorValue();
		}

		result.t= bool_type_;

		if( l_in_register != LLVMValueRef::Null && r_in_register != LLVMValueRef::Null )
		{
			unsafe
			{
					 if( operator == BinaryOperatorType::Less )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLT, l_in_register, r_in_register, "<\0"[0] );
					}
					else if( is_signed )
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLT, l_in_register, r_in_register, "<\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULT, l_in_register, r_in_register, "<\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::LessEqual )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLE, l_in_register, r_in_register, "<=\0"[0] );
					}
					else if( is_signed )
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLE, l_in_register, r_in_register, "<=\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULE, l_in_register, r_in_register, "<=\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::Greater )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGT, l_in_register, r_in_register, ">\0"[0] );
					}
					else if( is_signed )
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGT, l_in_register, r_in_register, ">\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGT, l_in_register, r_in_register, ">\0"[0] );
					}
				}
				else if( operator == BinaryOperatorType::GreaterEqual )
				{
					if( is_float )
					{
						result.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGE, l_in_register, r_in_register, ">=\0"[0] );
					}
					else if( is_signed )
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGE, l_in_register, r_in_register, ">=\0"[0] );
					}
					else
					{
						result.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGE, l_in_register, r_in_register, ">=\0"[0] );
					}
				}
			}
		}
	}
	else if( operator == BinaryOperatorType::CompareOrder )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, src_loc, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() && l_raw_pointer_type.empty() && l_enum_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
			return ErrorValue();
		}

		if( !l_fundamental_type.empty() && !( is_integer || is_float || IsChar( l_fundamental_type.try_deref().fundamental_type ) ) )
		{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_type )
				return ErrorValue();
		}

		auto result_fundamental_type= U_FundamentalType::i32_;
		var LLVMTypeRef result_llvm_type= GetFundamentalLLVMType( result_fundamental_type );
		if( l_in_register != LLVMValueRef::Null && r_in_register != LLVMValueRef::Null )
		{
			unsafe
			{
				var LLVMValueRef mut less= zero_init, mut greater= zero_init;
				if( is_float )
				{
					less= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLT, l_in_register, r_in_register, "<\0"[0] );
					greater= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGT, l_in_register, r_in_register, ">\0"[0] );
				}
				else if( is_signed )
				{
					less= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLT, l_in_register, r_in_register, "<\0"[0] );
					greater= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGT, l_in_register, r_in_register, ">\0"[0] );
				}
				else
				{
					less= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULT, l_in_register, r_in_register, "<\0"[0] );
					greater= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGT, l_in_register, r_in_register, ">\0"[0] );
				}

				var LLVMValueRef zero= LLVMConstInt( result_llvm_type, 0u64, LLVMBool::True );
				var LLVMValueRef plus_one= LLVMConstInt( result_llvm_type, 1u64, LLVMBool::True );
				var LLVMValueRef minus_one= LLVMConstInt( result_llvm_type, ~0u64, LLVMBool::True );

				result.llvm_value=
					LLVMBuildSelect(
						function_context.llvm_ir_builder,
						less,
						minus_one,
						LLVMBuildSelect( function_context.llvm_ir_builder, greater, plus_one, zero, g_null_string ),
						g_null_string );
			}
		}
		result.t= FundamentalType( result_fundamental_type, result_llvm_type );
	}
	else{ halt; }

	if( l_var.constexpr_value != LLVMValueRef::Null &&
		r_var.constexpr_value != LLVMValueRef::Null &&
		unsafe( LLVMIsConstant( result.llvm_value ) ) == LLVMBool::True )
	{
		result.constexpr_value= result.llvm_value;
	}

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildLazyBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	var VariableLite l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.deref() ).lock_imut().deref();
	if( l_var.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch, names_scope, binary_operator.src_loc, bool_type_, l_var.t )
		return ErrorValue();
	}

	auto l_var_in_register= CreateMoveToLLVMRegisterInstruction( l_var, function_context );
	DestroyUnusedTemporaryVariables( names_scope, function_context, binary_operator.src_loc ); // Destroy right part temporaries.

	var [ ReferencesGraph, 2 ] mut branches_references_graphs;
	branches_references_graphs[0]= function_context.references_graph;

	var LLVMBasicBlockRef mut l_part_block= zero_init, mut r_part_block= zero_init, mut block_after_operator= zero_init;
	if( !function_context.is_functionless_context )
	{
		unsafe
		{
			l_part_block= LLVMGetInsertBlock( function_context.llvm_ir_builder );
			r_part_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
			block_after_operator= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

			if( binary_operator.operator == BinaryOperatorType::LazyLogicalAnd )
			{
				LLVMBuildCondBr( function_context.llvm_ir_builder, l_var_in_register, r_part_block, block_after_operator );
			}
			else if( binary_operator.operator == BinaryOperatorType::LazyLogicalOr )
			{
				LLVMBuildCondBr( function_context.llvm_ir_builder, l_var_in_register, block_after_operator, r_part_block );
			}
			else { halt; }

			LLVMAppendExistingBasicBlock( function_context.llvm_function, r_part_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, r_part_block );
		}
	}

	auto mut r_var_in_register= LLVMValueRef::Null;
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		with( &r_var: BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.deref() ).lock_imut().deref() )
		{
			if( r_var.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch, names_scope, binary_operator.src_loc, bool_type_, r_var.t )
				return ErrorValue();
			}

			r_var_in_register= CreateMoveToLLVMRegisterInstruction( r_var, function_context );
		}
		CallDestructorsForTopVariablesFrame( names_scope, function_context, binary_operator.src_loc );
	}

	branches_references_graphs[1]= function_context.references_graph;
	function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( branches_references_graphs, names_scope, binary_operator.src_loc );

	auto mut phi_node= LLVMValueRef::Null;
	if( !function_context.is_functionless_context )
	{
		unsafe
		{
			auto r_part_end_block= LLVMGetInsertBlock( function_context.llvm_ir_builder );
			LLVMBuildBr( function_context.llvm_ir_builder, block_after_operator );
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_operator );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_operator );

			phi_node= LLVMBuildPhi( function_context.llvm_ir_builder, fundamental_llvm_types_.bool_, g_null_string );

			var [ LLVMValueRef, 2 ] mut incoming_values[ l_var_in_register, r_var_in_register ];
			var [ LLVMBasicBlockRef, 2 ] mut incoming_blocks[ l_part_block, r_part_end_block ];
			LLVMAddIncoming( phi_node, $<(incoming_values[0]), $<(incoming_blocks[0]), 2u );
		}
	}

	var Variable mut result
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.llvm_value= phi_node,
		.name= BinaryOperatorToString( binary_operator.operator ),
	};

	unsafe
	{
		if( l_var_in_register != LLVMValueRef::Null && LLVMIsConstant( l_var_in_register ) == LLVMBool::True &&
			r_var_in_register != LLVMValueRef::Null && LLVMIsConstant( r_var_in_register ) == LLVMBool::True )
		{
			if( binary_operator.operator == BinaryOperatorType::LazyLogicalAnd )
			{
				result.constexpr_value= LLVMBuildAnd( function_context.llvm_ir_builder, l_var_in_register, r_var_in_register, g_null_string );
			}
			else if( binary_operator.operator == BinaryOperatorType::LazyLogicalOr )
			{
				result.constexpr_value= LLVMBuildOr ( function_context.llvm_ir_builder, l_var_in_register, r_var_in_register, g_null_string );
			}
			else{ halt; }
		}
	}

	// Register variable for references checking.
	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::TryCallOverloadedBinaryOperator(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	OverloadedOperator operator,
	ust::shared_ptr_final</Synt::Expression/>& arg_l,
	ust::shared_ptr_final</Synt::Expression/>& arg_r,
	ArgsEvaluationOrder args_evaluation_order,
	SrcLoc& src_loc ) : ust::optional</Value/>
{
	auto in_args= ust::make_array( arg_l, arg_r );

	var ust::vector</VariableTypeExtended/> mut args;

	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var bool prev_is_functionless_context= function_context.is_functionless_context;
		function_context.is_functionless_context= true;

		auto state= SaveFunctionContextState( function_context );

		foreach( &in_arg : in_args )
		{
			if( function_context.args_preevaluation_cache.find( in_arg ).empty() )
			{
				with( &arg: BuildExpressionCodeEnsureVariable( names_scope, function_context, in_arg.deref() ).lock_imut().deref() )
				{
					var VariableTypeExtended mut f_arg{ .t(arg.t), .value_type= arg.value_type };
					function_context.args_preevaluation_cache.insert( in_arg, move(f_arg) );
				}
				DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc );
			}
			args.push_back( function_context.args_preevaluation_cache[in_arg] );
		}

		RestoreFunctionContextState( function_context, state );
		function_context.is_functionless_context= prev_is_functionless_context;
	}

	auto& args_ref= args;

	if( operator == OverloadedOperator::Assign &&
		args_ref.front().t == args_ref.back().t &&
		( !args_ref.front().t.GetClassType().empty() || !args_ref.front().t.GetArrayType().empty() || !args_ref.front().t.GetTupleType().empty() ) &&
		args_ref.front().value_type == ValueType::ReferenceMut &&
		args_ref.back().value_type == ValueType::Value )
	{
		// Do move assign.
		// TODO - what exact evaluation order should be here?

		if_var( class_type : args_ref.front().t.GetClassType() )
		{
			// Forbid move-assignment for destination of non-final polymorph class.
			// This is needed to prevent changing class fields (including virtual table pointer) relevant to derived class with class fields relevant to base class.
			// For example
			// cast_ref</Base/>(derived)= Base();
			auto kind= class_type.lock_imut().deref().kind;
			if( kind == ClassType::Kind::Interface || kind == ClassType::Kind::Abstract || kind == ClassType::Kind::PolymorphNonFinal )
			{
				REPORT_ERROR( MoveAssignForNonFinalPolymorphClass, names_scope, src_loc, args_ref.front().t )
			}
		}

		var VariablePtr r_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_r.deref() );
		var VariableLite r_var= r_var_ptr.lock_imut().deref();

		// Prevent modification of r_var during l_val calculation.
		var Variable mut r_var_lock_node_variable
		{
			.value_type= ValueType::ReferenceImut,
			.location= Variable::Location::Pointer,
			.name= r_var_ptr.lock_imut().deref().name + " lock",
		};
		var VariablePtr r_var_lock_node( move(r_var_lock_node_variable ) );
		function_context.references_graph.AddNode( r_var_lock_node );
		function_context.references_graph.TryAddLink( r_var_ptr, r_var_lock_node, names_scope, src_loc );

		var VariablePtr l_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.deref() );
		var VariableLite l_var= l_var_ptr.lock_imut().deref();

		function_context.references_graph.RemoveNode( r_var_lock_node );

		BuildDestructorPart( names_scope, function_context, l_var.llvm_value, l_var.t, src_loc );

		SetupReferencesInCopyOrMove( names_scope, function_context, l_var_ptr, r_var_ptr, src_loc );

		function_context.references_graph.MoveNode( r_var_ptr );

		CopyBytes( l_var.llvm_value, r_var.llvm_value, r_var.t, function_context );
		CreateLifetimeEnd( function_context, r_var.llvm_value );

		var Variable mut move_result{ .t= void_type_, .value_type= ValueType::Value, .location= Variable::Location::LLVMRegister };
		return Value( VariablePtr( move(move_result) ) );
	}
	else if( args_ref.front().t == args_ref.back().t && ( !args_ref.front().t.GetArrayType().empty() || !args_ref.front().t.GetTupleType().empty() ) )
	{
		return CallBinaryOperatorForArrayOrTuple( names_scope, function_context, operator, arg_l, arg_r, src_loc );
	}

	if_var( &overloaded_operator : GetOverloadedOperator( args_ref.range(), operator, names_scope, src_loc ) )
	{
		if( overloaded_operator.is_deleted )
		{
			REPORT_ERROR( AccessingDeletedMethod, names_scope, src_loc )
			return ust::null_optional;
		}

		if( !( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
		{
			function_context.have_non_constexpr_operations_inside= true;
		}

		var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( overloaded_operator );

		return DoCallFunction(
			names_scope,
			function_context,
			overloaded_operator.t,
			llvm_function,
			overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete,
			ust::empty_range,
			in_args,
			args_evaluation_order,
			src_loc );
	}

	return ust::null_optional;
}

fn CodeBuilder::CallBinaryOperatorForArrayOrTuple(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	OverloadedOperator operator,
	ust::shared_ptr_final</Synt::Expression/>& arg_l,
	ust::shared_ptr_final</Synt::Expression/>& arg_r,
	SrcLoc& src_loc ) : Value
{
	if( operator == OverloadedOperator::Assign )
	{
		var VariablePtr r_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_r.deref() );
		var VariableLite r_var= r_var_ptr.lock_imut().deref();

		// Prevent modification of r_var during l_val calculation.
		var Variable mut r_var_lock_node_variable
		{
			.value_type= ValueType::ReferenceImut,
			.location= Variable::Location::Pointer,
			.name= r_var_ptr.lock_imut().deref().name + " lock",
		};
		var VariablePtr r_var_lock_node( move(r_var_lock_node_variable ) );
		function_context.references_graph.AddNode( r_var_lock_node );
		function_context.references_graph.TryAddLink( r_var_ptr, r_var_lock_node, names_scope, src_loc );

		var VariablePtr l_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.deref() );
		var VariableLite l_var= l_var_ptr.lock_imut().deref();
		halt if( r_var.t != l_var.t ); // Checked before

		function_context.references_graph.RemoveNode( r_var_lock_node );

		if( !l_var.t.IsCopyAssignable() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_var.t )
			return ErrorValue();
		}
		if( l_var.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, src_loc )
			return ErrorValue();
		}
		function_context.references_graph.EnsureHaveNoOutgoingLinks( l_var_ptr, names_scope, src_loc );

		SetupReferencesInCopyOrMove( names_scope, function_context, l_var_ptr, r_var_ptr, src_loc );

		BuildCopyAssignmentOperatorPart( names_scope, function_context, l_var.llvm_value, r_var.llvm_value, l_var.t, src_loc );

		DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc );

		var Variable mut result{ .t= void_type_, .value_type= ValueType::Value, .location= Variable::Location::LLVMRegister };
		return VariablePtr( move(result) );
	}
	else if( operator == OverloadedOperator::CompareEqual )
	{
		var VariablePtr l_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.deref() );
		var VariableLite l_var= l_var_ptr.lock_imut().deref();

		var Variable mut l_var_lock_node_variable
		{
			.value_type= ValueType::ReferenceImut,
			.location= Variable::Location::Pointer,
			.name= l_var_ptr.lock_imut().deref().name + " lock",
		};
		var VariablePtr l_var_lock_node( move(l_var_lock_node_variable ) );
		function_context.references_graph.AddNode( l_var_lock_node );
		function_context.references_graph.TryAddLink( l_var_ptr, l_var_lock_node, names_scope, src_loc );

		var VariablePtr r_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_r.deref() );
		var VariableLite r_var= r_var_ptr.lock_imut().deref();
		halt if( l_var.t != r_var.t ); // Checked before

		function_context.references_graph.RemoveNode( l_var_lock_node );

		function_context.references_graph.EnsureHaveNoOutgoingMutableNodes( r_var_ptr, names_scope, src_loc );

		if( !l_var.t.IsEqualityComparable() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_var.t )
			return ErrorValue();
		}

		var Variable mut result
		{
			.t= bool_type_,
			.value_type= ValueType::Value,
			.location= Variable::Location::LLVMRegister,
			.name= "==",
		};

		unsafe
		{
			if( l_var.constexpr_value != LLVMValueRef::Null && r_var.constexpr_value != LLVMValueRef::Null )
			{
				result.constexpr_value= ConstexprCompareEqual( names_scope, function_context, l_var.constexpr_value, r_var.constexpr_value, l_var.t, src_loc );
				result.llvm_value= result.constexpr_value;
			}
			else
			{
				var LLVMBasicBlockRef false_basic_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
				var LLVMBasicBlockRef end_basic_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

				BuildEqualityCompareOperatorPart(
					names_scope,
					function_context,
					l_var.llvm_value,
					r_var.llvm_value,
					l_var.t,
					false_basic_block,
					src_loc );

				if( U1_BasicBlockHasPredecessors( false_basic_block ) )
				{
					// True branch.
					var LLVMBasicBlockRef true_basic_block= LLVMGetInsertBlock( function_context.llvm_ir_builder );
					LLVMBuildBr( function_context.llvm_ir_builder, end_basic_block );

					// False branch.
					LLVMAppendExistingBasicBlock( function_context.llvm_function, false_basic_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, false_basic_block );
					LLVMBuildBr( function_context.llvm_ir_builder, end_basic_block );

					// End basic block.
					LLVMAppendExistingBasicBlock( function_context.llvm_function, end_basic_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, end_basic_block );

					var LLVMValueRef phi= LLVMBuildPhi( function_context.llvm_ir_builder, fundamental_llvm_types_.bool_, g_null_string );

					var LLVMValueRef false_value= LLVMConstInt( fundamental_llvm_types_.bool_, 0u64, LLVMBool::False );
					var LLVMValueRef true_value = LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False );

					var [ LLVMValueRef, 2 ] mut values[ false_value, true_value ];
					var [ LLVMBasicBlockRef, 2 ] mut blocks[ false_basic_block, true_basic_block ];
					LLVMAddIncoming( phi, $<(values[0]), $<(blocks[0]), 2u );

					result.llvm_value= phi;
				}
				else
				{
					// Empty tuple or array.

					LLVMAppendExistingBasicBlock( function_context.llvm_function, false_basic_block );
					LLVMDeleteBasicBlock( false_basic_block );

					LLVMAppendExistingBasicBlock( function_context.llvm_function, end_basic_block );
					LLVMDeleteBasicBlock( end_basic_block );

					result.llvm_value= LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False );
				}
			}
		}

		var VariablePtr mut result_ptr( move(result) );
		function_context.references_graph.AddNode( result_ptr );
		RegisterTemporaryVariable( function_context, result_ptr );
		return move(result_ptr);
	}
	else
	{
		var VariablePtr l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.deref() );
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, l_var.lock_imut().deref().t )
		return ErrorValue();
	}
}

fn CodeBuilder::TryCallOverloadedUnaryOperator(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	OverloadedOperator operator,
	VariablePtr& variable_ptr,
	SrcLoc& src_loc ) : ust::optional</Value/>
{
	var VariableLite variable= variable_ptr.lock_imut().deref();
	if( variable.t.GetClassType().empty() )
	{
		return ust::null_optional;
	}

	var [ VariableTypeExtended, 1 ] args[ { .t(variable.t), .value_type= variable.value_type } ];

	if_var( &overloaded_operator : GetOverloadedOperator( args, operator, names_scope, src_loc ) )
	{
		auto fetch_result= TryFetchVirtualFunction( variable_ptr, overloaded_operator, names_scope, function_context, src_loc );

		if( !( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
		{
			function_context.have_non_constexpr_operations_inside= true;
		}

		return DoCallFunction(
			names_scope,
			function_context,
			fetch_result[0],
			overloaded_operator.t,
			fetch_result[1],
			overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete,
			ust::empty_range,
			src_loc );
	}

	return ust::null_optional;
}

fn CodeBuilder::TryCallOverloadedPostfixOperator(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	OverloadedOperator operator,
	VariablePtr& variable_ptr,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& synt_args,
	SrcLoc& src_loc ) : ust::optional</Value/>
{
	var VariableLite variable= variable_ptr.lock_imut().deref();

	var ust::vector</ VariableTypeExtended /> mut args;

	var VariableTypeExtended mut this_type{ .t(variable.t), .value_type= variable.value_type };
	args.push_back( move(this_type) );

	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var bool prev_is_functionless_context= function_context.is_functionless_context;
		function_context.is_functionless_context= true;

		auto state= SaveFunctionContextState( function_context );

		foreach( &in_arg : synt_args )
		{
			with( &arg: BuildExpressionCodeEnsureVariable( names_scope, function_context, in_arg.deref() ).lock_imut().deref() )
			{
				var VariableTypeExtended mut type_extended{ .t(arg.t), .value_type= arg.value_type };
				args.push_back( move(type_extended) );
			}
			DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc );
		}

		RestoreFunctionContextState( function_context, state );
		function_context.is_functionless_context= prev_is_functionless_context;
	}

	if_var( &overloaded_operator : GetOverloadedOperator( args.range(), operator, names_scope, src_loc ) )
	{
		auto fetch_result= TryFetchVirtualFunction( variable_ptr, overloaded_operator, names_scope, function_context, src_loc );

		if( !( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
		{
			function_context.have_non_constexpr_operations_inside= true;
		}

		return DoCallFunction(
			names_scope,
			function_context,
			fetch_result[0],
			overloaded_operator.t,
			fetch_result[1],
			overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete,
			synt_args,
			src_loc );
	}

	return ust::null_optional;
}

fn CodeBuilder::CallFunctionsSet(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	VariableNullablePtr mut this_,
	FunctionsSet& functions_set,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
	SrcLoc& src_loc ) : Value
{
	// Pre-evaluate arguments to know exact types and select exact function.
	var ust::vector</VariableTypeExtended/> mut args_evaluated;
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var bool prev_is_functionless_context= function_context.is_functionless_context;
		function_context.is_functionless_context= true;

		auto state= SaveFunctionContextState( function_context );

		if( !this_.empty() )
		{
			with( &thi : this_.try_lock_imut().deref() )
			{
				var VariableTypeExtended mut out_arg{ .t( thi.t ), .value_type= thi.value_type };
				args_evaluated.push_back( move(out_arg) );
			}
		}

		foreach( &arg : args )
		{
			if( function_context.args_preevaluation_cache.find( arg ).empty() )
			{
				with( &arg_variable: BuildExpressionCodeEnsureVariable( names_scope, function_context, arg.deref() ).lock_imut().deref() )
				{
					var VariableTypeExtended mut out_arg{ .t( arg_variable.t ), .value_type= arg_variable.value_type };
					function_context.args_preevaluation_cache.insert( arg, move(out_arg) );
				}
				DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc );
			}
			args_evaluated.push_back( function_context.args_preevaluation_cache[arg] );
		}

		RestoreFunctionContextState( function_context, state );
		function_context.is_functionless_context= prev_is_functionless_context;
	}

	auto function_selected_opt=
		GetOverloadedFunction(
			functions_set,
			args_evaluated.range(),
			!this_.empty(),
			names_scope,
			src_loc );
	if( function_selected_opt.empty() )
	{
		return ErrorValue();
	}
	var FunctionVariable& function_selected= function_selected_opt.try_deref();

	if( function_selected.is_deleted )
	{
		REPORT_ERROR( AccessingDeletedMethod, names_scope, src_loc )
		return ErrorValue();
	}

	if( !this_.empty() && !function_selected.is_this_call )
	{
		this_.reset();
	}

	if( !( function_selected.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || function_selected.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
	{
		function_context.have_non_constexpr_operations_inside= true;
	}

	var bool is_constexpr= function_selected.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete;

	if( !this_.empty() )
	{
		auto fetch_res= TryFetchVirtualFunction( this_.try_to_non_nullable(), function_selected, names_scope, function_context, src_loc );
		return DoCallFunction(
			names_scope,
			function_context,
			fetch_res[0],
			function_selected.t,
			fetch_res[1],
			is_constexpr,
			args,
			src_loc );
	}

	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( function_selected );

	return DoCallFunction(
		names_scope,
		function_context,
		this_,
		function_selected.t,
		llvm_function,
		is_constexpr,
		args,
		src_loc );
}

fn CodeBuilder::DoCallFunction(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	VariableNullablePtr& this_,
	FunctionType& function_type,
	LLVMValueRef function,
	bool is_constexpr,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
	SrcLoc& src_loc ) : Value
{
	var ust::vector</ VariablePtr /> mut preevaluated_args;
	if( !this_.empty() )
	{
		preevaluated_args.push_back( this_.try_to_non_nullable() );
	}

	return DoCallFunction(
		names_scope,
		function_context,
		function_type,
		function,
		is_constexpr,
		preevaluated_args.range(),
		args,
		ArgsEvaluationOrder::Direct,
		src_loc );
}

fn CodeBuilder::DoCallFunction(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	FunctionType& function_type,
	LLVMValueRef function,
	bool mut is_constexpr,
	ust::array_view_imut</ VariablePtr />& preevaluated_args,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
	ArgsEvaluationOrder args_evaluation_order,
	SrcLoc& src_loc ) : Value
{
	var size_type total_args= preevaluated_args.size() + args.size();
	if( total_args != function_type.params.size() )
	{
		REPORT_ERROR( InvalidFunctionArgumentCount, names_scope, src_loc, total_args, function_type.params.size() )
		return ErrorValue();
	}

	// TODO - maybe forbid calling functions with incomplete type for returned reference?
	if( function_type.return_value_type == ValueType::Value && !EnsureTypeComplete( function_type.return_type ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, function_type.return_type )
		return ErrorValue();
	}
	if( function_type.is_unsafe && !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( UnsafeFunctionCallOutsideUnsafeBlock, names_scope, src_loc )
	}

	var ust::vector</LLVMValueRef/> mut llvm_args;

	auto mut s_ret_value= LLVMValueRef::Null;
	var bool return_value_is_composite= function_type.ReturnsCompositeValue();
	var bool return_value_is_sret= FunctionTypeIsSRet( function_type );
	if( return_value_is_composite )
	{
		if( !function_context.is_functionless_context )
		{
			s_ret_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, function_type.return_type.GetLLVMType(), g_null_string ) );
		}

		if( return_value_is_sret )
		{
			llvm_args.push_back( s_ret_value );
		}
	}

	auto first_llvm_arg_number= select( return_value_is_sret ? 1s : 0s );
	llvm_args.resize( first_llvm_arg_number + total_args, LLVMValueRef::Null );

	var ust::vector</ LLVMValueRef /> mut constexpr_args;
	if( is_constexpr && function_type.return_value_type == ValueType::Value )
	{
		constexpr_args.resize( llvm_args.size(), LLVMValueRef::Null );
	}
	else
	{
		is_constexpr= false; // Can't call constexpr function, returning reference.
	}

	// TODO - use vector of pairs instead of pair of vectors.
	var ust::vector</VariableNullablePtr/> mut args_nodes, mut reference_args_inner_nodes;
	args_nodes.resize( total_args );
	reference_args_inner_nodes.resize( total_args );

	var ust::vector</LLVMValueRef/> mut value_args_for_lifetime_end_call;

	for( var size_type mut i= 0s; i < total_args; ++i )
	{
		auto arg_n= select( args_evaluation_order == ArgsEvaluationOrder::Direct ? i : total_args - i - 1s );
		auto &mut llvm_arg= llvm_args[ first_llvm_arg_number + arg_n ];

		var ust::string8 arg_number_str= ust::to_string8(arg_n);

		auto& param= function_type.params[arg_n];
		var Type& expected_arg_type= param.t;
		var VariablePtr mut arg_ptr=
			select( arg_n < preevaluated_args.size()
				? preevaluated_args[arg_n]
				: BuildExpressionCodeEnsureVariable( names_scope, function_context, args[ arg_n - preevaluated_args.size() ].deref() ) );

		// Convert variable in function call.
		if( arg_ptr.lock_imut().deref().t != expected_arg_type )
		{
			if_var( &conversion_constructor_ : GetConversionConstructor( names_scope, expected_arg_type, arg_ptr.lock_imut().deref().t, src_loc ) )
			{
				arg_ptr= ConvertVariable( names_scope, function_context, arg_ptr, expected_arg_type, conversion_constructor_, src_loc );
			}
		}

		var VariableLite arg= arg_ptr.lock_imut().deref();

		if( arg.constexpr_value == LLVMValueRef::Null || param.value_type == ValueType::ReferenceMut )
		{
			is_constexpr= false;
		}

		if( param.value_type == ValueType::Value )
		{
			if( !arg.t.ReferenceIsConvertibleTo( expected_arg_type ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, src_loc, arg.t, expected_arg_type )
				return ErrorValue();
			}

			var Variable mut arg_node_variable
			{
				.value_type= ValueType::Value,
				.location= Variable::Location::Pointer,
				.name= "value arg " + arg_number_str,
			};
			var VariablePtr arg_node( move(arg_node_variable) );
			args_nodes[arg_n]= arg_node;
			function_context.references_graph.AddNode( arg_node );

			if( expected_arg_type.GetInnerReferenceKind() != InnerReferenceKind::None )
			{
				var ReferencesGraph::NodesSet inner_references= function_context.references_graph.GetAccessibleVariableNodesInnerReferences( arg_ptr );
				var bool mut is_mutable= false;
				foreach( &inner_reference : inner_references )
				{
					is_mutable |= inner_reference.lock_imut().deref().value_type == ValueType::ReferenceMut;
				}

				auto own_inner_reference= function_context.references_graph.CreateNodeInnerReference(
					arg_node,
					select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ) );

				foreach( &inner_reference : inner_references )
				{
					function_context.references_graph.TryAddLink( inner_reference, own_inner_reference, names_scope, src_loc );
				}
			}

			if( !arg.t.GetClassType().empty() || !arg.t.GetArrayType().empty() || !arg.t.GetTupleType().empty() )
			{
				var LLVMTypeRef single_scalar_type= GetSingleScalarType( arg.t.GetLLVMType() );
				if( is_constexpr && arg.constexpr_value != LLVMValueRef::Null )
				{
					if( single_scalar_type == LLVMTypeRef::Null )
					{
						constexpr_args[ first_llvm_arg_number + arg_n ]= arg.constexpr_value;
					}
					else
					{
						constexpr_args[ first_llvm_arg_number + arg_n ]= UnwrapRawScalarConstant( arg.constexpr_value );
					}
				}

				if( arg.value_type == ValueType::Value && arg.t == expected_arg_type )
				{
					// Move value to argument.
					function_context.references_graph.MoveNode( arg_ptr );

					if( single_scalar_type == LLVMTypeRef::Null )
					{
						llvm_arg= arg.llvm_value;
						if( !function_context.is_functionless_context )
						{
							value_args_for_lifetime_end_call.push_back( llvm_arg );
						}
					}
					else
					{
						if( !function_context.is_functionless_context )
						{
							llvm_arg= unsafe( LLVMBuildLoad2( function_context.llvm_ir_builder, single_scalar_type, arg.llvm_value, g_null_string ) );
							CreateLifetimeEnd( function_context, arg.llvm_value );
						}
					}

				}
				else
				{
					// Allow value params of abstract types (it is useful in templates) but disallow call of such functions.
					if( expected_arg_type.IsAbstract() )
					{
						REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, src_loc, expected_arg_type )
						return ErrorValue();
					}

					if( !function_context.is_functionless_context )
					{
						var LLVMTypeRef expected_arg_llvm_type= expected_arg_type.GetLLVMType();
						auto var_copy= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, expected_arg_llvm_type, g_null_string ) );
						CreateLifetimeStart( function_context, var_copy );

						auto mut value_for_copy= CreateReferenceCast( arg.llvm_value, arg.t, expected_arg_type, function_context );
						BuildCopyConstructorPart( names_scope, function_context, var_copy, value_for_copy, expected_arg_type, src_loc );

						if( single_scalar_type == LLVMTypeRef::Null )
						{
							llvm_arg= var_copy;
							value_args_for_lifetime_end_call.push_back( var_copy );
						}
						else
						{
							llvm_arg= unsafe( LLVMBuildLoad2( function_context.llvm_ir_builder, single_scalar_type, var_copy, g_null_string ) );
							CreateLifetimeEnd( function_context, var_copy );
						}
					}
				}
			}
			else
			{
				if( is_constexpr && arg.constexpr_value != LLVMValueRef::Null )
				{
					constexpr_args[ first_llvm_arg_number + arg_n ]= arg.constexpr_value;
				}

				llvm_arg= CreateMoveToLLVMRegisterInstruction( arg, function_context );
			}
		}
		else
		{
			if( param.value_type == ValueType::ReferenceMut )
			{
				if( arg.value_type == ValueType::Value )
				{
					REPORT_ERROR( ExpectedReferenceValue, names_scope, src_loc )
				}
				else if( arg.value_type != ValueType::ReferenceMut )
				{
					REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, src_loc )
				}
			}
			if( arg.t != expected_arg_type && !arg.t.ReferenceIsConvertibleTo( expected_arg_type ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, src_loc, arg.t, expected_arg_type )
				return ErrorValue();
			}

			if( is_constexpr && arg.constexpr_value != LLVMValueRef::Null && param.value_type != ValueType::ReferenceMut )
			{
				// TODO - what about types conversion in constexpr call?
				constexpr_args[ first_llvm_arg_number + arg_n ]= arg.constexpr_value;
			}

			if( arg.location == Variable::Location::LLVMRegister )
			{
				// Bind value to const reference.
				if( !function_context.is_functionless_context )
				{
					auto temp_storage= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, arg.t.GetLLVMType(), g_null_string ) );
					CreateTypedStore( function_context, arg.t, arg.llvm_value, temp_storage );
					llvm_arg= temp_storage;
					// Do not call here lifetime.start since there is no way to call lifetime.end for this value, because this allocation logically linked with some temp variable and can extend it's lifetime.
				}
			}
			else
			{
				llvm_arg= arg.llvm_value;
			}

			llvm_arg= CreateReferenceCast( llvm_arg, arg.t, expected_arg_type, function_context );

			var Variable mut arg_node_variable
			{
				.value_type= param.value_type,
				.location= Variable::Location::Pointer,
				.llvm_value= llvm_arg,
				.name= "reference arg " + arg_number_str ,
			};
			var VariablePtr arg_node( move(arg_node_variable) );
			args_nodes[arg_n]= arg_node;
			function_context.references_graph.AddNode( arg_node );
			function_context.references_graph.TryAddLink( arg_ptr, arg_node, names_scope, src_loc );

			if( expected_arg_type.GetInnerReferenceKind() != InnerReferenceKind::None )
			{
				var ReferencesGraph::NodesSet inner_references= function_context.references_graph.GetAccessibleVariableNodesInnerReferences( arg_ptr );
				var bool mut is_mutable= false;
				foreach( &inner_reference : inner_references )
				{
					is_mutable |= inner_reference.lock_imut().deref().value_type == ValueType::ReferenceMut;
				}

				var Variable mut own_reference_node_variable
				{
					.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
					.location= Variable::Location::Pointer,
					.name= "inner reference lock " + arg_number_str,
				};
				var VariablePtr own_reference_node( move(own_reference_node_variable) );
				reference_args_inner_nodes[arg_n]= own_reference_node;
				function_context.references_graph.AddNode( own_reference_node );

				foreach( &inner_reference : inner_references )
				{
					function_context.references_graph.TryAddLink( inner_reference, own_reference_node, names_scope, src_loc );
				}
			}
		}

		// Destroy unused temporary variables after each arg evaluation.
		DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc );
	}

	var Variable mut result
	{
		.t= function_type.return_type,
		.value_type= function_type.return_value_type,
		.location= Variable::Location::Pointer, // set later
		.name= "call result " + function_type.return_type.ToString(),
	};

	if( function_type.return_value_type == ValueType::Value )
	{
		if( return_value_is_composite )
		{
			result.location= Variable::Location::Pointer;
			result.llvm_value= s_ret_value;
			CreateLifetimeStart( function_context, s_ret_value ); // Create lifetime start after args evaluation but before call.
		}
		else
		{
			result.location= Variable::Location::LLVMRegister;
		}
	}
	else
	{
		result.location= Variable::Location::Pointer;
	}

	if( is_constexpr )
	{
		auto res= constexpr_function_evaluator_.Evaluate( function, constexpr_args.range() );

		if( res.errors.empty() )
		{
			if( function_type.return_value_type == ValueType::Value && function_type.return_type == void_type_ )
			{
				result.constexpr_value= unsafe( LLVMConstNull( fundamental_llvm_types_.void_ ) );
				result.llvm_value= result.constexpr_value;
			}
			else if( return_value_is_composite )
			{
				if( return_value_is_sret )
				{
					MoveConstantToMemory( s_ret_value, res.constant, function_context );
					result.constexpr_value= res.constant;
				}
				else
				{
					if( !function_context.is_functionless_context )
					{
						unsafe( LLVMBuildStore( function_context.llvm_ir_builder, res.constant, result.llvm_value ) );
					}
					result.constexpr_value= WrapRawScalarConstant( res.constant, function_type.return_type.GetLLVMType() );
				}
			}
			else
			{
				result.llvm_value= res.constant;
				result.constexpr_value= res.constant;
			}
		}
		else
		{
			with( mut lock : names_scope.lock_imut().deref().GetErrors().try_lock_mut() )
			{
				foreach( &err : res.errors )
				{
					var CodeBuilderError mut out_error
					{
						.code= CodeBuilderErrorCode::ConstexprFunctionEvaluationError,
						.src_loc= src_loc,
						.text= err,
					};
					lock.deref().push_back( move(out_error) );
				}
			}
		}
	}
	else if( !function_context.is_functionless_context )
	{
		// Perform regular call for non-constexpr function or in case of error in constexpr function evaluation.
		var LLVMTypeRef function_llvm_type=
			unsafe( select(
				LLVMIsAFunction( function ) == LLVMValueRef::Null
					? GetLLVMFunctionType( function_type )
					: U1_GetFunctionType( function ) ) );

		var LLVMValueRef call_result=
			unsafe( LLVMBuildCall2(
				function_context.llvm_ir_builder,
				function_llvm_type,
				function,
				llvm_args.data(), u32(llvm_args.size()),
				g_null_string ) );

		unsafe( LLVMSetInstructionCallConv( call_result, function_type.calling_convention ) );

		if( function_type.return_value_type == ValueType::Value && function_type.return_type == void_type_ )
		{
			result.llvm_value= unsafe( LLVMGetUndef( fundamental_llvm_types_.void_ ) );
		}
		else if( return_value_is_composite )
		{
			if( !return_value_is_sret )
			{
				unsafe( LLVMBuildStore( function_context.llvm_ir_builder, call_result, result.llvm_value ) );
			}
		}
		else
		{
			result.llvm_value= call_result;
		}
	}

	// Call "lifetime.end" just right after call for value args, allocated on stack of this function.
	// It is fine because there is no way to return reference to value arg (reference protection does not allow this).
	if( !function_context.is_functionless_context )
	{
		foreach( value_arg : value_args_for_lifetime_end_call )
		{
			CreateLifetimeEnd( function_context, value_arg );
		}
	}

	// Remove temp inner nodes.
	foreach( &node : reference_args_inner_nodes )
	{
		if( !node.empty() )
		{
			function_context.references_graph.RemoveNode( node.try_to_non_nullable() );
		}
	}

	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );

	// Prepare result references.
	if( function_type.return_value_type != ValueType::Value )
	{
		foreach( &param_reference : function_type.return_references )
		{
			var size_type i(param_reference.param_index);
			auto& arg_node= args_nodes[i];
			if( arg_node.empty() )
			{
				continue;
			}
			var VariablePtr arg_node_non_null= arg_node.try_to_non_nullable();

			if( param_reference.reference_index == FunctionType::c_param_reference_number )
			{
				function_context.references_graph.TryAddLink( arg_node_non_null, result_ptr, names_scope, src_loc );
			}
			if( param_reference.reference_index == 0u8 )
			{
				foreach( &inner_node : function_context.references_graph.GetAccessibleVariableNodesInnerReferences( arg_node_non_null ) )
				{
					function_context.references_graph.TryAddLink( inner_node, result_ptr, names_scope, src_loc );
				}
			}
		}
	}
	else if( function_type.return_type.GetInnerReferenceKind() != InnerReferenceKind::None )
	{
		// First, know, what kind of reference we needs - mutable or immutable.
		var bool mut inner_reference_is_mutable= false;
		foreach( &param_reference : function_type.return_references )
		{
			var size_type i(param_reference.param_index);
			auto& arg_node= args_nodes[i];
			if( arg_node.empty() )
			{
				continue;
			}
			var VariablePtr arg_node_non_null= arg_node.try_to_non_nullable();

			if( param_reference.reference_index == FunctionType::c_param_reference_number )
			{
				inner_reference_is_mutable |= arg_node_non_null.lock_imut().deref().value_type == ValueType::ReferenceMut;
			}
			if( param_reference.reference_index == 0u8 )
			{
				foreach( &inner_node : function_context.references_graph.GetAccessibleVariableNodesInnerReferences( arg_node_non_null ) )
				{
					inner_reference_is_mutable |= inner_node.lock_imut().deref().value_type == ValueType::ReferenceMut;
				}
			}
		}

		// Than, create inner node and link input nodes with it.
		var VariablePtr inner_node=
			function_context.references_graph.CreateNodeInnerReference(
				result_ptr,
				select( inner_reference_is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ) );

		foreach( &param_reference : function_type.return_references )
		{
			var size_type i(param_reference.param_index);
			auto& arg_node= args_nodes[i];
			if( arg_node.empty() )
			{
				continue;
			}
			var VariablePtr arg_node_non_null= arg_node.try_to_non_nullable();

			if( param_reference.reference_index == FunctionType::c_param_reference_number )
			{
				function_context.references_graph.TryAddLink( arg_node_non_null, inner_node, names_scope, src_loc );
			}
			if( param_reference.reference_index == 0u8 )
			{
				foreach( &dst_inner_node_id : function_context.references_graph.GetAccessibleVariableNodesInnerReferences( arg_node_non_null ) )
				{
					function_context.references_graph.TryAddLink( dst_inner_node_id, inner_node, names_scope, src_loc );
				}
			}
		}
	}

	// Setup references after call.
	foreach( &reference_pollution : function_type.references_pollution )
	{
		var size_type dst_arg(reference_pollution.dst.param_index);
		var size_type src_arg(reference_pollution.src.param_index);
		if( function_type.params[ dst_arg ].t.GetInnerReferenceKind() == InnerReferenceKind::None ||
			args_nodes[src_arg].empty() ||
			args_nodes[dst_arg].empty() ||
			function_type.params[ dst_arg ].value_type == ValueType::Value ) // Skip reference pollution for value params. TODO - is this correct?
		{
			continue;
		}

		var VariablePtr src_node= args_nodes[src_arg].try_to_non_nullable();
		var VariablePtr dst_node= args_nodes[dst_arg].try_to_non_nullable();

		var ReferencesGraph::NodesSet mut src_nodes;
		var bool mut src_variables_is_mut= false;
		if( reference_pollution.src.reference_index == FunctionType::c_param_reference_number )
		{
			// Reference-arg itself.
			src_nodes.insert( src_node );
			src_variables_is_mut= function_type.params[src_arg].value_type == ValueType::ReferenceMut;
		}
		else
		{
			// Variables, referenced by inner references_graph references.
			src_nodes= function_context.references_graph.GetAccessibleVariableNodesInnerReferences( src_node );

			foreach( &node : src_nodes )
			{
				src_variables_is_mut|= node.lock_imut().deref().value_type == ValueType::ReferenceMut;
			}
		}

		var bool dst_inner_reference_is_mut= function_type.params[ dst_arg ].t.GetInnerReferenceKind() == InnerReferenceKind::Mut;
		// Even if reference-pollution is mutable, but if src vars is immutable, link as immutable.
		var bool result_node_is_mut= src_variables_is_mut && dst_inner_reference_is_mut;

		if( !src_nodes.empty() )
		{
			foreach( dst_node : function_context.references_graph.GetAllAccessibleVariableNodes( dst_node ) )
			{
				var VariableNullablePtr mut inner_reference_node= function_context.references_graph.GetNodeInnerReference( dst_node );
				if( inner_reference_node.empty() )
				{
					inner_reference_node= function_context.references_graph.CreateNodeInnerReference(
						dst_node,
						select( result_node_is_mut ? ValueType::ReferenceMut : ValueType::ReferenceImut ) );
				}

				var VariablePtr inner_reference_node_no_null= inner_reference_node.try_to_non_nullable();
				var ValueType inner_reference_node_value_type= inner_reference_node_no_null.lock_imut().deref().value_type;

				if( (  result_node_is_mut && inner_reference_node_value_type == ValueType::ReferenceImut ) ||
					( !result_node_is_mut && inner_reference_node_value_type == ValueType::ReferenceMut ) )
				{
					REPORT_ERROR( InnerReferenceMutabilityChanging, names_scope, src_loc, inner_reference_node_no_null.lock_imut().deref().name )
				}

				foreach( & src_node : src_nodes )
				{
					function_context.references_graph.TryAddLink( src_node, inner_reference_node_no_null, names_scope, src_loc );
				}
			}
		}
	}

	// Remove temp nodes.
	foreach( &node : args_nodes )
	{
		if( !node.empty() )
		{
			function_context.references_graph.RemoveNode( node.try_to_non_nullable() );
		}
	}

	DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc ); // Destroy temporary args.

	// Register result variable for destruction and references graph checks.
	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::BuildTempVariableConstruction(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	Type& t,
	ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args,
	SrcLoc& src_loc ) : Value
{
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, t )
		return ErrorValue();
	}
	if( t.IsAbstract() )
	{
		REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, src_loc, t )
		return ErrorValue();
	}

	var ust::string8 mut name= "temp " + t.ToString();

	var Variable mut result
	{
		.t= t,
		.location= Variable::Location::Pointer,
		.value_type= ValueType::Value,
		.name= name,
	};

	auto mut llvm_value= LLVMValueRef::Null;
	if( !function_context.is_functionless_context )
	{
		name += "\0";
		llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), name.front() ) );
		CreateLifetimeStart( function_context, llvm_value );
	}
	result.llvm_value= llvm_value;

	var VariablePtr mut result_ptr( move(result) );

	function_context.references_graph.AddNode( result_ptr );

	{
		var Variable mut variable_for_initialization
		{
			.t= t,
			.value_type= ValueType::ReferenceMut,
			.location= Variable::Location::Pointer,
			.llvm_value= llvm_value,
			.name= name,
		};
		var VariablePtr variable_for_initialization_ptr( move(variable_for_initialization) );
		function_context.references_graph.AddNode( variable_for_initialization_ptr );
		function_context.references_graph.AddLink( result_ptr, variable_for_initialization_ptr );

		var LLVMValueRef constexpr_value= BuildConstructorInitializer( names_scope, function_context, variable_for_initialization_ptr, args, src_loc );

		function_context.references_graph.RemoveNode( variable_for_initialization_ptr );

		with( mut lock : result_ptr.lock_mut() )
		{
			lock.deref().constexpr_value= constexpr_value;
		}
	}

	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::ConvertVariable(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	VariablePtr& src,
	Type& dst_type,
	FunctionVariable& conversion_constructor_,
	SrcLoc& src_loc ) : VariablePtr
{
	auto mut llvm_value= LLVMValueRef::Null;
	if( !function_context.is_functionless_context )
	{
		llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, dst_type.GetLLVMType(), g_null_string ) );
		CreateLifetimeStart( function_context, llvm_value );
	}

	var Variable mut result
	{
		.t= dst_type,
		.value_type= ValueType::Value,
		.location= Variable::Location::Pointer,
		.llvm_value= llvm_value,
		.name= "converted " + dst_type.ToString(),
	};

	var VariablePtr mut result_ptr( move(result) );
	function_context.references_graph.AddNode( result_ptr );

	{
		// Create temp variables storage for preventing of destruction of "arg".
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var Variable mut result_for_constructor_call
		{
			.t= dst_type,
			.value_type= ValueType::ReferenceMut,
			.location= Variable::Location::Pointer,
			.llvm_value= llvm_value,
			.name= "converted " + dst_type.ToString(),
		};
		var VariablePtr result_for_constructor_call_ptr( move(result_for_constructor_call) );
		function_context.references_graph.AddNode( result_for_constructor_call_ptr );
		function_context.references_graph.AddLink( result_ptr, result_for_constructor_call_ptr );

		var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( conversion_constructor_ );

		DoCallFunction(
			names_scope,
			function_context,
			conversion_constructor_.t,
			llvm_function,
			false, // Can't call for now constructors as constexpr functions.
			ust::make_array( result_for_constructor_call_ptr, src ),
			ust::empty_range,
			ArgsEvaluationOrder::Direct,
			src_loc );

		function_context.references_graph.RemoveNode( result_for_constructor_call_ptr );

		CallDestructorsForTopVariablesFrame( names_scope, function_context, src_loc );
	}

	DestroyUnusedTemporaryVariables( names_scope, function_context, src_loc ); // Destroy source, if needed.

	RegisterTemporaryVariable( function_context, result_ptr );
	return move(result_ptr);
}

fn CodeBuilder::EvaluateBoolConstantExpression( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : bool
{
	var VariableLite v= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression ).lock_imut().deref();
	if( v.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch, names_scope, Synt::GetSrcLoc( expression ), bool_type_, v.t )
		return false;
	}
	if( v.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( ExpectedConstantExpression, names_scope, Synt::GetSrcLoc( expression ) )
		return false;
	}

	// Do not need to destroy variables here, because this function is normally called only in constexr context.

	return unsafe( LLVMConstIntGetZExtValue( v.constexpr_value ) ) != 0u64;
}

} // namespace U1
