import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::BuildExpressionCodeEnsureVariable( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable
{
	var Value mut value= BuildExpressionCode( names_scope, function_context, expression );

	if_var( &mut v : value.get</Variable/>())
	{
		return take(v);
	}

	REPORT_ERROR( ExpectedVariable, names_scope, Synt::GetFilePos(expression), GetValueKindName(value) )

	var Variable mut dummy;
	dummy.t= FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ );
	dummy.location= Variable::Location::LLVMRegister;
	unsafe{  dummy.llvm_value= LLVMGetUndef( fundamental_llvm_types_.invalid_type_ );  }
	return move(dummy);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value
{
	variant_visit( &el : expression )
	{
		return BuildExpressionCode( names_scope, function_context, el );
	}

	halt;
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value
{
	// "EmptyVariant" used only as stub during expression building in syntax analyzer. It should never be in final result.
	halt;
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value
{
	var ust::array_view_imut</char8/> mut type_suffix( numeric_constant.num.type_suffix );
	while( !type_suffix.empty() && type_suffix.back() == "\0"c8 )
	{
		type_suffix.drop_back();
	}

	auto mut t= U_FundamentalType::InvalidType;
	if( type_suffix.empty() )
	{
		t= select( numeric_constant.num.has_fractional_point ? U_FundamentalType::f64_ : U_FundamentalType::i32_ );
	}
	else if( type_suffix == ust::string8("u") )
	{
		t= U_FundamentalType::u32_;
	}
	else if( type_suffix == ust::string8("s") )
	{
		t= size_type_.GetFundamentalType().get_ref().fundamental_type;
	}
	else if( type_suffix == ust::string8("f") )
	{
		t= U_FundamentalType::f32_;
	}
	else if( type_suffix == ust::string8("c8") )
	{
		t= U_FundamentalType::char8_;
	}
	else if( type_suffix == ust::string8("c16") )
	{
		t= U_FundamentalType::char16_;
	}
	else if( type_suffix == ust::string8("c32") )
	{
		t= U_FundamentalType::char32_;
	}
	else
	{
		t= GetFundamentalTypeByName( type_suffix );
	}

	if( t == U_FundamentalType::InvalidType )
	{
		REPORT_ERROR( UnknownNumericConstantType, names_scope, numeric_constant.file_pos, ust::string8(type_suffix) )
		return ErrorValue();
	}

	var Variable mut res
	{
		.t= Type( FundamentalType( t, GetFundamentalLLVMType(t) ) ),
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, "numeric constant" ),
	};

	unsafe
	{
		if( IsFloatingPoint( t ) )
		{
			res.constexpr_value= LLVMConstReal( res.t.GetLLVMType(), numeric_constant.num.value_double );
		}
		else if( IsSignedInteger( t ) )
		{
			res.constexpr_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::True  );
		}
		else if( IsUnsignedInteger( t ) || IsChar( t ) )
		{
			res.constexpr_value= LLVMConstInt( res.t.GetLLVMType(), numeric_constant.num.value_int, LLVMBool::False );
		}
		else{ halt; }
	}
	res.llvm_value= res.constexpr_value;

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= res.t,
		.is_mutable= false,
		.llvm_value= res.llvm_value,
		.constexpr_value= res.constexpr_value,
		.node_id= res.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(res);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value
{
	var Variable mut res
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
		.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, "boolean constant" ),
	};

	unsafe{ res.constexpr_value= LLVMConstInt( res.t.GetLLVMType(), select( boolean_constant.value ? 1u64 : 0u64 ), LLVMBool::True ); }
	res.llvm_value= res.constexpr_value;

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= res.t,
		.is_mutable= false,
		.llvm_value= res.llvm_value,
		.constexpr_value= res.constexpr_value,
		.node_id= res.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(res);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StringLiteral& string_literal ) : Value
{
	auto mut char_type= U_FundamentalType::InvalidType;
	auto mut is_array= true;

	auto& type_suffix= string_literal.type_suffix;
	if( type_suffix == "" || type_suffix == "u8" )
	{
		char_type= U_FundamentalType::char8_;
		is_array= true;
	}
	else if( type_suffix == "u16" )
	{
		char_type= U_FundamentalType::char16_;
		is_array= true;
	}
	else if( type_suffix == "u32" )
	{
		char_type= U_FundamentalType::char32_;
		is_array= true;
	}
	else if( type_suffix == "c8"  || type_suffix == GetFundamentalTypeName( U_FundamentalType::char8_  ) )
	{
		char_type= U_FundamentalType::char8_ ;
		is_array= false;
	}
	else if( type_suffix == "c16" || type_suffix == GetFundamentalTypeName( U_FundamentalType::char16_ ) )
	{
		char_type= U_FundamentalType::char16_;
		is_array= false;
	}
	else if( type_suffix == "c32" || type_suffix == GetFundamentalTypeName( U_FundamentalType::char32_ ) )
	{
		char_type= U_FundamentalType::char32_;
		is_array= false;
	}
	else
	{
		REPORT_ERROR( UnknownStringLiteralSuffix, names_scope, string_literal.file_pos, string_literal.type_suffix )
		return ErrorValue();
	}

	auto element_llvm_type= GetFundamentalLLVMType(char_type);

	if( is_array )
	{
		auto mut array_size= 0s;
		auto mut llvm_type= LLVMTypeRef::Null;
		auto mut constexpr_value= LLVMValueRef::Null;
		auto mut global_value= LLVMValueRef::Null;
		unsafe
		{
			if( char_type == U_FundamentalType::char8_ )
			{
				constexpr_value= LLVMConstStringInContext( llvm_context_, string_literal.value.front_unsafe(), u32(string_literal.value.size()), LLVMBool::True );
				array_size= string_literal.value.size();
			}
			else if( char_type == U_FundamentalType::char16_ )
			{
				var ust::string16 mut buff;
				auto buff_size= string_literal.value.size() * 4s;
				buff.resize( buff_size, "\0"c16 ); // Reserve enough space.

				array_size= U1_ConvertUTF8ToUTF16( string_literal.value.front_unsafe(), string_literal.value.size(), buff.front_unsafe(), buff_size );
				halt if(array_size > buff.size());

				constexpr_value= U1_ConstDataArray( element_llvm_type, cast_imut(buff).front_unsafe(), array_size * typeinfo</char16/>.size_of, array_size );
			}
			else if( char_type == U_FundamentalType::char32_ )
			{
				var ust::string32 mut buff;
				auto buff_size= string_literal.value.size() * 4s;
				buff.resize( buff_size, "\0"c32 ); // Reserve enough space.

				array_size= U1_ConvertUTF8ToUTF32( string_literal.value.front_unsafe(), string_literal.value.size(), buff.front_unsafe(), buff_size );
				halt if(array_size > buff.size());

				constexpr_value= U1_ConstDataArray( element_llvm_type, cast_imut(buff).front_unsafe(), array_size * typeinfo</char32/>.size_of, array_size );
			}
			else{ halt; }

			llvm_type= LLVMArrayType( element_llvm_type, u32(array_size) );

			// TODO - reuse global variable for equal string literals.
			global_value= AddGlobalConstantVariable( "TODO - name\0", llvm_type, constexpr_value );
		}

		var ArrayType mut array_type
		{
			.element_type= FundamentalType( char_type, element_llvm_type ),
			.element_count= u64(array_size),
			.llvm_type= llvm_type,
		};
		var Variable mut res
		{
			.t= move(array_type),
			.location= Variable::Location::Pointer,
			.llvm_value= global_value,
			.constexpr_value= constexpr_value,
		};

		return move(res);
	}
	else
	{
		auto mut constexpr_value= LLVMValueRef::Null;
		unsafe
		{
			if( char_type == U_FundamentalType::char8_ )
			{
				if( string_literal.value.size() != 1s )
				{
					REPORT_ERROR( InvalidSizeForCharLiteral, names_scope, string_literal.file_pos, string_literal.value )
					return ErrorValue();
				}

				constexpr_value= LLVMConstInt( element_llvm_type, u64(string_literal.value.front()), LLVMBool::False );
			}
			else if( char_type == U_FundamentalType::char16_ )
			{
				var char16 mut c= zero_init;
				if( string_literal.value.empty() ||
					U1_ConvertUTF8ToUTF16( string_literal.value.front_unsafe(), string_literal.value.size(), c, 1s ) != 1s )
				{
					REPORT_ERROR( InvalidSizeForCharLiteral, names_scope, string_literal.file_pos, string_literal.value )
					return ErrorValue();
				}

				constexpr_value= LLVMConstInt( element_llvm_type, u64(c), LLVMBool::False );
			}
			else if( char_type == U_FundamentalType::char32_ )
			{
				var char32 mut c= zero_init;
				if( string_literal.value.empty() ||
					U1_ConvertUTF8ToUTF32( string_literal.value.front_unsafe(), string_literal.value.size(), c, 1s ) != 1s )
				{
					REPORT_ERROR( InvalidSizeForCharLiteral, names_scope, string_literal.file_pos, string_literal.value )
					return ErrorValue();
				}

				constexpr_value= LLVMConstInt( element_llvm_type, u64(c), LLVMBool::False );
			}
			else{ halt; }
		}

		var Variable mut res
		{
			.t= FundamentalType( char_type, element_llvm_type ),
			.location= Variable::Location::LLVMRegister,
			.llvm_value= constexpr_value,
			.constexpr_value= constexpr_value,
		};

		return move(res);
	}
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value
{
	if( named_operand.start.get</ust::string8/>().empty() || !named_operand.tail.empty() )
	{
		return ResolveValue( names_scope, function_context, named_operand );
	}

	// Process special simple names here.
	var ust::string8& name= named_operand.start.get</ust::string8/>().get_ref();
	if( name == KeywordToString( Keyword::this_ ) )
	{
		if( function_context.this_.empty() || function_context.whole_this_is_unavailable )
		{
			REPORT_ERROR( ThisUnavailable, names_scope, named_operand.file_pos )
			return ErrorValue();
		}
		return function_context.this_.get_ref();
	}
	if( name == KeywordToString( Keyword::base_ ) )
	{
		if( function_context.this_.empty() )
		{
			REPORT_ERROR( BaseUnavailable, names_scope, named_operand.file_pos )
			return ErrorValue();
		}

		auto &this_= function_context.this_.get_ref();

		auto class_type= this_.t.GetClassType().get_ref();
		auto base_class= class_type.lock_imut().get_ref().base_class;
		if( base_class.empty() )
		{
			REPORT_ERROR( BaseUnavailable, names_scope, named_operand.file_pos )
			return ErrorValue();
		}
		if( cast_imut(function_context).whole_this_is_unavailable &&
			!cast_imut(function_context).uninitialized_this_fields.find( KeywordToString( Keyword::base_ ) ).empty() )
		{
			REPORT_ERROR( FieldIsNotInitializedYet, names_scope, named_operand.file_pos, KeywordToString( Keyword::base_ ) )
			return ErrorValue();
		}

		var Type base_type= ust::to_non_nullable(base_class);
		var Variable mut base_
		{
			.t= base_type,
			.value_type= this_.value_type,
			.llvm_value= CreateReferenceCast( this_.llvm_value, this_.t, base_type, function_context ),
		};

		return move(base_);
	}

	return ResolveValue( names_scope, function_context, named_operand );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeinfo& typeinfo_ ) : Value
{
	var NamesScopePtr mut root_names_scope= names_scope;
	while(true)
	{
		auto parent= root_names_scope.lock_imut().get_ref().GetParent();
		if( parent.empty() )
		{
			break;
		}
		root_names_scope= ust::to_non_nullable( parent );
	}

	var Type t= PrepareType( names_scope, function_context, typeinfo_.type_name );
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, typeinfo_.file_pos, t.ToString() )
		return ErrorValue();
	}

	return BuildTypeinfo( t, root_names_scope );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRef& cast_ref_ ) : Value
{
	return DoReferenceCast( names_scope, function_context, cast_ref_.t, cast_ref_.expression.get_ref(), cast_ref_.file_pos, false );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRefUnsafe& cast_ref_unsafe_ ) : Value
{
	if( !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( UnsafeReferenceCastOutsideUnsafeBlock, names_scope, cast_ref_unsafe_.file_pos )
	}
	return DoReferenceCast( names_scope, function_context, cast_ref_unsafe_.t, cast_ref_unsafe_.expression.get_ref(), cast_ref_unsafe_.file_pos, true );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastImut& cast_imut_ ) : Value
{
	var Variable v= BuildExpressionCodeEnsureVariable( names_scope, function_context, cast_imut_.expression.get_ref() );

	var Variable mut r
	{
		.t= v.t,
		.value_type= ValueType::ReferenceImut,
		.location= Variable::Location::Pointer,
		.node_id= v.node_id,
	};

	// TODO - maybe forbid reference casting for ValueType::Value?
	if( v.location == Variable::Location::LLVMRegister )
	{
		unsafe
		{
			r.llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, v.t.GetLLVMType(), "\0"[0] );
			LLVMBuildStore( function_context.llvm_ir_builder, v.llvm_value, r.llvm_value );
		}
	}
	else
	{
		r.llvm_value= v.llvm_value;
	}

	return move(r);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastMut& cast_mut_ ) : Value
{
	if( !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( MutableReferenceCastOutsideUnsafeBlock, names_scope, cast_mut_.file_pos )
	}

	var Variable v= BuildExpressionCodeEnsureVariable( names_scope, function_context, cast_mut_.expression.get_ref() );

	var Variable mut r
	{
		.t= v.t,
		.value_type= ValueType::ReferenceMut,
		.location= Variable::Location::Pointer,
		.node_id= v.node_id,
	};

	// TODO - maybe forbid reference casting for ValueType::Value?
	if( v.location == Variable::Location::LLVMRegister )
	{
		unsafe
		{
			r.llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, v.t.GetLLVMType(), "\0"[0] );
			LLVMBuildStore( function_context.llvm_ir_builder, v.llvm_value, r.llvm_value );
		}
	}
	else
	{
		r.llvm_value= v.llvm_value;
	}

	return move(r);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MoveOperator& move_operator ) : Value
{
	var Synt::ComplexName complex_name{ .file_pos= move_operator.file_pos, .start= move_operator.variable_name };
	var Value value= ResolveValue( names_scope, function_context, complex_name );
	if( value.get</Variable/>().empty() )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.file_pos, GetValueKindName(value) )
		return ErrorValue();
	}

	var Variable& variable= value.get</Variable/>().get_ref();
	if( variable.node_id == ReferencesGraph::c_empty_node_id )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.file_pos, ust::string8( "global constant" ) )
		return ErrorValue();
	}
	if( function_context.references_graph.GetNodeKind( variable.node_id ) != ReferencesGraph::NodeKind::Variable )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, move_operator.file_pos, ust::string8( "reference" ) )
		return ErrorValue();
	}

	if( variable.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, move_operator.file_pos )
		return ErrorValue();
	}
	if( function_context.references_graph.NodeIsMoved( variable.node_id ) )
	{
		REPORT_ERROR( AccessingMovedVariable, names_scope, move_operator.file_pos, function_context.references_graph.GetNodeName( variable.node_id ) )
		return ErrorValue();
	}
	if( function_context.references_graph.HaveOutgoingLinks( variable.node_id ) )
	{
		REPORT_ERROR( MovedVariableHaveReferences, names_scope, move_operator.file_pos, function_context.references_graph.GetNodeName( variable.node_id ) )
		return ErrorValue();
	}

	var Variable mut result= variable;
	result.value_type= ValueType::Value;

	var ust::string8 mut node_name= "moved ";
	node_name+= function_context.references_graph.GetNodeName( variable.node_id );
	result.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, move(node_name) );

	SetupReferencesInCopyOrMove( names_scope, function_context, result.t, result.node_id, variable.node_id, move_operator.file_pos );

	function_context.references_graph.MoveNode( variable.node_id );

	{// Register variable for references checking and destruction.
		var NamesScopeVariable mut names_scope_variable
		{
			.t= result.t,
			.is_mutable= true,
			.llvm_value= result.llvm_value,
			.constexpr_value= result.constexpr_value,
			.node_id= result.node_id,
		};
		function_context.variables_frames.back().push_back( move(names_scope_variable) );
	}

	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TakeOperator& take_operator ) : Value
{
	var Variable variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, take_operator.expression.get_ref() );
	if( variable.value_type == ValueType::Value )
	{
		return variable; // If it is value - just pass it.
	}

	if( variable.node_id == ReferencesGraph::c_empty_node_id )
	{
		REPORT_ERROR( ExpectedVariable, names_scope, take_operator.file_pos, ust::string8( "global constant" ) )
		return ErrorValue();
	}

	if( variable.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, take_operator.file_pos )
		return ErrorValue();
	}
	if( function_context.references_graph.HaveOutgoingLinks( variable.node_id ) )
	{
		REPORT_ERROR( MovedVariableHaveReferences, names_scope, take_operator.file_pos, function_context.references_graph.GetNodeName( variable.node_id ) )
		return ErrorValue();
	}

	var ust::string8 src_variable_name= function_context.references_graph.GetNodeName( variable.node_id );

	var ust::string8 mut variable_name= "taken ";
	variable_name+= src_variable_name;

	var Variable mut result
	{
		.t= variable.t,
		.value_type= ValueType::Value,
		.location= Variable::Location::Pointer,
		.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, variable_name ),
	};

	variable_name.push_back( "\0"c8 );
	unsafe{  result.llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, result.t.GetLLVMType(), variable_name.front() );  }

	// Copy content to new variable.
	CopyBytes( result.llvm_value, variable.llvm_value, result.t, function_context );

	SetupReferencesInCopyOrMove( names_scope, function_context, result.t, result.node_id, variable.node_id, take_operator.file_pos );

	{ // Apply empty initializer for source variable.
		var NamesScopeVariable mut names_scope_variable
		{
			.t= variable.t,
			.is_mutable= true,
			.llvm_value= variable.llvm_value,
			.constexpr_value= variable.constexpr_value,
			.node_id= variable.node_id,
		};
		BuildEmptyInitializer( names_scope, function_context, names_scope_variable, src_variable_name, take_operator.file_pos );
	}

	{// Register variable for references checking and destruction.
		var NamesScopeVariable mut names_scope_variable
		{
			.t= result.t,
			.is_mutable= true,
			.llvm_value= result.llvm_value,
			.constexpr_value= result.constexpr_value,
			.node_id= result.node_id,
		};
		function_context.variables_frames.back().push_back( move(names_scope_variable) );
	}

	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	if( binary_operator.operator == BinaryOperatorType::LazyLogicalAnd || binary_operator.operator == BinaryOperatorType::LazyLogicalOr )
	{
		return BuildLazyBinaryOperator( names_scope, function_context, binary_operator );
	}

	if_var( & res :
		TryCallOverloadedBinaryOperator(
			names_scope,
			function_context,
			GetOverloadedOperatorForBinaryOperator( binary_operator.operator ),
			binary_operator.l,
			binary_operator.r,
			ArgsEvaluationOrder::Direct,
			binary_operator.file_pos ) )
	{
		return res;
	}

	auto mut l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.get_ref() );
	// Save l_var in register, prevent its modification during r_var calculation.
	l_var.llvm_value= CreateMoveToLLVMRegisterInstruction( l_var, function_context );
	l_var.location= Variable::Location::LLVMRegister;
	l_var.value_type= ValueType::Value;

	// Destroy temporaries of left part.
	DestroyUnusedTemporaryVariables( names_scope, function_context, binary_operator.file_pos );

	auto r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.get_ref() );

	return BuildBinaryOperator( names_scope, function_context, l_var, r_var, binary_operator.operator, binary_operator.file_pos );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BracketExpression& bracket_expression ) : Value
{
	return BuildExpressionCode( names_scope, function_context, bracket_expression.expr.get_ref() );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.value.get_ref() );

	if( !variable.t.GetClassType().empty() )
	{
		// Try to call overloaded [] operator.
		var [ VariableTypeExtened, 2 ] mut args
		[
			{ .t(variable.t), .value_type= variable.value_type },
			{ .t(invalid_type_), .value_type= ValueType::Value },
		];

		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();
			auto instructions_state= SaveInstructionsState( function_context );

			var Variable arg= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.index.get_ref() );
			args[1].t= arg.t;
			args[1].value_type= arg.value_type;

			RestoreInstructionsState( function_context, instructions_state );
		}

		if_var( mut overloaded_operator : GetOverloadedOperator( args, OverloadedOperator::Indexing, names_scope, indexation_operator.file_pos ) )
		{
			if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
			{
				function_context.have_non_constexpr_operations_inside= true; // Can not call non-constexpr function in constexpr function.
			}

			auto fetch_result= TryFetchVirtualFunction( variable, overloaded_operator, function_context );
			overloaded_operator.llvm_function= fetch_result[1];

			var [ ust::shared_ptr_final</Synt::Expression/>, 1 ] args[ indexation_operator.index ];
			return DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />( fetch_result[0] ),
				overloaded_operator,
				ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />( args ),
				indexation_operator.file_pos );
		}
	}

	// This is not a class - process indexation operator for array or tuple.

	// Prevent modification of variable during index calculation.
	var ReferencesGraph::NodeId mut variable_lock_node= ReferencesGraph::c_empty_node_id;
	if( variable.node_id != ReferencesGraph::c_empty_node_id )
	{
		variable_lock_node= function_context.references_graph.AddNode(
			select( variable.value_type == ValueType::ReferenceMut ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
			"[]" );
		function_context.references_graph.AddLink( variable.node_id, variable_lock_node );
	}

	auto index= BuildExpressionCodeEnsureVariable( names_scope, function_context, indexation_operator.index.get_ref() );

	if_var( &variable_array_type : variable.t.GetArrayType() )
	{
		if_var( &index_fundamental_type : index.t.GetFundamentalType() )
		{
			if( !(
				IsUnsignedInteger( index_fundamental_type.fundamental_type ) ||
				( IsSignedInteger( index_fundamental_type.fundamental_type ) && index.constexpr_value != LLVMValueRef::Null ) ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, indexation_operator.file_pos, ust::string8("any unsigned integer"), index.t )
				return ErrorValue();
			}
			if( variable.location != Variable::Location::Pointer )
			{
				// TODO - Strange variable location.
				return ErrorValue();
			}

			var LLVMValueRef mut index_value= CreateMoveToLLVMRegisterInstruction( index, function_context );
			if( index.constexpr_value != LLVMValueRef::Null )
			{
				// Statically check index.
				auto mut index_value_num= 0u64;
				unsafe{  index_value_num= LLVMConstIntGetZExtValue( index_value );  }
				if( index_value_num >= variable_array_type.element_count )
				{
					REPORT_ERROR( ArrayIndexOutOfBounds, names_scope, indexation_operator.file_pos, index_value_num, variable_array_type.element_count )
					return ErrorValue();
				}
			}
			else
			{
				// Dynamically check index.
				unsafe
				{
					auto mut index_value_for_compare= index_value;
					auto index_type_size= index_fundamental_type.GetSize();
					auto size_type_size= size_type_.GetFundamentalType().get_ref().GetSize();
					if( index_type_size > size_type_size )
					{
						index_value_for_compare= LLVMBuildTrunc( function_context.llvm_ir_builder, index_value_for_compare, fundamental_llvm_types_.int_ptr, "\0"[0] );
					}
					else if( index_type_size < size_type_size )
					{
						index_value_for_compare= LLVMBuildZExt( function_context.llvm_ir_builder, index_value_for_compare, fundamental_llvm_types_.int_ptr, "\0"[0] );
					}

					auto size_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, variable_array_type.element_count, LLVMBool::False );
					auto condition= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGE, index_value_for_compare, size_value, "\0"[0] );
					auto halt_block = LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
					auto ok_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

					LLVMBuildCondBr( function_context.llvm_ir_builder, condition, halt_block, ok_block );

					LLVMAppendExistingBasicBlock( function_context.llvm_function, halt_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, halt_block );

					LLVMBuildCall( function_context.llvm_ir_builder, halt_function_, LLVMValueRef::Null, 0u, "\0"[0] );
					LLVMBuildUnreachable( function_context.llvm_ir_builder );

					LLVMAppendExistingBasicBlock( function_context.llvm_function, ok_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, ok_block );
				}
			}

			var Variable mut result
			{
				.t= variable_array_type.element_type,
				.location= Variable::Location::Pointer,
				.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.node_id= variable.node_id,
			};

			unsafe
			{
				var [ LLVMValueRef, 2 ] indexes[ GetZeroGEPIndex(), index_value ];
				result.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] ); // TODO - maybe add "inbounds" attribute?
			}

			if( variable.constexpr_value != LLVMValueRef::Null && index.constexpr_value != LLVMValueRef::Null )
			{
				unsafe
				{
					result.constexpr_value= LLVMConstExtractValue( variable.constexpr_value, u32( LLVMConstIntGetZExtValue( index_value ) ), 1u );
				}
			}

			DestroyUnusedTemporaryVariables( names_scope, function_context, indexation_operator.file_pos ); // Destroy index.
			if( variable_lock_node != ReferencesGraph::c_empty_node_id )
			{
				function_context.references_graph.RemoveNode( variable_lock_node );
			}

			return move(result);
		}
		REPORT_ERROR( TypesMismatch, names_scope, indexation_operator.file_pos, ust::string8("any unsigned integer"), index.t )
	}
	if_var( &variable_tuple_type : variable.t.GetTupleType() )
	{
		if_var( &index_fundamental_type : index.t.GetFundamentalType() )
		{
			if( !IsInteger( index_fundamental_type.fundamental_type ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, indexation_operator.file_pos, ust::string8("any integer"), index.t )
				return ErrorValue();
			}
			if( index.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, indexation_operator.file_pos )
				return ErrorValue();
			}

			// TODO - check also signed types
			var u64 mut type_index= ~0u64;
			unsafe{  type_index= LLVMConstIntGetZExtValue( index.constexpr_value );  }
			if( type_index >= u64(variable_tuple_type.element_types.size()) )
			{
				REPORT_ERROR( TupleIndexOutOfBounds, names_scope, indexation_operator.file_pos, type_index, variable_tuple_type.element_types.size() )
				return ErrorValue();
			}

			var Variable mut result
			{
				.t= variable_tuple_type.element_types[type_index],
				.location= Variable::Location::Pointer,
				.value_type= select( variable.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.llvm_value= CreateTupleElementGEP( variable.llvm_value, size_type(type_index), function_context ),
				.node_id= variable.node_id,
			};

			if( variable.constexpr_value != LLVMValueRef::Null )
			{
				unsafe{  result.constexpr_value= LLVMConstExtractValue( variable.constexpr_value, u32(type_index), 1u );  }
			}

			DestroyUnusedTemporaryVariables( names_scope, function_context, indexation_operator.file_pos ); // Destroy index.
			if( variable_lock_node != ReferencesGraph::c_empty_node_id )
			{
				function_context.references_graph.RemoveNode( variable_lock_node );
			}

			return move(result);
		}
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, index.t )
	}

	REPORT_ERROR( OperationNotSupportedForThisType, names_scope, indexation_operator.file_pos, variable.t )

	return ErrorValue();
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value
{
	auto function= BuildExpressionCode( names_scope, function_context, call_operator.value.get_ref() );

	var ust::optional_ref</ FunctionsSet, false /> mut functions_set;
	var ust::optional_ref</ Variable, false /> mut this_;

	if_var( &t : function.get</Type/>() )
	{
		return BuildTempVariableConstruction( names_scope, function_context, t, call_operator.args, call_operator.file_pos );
	}
	if_var( & in_functions_set : function.get</FunctionsSet/>() )
	{
		functions_set.reset(in_functions_set);
	}
	if_var( & this_methods_set : function.get</ThisMethodsSet/>() )
	{
		functions_set.reset(this_methods_set.functions_set);
		this_.reset(this_methods_set.this_);
	}
	if_var( & variable : function.get</Variable/>() )
	{
		if_var( &function_pointer_type : variable.t.GetFunctionPointerType() )
		{
			var FunctionVariable function_variable
			{
				.t= function_pointer_type.function_type,
				.llvm_function= CreateMoveToLLVMRegisterInstruction( variable , function_context )
			};

			return DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />(),
				function_variable,
				call_operator.args.range(),
				call_operator.file_pos );
		}

		// Try to call overloaded () operator.

		var ust::vector</VariableTypeExtened/> mut args;

		{
			var VariableTypeExtened mut this_arg{ .t(variable.t), .value_type= variable.value_type };
			args.push_back(move(this_arg));
		}

		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();
			auto instructions_state= SaveInstructionsState( function_context );

			foreach( &in_arg : call_operator.args )
			{
				if( function_context.args_preevaluation_cache.find( in_arg ).empty() )
				{
					auto arg= BuildExpressionCodeEnsureVariable( names_scope, function_context, in_arg.get_ref() );
					var VariableTypeExtened mut f_arg{ .t(arg.t), .value_type= arg.value_type };
					function_context.args_preevaluation_cache.insert( in_arg, move(f_arg) );
				}
				args.push_back( function_context.args_preevaluation_cache[in_arg] );
			}

			RestoreInstructionsState( function_context, instructions_state );
		}

		if_var( mut overloaded_operator : GetOverloadedOperator( args.range(), OverloadedOperator::Call, names_scope, call_operator.file_pos ) )
		{
			if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
			{
				function_context.have_non_constexpr_operations_inside= true; // Can not call non-constexpr function in constexpr function.
			}

			auto fetch_result= TryFetchVirtualFunction( variable, overloaded_operator, function_context );
			overloaded_operator.llvm_function= fetch_result[1];

			return DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />(fetch_result[0]),
				overloaded_operator,
				call_operator.args.range(),
				call_operator.file_pos );
		}
	}

	if( functions_set.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, call_operator.file_pos, ust::string8("non-function value") )
		return ErrorValue();
	}

	return CallFunctionsSet( names_scope, function_context, this_, functions_set.get_ref(), call_operator.args.range(), call_operator.file_pos );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MemberAccessOperator& member_access_operator ) : Value
{
	if( member_access_operator.member_name == KeywordToString( Keyword::constructor_ ) ||
		member_access_operator.member_name == KeywordToString( Keyword::destructor_ ) )
	{
		if( !function_context.is_in_unsafe_block )
		{
			REPORT_ERROR( ExplicitAccessToThisMethodIsUnsafe, names_scope, member_access_operator.file_pos, member_access_operator.member_name )
		}
	}

	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, member_access_operator.value.get_ref() );
	if( !EnsureTypeComplete( variable.t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, member_access_operator.file_pos, variable.t )
		return ErrorValue();
	}

	auto class_type_ref= variable.t.GetClassType();
	if( class_type_ref.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, member_access_operator.file_pos, variable.t )
		return ErrorValue();
	}
	var ClassTypePtr class_type= class_type_ref.get_ref();

	var ust::optional</NamesScopeValue/> mut class_member;
	auto class_members= class_type.lock_imut().get_ref().members;
	if_var( &member : class_members.lock_imut().get_ref().GetThisScopeValue( member_access_operator.member_name ) )
	{
		class_member= member;
	}

	if( class_member.empty() )
	{
		REPORT_ERROR( NameNotFound, names_scope, member_access_operator.file_pos, member_access_operator.member_name )
		return ErrorValue();
	}

	if( u32( names_scope.lock_imut().get_ref().GetAccessFor( class_type ) ) <
		u32( class_type.lock_imut().get_ref().GetMemberVisibility( member_access_operator.member_name ) ) )
	{
		REPORT_ERROR( AccessingNonpublicClassMember, names_scope, member_access_operator.file_pos, member_access_operator.member_name, variable.t.ToString() )
	}

	{
		auto field_ptr= class_member.get_ref().Get</ClassField/>();
		if( !field_ptr.empty() )
		{
			if( !member_access_operator.template_args.empty() )
			{
				REPORT_ERROR( ValueIsNotTemplate, names_scope, member_access_operator.file_pos )
			}

			auto field_lock= field_ptr.lock_imut();
			auto& field= field_lock.get_ref();

			if( field.index == ~0s ){ return ErrorValue(); } // May be in case of error

			auto mut this_value_corrected= variable.llvm_value;
			{
				var ClassTypePtr mut current_class_type= class_type;
				auto field_source_class= field.source_class.lock();
				while( current_class_type != field_source_class )
				{
					auto base_class= current_class_type.lock_imut().get_ref().base_class;
					if( base_class.empty() )
					{
						// May be in case of errors.
						REPORT_ERROR( AccessOfNonThisClassField, names_scope, member_access_operator.file_pos, member_access_operator.member_name )
						return ErrorValue();
					}
					this_value_corrected= CreateBaseClassFieldGEP( this_value_corrected, function_context );
					current_class_type= ust::to_non_nullable( base_class );
				}
			}

			auto op_name_nt= "." + member_access_operator.member_name + "\0";
			if( field.is_reference )
			{
				var Variable mut result
				{
					.t= field.t,
					.location= Variable::Location::Pointer,
					.value_type= select( field.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				};

				auto ptr_value= CreateFieldGEP( this_value_corrected, field, function_context );
				unsafe{  result.llvm_value= LLVMBuildLoad( function_context.llvm_ir_builder, ptr_value, op_name_nt.front() );  }

				if( variable.constexpr_value != LLVMValueRef::Null )
				{
					// Small hack for typeinfo - it's initializer initialized only if typeinfo is complete, so, make it complete before getting constexpr value for it.
					if( EnsureTypeComplete( field.t ) )
					{
						unsafe
						{
							result.constexpr_value= LLVMGetInitializer( LLVMConstExtractValue( variable.constexpr_value, u32(field.index), 1u ) );
						}
					}
				}

				if( variable.node_id != ReferencesGraph::c_empty_node_id )
				{
					var ust::string8 mut node_name= function_context.references_graph.GetNodeName( variable.node_id );
					node_name+= ".";
					node_name+= field.syntax_element.get_ref().name;
					auto reference_field_node= function_context.references_graph.AddNode(
						select( field.is_mutable ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
						move(node_name) );
					result.node_id= reference_field_node;

					foreach( &inner_node_value : function_context.references_graph.GetAllAccessibleVariableInnerNodes( variable.node_id ) )
					{
						var ReferencesGraph::NodeId inner_node= inner_node_value.key();
						if( (  field.is_mutable && function_context.references_graph.HaveOutgoingLinks( inner_node ) ) ||
							( !field.is_mutable && function_context.references_graph.HaveOutgoingMutableNodes( inner_node ) ) )
						{
							REPORT_ERROR( ReferenceProtectionError, names_scope, member_access_operator.file_pos, function_context.references_graph.GetNodeName( inner_node ) )
						}
						else
						{
							function_context.references_graph.AddLink( inner_node, reference_field_node );
						}
					}

					// Register variable for references checking.
					var NamesScopeVariable mut names_scope_variable
					{
						.t= result.t,
						.is_mutable= field.is_mutable,
						.llvm_value= result.llvm_value,
						.constexpr_value= result.constexpr_value,
						.node_id= reference_field_node,
					};
					function_context.variables_frames.back().push_back( move(names_scope_variable) );
				}

				return move(result);
			}
			else
			{
				var Variable mut result
				{
					.t= field.t,
					.location= Variable::Location::Pointer,
					.value_type= select( variable.value_type == ValueType::ReferenceMut && field.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
					.llvm_value= CreateFieldGEP( this_value_corrected, field, function_context ),
					.node_id= variable.node_id,
				};

				if( variable.constexpr_value != LLVMValueRef::Null )
				{
					unsafe{ result.constexpr_value= LLVMConstExtractValue( variable.constexpr_value, u32(field.index), 1u ); }
				}

				return move(result);
			}
		}
		{
			auto functions_set_ptr= class_member.get_ref().Get</NamesScopeFunctionsSet/>();
			if( !functions_set_ptr.empty() )
			{
				BuildFunctionsSet( class_type.lock_imut().get_ref().members, ust::to_non_nullable( functions_set_ptr ), false );

				var ThisMethodsSet mut this_methods_set{ .this_= variable };

				if( !member_access_operator.template_args.empty() )
				{
					auto functions_set_lock= functions_set_ptr.lock_imut();
					auto& functions_set= functions_set_lock.get_ref().functions_set;

					if( functions_set.function_templates.empty() )
					{
						REPORT_ERROR( ValueIsNotTemplate, names_scope, member_access_operator.file_pos )
						return ErrorValue();
					}

					// Prevent destruction of variable during evaluation of member function template args.
					var ReferencesGraph::NodeId mut variable_lock_node= ReferencesGraph::c_empty_node_id;
					if( variable.node_id != ReferencesGraph::c_empty_node_id )
					{
						var ust::string8 mut node_name= function_context.references_graph.GetNodeName( variable.node_id ) + " lock";
						variable_lock_node= function_context.references_graph.AddNode(
							select( variable.value_type == ValueType::ReferenceMut ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
							move(node_name) );
						function_context.references_graph.AddLink( variable.node_id, variable_lock_node );
					}

					auto val= ParametrizeTemplateFunctions(
						names_scope,
						function_context,
						functions_set,
						member_access_operator.template_args.get_ref(),
						member_access_operator.file_pos );

					if( variable_lock_node != ReferencesGraph::c_empty_node_id )
					{
						function_context.references_graph.RemoveNode( variable_lock_node );
					}

					if( val.empty() )
					{
						return ErrorValue();
					}

					this_methods_set.functions_set= val.get_ref().Get</NamesScopeFunctionsSet/>().lock_imut().get_ref().functions_set;
				}
				else
				{
					this_methods_set.functions_set= functions_set_ptr.lock_imut().get_ref().functions_set;
				}

				return move(this_methods_set);
			}
		}
	}

	REPORT_ERROR( NotImplemented, names_scope, member_access_operator.file_pos, ust::string8("class members, except fields or methods") )
	return ErrorValue();
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryPlus& unary_plus ) : Value
{
	// Do nothing with unary plus.
	// TODO - maybe check type or do something else?
	return BuildExpressionCode( names_scope, function_context, unary_plus.expr.get_ref() );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, unary_minus.expr.get_ref() );

	if( !variable.t.GetClassType().empty() )
	{
		var [ VariableTypeExtened, 1 ] args[ { .t(variable.t), .value_type= variable.value_type } ];

		if_var( mut overloaded_operator : GetOverloadedOperator( args, OverloadedOperator::Sub, names_scope, unary_minus.file_pos ) )
		{
			if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
			{
				function_context.have_non_constexpr_operations_inside= true; // Can not call non-constexpr function in constexpr function.
			}

			auto fetch_result= TryFetchVirtualFunction( variable, overloaded_operator, function_context );
			overloaded_operator.llvm_function= fetch_result[1];

			return DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />(fetch_result[0]),
				overloaded_operator,
				ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />(),
				unary_minus.file_pos );
		}
	}

	auto fundamental_type= variable.t.GetFundamentalType();
	if( fundamental_type.empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, unary_minus.file_pos, variable.t )
		return ErrorValue();
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );

	var Variable mut result
	{
		.t= variable.t,
		.location= Variable::Location::LLVMRegister,
		.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, "-" ),
	};

	if( IsInteger( fundamental_type.get_ref().fundamental_type ) )
	{
		unsafe{  result.llvm_value= LLVMBuildNeg( function_context.llvm_ir_builder, value_in_register, "-\0"[0] );  }
	}
	else if( IsFloatingPoint( fundamental_type.get_ref().fundamental_type ) )
	{
		unsafe{  result.llvm_value= LLVMBuildFNeg( function_context.llvm_ir_builder, value_in_register, "-\0"[0] );  }
	}
	else
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, unary_minus.file_pos, variable.t )
		return ErrorValue();
	}

	unsafe{  if( LLVMIsConstant( result.llvm_value ) == LLVMBool::True ){ result.constexpr_value= result.llvm_value; }  }

	DestroyUnusedTemporaryVariables( names_scope, function_context, unary_minus.file_pos );

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= result.t,
		.is_mutable= false,
		.llvm_value= result.llvm_value,
		.constexpr_value= result.constexpr_value,
		.node_id= result.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, logical_not.expr.get_ref() );

	if( !variable.t.GetClassType().empty() )
	{
		var [ VariableTypeExtened, 1 ] args[ { .t(variable.t), .value_type= variable.value_type} ];

		if_var( mut overloaded_operator : GetOverloadedOperator( args, OverloadedOperator::LogicalNot, names_scope, logical_not.file_pos ) )
		{
			if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
			{
				function_context.have_non_constexpr_operations_inside= true; // Can not call non-constexpr function in constexpr function.
			}

			auto fetch_result= TryFetchVirtualFunction( variable, overloaded_operator, function_context );
			overloaded_operator.llvm_function= fetch_result[1];

			return DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />(fetch_result[0]),
				overloaded_operator,
				ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />(),
				logical_not.file_pos );
		}
	}

	if( variable.t != bool_type_ )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, logical_not.file_pos, variable.t )
		return ErrorValue();
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );

	var Variable mut result
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
		.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, "!" ),
	};

	unsafe
	{
		result.llvm_value= LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "!\0"[0] );
		if( LLVMIsConstant( result.llvm_value ) == LLVMBool::True ){ result.constexpr_value= result.llvm_value; }
	}

	DestroyUnusedTemporaryVariables( names_scope, function_context, logical_not.file_pos );

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= result.t,
		.is_mutable= false,
		.llvm_value= result.llvm_value,
		.constexpr_value= result.constexpr_value,
		.node_id= result.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value
{
	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, bitwise_not.expr.get_ref() );

	if( !variable.t.GetClassType().empty() )
	{
		var [ VariableTypeExtened, 1 ] args[ { .t(variable.t), .value_type= variable.value_type} ];

		if_var( mut overloaded_operator : GetOverloadedOperator( args, OverloadedOperator::BitwiseNot, names_scope, bitwise_not.file_pos ) )
		{
			if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
			{
				function_context.have_non_constexpr_operations_inside= true; // Can not call non-constexpr function in constexpr function.
			}

			auto fetch_result= TryFetchVirtualFunction( variable, overloaded_operator, function_context );
			overloaded_operator.llvm_function= fetch_result[1];

			return DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />(fetch_result[0]),
				overloaded_operator,
				ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />(),
				bitwise_not.file_pos );
		}
	}

	auto fundamental_type= variable.t.GetFundamentalType();
	if( fundamental_type.empty() || !IsInteger( fundamental_type.get_ref().fundamental_type ) )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, bitwise_not.file_pos, variable.t )
		return ErrorValue();
	}

	auto value_in_register= CreateMoveToLLVMRegisterInstruction( variable, function_context );

	var Variable mut result
	{
		.t= variable.t,
		.location= Variable::Location::LLVMRegister,
		.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, "~" ),
	};

	unsafe
	{
		result.llvm_value= LLVMBuildNot( function_context.llvm_ir_builder, value_in_register, "~\0"[0] );
		if( LLVMIsConstant( result.llvm_value ) == LLVMBool::True ){ result.constexpr_value= result.llvm_value; }
	}

	DestroyUnusedTemporaryVariables( names_scope, function_context, bitwise_not.file_pos );

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= result.t,
		.is_mutable= false,
		.llvm_value= result.llvm_value,
		.constexpr_value= result.constexpr_value,
		.node_id= result.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(result);
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Value
{
	return PrepareType( names_scope, function_context, array_type );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Value
{
	return PrepareType( names_scope, function_context, tuple_type );
}

fn CodeBuilder::BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type ) : Value
{
	return PrepareType( names_scope, function_context, function_type );
}

fn CodeBuilder::DoReferenceCast( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name, Synt::Expression& expression, FilePos& file_pos, bool allow_unsafe ) : Value
{
	var Type t= PrepareType( names_scope, function_context, type_name );
	var Variable v= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression );

	var Variable mut r
	{
		.t= t,
		.value_type= select( v.value_type == ValueType::ReferenceMut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.node_id= v.node_id,
	};

	// TODO - maybe forbid reference casting for ValueType::Value?
	auto mut src_llvm_value= v.llvm_value;
	if( v.location == Variable::Location::LLVMRegister )
	{
		unsafe
		{
			src_llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, v.t.GetLLVMType(), "\0"[0] );
			LLVMBuildStore( function_context.llvm_ir_builder, v.llvm_value, src_llvm_value );
		}
	}

	if( v.t == t )
	{
		r.llvm_value= src_llvm_value;
	}
	else if( t == void_type_ )
	{
		r.llvm_value= CreateReferenceCast( src_llvm_value, v.t, t, function_context );
	}
	else
	{
		// We needs complete types to check reference conversion possibility.
		if( !EnsureTypeComplete( t ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope, file_pos, t )
			return ErrorValue();
		}
		if( v.t != void_type_ && !EnsureTypeComplete( v.t ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope, file_pos, v.t )
			return ErrorValue();
		}

		if( v.t.ReferenceIsConvertibleTo( t ) )
		{
			r.llvm_value= CreateReferenceCast( src_llvm_value, v.t, t, function_context );
		}
		else
		{
			if( allow_unsafe )
			{
				unsafe
				{
					auto dst_pointer_type= LLVMPointerType( t.GetLLVMType(), 0u );
					r.llvm_value= LLVMBuildPointerCast( function_context.llvm_ir_builder, src_llvm_value, dst_pointer_type, "\0"[0] );
				}
			}
			else
			{
				REPORT_ERROR( TypesMismatch, names_scope, file_pos, t, v.t )
				return ErrorValue();
			}
		}
	}

	return move(r);
}

fn CodeBuilder::BuildBinaryOperator( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Variable& l_var, Variable& r_var, BinaryOperatorType operator, FilePos& file_pos ) : Value
{
	auto l_in_register= CreateMoveToLLVMRegisterInstruction( l_var, function_context );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r_var, function_context );

	var Type& l_type= l_var.t;
	var Type& r_type= r_var.t;
	auto l_fundamental_type= l_type.GetFundamentalType();
	auto r_fundamental_type= r_type.GetFundamentalType();

	var Variable mut res
	{
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
	};

	if(
		operator == BinaryOperatorType::Add ||
		operator == BinaryOperatorType::Sub ||
		operator == BinaryOperatorType::Mul ||
		operator == BinaryOperatorType::Div ||
		operator == BinaryOperatorType::Rem )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, file_pos, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}
		if( l_fundamental_type.get_ref().GetSize() < 4s )
		{
			// Operation supported only for 32 and 64bit operands
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}

		var bool is_float= IsFloatingPoint( l_fundamental_type.get_ref().fundamental_type );
		if( !( IsInteger( l_fundamental_type.get_ref().fundamental_type  ) || is_float ) )
		{
			// this operations allowed only for integer and floating point operands.
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}

		var bool is_signed= IsSignedInteger( l_fundamental_type.get_ref().fundamental_type );

		res.t= l_type;

		unsafe
		{
				 if( operator == BinaryOperatorType::Add )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildAdd( function_context.llvm_ir_builder, l_in_register, r_in_register, "+\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::Sub )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildSub( function_context.llvm_ir_builder, l_in_register, r_in_register, "-\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::Mul )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildMul( function_context.llvm_ir_builder, l_in_register, r_in_register, "*\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::Div )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildSDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildUDiv( function_context.llvm_ir_builder, l_in_register, r_in_register, "/\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::Rem )
			{
				if( is_float )
				{
					res.llvm_value= LLVMBuildFRem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildSRem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildURem( function_context.llvm_ir_builder, l_in_register, r_in_register, "%\0"[0] );
				}
			}

			if( LLVMIsConstant( res.llvm_value ) == LLVMBool::True )
			{
				res.constexpr_value= res.llvm_value;

				if( LLVMIsUndef( res.constexpr_value ) == LLVMBool::True )
				{
					res.constexpr_value= LLVMValueRef::Null;
					REPORT_ERROR( ConstantExpressionResultIsUndefined, names_scope, file_pos )
				}
			}
		}
	}
	else if(
		operator == BinaryOperatorType::And ||
		operator == BinaryOperatorType::Or  ||
		operator == BinaryOperatorType::Xor )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, file_pos, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}
		if( !( IsInteger( l_fundamental_type.get_ref().fundamental_type ) || l_fundamental_type.get_ref().fundamental_type == U_FundamentalType::bool_ ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}

		res.t= l_type;

		unsafe
		{
				 if( operator == BinaryOperatorType::And )
			{
				res.llvm_value= LLVMBuildAnd( function_context.llvm_ir_builder, l_in_register, r_in_register, "&\0"[0] );
			}
			else if( operator == BinaryOperatorType::Or  )
			{
				res.llvm_value= LLVMBuildOr ( function_context.llvm_ir_builder, l_in_register, r_in_register, "|\0"[0] );
			}
			else if( operator == BinaryOperatorType::Xor )
			{
				res.llvm_value= LLVMBuildXor( function_context.llvm_ir_builder, l_in_register, r_in_register, "^\0"[0] );
			}
		}
	}
	else if(
		operator == BinaryOperatorType::ShiftLeft ||
		operator == BinaryOperatorType::ShiftRight )
	{
		if( l_fundamental_type.empty() || !IsInteger( l_fundamental_type.get_ref().fundamental_type ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}
		if( r_fundamental_type.empty() || !IsUnsignedInteger( r_fundamental_type.get_ref().fundamental_type ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope,file_pos, r_type )
			return ErrorValue();
		}

		auto mut l_value_for_op= l_in_register;
		auto mut r_value_for_op= r_in_register;

		res.t= l_type;

		unsafe
		{
			// Convert value of shift to type of shifted value. LLVM Reuqired this.
			if( r_fundamental_type.get_ref().GetSize() > l_fundamental_type.get_ref().GetSize() )
			{
				r_value_for_op= LLVMBuildTrunc( function_context.llvm_ir_builder, r_value_for_op, l_type.GetLLVMType(), "\0"[0] );
			}
			else if( r_fundamental_type.get_ref().GetSize() < l_fundamental_type.get_ref().GetSize() )
			{
				r_value_for_op= LLVMBuildZExt( function_context.llvm_ir_builder, r_value_for_op, l_type.GetLLVMType(), "\0"[0] );
			}

			if( operator == BinaryOperatorType::ShiftLeft )
			{
				res.llvm_value= LLVMBuildShl( function_context.llvm_ir_builder, l_value_for_op, r_value_for_op, "\0"[0] );
			}
			else if( operator == BinaryOperatorType::ShiftRight )
			{
				if( IsSignedInteger( l_fundamental_type.get_ref().fundamental_type ) )
				{
					res.llvm_value= LLVMBuildAShr( function_context.llvm_ir_builder, l_value_for_op, r_value_for_op, "\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildLShr( function_context.llvm_ir_builder, l_value_for_op, r_value_for_op, "\0"[0] );
				}
			}
			else{ halt; }
		}
	}
	else if(
		operator == BinaryOperatorType::Equal ||
		operator == BinaryOperatorType::NotEqual )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, file_pos, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() && l_type.GetEnumType().empty() && l_type.GetFunctionPointerType().empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}

		var bool if_float= !l_fundamental_type.empty() && IsFloatingPoint( l_fundamental_type.get_ref().fundamental_type );

		res.t= bool_type_;

		// Use ordered floating point compare operations, which result is false for NaN, except !=. nan != nan must be true.
		unsafe
		{
				 if( operator == BinaryOperatorType::Equal )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OEQ, l_in_register, r_in_register, "==\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::EQ, l_in_register, r_in_register, "==\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::NotEqual )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::UNE, l_in_register, r_in_register, "!=\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::NE, l_in_register, r_in_register, "!=\0"[0] );
				}
			}
		}
	}
	else if(
		operator == BinaryOperatorType::Less ||
		operator == BinaryOperatorType::LessEqual ||
		operator == BinaryOperatorType::Greater ||
		operator == BinaryOperatorType::GreaterEqual )
	{
		if( l_type != r_type )
		{
			REPORT_ERROR( NoMatchBinaryOperatorForGivenTypes, names_scope, file_pos, r_type, l_type, BinaryOperatorToString( operator ) )
			return ErrorValue();
		}
		if( l_fundamental_type.empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}

		var bool if_float= IsFloatingPoint( l_fundamental_type.get_ref().fundamental_type );
		var bool is_char= IsChar( l_fundamental_type.get_ref().fundamental_type );
		var bool is_signed= !is_char && IsSignedInteger( l_fundamental_type.get_ref().fundamental_type );
		if( !( IsInteger( l_fundamental_type.get_ref().fundamental_type ) || if_float || is_char ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_type )
			return ErrorValue();
		}

		res.t= bool_type_;

		unsafe
		{
				 if( operator == BinaryOperatorType::Less )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLT, l_in_register, r_in_register, "<\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLT, l_in_register, r_in_register, "<\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULT, l_in_register, r_in_register, "<\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::LessEqual )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OLE, l_in_register, r_in_register, "<=\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SLE, l_in_register, r_in_register, "<=\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULE, l_in_register, r_in_register, "<=\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::Greater )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGT, l_in_register, r_in_register, ">\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGT, l_in_register, r_in_register, ">\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGT, l_in_register, r_in_register, ">\0"[0] );
				}
			}
			else if( operator == BinaryOperatorType::GreaterEqual )
			{
				if( if_float )
				{
					res.llvm_value= LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OGE, l_in_register, r_in_register, ">=\0"[0] );
				}
				else if( is_signed )
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::SGE, l_in_register, r_in_register, ">=\0"[0] );
				}
				else
				{
					res.llvm_value= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::UGE, l_in_register, r_in_register, ">=\0"[0] );
				}
			}
		}
	}
	else{ halt; }

	unsafe{ if( LLVMIsConstant( res.llvm_value ) == LLVMBool::True ){ res.constexpr_value= res.llvm_value; }  }

	res.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, BinaryOperatorToString( operator ) );

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= res.t,
		.is_mutable= true,
		.llvm_value= res.llvm_value,
		.constexpr_value= res.constexpr_value,
		.node_id= res.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(res);
}

fn CodeBuilder::BuildLazyBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value
{
	var Variable l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.l.get_ref() );
	if( l_var.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch, names_scope, binary_operator.file_pos, bool_type_, l_var.t )
		return ErrorValue();
	}

	var LLVMBasicBlockRef mut l_part_block= zero_init, mut r_part_block= zero_init, mut block_after_operator= zero_init;
	unsafe
	{
		l_part_block= LLVMGetInsertBlock( function_context.llvm_ir_builder );
		r_part_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		block_after_operator= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
	}

	auto l_var_in_register= CreateMoveToLLVMRegisterInstruction( l_var, function_context );

	DestroyUnusedTemporaryVariables( names_scope, function_context, binary_operator.file_pos ); // Destroy right part temporaries.

	var [ ReferencesGraph, 2 ] mut branches_references_graphs;
	branches_references_graphs[0]= function_context.references_graph;

	unsafe
	{
		if( binary_operator.operator == BinaryOperatorType::LazyLogicalAnd )
		{
			LLVMBuildCondBr( function_context.llvm_ir_builder, l_var_in_register, r_part_block, block_after_operator );
		}
		else if( binary_operator.operator == BinaryOperatorType::LazyLogicalOr )
		{
			LLVMBuildCondBr( function_context.llvm_ir_builder, l_var_in_register, block_after_operator, r_part_block );
		}
		else { halt; }

		LLVMAppendExistingBasicBlock( function_context.llvm_function, r_part_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, r_part_block );
	}

	auto mut r_var_in_register= LLVMValueRef::Null;
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var Variable r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, binary_operator.r.get_ref() );
		if( r_var.t != bool_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, binary_operator.file_pos, bool_type_, r_var.t )
			return ErrorValue();
		}

		r_var_in_register= CreateMoveToLLVMRegisterInstruction( r_var, function_context );
		CallDestructorsForTopVariablesFrame( names_scope, function_context, binary_operator.file_pos );
	}

	branches_references_graphs[1]= function_context.references_graph;
	function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( branches_references_graphs, names_scope, binary_operator.file_pos );

	auto mut phi_node= LLVMValueRef::Null;
	unsafe
	{
		auto r_part_end_block= LLVMGetInsertBlock( function_context.llvm_ir_builder );
		LLVMBuildBr( function_context.llvm_ir_builder, block_after_operator );
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_operator );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_operator );

		phi_node= LLVMBuildPhi( function_context.llvm_ir_builder, fundamental_llvm_types_.bool_, "\0"[0] );

		var [ LLVMValueRef, 2 ] incoming_values[ l_var_in_register, r_var_in_register ];
		var [ LLVMBasicBlockRef, 2 ] incoming_blocks[ l_part_block, r_part_end_block ];
		LLVMAddIncoming( phi_node, incoming_values[0], incoming_blocks[0], 2u );
	}

	var Variable mut result
	{
		.t= bool_type_,
		.location= Variable::Location::LLVMRegister,
		.value_type= ValueType::Value,
		.llvm_value= phi_node
	};

	unsafe
	{
		if( LLVMIsConstant( l_var_in_register ) == LLVMBool::True && LLVMIsConstant( r_var_in_register ) == LLVMBool::True )
		{
			if( binary_operator.operator == BinaryOperatorType::LazyLogicalAnd )
			{
				result.constexpr_value= LLVMBuildAnd( function_context.llvm_ir_builder, l_var_in_register, r_var_in_register, "\0"[0] );
			}
			else if( binary_operator.operator == BinaryOperatorType::LazyLogicalOr )
			{
				result.constexpr_value= LLVMBuildOr ( function_context.llvm_ir_builder, l_var_in_register, r_var_in_register, "\0"[0] );
			}
			else{ halt; }
		}
	}

	result.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, BinaryOperatorToString( binary_operator.operator ) );

	// Register variable for references checking.
	var NamesScopeVariable mut names_scope_variable
	{
		.t= result.t,
		.is_mutable= true,
		.llvm_value= result.llvm_value,
		.constexpr_value= result.constexpr_value,
		.node_id= result.node_id,
	};
	function_context.variables_frames.back().push_back( move(names_scope_variable) );

	return move(result);
}

fn CodeBuilder::TryCallOverloadedBinaryOperator(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	OverloadedOperator operator,
	ust::shared_ptr_final</Synt::Expression/>& arg_l,
	ust::shared_ptr_final</Synt::Expression/>& arg_r,
	ArgsEvaluationOrder args_evaluation_order,
	FilePos& file_pos ) : ust::optional</Value/>
{
	var [ ust::shared_ptr_final</Synt::Expression/>, 2 ] in_args[ arg_l, arg_r ];

	var ust::vector</VariableTypeExtened/> mut args;

	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();
		auto instructions_state= SaveInstructionsState( function_context );

		foreach( &in_arg : in_args )
		{
			if( function_context.args_preevaluation_cache.find( in_arg ).empty() )
			{
				auto arg= BuildExpressionCodeEnsureVariable( names_scope, function_context, in_arg.get_ref() );
				var VariableTypeExtened mut f_arg{ .t(arg.t), .value_type= arg.value_type };
				function_context.args_preevaluation_cache.insert( in_arg, move(f_arg) );
			}
			args.push_back( function_context.args_preevaluation_cache[in_arg] );
		}

		RestoreInstructionsState( function_context, instructions_state );
	}

	if( operator == OverloadedOperator::Assign &&
		cast_imut(args).front().t == cast_imut(args).back().t &&
		( !cast_imut(args).front().t.GetClassType().empty() || !cast_imut(args).front().t.GetTupleType().empty() ) &&
		cast_imut(args).front().value_type == ValueType::ReferenceMut &&
		cast_imut(args).back().value_type == ValueType::Value )
	{
		// Do move assign.
		// TODO - what exact evaluation order should be here?

		var Variable r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_r.get_ref() );

		// Prevent modification of r_var during l_val calculation.
		var ReferencesGraph::NodeId mut r_var_lock_node= ReferencesGraph::c_empty_node_id;
		if( r_var.node_id != ReferencesGraph::c_empty_node_id )
		{
			var ust::string8 mut node_name= function_context.references_graph.GetNodeName( r_var.node_id ) + " lock";
			r_var_lock_node= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::ReferenceMut, move(node_name) );
			function_context.references_graph.AddLink( r_var.node_id, r_var_lock_node );
		}

		var Variable l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.get_ref() );

		if( r_var_lock_node != ReferencesGraph::c_empty_node_id )
		{
			function_context.references_graph.RemoveNode( r_var_lock_node );
		}

		BuildDestructorPart( names_scope, function_context, l_var.llvm_value, l_var.t, file_pos );

		SetupReferencesInCopyOrMove( names_scope, function_context, l_var.t, l_var.node_id, r_var.node_id, file_pos );

		if( r_var.node_id != ReferencesGraph::c_empty_node_id )
		{
			function_context.references_graph.MoveNode( r_var.node_id );
		}
		CopyBytes( l_var.llvm_value, r_var.llvm_value, r_var.t, function_context );

		var Variable mut move_result{ .t= void_type_for_ret_ };
		return Value( move(move_result) );
	}
	else if( cast_imut(args).front().t == cast_imut(args).back().t && !args.front().t.GetTupleType().empty() )
	{
		return CallBinaryOperatorForTuple( names_scope, function_context, operator, arg_l, arg_r, file_pos );
	}

	if_var( &overloaded_operator : GetOverloadedOperator( args.range(), operator, names_scope, file_pos ) )
	{
		if( overloaded_operator.is_deleted )
		{
			REPORT_ERROR( AccessingDeletedMethod, names_scope, file_pos )
			return ust::optional</Value/>();
		}
		if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
		{
			function_context.have_non_constexpr_operations_inside= true; // Can not call non-constexpr function in constexpr function.
		}

		return DoCallFunction(
			names_scope,
			function_context,
			overloaded_operator,
			ust::array_view_imut</ Variable />(),
			in_args,
			args_evaluation_order,
			file_pos );
	}

	return ust::optional</Value/>();
}

fn CodeBuilder::CallBinaryOperatorForTuple(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	OverloadedOperator operator,
	ust::shared_ptr_final</Synt::Expression/>& arg_l,
	ust::shared_ptr_final</Synt::Expression/>& arg_r,
	FilePos& file_pos ) : Value
{
	// Currently only copy assignment supported for tuples.
	if( operator != OverloadedOperator::Assign )
	{
		var Variable l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.get_ref() );
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_var.t )
		return ErrorValue();
	}

	var Variable r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_r.get_ref() );

	// Prevent modification of r_var during l_val calculation.
	var ReferencesGraph::NodeId mut r_var_lock_node= ReferencesGraph::c_empty_node_id;
	if( r_var.node_id != ReferencesGraph::c_empty_node_id )
	{
		var ust::string8 mut node_name= function_context.references_graph.GetNodeName( r_var.node_id ) + " lock";
		r_var_lock_node= function_context.references_graph.AddNode(
			select( r_var.value_type == ValueType::ReferenceMut ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
			move(node_name) );
		function_context.references_graph.AddLink( r_var.node_id, r_var_lock_node );
	}

	var Variable l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg_l.get_ref() );
	halt if( r_var.t != l_var.t ); // Checked before

	if( r_var_lock_node != ReferencesGraph::c_empty_node_id )
	{
		function_context.references_graph.RemoveNode( r_var_lock_node );
	}

	if( !l_var.t.IsCopyAssignable() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, l_var.t )
		return ErrorValue();
	}
	if( l_var.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, file_pos )
		return ErrorValue();
	}
	if( l_var.node_id != ReferencesGraph::c_empty_node_id && function_context.references_graph.HaveOutgoingLinks( l_var.node_id ) )
	{
		REPORT_ERROR( ReferenceProtectionError, names_scope, file_pos, function_context.references_graph.GetNodeName( l_var.node_id ) )
	}

	SetupReferencesInCopyOrMove( names_scope, function_context, l_var.t, l_var.node_id, r_var.node_id, file_pos );

	BuildCopyAssignmentOperatorPart( names_scope, function_context, l_var.llvm_value, r_var.llvm_value, l_var.t, file_pos );

	DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos );

	var Variable mut result{ .t= void_type_for_ret_ };
	return move(result);
}

fn CodeBuilder::CallFunctionsSet(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::optional_ref</ Variable, false /> mut this_,
	FunctionsSet& functions_set,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
	FilePos& file_pos ) : Value
{
	// Pre-evaluate arguments to know exact types and select exact function.
	var ust::vector</VariableTypeExtened/> mut args_evaluated;
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		auto instructions_state= SaveInstructionsState( function_context );

		if( !this_.empty() )
		{
			var VariableTypeExtened mut out_arg{ .t( this_.get_ref().t ), .value_type= this_.get_ref().value_type };
			args_evaluated.push_back( move(out_arg) );
		}

		foreach( &arg : args )
		{
			if( function_context.args_preevaluation_cache.find( arg ).empty() )
			{
				auto arg_variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, arg.get_ref() );
				var VariableTypeExtened mut out_arg{ .t( arg_variable.t ), .value_type= arg_variable.value_type };
				function_context.args_preevaluation_cache.insert( arg, move(out_arg) );
			}
			args_evaluated.push_back( function_context.args_preevaluation_cache[arg] );
		}

		RestoreInstructionsState( function_context, instructions_state );
	}

	auto mut function_selected=
		GetOverloadedFunction(
			functions_set,
			args_evaluated.range(),
			!this_.empty(),
			names_scope,
			file_pos,
			true );
	if( function_selected.empty() )
	{
		return ErrorValue();
	}

	if( function_selected.get_ref().is_deleted )
	{
		REPORT_ERROR( AccessingDeletedMethod, names_scope, file_pos )
		return ErrorValue();
	}

	if( !this_.empty() && !function_selected.get_ref().is_this_call )
	{
		this_.reset();
	}

	if( !this_.empty() )
	{
		auto fetch_res= TryFetchVirtualFunction( this_.get_ref(), function_selected.get_ref(), function_context );
		function_selected.get_ref().llvm_function= fetch_res[1];
		return DoCallFunction(
			names_scope,
			function_context,
			ust::optional_ref</Variable, false/>( fetch_res[0] ),
			function_selected.get_ref(),
			args,
			file_pos );
	}

	return DoCallFunction(
		names_scope,
		function_context,
		this_,
		function_selected.get_ref(),
		args,
		file_pos );
}

fn CodeBuilder::DoCallFunction(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::optional_ref</ Variable, false />& this_,
	FunctionVariable& function,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
	FilePos& file_pos ) : Value
{
	if( function.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
	{
		function_context.have_non_constexpr_operations_inside= true;
	}

	if( function.is_this_call && this_.empty() )
	{
		REPORT_ERROR( CallOfThiscallFunctionUsingNonthisArgument, names_scope, file_pos )
		return ErrorValue();
	}
	/* TODO - what if we call non-this-call function using "this", like
		struct S{ fn Foo( S& s ); }
		fn Bar( S& s ) { s.Foo(); }
	???
	*/

	var ust::vector</ Variable /> mut preevaluated_args;
	if( !this_.empty() )
	{
		preevaluated_args.push_back( this_.get_ref() );
	}

	return DoCallFunction(
		names_scope,
		function_context,
		function,
		preevaluated_args.range(),
		args,
		ArgsEvaluationOrder::Direct,
		file_pos );
}

fn CodeBuilder::DoCallFunction(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	FunctionVariable& function,
	ust::array_view_imut</ Variable />& preevaluated_args,
	ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
	ArgsEvaluationOrder args_evaluation_order,
	FilePos& file_pos ) : Value
{
	auto total_args= preevaluated_args.size() + args.size();

	var FunctionType& function_type= function.t;

	if( total_args != function_type.params.size() )
	{
		REPORT_ERROR( InvalidFunctionArgumentCount, names_scope, file_pos, total_args, function_type.params.size() )
		return ErrorValue();
	}

	// TODO - maybe forbid calling functions with incomplete type for returned reference?
	if( !function_type.return_value_is_reference && !EnsureTypeComplete( function_type.return_type ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, file_pos, function_type.return_type )
		return ErrorValue();
	}
	if( function_type.is_unsafe && !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( UnsafeFunctionCallOutsideUnsafeBlock, names_scope, file_pos )
	}

	var ust::vector</LLVMValueRef/> mut llvm_args;

	auto mut s_ret_value= LLVMValueRef::Null;
	auto is_s_ret= !function_type.return_value_is_reference && ( !function_type.return_type.GetClassType().empty() || !function_type.return_type.GetTupleType().empty() );
	if( is_s_ret )
	{
		unsafe{  s_ret_value= LLVMBuildAlloca( function_context.alloca_ir_builder, function_type.return_type.GetLLVMType(), "\0"[0] );  }
		llvm_args.push_back( s_ret_value );
	}

	auto first_llvm_arg_number= select( is_s_ret ? 1s : 0s );
	llvm_args.resize( first_llvm_arg_number + total_args, LLVMValueRef::Null );

	var ust::vector</ LLVMValueRef /> mut constexpr_args;
	auto mut is_constexpr= false;
	if( function.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete &&
		!function_type.return_value_is_reference )
	{
		is_constexpr= true;
		constexpr_args.resize( llvm_args.size(), LLVMValueRef::Null );
	}

	var ust::vector</ReferencesGraph::NodeId/> mut args_nodes, mut reference_args_inner_nodes;
	args_nodes.resize( total_args, ReferencesGraph::c_empty_node_id );
	reference_args_inner_nodes.resize( total_args, ReferencesGraph::c_empty_node_id );

	for( var size_type mut i= 0s; i < total_args; ++i )
	{
		auto arg_n= select( args_evaluation_order == ArgsEvaluationOrder::Direct ? i : total_args - i - 1s );
		auto &mut llvm_arg= llvm_args[ first_llvm_arg_number + arg_n ];

		auto& param= function_type.params[arg_n];
		var Type& expected_arg_type= param.t;
		auto arg=
			select( arg_n < preevaluated_args.size()
				? preevaluated_args[arg_n]
				: BuildExpressionCodeEnsureVariable( names_scope, function_context, args[ arg_n - preevaluated_args.size() ].get_ref() ) );

		if( is_constexpr && arg.constexpr_value != LLVMValueRef::Null && !( param.is_mutable && param.is_reference ) )
		{
			// TODO - what about types conversion in constexpr call?
			constexpr_args[ first_llvm_arg_number + arg_n ]= arg.constexpr_value;
		}
		else
		{
			is_constexpr= false;
		}

		if( param.is_reference )
		{
			if( param.is_mutable )
			{
				if( arg.value_type == ValueType::Value )
				{
					REPORT_ERROR( ExpectedReferenceValue, names_scope, file_pos )
				}
				else if( arg.value_type != ValueType::ReferenceMut )
				{
					REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, file_pos )
				}
			}
			if( arg.t != expected_arg_type && !arg.t.ReferenceIsConvertibleTo( expected_arg_type ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, file_pos, arg.t, expected_arg_type )
				return ErrorValue();
			}

			if( arg.node_id != ReferencesGraph::c_empty_node_id )
			{
				if( (  param.is_mutable && function_context.references_graph.HaveOutgoingLinks( arg.node_id ) ) ||
					( !param.is_mutable && function_context.references_graph.HaveOutgoingMutableNodes( arg.node_id ) ) )
				{
					REPORT_ERROR( ReferenceProtectionError, names_scope, file_pos, function_context.references_graph.GetNodeName( arg.node_id ) )
				}
				else
				{
					auto arg_node_id= function_context.references_graph.AddNode(
						select( param.is_mutable ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
						"_arg_" + ust::to_string8(arg_n) );
					args_nodes[arg_n]= arg_node_id;
					function_context.references_graph.AddLink( arg.node_id, arg_node_id );
				}

				if( expected_arg_type.GetInnerReferenceKind() != InnerReferenceKind::None )
				{
					var ReferencesGraph::NodesSet inner_references= function_context.references_graph.GetAllAccessibleVariableInnerNodes( arg.node_id );
					var bool mut is_mutable= false;
					foreach( inner_reference : inner_references )
					{
						is_mutable |= function_context.references_graph.GetNodeKind( inner_reference.key() ) == ReferencesGraph::NodeKind::ReferenceMut;
					}

					auto own_reference_node= function_context.references_graph.AddNode(
						select( is_mutable ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
						"arg" + ust::to_string8(arg_n) + "lock" );
					reference_args_inner_nodes[arg_n]= own_reference_node;

					foreach( &inner_reference_value : inner_references )
					{
						var ReferencesGraph::NodeId inner_reference= inner_reference_value.key();
						if( (  is_mutable && function_context.references_graph.HaveOutgoingLinks( inner_reference ) ) ||
							( !is_mutable && function_context.references_graph.HaveOutgoingMutableNodes( inner_reference ) ) )
						{
							REPORT_ERROR( ReferenceProtectionError, names_scope, file_pos, function_context.references_graph.GetNodeName( inner_reference ) )
						}
						else
						{
							function_context.references_graph.AddLink( inner_reference, own_reference_node );
						}
					}
				}
			}

			if( arg.location == Variable::Location::LLVMRegister )
			{
				// Bind value to const reference.
				unsafe
				{
					auto temp_storage= LLVMBuildAlloca( function_context.alloca_ir_builder, arg.t.GetLLVMType(), "\0"[0] );
					LLVMBuildStore( function_context.llvm_ir_builder, arg.llvm_value, temp_storage );
					llvm_arg= temp_storage;
				}
			}
			else
			{
				llvm_arg= arg.llvm_value;
			}

			llvm_arg= CreateReferenceCast( llvm_arg, arg.t, expected_arg_type, function_context );
		}
		else
		{
			if( !arg.t.ReferenceIsConvertibleTo( expected_arg_type ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, file_pos, arg.t, expected_arg_type )
				return ErrorValue();
			}

			if( arg.node_id != ReferencesGraph::c_empty_node_id )
			{
				auto arg_node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, "_arg_" + ust::to_string8(arg_n) );
				args_nodes[arg_n]= arg_node_id;

				if( expected_arg_type.GetInnerReferenceKind() != InnerReferenceKind::None )
				{
					var ReferencesGraph::NodesSet inner_references= function_context.references_graph.GetAllAccessibleVariableInnerNodes( arg.node_id );
					var bool mut is_mutable= false;
					foreach( inner_reference : inner_references )
					{
						is_mutable |= function_context.references_graph.GetNodeKind( inner_reference.key() ) == ReferencesGraph::NodeKind::ReferenceMut;
					}

					auto own_inner_reference= function_context.references_graph.CreateNodeInnerReference(
						arg_node_id,
						select( is_mutable ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ) );

					foreach( &inner_reference_value : inner_references )
					{
						var ReferencesGraph::NodeId inner_reference= inner_reference_value.key();
						if( (  is_mutable && function_context.references_graph.HaveOutgoingLinks( inner_reference ) ) ||
							( !is_mutable && function_context.references_graph.HaveOutgoingMutableNodes( inner_reference ) ) )
						{
							REPORT_ERROR( ReferenceProtectionError, names_scope, file_pos, function_context.references_graph.GetNodeName( inner_reference ) )
						}
						else
						{
							function_context.references_graph.AddLink( inner_reference, own_inner_reference );
						}
					}
				}
			}

			if( !arg.t.GetClassType().empty() || !arg.t.GetTupleType().empty() )
			{
				if( arg.value_type == ValueType::Value && arg.t == expected_arg_type )
				{
					// Move value to argument.
					if( arg.node_id != ReferencesGraph::c_empty_node_id )
					{
						function_context.references_graph.MoveNode( arg.node_id );
					}
					llvm_arg= arg.llvm_value;
				}
				else
				{
					auto mut var_copy= LLVMValueRef::Null;
					unsafe
					{
						var_copy= LLVMBuildAlloca( function_context.alloca_ir_builder, expected_arg_type.GetLLVMType(), "\0"[0] );
					}

					auto mut value_for_copy= CreateReferenceCast( arg.llvm_value, arg.t, expected_arg_type, function_context );
					BuildCopyConstructorPart( names_scope, function_context, var_copy, value_for_copy, expected_arg_type, file_pos );

					llvm_arg= var_copy;
				}
			}
			else
			{
				llvm_arg= CreateMoveToLLVMRegisterInstruction( arg, function_context );
			}
		}

		// Destroy unused temporary variables after each arg evaluation.
		DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos );
	}

	var Variable mut result
	{
		.t= function_type.return_type,
	};

	var ust::string8 mut node_name= "call result " + function_type.return_type.ToString();

	if( function_type.return_value_is_reference )
	{
		result.location= Variable::Location::Pointer;
		result.value_type= select( function_type.return_value_is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );

		result.node_id= function_context.references_graph.AddNode(
			select( function_type.return_value_is_mutable ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ),
			move(node_name) );
	}
	else
	{
		result.value_type= ValueType::Value;
		if( is_s_ret )
		{
			result.location= Variable::Location::Pointer;
			result.llvm_value= s_ret_value;
		}
		else
		{
			result.location= Variable::Location::LLVMRegister;
		}

		result.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, move(node_name) );
	}

	if( is_constexpr )
	{
		auto res= constexpr_function_evaluator_.Evaluate( function.llvm_function, constexpr_args.range() );

		if( res.errors.empty() )
		{
			result.constexpr_value= res.constant;

			if( is_s_ret )
			{
				MoveConstantToMemory( s_ret_value, res.constant, function_context );
			}
			else
			{
				result.llvm_value= result.constexpr_value;
			}
		}
		else
		{
			auto errors_container_ptr= names_scope.lock_imut().get_ref().GetErrors();
			auto mut lock= errors_container_ptr.lock_mut();
			auto &mut errors_container= lock.get_ref();
			foreach( &err : res.errors )
			{
				var CodeBuilderError mut out_error
				{
					.code= CodeBuilderErrorCode::ConstexprFunctionEvaluationError,
					.file_pos= file_pos,
					.text= err,
				};
				errors_container.push_back( move(out_error) );
			}
		}
	}

	if( result.constexpr_value == LLVMValueRef::Null )
	{
		// Perform regular call for non-constexpr function or in case of error in constexpr function evaluation.
		unsafe
		{
			auto call_result= LLVMBuildCall( function_context.llvm_ir_builder, function.llvm_function, cast_imut(llvm_args).front_unsafe(), u32(llvm_args.size()), "\0"[0] );
			if( !is_s_ret ){  result.llvm_value= call_result;  }
		}
	}

	// Remove temp inner nodes.
	foreach( node_id : reference_args_inner_nodes )
	{
		if( node_id != ReferencesGraph::c_empty_node_id )
		{
			function_context.references_graph.RemoveNode( node_id );
		}
	}

	// Prepare result references.
	if( function_type.return_value_is_reference )
	{
		foreach( &param_reference : function_type.return_references )
		{
			var size_type i(param_reference.param_index);
			if( args_nodes[i] == ReferencesGraph::c_empty_node_id )
			{
				continue;
			}

			// TODO - maybe check for errors before creating links?
			if( param_reference.reference_index == FunctionType::c_param_reference_number )
			{
				function_context.references_graph.AddLink( args_nodes[i], result.node_id );
			}
			if( param_reference.reference_index == 0u8 )
			{
				foreach( inner_node_value : function_context.references_graph.GetAllAccessibleVariableInnerNodes( args_nodes[i] ) )
				{
					function_context.references_graph.AddLink( inner_node_value.key(), result.node_id );
				}
			}
		}
	}
	else if( function_type.return_type.GetInnerReferenceKind() != InnerReferenceKind::None )
	{
		// First, know, what kind of reference we needs - mutable or immutable.
		var bool mut inner_reference_is_mutable= false;
		foreach( &param_reference : function_type.return_references )
		{
			var size_type i(param_reference.param_index);
			if( args_nodes[i] == ReferencesGraph::c_empty_node_id )
			{
				continue;
			}

			if( param_reference.reference_index == FunctionType::c_param_reference_number )
			{
				inner_reference_is_mutable |= function_context.references_graph.GetNodeKind( args_nodes[i] ) == ReferencesGraph::NodeKind::ReferenceMut;
			}
			if( param_reference.reference_index == 0u8 )
			{
				foreach( inner_node_value : function_context.references_graph.GetAllAccessibleVariableInnerNodes( args_nodes[i] ) )
				{
					inner_reference_is_mutable |= function_context.references_graph.GetNodeKind( inner_node_value.key() ) == ReferencesGraph::NodeKind::ReferenceMut;
				}
			}
		}

		// Then, create inner node and link input nodes with it.
		var ReferencesGraph::NodeId inner_node_id=
			function_context.references_graph.CreateNodeInnerReference(
				result.node_id,
				select( inner_reference_is_mutable ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ) );

		foreach( &param_reference : function_type.return_references )
		{
			var size_type i(param_reference.param_index);
			if( args_nodes[i] == ReferencesGraph::c_empty_node_id )
			{
				continue;
			}

			// TODO - maybe check for errors before creating links?
			if( param_reference.reference_index == FunctionType::c_param_reference_number )
			{
				function_context.references_graph.AddLink( args_nodes[i], inner_node_id );
			}
			if( param_reference.reference_index == 0u8 )
			{
				foreach( inner_node_value : function_context.references_graph.GetAllAccessibleVariableInnerNodes( args_nodes[i] ) )
				{
					function_context.references_graph.AddLink( inner_node_value.key(), inner_node_id );
				}
			}
		}
	}

	// Setup references after call.
	foreach( &reference_pollution : function_type.references_pollution )
	{
		var size_type dst_arg(reference_pollution.dst.param_index);
		var size_type src_arg(reference_pollution.src.param_index);
		if( function_type.params[ dst_arg ].t.GetInnerReferenceKind() == InnerReferenceKind::None ||
			args_nodes[src_arg] == ReferencesGraph::c_empty_node_id ||
			args_nodes[dst_arg] == ReferencesGraph::c_empty_node_id ||
			!function_type.params[ dst_arg ].is_reference ) // Skip reference pollution for value params. TODO - is this correct?
		{
			continue;
		}

		var ReferencesGraph::NodesSet mut src_nodes;
		var bool mut src_variables_is_mut= false;
		if( reference_pollution.src.reference_index == FunctionType::c_param_reference_number )
		{
			// Reference-arg itself.
			src_nodes.insert( args_nodes[src_arg], 0 );

			src_variables_is_mut= function_type.params[src_arg].is_mutable;
		}
		else
		{
			// Variables, referenced by inner references_graph references.
			src_nodes= function_context.references_graph.GetAllAccessibleVariableInnerNodes( args_nodes[src_arg] );

			foreach( &node_id_value : src_nodes )
			{
				src_variables_is_mut|= function_context.references_graph.GetNodeKind( node_id_value.key() ) == ReferencesGraph::NodeKind::ReferenceMut;
			}
		}

		var bool dst_inner_reference_is_mut= function_type.params[ dst_arg ].t.GetInnerReferenceKind() == InnerReferenceKind::Mut;
		// Even if reference-pollution is mutable, but if src vars is immutable, link as immutable.
		var bool result_node_is_mut= src_variables_is_mut && dst_inner_reference_is_mut;

		foreach( &dst_node_value : function_context.references_graph.GetAllAccessibleVariableNodes( args_nodes[dst_arg] ) )
		{
			var ReferencesGraph::NodeId dst_node= dst_node_value.key();
			var ReferencesGraph::NodeId mut inner_reference_node_id= function_context.references_graph.GetNodeInnerReference( dst_node );
			if( inner_reference_node_id == ReferencesGraph::c_empty_node_id )
			{
				inner_reference_node_id= function_context.references_graph.CreateNodeInnerReference(
					dst_node,
					select( result_node_is_mut ? ReferencesGraph::NodeKind::ReferenceMut : ReferencesGraph::NodeKind::ReferenceImut ) );
			}

			if( function_context.references_graph.GetNodeKind( inner_reference_node_id ) != ReferencesGraph::NodeKind::ReferenceMut && result_node_is_mut )
			{
				REPORT_ERROR( NotImplemented, names_scope, file_pos, ust::string8( "changing inner node reference kind immutable to mutable" ) )
			}

			// TODO - check here for errors.
			foreach( & src_node_id_value : src_nodes )
			{
				function_context.references_graph.AddLink( src_node_id_value.key(), inner_reference_node_id );
			}
		}
	}

	// Remove temp nodes.
	foreach( node_id : args_nodes )
	{
		if( node_id != ReferencesGraph::c_empty_node_id )
		{
			function_context.references_graph.RemoveNode( node_id );
		}
	}

	DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos ); // Destroy temporary args.

	{ 	// Register result variable for destruction and references graph checks.
		var NamesScopeVariable mut names_scope_variable
		{
			.t= result.t,
			.is_mutable= true,
			.llvm_value= result.llvm_value,
			.constexpr_value= result.constexpr_value,
			.node_id= result.node_id,
		};
		function_context.variables_frames.back().push_back( move(names_scope_variable) );
	}

	return move(result);
}

fn CodeBuilder::BuildTempVariableConstruction(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	Type& t,
	ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args,
	FilePos& file_pos ) : Value
{
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, file_pos, t )
		return ErrorValue();
	}
	if( t.IsAbstract() )
	{
		REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, file_pos, t )
		return ErrorValue();
	}

	var Variable mut result
	{
		.t= t,
		.location= Variable::Location::Pointer,
		.value_type= ValueType::Value,
	};

	auto name= "_temp_" + t.ToString() + "\0";
	unsafe{  result.llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), name.front() );  }

	result.node_id= function_context.references_graph.AddNode( ReferencesGraph::NodeKind::Variable, name );

	{
		var NamesScopeVariable mut names_scope_variable
		{
			.t= t,
			.is_mutable= true,
			.llvm_value= result.llvm_value,
			.node_id= result.node_id,
		};
		result.constexpr_value= BuildConstructorInitializer( names_scope, function_context, names_scope_variable, args, file_pos );

		function_context.variables_frames.back().push_back( move(names_scope_variable) );
	}

	return move(result);
}

} // namespace U1
