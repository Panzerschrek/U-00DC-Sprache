import "/string_conversions.u"
import "/keywords.uh"
import "mangling.uh"

namespace U1
{

fn CreateManglerMSVC(bool is_32_bit) : ust::box</IMangler/>
{
	return ust::make_box(ManglerMSVC(is_32_bit));
}

class ManglerMSVC final : IMangler
{
public:
	fn constructor(bool is_32_bit);

	fn virtual override MangleFunction(
		mut this,
		NamesScope& parent_scope,
		ust::string8& name,
		FunctionType& function_type ) : ust::string8;

	fn virtual override MangleFunction(
		mut this,
		NamesScope& parent_scope,
		ust::string8& name,
		FunctionType& function_type,
		TemplateArgsFinished& template_args ) : ust::string8;

	fn virtual override MangleGlobalVariable( mut this, NamesScope& parent_scope, ust::string8& variable_name, Type& t, bool is_constant ) : ust::string8;
	fn virtual override MangleType( mut this, Type& t ) : ust::string8;
	fn virtual override MangleTemplateArgs( mut this, TemplateArgsFinished& template_args ) : ust::string8;
	fn virtual override MangleVirtualTable( mut this, Type& t ) : ust::string8;

private:
	fn MangleFunctionImpl(
		mut this,
		NamesScope& parent_scope,
		ust::string8& name,
		FunctionType& function_type,
		ust::optional_ref_imut</TemplateArgsFinished/> template_args ) : ust::string8;

	fn EncodeType( this, ManglerStateMSVC &mut mangler_state, Type& t );
	fn EncodeFunctionType( this, ManglerStateMSVC &mut mangler_state, FunctionType& function_type, bool encode_full_type );
	fn EncodeFunctionParams( this, ManglerStateMSVC &mut mangler_state, ust::vector</FunctionType::Param/>& params );
	fn EncodeTemplateArgs( this, ManglerStateMSVC &mut mangler_state, TemplateArgsFinished& template_args );
	fn EncodeFullName( this, ManglerStateMSVC &mut mangler_state, ust::array_view_imut</char8/> name, NamesScope& scope );
	fn EncodeNamespacePostfix_r( this, ManglerStateMSVC &mut mangler_state, NamesScope& scope );
	fn EncodeTemplateClassName( this, ManglerStateMSVC &mut mangler_state, ClassType& the_class );
	fn EncodeNumber( this, ManglerStateMSVC &mut mangler_state, i64 num );
	fn EncodeNumber( this, ManglerStateMSVC &mut mangler_state, u64 num );

private:
	ust::string8 imut pointer_types_modifier_;
}

fn ManglerMSVC::constructor(bool is_32_bit)
	( pointer_types_modifier_( select( is_32_bit ? ust::string8("") : ust::string8("E") ) ) )
{
}

fn ManglerMSVC::MangleFunction(
	mut this,
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type ) : ust::string8
{
	return MangleFunctionImpl( parent_scope, name, function_type, ust::optional_ref_imut</TemplateArgsFinished/>() );
}

fn ManglerMSVC::MangleFunction(
	mut this,
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type,
	TemplateArgsFinished& template_args ) : ust::string8
{
	return MangleFunctionImpl( parent_scope, name, function_type, ust::optional_ref_imut</TemplateArgsFinished/>(template_args) );
}

fn ManglerMSVC::MangleGlobalVariable( mut this, NamesScope& parent_scope, ust::string8& variable_name, Type& t, bool is_constant ) : ust::string8
{
	var ManglerStateMSVC mut mangler_state;

	mangler_state.PushElement( g_name_prefix );
	EncodeFullName( mangler_state, variable_name.range(), parent_scope );

	mangler_state.PushElement( "3"c8 ); // Special name for global variables.
	EncodeType( mangler_state, t );
	mangler_state.PushElement( select( is_constant ? g_imut_prefix : g_mut_prefix ) );

	return MakeNullTerminatedString( mangler_state.TakeRes() );
}

fn ManglerMSVC::MangleType( mut this, Type& t ) : ust::string8
{
	var ManglerStateMSVC mut mangler_state;
	EncodeType( mangler_state, t );
	return MakeNullTerminatedString( mangler_state.TakeRes() );
}

fn ManglerMSVC::MangleTemplateArgs( mut this, TemplateArgsFinished& template_args ) : ust::string8
{
	var ManglerStateMSVC mut mangler_state;
	EncodeTemplateArgs( mangler_state, template_args );
	return MakeNullTerminatedString( mangler_state.TakeRes() );
}

fn ManglerMSVC::MangleVirtualTable( mut this, Type& t ) : ust::string8
{
	var ManglerStateMSVC mut mangler_state;

	mangler_state.PushElement( g_name_prefix );
	mangler_state.PushElement( "?_7" ); // Special name for virtual functions table.
	EncodeNamespacePostfix_r( mangler_state, t.GetClassType().try_deref().lock_imut().deref().members.lock_imut().deref() );
	mangler_state.PushElement( g_terminator ); // Finish list of name components
	mangler_state.PushElement( "6" ); // "6" for "vftable"
	mangler_state.PushElement( g_imut_prefix );
	mangler_state.PushElement( g_terminator );

	return MakeNullTerminatedString( mangler_state.TakeRes() );
}

fn ManglerMSVC::MangleFunctionImpl(
	mut this,
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type,
	ust::optional_ref_imut</TemplateArgsFinished/> template_args ) : ust::string8
{
	// For class methods do not encode stuff like access labels, or methods-related stuff.
	// Just encode class methods as regular functions inside namespaces, with "this" as regular param.

	var ManglerStateMSVC mut mangler_state;

	mangler_state.PushElement( g_name_prefix );

	auto op_name= GetOperatorNameMSVC( name );

	if( !template_args.empty() )
	{
		// Use separate backreferences table.
		var ManglerStateMSVC mut template_mangler_state;
		{
			template_mangler_state.PushElement( g_template_prefix );
			if( !op_name.empty() )
			{
				template_mangler_state.PushElement( op_name );
			}
			else
			{
				template_mangler_state.EncodeName( name.range() );
			}
			EncodeTemplateArgs( template_mangler_state, template_args.try_deref() );
		}
		// Do not create backreference for template name, just push template name instead.
		mangler_state.PushElement( template_mangler_state.TakeRes().range() );
	}
	else
	{
		if( !op_name.empty() )
		{
			mangler_state.PushElement( op_name );
		}
		else
		{
			mangler_state.EncodeName( name.range() );
		}
	}

	EncodeNamespacePostfix_r( mangler_state, parent_scope );
	// Finish list of name components.
	mangler_state.PushElement( g_terminator );

	// Access label. Use global access modifier. There is no reason to use real access modifiers for class members
	mangler_state.PushElement( "Y" );

	// No need to encode full function type, like "unsafe" flag or return references/references pollution,
	// since it's not possible to overload function unsing only such data.
	auto encode_full_function_type= false;
	EncodeFunctionType( mangler_state, function_type, encode_full_function_type );

	return MakeNullTerminatedString( mangler_state.TakeRes() );
}

fn ManglerMSVC::EncodeType( this, ManglerStateMSVC &mut mangler_state, Type& t )
{
	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		mangler_state.PushElement( GetFundamentalTypeNameMSVC( fundamental_type.fundamental_type ) );
		return;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		// Process nested arrays.
		var ust::vector</u64/> mut dimensions;

		var Type mut element_type= t;
		while( true )
		{
			if_var( element_type_as_array_type : element_type.GetArrayType() )
			{
				dimensions.push_back( element_type_as_array_type.element_count );
				auto mut t= element_type_as_array_type.element_type;
				element_type= move(t);
				continue;
			}
			break;
		}

		mangler_state.PushElement( "Y" );
		EncodeNumber( mangler_state, u64(dimensions.size()) );
		foreach( dimension_size : dimensions )
		{
			EncodeNumber( mangler_state, dimension_size );
		}
		EncodeType( mangler_state, element_type );

		return;
	}
	if_var( &tuple_type : t.GetTupleType() )
	{
		// Encode tuples, like type templates.
		var TemplateArgsFinished mut template_args;
		foreach( &element_type : tuple_type.element_types )
		{
			template_args.push_back( element_type );
		}

		mangler_state.PushElement( g_class_type_prefix );

		// Use separate backreferences table.
		{
			var ManglerStateMSVC mut template_mangler_state;

			template_mangler_state.PushElement( g_template_prefix );
			template_mangler_state.EncodeName( KeywordToString( Keyword::tup_ ) );
			EncodeTemplateArgs( template_mangler_state, template_args );

			mangler_state.EncodeNameNoTerminator( template_mangler_state.TakeRes().range() );
		}
		// Finish class name.
		mangler_state.PushElement( g_terminator );

		return;
	}
	if_var( &class_type_ptr : t.GetClassType() )
	{
		auto class_lock= class_type_ptr.lock_imut();
		auto& class_type= class_lock.deref();
		auto class_members= class_type.members;
		auto class_members_lock= class_members.lock_imut();
		auto& class_members_ref= class_members_lock.deref();

		mangler_state.PushElement( g_class_type_prefix );

		if( !class_type.typeinfo_src_type_.empty() )
		{
			// Encode typeinfo, like type template.

			// Use separate backreferences table.
			{
				var ManglerStateMSVC mut template_mangler_state;

				template_mangler_state.PushElement( g_template_prefix );
				template_mangler_state.EncodeName( class_members_ref.GetThisNamespaceName().range() );
				EncodeType( template_mangler_state, class_type.typeinfo_src_type_.try_deref() );
				// Finish list of template arguments.
				template_mangler_state.PushElement( g_terminator );

				mangler_state.EncodeNameNoTerminator( template_mangler_state.TakeRes().range() );
			}
			// Finish class name.
			mangler_state.PushElement( g_terminator );
		}
		else if( !class_type.base_template.empty() )
		{
			EncodeTemplateClassName( mangler_state, class_type );
			// Finish list of name components.
			mangler_state.PushElement( g_terminator );
		}
		else
		{
			EncodeFullName( mangler_state, class_members_ref.GetThisNamespaceName().range(), class_members_ref.GetParent().try_lock_imut().deref() );
		}
		return;
	}
	if_var( &enum_type : t.GetEnumType() )
	{
		mangler_state.PushElement( "W" );
		mangler_state.PushElement( "4" ); // Underlaying type. Modern MSVC uses "4" for all enums independent on underlaying type.

		auto enum_members= enum_type.lock_imut().deref().names_scope;
		auto enum_members_lock= enum_members.lock_imut();
		auto& enum_members_ref= enum_members_lock.deref();
		EncodeFullName( mangler_state, enum_members_ref.GetThisNamespaceName().range(), enum_members_ref.GetParent().try_lock_imut().deref() );
		return;
	}
	if_var( &raw_poiter_type : t.GetRawPointerType() )
	{
		mangler_state.PushElement( g_pointer_prefix );
		mangler_state.PushElement( pointer_types_modifier_.range() );
		mangler_state.PushElement( g_mut_prefix );
		EncodeType( mangler_state, raw_poiter_type.element_type );
		return;
	}
	if_var( &function_pointer_type : t.GetFunctionPointerType() )
	{
		mangler_state.PushElement( g_pointer_prefix );
		mangler_state.PushElement( "6" );
		EncodeFunctionType( mangler_state, function_pointer_type.function_type, true );
		return;
	}
	if_var( &function_type : t.GetFunctionType() )
	{
		EncodeFunctionType( mangler_state, function_type, true );
		return;
	}

	halt;
}

fn ManglerMSVC::EncodeFunctionType( this, ManglerStateMSVC &mut mangler_state, FunctionType& function_type, bool encode_full_type )
{
	mangler_state.PushElement( GetCallingConventionName( function_type.calling_convention ) );

	if( function_type.return_value_type != ValueType::Value )
	{
		mangler_state.PushElement( g_reference_prefix );
		mangler_state.PushElement( pointer_types_modifier_.range() );
		mangler_state.PushElement( select( function_type.return_value_type == ValueType::ReferenceMut ? g_mut_prefix : g_imut_prefix ) );
	}
	else if(
		!function_type.return_type.GetClassType().empty()||
		!function_type.return_type.GetEnumType().empty() ||
		!function_type.return_type.GetTupleType().empty() )
	{
		mangler_state.PushElement( "?" );
		mangler_state.PushElement( g_mut_prefix ); // Return value is mutable
	}

	EncodeType( mangler_state, function_type.return_type );

	EncodeFunctionParams( mangler_state, function_type.params );

	var bool mut params_empty= function_type.params.empty();

	if( encode_full_type )
	{
		// Encode additional function properties as params.
		if( function_type.is_unsafe )
		{
			// Encode "unsafe" flag as param of type "unsafe".
			params_empty= false;

			mangler_state.PushElement( g_class_type_prefix );
			mangler_state.PushElement( KeywordToString( Keyword::unsafe_ ) );
			// Finish list of name components.
			mangler_state.PushElement( g_terminator );
			// Finish class name.
			mangler_state.PushElement( g_terminator );
		}
		if( !function_type.return_references.empty() )
		{
			// Encode return references, like template class with special name and numeric args.
			params_empty= false;

			mangler_state.PushElement( g_class_type_prefix );

			// Use separate backreferences table.
			{
				var ManglerStateMSVC mut template_mangler_state;

				template_mangler_state.PushElement( g_template_prefix );
				template_mangler_state.EncodeName( "_RR" );
				foreach( &arg_and_tag : function_type.return_references )
				{
					template_mangler_state.PushElement( g_numeric_template_arg_prefix );
					EncodeNumber( template_mangler_state, u64(arg_and_tag.param_index)  );
					template_mangler_state.PushElement( g_numeric_template_arg_prefix );
					EncodeNumber( template_mangler_state, u64(arg_and_tag.reference_index) );
				}
				// Finish list of template args.
				template_mangler_state.PushElement( g_terminator );

				mangler_state.EncodeNameNoTerminator( template_mangler_state.TakeRes().range() );
			}
			// Finish class name.
			mangler_state.PushElement( g_terminator );
		}
		if( !function_type.references_pollution.empty() )
		{
			// Encode references pollution like template class with special name and numeric args.
			params_empty= false;

			mangler_state.PushElement( g_class_type_prefix );

			// Use separate backreferences table.
			{
				var ManglerStateMSVC mut template_mangler_state;

				template_mangler_state.PushElement( g_template_prefix );
				template_mangler_state.EncodeName( "_RP" );
				foreach( &pollution : function_type.references_pollution )
				{
					template_mangler_state.PushElement( g_numeric_template_arg_prefix );
					EncodeNumber( template_mangler_state, u64(pollution.dst.param_index) );
					template_mangler_state.PushElement( g_numeric_template_arg_prefix );
					EncodeNumber( template_mangler_state, u64(pollution.dst.reference_index) );
					template_mangler_state.PushElement( g_numeric_template_arg_prefix );
					EncodeNumber( template_mangler_state, u64(pollution.src.param_index) );
					template_mangler_state.PushElement( g_numeric_template_arg_prefix );
					EncodeNumber( template_mangler_state, u64(pollution.src.reference_index) );
				}
				// Finish list of template args.
				template_mangler_state.PushElement( g_terminator );

				mangler_state.EncodeNameNoTerminator( template_mangler_state.TakeRes().range() );
			}
			// Finish class name.
			mangler_state.PushElement( g_terminator );
		}
	}

	if( params_empty )
	{
		mangler_state.PushElement( GetFundamentalTypeNameMSVC( U_FundamentalType::void_ ) ); // In case of empty params just leave single type - "void" without terminator symbol.
	}
	else
	{
		mangler_state.PushElement( g_terminator ); // Finish list of params.
	}

	mangler_state.PushElement( "Z" );
}

fn ManglerMSVC::EncodeFunctionParams( this, ManglerStateMSVC &mut mangler_state, ust::vector</FunctionType::Param/>& params )
{
	var ust::vector</FunctionType::Param/> mut back_references;

	foreach( & param : params )
	{
		if( param.value_type == ValueType::Value && !param.t.GetFundamentalType().empty() )
		{
			// For trivial params (fundamentals with no reference modifiers) do not create backreferences.
			EncodeType( mangler_state, param.t );
		}
		else
		{

			var bool mut found = false;
			for( auto mut i= 0s; i < back_references.size(); ++i )
			{
				if( param == back_references[i] )
				{
					mangler_state.PushElement( char8(i + size_type("0"c8)) );
					found= true;
					break;
				}
			}

			if( !found )
			{
				if( param.value_type != ValueType::Value )
				{
					mangler_state.PushElement( g_reference_prefix );
					mangler_state.PushElement( pointer_types_modifier_.range() );
					mangler_state.PushElement( select( param.value_type == ValueType::ReferenceMut ? g_mut_prefix : g_imut_prefix ) );
				}

				EncodeType( mangler_state, param.t );

				if( back_references.size() < g_num_back_references )
				{
					back_references.push_back( param );
				}
			}
		}
	}
}

fn ManglerMSVC::EncodeTemplateArgs( this, ManglerStateMSVC &mut mangler_state, TemplateArgsFinished& template_args )
{
	foreach( template_arg : template_args )
	{
		if_var( &t : template_arg.get</Type/>() )
		{
			if( !t.GetArrayType().empty() )
			{
				mangler_state.PushElement( "$$B" );
			}

			EncodeType( mangler_state, t );
		}
		if_var( &v : template_arg.get</Variable/>() )
		{
			// HACK!
			// This is not how C++ compiler encodes value template args.
			// In C++ this is just numbers.
			// In Ü it's possible to create several type templates with same name and single value template param
			// but with different param type.
			// And it's possible to use same numeric value with diffirent types for instantiation of different type templates.
			// So, we need to distinguish between such template types.
			// Because of that prefix each numeric arg with type, like this is just hidden type param for each value param.
			EncodeType( mangler_state, v.t );

			mangler_state.PushElement( g_numeric_template_arg_prefix );

			auto mut is_signed= false;
			if_var( fundamental_type : v.t.GetFundamentalType() )
			{
				is_signed= IsSignedInteger( fundamental_type.fundamental_type );
			}
			if_var( enum_type : v.t.GetEnumType() )
			{
				is_signed= IsSignedInteger( enum_type.lock_imut().deref().underlaying_type.fundamental_type );
			}

			unsafe
			{
				if( is_signed )
				{
					EncodeNumber( mangler_state, LLVMConstIntGetSExtValue( v.constexpr_value ) );
				}
				else
				{
					EncodeNumber( mangler_state, LLVMConstIntGetZExtValue( v.constexpr_value ) );
				}
			}
		}
	}

	// Finish list of arguments.
	mangler_state.PushElement( g_terminator );
}

fn ManglerMSVC::EncodeFullName( this, ManglerStateMSVC &mut mangler_state, ust::array_view_imut</char8/> name, NamesScope& scope )
{
	mangler_state.EncodeName( name );
	EncodeNamespacePostfix_r( mangler_state, scope );
	// Finish list of name components.
	mangler_state.PushElement(g_terminator );
}

fn ManglerMSVC::EncodeNamespacePostfix_r( this, ManglerStateMSVC &mut mangler_state, NamesScope& scope )
{
	if( scope.GetParent().empty() ) // Root namespace.
	{
		return;
	}

	auto class_ptr= scope.GetClass();
	if( !class_ptr.empty() )
	{
		auto class_lock= class_ptr.try_lock_imut();
		auto& class_= class_lock.deref();
		if( !class_.base_template.empty() )
		{
			EncodeTemplateClassName( mangler_state, class_ );
			return;
		}
	}

	mangler_state.EncodeName( scope.GetThisNamespaceName().range() );

	EncodeNamespacePostfix_r( mangler_state, scope.GetParent().try_lock_imut().deref() );
}

fn ManglerMSVC::EncodeTemplateClassName( this, ManglerStateMSVC &mut mangler_state, ClassType& the_class )
{
	var TypeTemplatePtr& type_template_ptr= the_class.base_template.try_deref().class_template;
	var TypeTemplate& type_template= type_template_ptr.deref();

	// Use separate backreferences table.
	{
		var ManglerStateMSVC mut template_mangler_state;

		template_mangler_state.PushElement( g_template_prefix );
		template_mangler_state.EncodeName( type_template.syntax_element.deref().name.range() );
		EncodeTemplateArgs( template_mangler_state, the_class.base_template.try_deref().signature_args );

		mangler_state.EncodeNameNoTerminator( template_mangler_state.TakeRes().range() );
	}

	EncodeNamespacePostfix_r( mangler_state, type_template.parent_names_scope.lock().try_lock_imut().deref() );
}

fn ManglerMSVC::EncodeNumber( this, ManglerStateMSVC &mut mangler_state, i64 num )
{
	if( num < 0i64 )
	{
		mangler_state.PushElement( "?" );
		EncodeNumber( mangler_state, u64(-num) );
	}
	else
	{
		EncodeNumber( mangler_state, u64(num) );
	}
}

fn ManglerMSVC::EncodeNumber( this, ManglerStateMSVC &mut mangler_state, u64 num )
{
	if( num == 0u64 )
	{
		mangler_state.PushElement( "A@" );
	}
	else if( num <= 10u64 )
	{
		mangler_state.PushElement( char8(num - 1u64 + u64("0"c8)) );
	}
	else
	{
		// Use hex numbers with digits in range [A;Q)
		var i64 mut hex_digit(15);
		while((num & (u64(0xF) << u64(hex_digit << 2u))) == 0u64)
		{
			--hex_digit; // It's impossible to reach zero here since "num" is non-zero.
		}

		while(hex_digit >= 0i64)
		{
			mangler_state.PushElement( char8(u64("A"c8) + ((num >> u64(hex_digit << 2u)) & u64(0xF))) );
			--hex_digit;
		}

		// Finish list of digits.
		mangler_state.PushElement( g_terminator );
	}
}

class ManglerStateMSVC
{
public:

	// Push name and possible create or use backreferences.
	fn EncodeName( mut this, ust::array_view_imut</char8/> str )
	{
		EncodeNameImpl( str, true );
	}

	fn EncodeNameNoTerminator( mut this, ust::array_view_imut</char8/> str )
	{
		EncodeNameImpl( str, false );
	}

	// Push non-name element (no need to create backreferences for it).
	fn PushElement( mut this, ust::array_view_imut</char8/> str )
	{
		res_+= str;
	}

	fn PushElement( mut this, char8 c )
	{
		res_.push_back( c );
	}

	fn TakeRes( mut this ) : ust::string8
	{
		return take(res_);
	}

private:
	fn EncodeNameImpl( mut this, ust::array_view_imut</char8/> str, bool use_terminator )
	{
		for( auto mut i= 0s; i < g_num_back_references; ++i )
		{
			var BackReference br= back_references_[i];
			if( res_.range().subrange( size_type(br.pos), size_type(br.pos + br.count) ) == str )
			{
				res_.push_back( char8(i + size_type("0"c8) ) );
				return;
			}
			if( br.count == 0u )
			{
				// Reached empty space - fill it.
				back_references_[i].pos= u32(res_.size());
				back_references_[i].count= u32(str.size());
				break;
			}
		}

		// Not found or reached backreferences limit.
		res_+= str;
		if( use_terminator )
		{
			res_.push_back( g_terminator );
		}
	}

private:
	// Store backreference as position and length in destination string.
	struct BackReference{ u32 pos= 0u; u32 count= 0u; }

private:
	[ BackReference, g_num_back_references ] back_references_;
	ust::string8 res_;
}

fn GetOperatorNameMSVC( ust::string8& o ) : ust::array_view_imut</ char8 />
{
	if( o == "+" ){ return "?H"; }
	if( o == "-" ){ return "?G"; }
	if( o == "*" ){ return "?D"; }
	if( o == "/" ){ return "?K"; }
	if( o == "%" ){ return "?L"; }

	if( o == "==" ){ return "?8"; }
	if( o == "<=>" ){ return "?__M"; } // C++ spaceship operator

	if( o == "&" ){ return "?I"; }
	if( o == "|" ){ return "?U"; }
	if( o == "^" ){ return "?T"; }

	if( o == "<<" ){ return "?6"; }
	if( o == ">>" ){ return "?5"; }

	if( o == "+=" ){ return "?Y"; }
	if( o == "-=" ){ return "?Z"; }
	if( o == "*=" ){ return "?X"; }
	if( o == "/=" ){ return "?_0"; }
	if( o == "%=" ){ return "?_1"; }

	if( o == "&=" ){ return "?_4"; }
	if( o == "|=" ){ return "?_5"; }
	if( o == "^=" ){ return "?_6"; }

	if( o == "<<=" ){ return "?_3"; }
	if( o == ">>=" ){ return "?_2"; }

	if( o == "!" ){ return "?7"; }
	if( o == "~" ){ return "?S"; }

	if( o == "=" ){ return "?4"; }
	if( o == "++" ){ return "?E"; }
	if( o == "--" ){ return "?F"; }

	if( o == "()" ){ return "?R"; }
	if( o == "[]" ){ return "?A"; }

	return "";
}

fn GetFundamentalTypeNameMSVC( U_FundamentalType t ) : ust::array_view_imut</ char8 />
{
	if( t == U_FundamentalType::InvalidType ){ return ""; }
	if( t == U_FundamentalType::LastType	){ return ""; }
	if( t == U_FundamentalType::void_		){ return "X"; }
	if( t == U_FundamentalType::bool_		){ return "_N"; }
	if( t == U_FundamentalType::i8_			){ return "C"; }
	if( t == U_FundamentalType::u8_			){ return "E"; }
	if( t == U_FundamentalType::i16_		){ return "F"; }
	if( t == U_FundamentalType::u16_		){ return "G"; }
	if( t == U_FundamentalType::i32_		){ return "H"; }
	if( t == U_FundamentalType::u32_		){ return "I"; }
	if( t == U_FundamentalType::i64_		){ return "_J"; }
	if( t == U_FundamentalType::u64_		){ return "_K"; }
	if( t == U_FundamentalType::i128_		){ return "_L"; }
	if( t == U_FundamentalType::u128_		){ return "_M"; }
	if( t == U_FundamentalType::f32_		){ return "M"; }
	if( t == U_FundamentalType::f64_		){ return "N"; }
	if( t == U_FundamentalType::char8_		){ return "D"; }
	if( t == U_FundamentalType::char16_		){ return "_S"; }
	if( t == U_FundamentalType::char32_		){ return "_U"; }
	return "";
}

fn MakeNullTerminatedString( ust::string8 mut str ) : ust::string8
{
	str.push_back( "\0"c8 );
	return move(str);
}

fn GetCallingConventionName( LLVMCallConvID cc ) : ust::array_view_imut</ char8 />
{
	if( cc == LLVMCallConv::C )
	{
		return "A";
	}
	if( cc == LLVMCallConv::Fast )
	{
		return "I";
	}
	if( cc == LLVMCallConv::Cold )
	{
		return "U";
	}
	if( cc == LLVMCallConv::X86Stdcall )
	{
		return "G";
	}

	return "A";
}

auto g_num_back_references= 10s;
auto g_name_prefix= "?"c8; // All names (function, variables) should start with it.
auto g_terminator= "@"c8;
auto& g_template_prefix= "?$";
auto& g_numeric_template_arg_prefix= "$0";
auto g_class_type_prefix = "U"c8;
auto g_reference_prefix = "A"c8;
auto g_pointer_prefix = "P"c8;
auto g_mut_prefix= "A"c8;
auto g_imut_prefix= "B"c8;

} // namespace U1
