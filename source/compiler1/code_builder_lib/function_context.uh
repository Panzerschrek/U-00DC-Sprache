import "/unordered_set.u"
import "references_graph.uh"

namespace U1
{

struct LoopFrame
{
	LLVMBasicBlockRef block_for_break;
	LLVMBasicBlockRef block_for_continue;
	// Number of variables frames at stack before loop block creation.
	size_type variable_frames_stack_size;

	ust::string8 name; // Contains label or is empty for non-labeled loops.

	// Populated during loop body building.
	ust::vector</ReferencesGraph/> break_references_graphs;
	ust::vector</ReferencesGraph/> continue_references_graphs;
}

class FunctionContext
{
public:
	fn constructor(
		LLVMContextRef llvm_context,
		LLVMValueRef in_llvm_function,
		FunctionType mut in_function_type );
	fn destructor();

public:
	FunctionType function_type;

	LLVMValueRef imut llvm_function;

	LLVMBuilderRef alloca_ir_builder= LLVMBuilderRef::Null;

	LLVMBasicBlockRef function_basic_block= LLVMBasicBlockRef::Null;
	LLVMBuilderRef llvm_ir_builder= LLVMBuilderRef::Null;

	// For reference checking. TODO - use single vector.
	ust::vector</ VariableNullablePtr /> mut args_nodes; // Contains only variable nodes (not reference nodes).
	ust::vector</ ust::vector</VariablePtr /> /> mut args_inner_variable_nodes; // Contains inner variable nodes.

	LLVMValueRef s_ret= LLVMValueRef::Null; // Also promise for coroutines

	// Specific for coroutines data.
	LLVMBasicBlockRef coro_final_suspend_bb= LLVMBasicBlockRef::Null; // Used to jump from "return" operator.
	LLVMBasicBlockRef coro_suspend_bb= LLVMBasicBlockRef::Null; // Used as final destination for "yield" and "return".
	LLVMBasicBlockRef coro_cleanup_bb= LLVMBasicBlockRef::Null; // Used as final destination after suspention destruction blocks.

	VariableNullablePtr this_;
	ust::vector</bool/> initialized_this_fields; // Non-empty in constructors. element is true, if field is already initialized.
	bool whole_this_is_unavailable= false;

	bool have_non_constexpr_operations_inside= false; // While building code, may set to "true".

	LLVMBasicBlockRef destructor_end_block= LLVMBasicBlockRef::Null; // For destructors only - used for "Br" instead of "ret"

	ust::vector</LoopFrame/> loops_stack;
	bool is_in_unsafe_block= false;

	bool is_functionless_context= false; // True for global function context or for function context, used for args preevaluation or typeof operator.

	type VariablesFrame= ust::vector</ VariablePtr />;
	ust::vector</VariablesFrame/> variables_frames;
	ReferencesGraph references_graph;

	// Cache result of arguments pre-evaluation for selection of overloaded functions and operators.
	// This needed for reducing exponential expression evaluation complexity.
	ust::unordered_map</ ust::shared_ptr_final</Synt::Expression/>, VariableTypeExtended /> args_preevaluation_cache;

	LLVMMetadataRef current_debug_info_scope= LLVMMetadataRef::Null;
}

class VariablesFrameHolder
{
public:
	fn constructor( mut this, FunctionContext & mut function_context ) @( ust::reference_notation::pollution::param0_param_1_reference )
	( function_context_= function_context )
	{
		function_context_.variables_frames.push_back( FunctionContext::VariablesFrame() );
	}

	fn destructor()
	{
		// Ensure that all references graph nodes are deleted. Normally this is not needed, because nodes removed in destructors calls.
		// But in case of errors destructors may not be called.
		for( auto mut i= 0s; i < function_context_.variables_frames.back().size(); ++i )
		{
			var VariablePtr variable= function_context_.variables_frames.back()[i];
			function_context_.references_graph.RemoveNode( variable );
		}
		function_context_.variables_frames.drop_back();
	}

	fn GetFunctionContext( this ) : FunctionContext &mut @( ust::reference_notation::return_references::param0_inner_reference0 )
	{
		return function_context_;
	}

private:
	FunctionContext &mut function_context_;
}

} // namespace U1
