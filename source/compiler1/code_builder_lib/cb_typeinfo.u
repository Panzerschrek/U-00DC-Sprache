import "/assert.u"
import "/sort.u"
import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

?macro <? ADD_BOOL_FIELD:block( ?name:expr, ?value:expr ) ?>
->
<?
	{
		var ClassField mut class_field
		{
			.t= bool_type_,
			.is_mutable= true,
			.is_reference= false,
			.index= u32(fields_llvm_types.size()),
			.syntax_element= dummy_syntax_element,
			.source_class= typeinfo_class,
		};

		fields_llvm_types.push_back( class_field.t.GetLLVMType() );
		fields_initializers.push_back( unsafe( LLVMConstInt( class_field.t.GetLLVMType(), select( ?value ? 1u64 : 0u64 ), LLVMBool::False ) ) );

		auto mut members_lock= class_members.lock_mut();
		members_lock.deref().AddName( ?name, move(class_field) );
	}
?>

?macro <? ADD_SIZE_FIELD:block( ?name:expr, ?value:expr ) ?>
->
<?
	{
		var ClassField mut class_field
		{
			.t= size_type_,
			.is_mutable= true,
			.is_reference= false,
			.index= u32(fields_llvm_types.size()),
			.syntax_element= dummy_syntax_element,
			.source_class= typeinfo_class,
		};

		fields_llvm_types.push_back( class_field.t.GetLLVMType() );
		fields_initializers.push_back( unsafe( LLVMConstInt( class_field.t.GetLLVMType(), u64(?value), LLVMBool::False ) ) );

		auto mut members_lock= class_members.lock_mut();
		members_lock.deref().AddName( ?name, move(class_field) );
	}
?>

?macro <? ADD_TYPEINFO_FIELD:block( ?name:expr, ?dependent_type:expr ) ?>
->
<?
	{
		auto dependent_type_typeinfo_ptr= GetTypeinfoPrototype( ?dependent_type, class_members.lock_imut().deref().GetParent().try_to_non_nullable() );
		auto lock= dependent_type_typeinfo_ptr.lock_imut();
		var Variable& dependent_type_typeinfo= lock.deref();
		var ClassField mut class_field
		{
			.t= dependent_type_typeinfo.t,
			.is_mutable= false,
			.is_reference= true,
			.index= u32(fields_llvm_types.size()),
			.syntax_element= dummy_syntax_element,
			.source_class= typeinfo_class,
		};

		fields_llvm_types.push_back( unsafe( LLVMPointerType( class_field.t.GetLLVMType(), 0u ) ) );

		fields_initializers.push_back( dependent_type_typeinfo.llvm_value );

		auto mut members_lock= class_members.lock_mut();
		members_lock.deref().AddName( ?name, move(class_field) );
	}
?>

?macro <? ADD_NAME_FIELD:block( ?name:expr ) ?>
->
<?
	{
		var ust::string8& element_name= ?name;

		var ArrayType mut array_type
		{
			.element_type= FundamentalType( U_FundamentalType::char8_, fundamental_llvm_types_.char8_ ),
			.element_count= u64(element_name.size()),
		};
		array_type.llvm_type= unsafe( LLVMArrayType( array_type.element_type.GetLLVMType(), u32(array_type.element_count) ) );

		var ClassField mut class_field
		{
			.t= move(array_type),
			.is_mutable= true,
			.is_reference= false,
			.index= u32(fields_llvm_types.size()),
			.syntax_element= dummy_syntax_element,
			.source_class= typeinfo_class,
		};

		fields_llvm_types.push_back( class_field.t.GetLLVMType() );
		fields_initializers.push_back( unsafe( LLVMConstStringInContext( llvm_context_, cast_mut(element_name).data(), u32(element_name.size()), LLVMBool::True ) ) );

		auto mut members_lock= class_members.lock_mut();
		members_lock.deref().AddName( "name", move(class_field) );
	}
?>

?macro <? ADD_CLASS_MEMBER_COMMON_FIELDS:block( ?name:expr ) ?>
->
<?
	{
		var ust::string8& name= ?name;
		ADD_NAME_FIELD( name )

		var Synt::ClassVisibility visibility= class_type.lock_imut().deref().GetMemberVisibility( name );
		ADD_BOOL_FIELD( "is_public"   , visibility == Synt::ClassVisibility::Public    )
		ADD_BOOL_FIELD( "is_protected", visibility == Synt::ClassVisibility::Protected )
		ADD_BOOL_FIELD( "is_private"  , visibility == Synt::ClassVisibility::Private   )
	}
?>

namespace U1
{

// Use reserved by language names, started with "_".
auto& g_typeinfo_root_class_name= "_TI";
auto& g_typeinfo_tuple_elements_list_node_class_name= "_TITL_";
auto& g_typeinfo_function_params_list_node_class_name= "_TIAL_";
auto& g_typeinfo_class_fields_list_node_class_name= "_TICFiL_";
auto& g_typeinfo_class_functions_list_node_class_name= "_TICFuL_";
auto& g_typeinfo_class_types_list_node_class_name= "_TICTL_";
auto& g_typeinfo_class_parents_list_node_class_name= "_TICPL_";
auto& g_typeinfo_enum_elements_list_node_class_name= "_TIEL_";

struct ClassFieldForTypeinfo
{
	ust::shared_ptr_imut</ClassField/> class_field;
	ust::string8 name;

	op<=>( ClassFieldForTypeinfo& l, ClassFieldForTypeinfo& r ) : i32
	{
		return l.name <=> r.name;
	}
}

struct ClassFunctionForTypeinfo
{
	FunctionVariable function;
	ust::string8 name;
	ust::string8 mangled_name;

	op<=>( ClassFunctionForTypeinfo& l, ClassFunctionForTypeinfo& r ) : i32
	{
		return l.mangled_name <=> r.mangled_name;
	}
}

struct ClassInnerTypeForTypeinfo
{
	Type t;
	ust::string8 name;

	op<=>( ClassInnerTypeForTypeinfo& l, ClassInnerTypeForTypeinfo& r ) : i32
	{
		return l.name <=> r.name;
	}
}

struct EnumElementForTypeinfo
{
	LLVMValueRef value;
	ust::string8 name;

	op<=>( EnumElementForTypeinfo& l, EnumElementForTypeinfo& r ) : i32
	{
		return l.name <=> r.name;
	}
}

fn CodeBuilder::BuildTypeinfo( mut this, Type& t, NamesScopePtr& root_namespace ) : VariablePtr
{
	GetTypeinfoPrototype( t, root_namespace );
	return BuildFullTypeinfo( t );
}

fn CodeBuilder::GetTypeinfoPrototype( mut this, Type& t, NamesScopePtr& root_namespace ) : VariablePtr
{
	// Check if already created.
	if_var( &entry : typeinfo_cache_.find(t) )
	{
		return entry.variable;
	}

	var ClassTypePtr typeinfo_class= CreateTypeinfoClass( root_namespace, t, g_typeinfo_root_class_name, true );

	var Variable mut v
	{
		.t= typeinfo_class,
		.value_type= ValueType::ReferenceImut,
		.location= Variable::Location::Pointer,
		.name= Type(typeinfo_class).ToString()
	};

	unsafe
	{
		auto llvm_type= v.t.GetLLVMType();
		v.constexpr_value= LLVMGetUndef( llvm_type ); // llvm::Constant is immutable, so, we can create real constant only if we build comple typeinfo.
		v.llvm_value= AddGlobalConstantVariable( "\0", llvm_type, v.constexpr_value );
	}

	var VariablePtr mut v_ptr= move(v).CreatePtr();
	var TypeinfoCacheElement mut cache_element{ .variable= v_ptr };
	typeinfo_cache_.insert( t, move(cache_element) );

	// Add type as typedef into class members namespace.
	// This allows us to get typename itself, using typeinfo variable and use such type as normal.
	{
		auto class_members= typeinfo_class.lock_imut().deref().members;
		auto mut members_lock= class_members.lock_mut();
		members_lock.deref().AddName( "src_type", t );
	}

	return move(v_ptr);
}

fn CodeBuilder::BuildFullTypeinfo( mut this, Type& t ) : VariablePtr
{
	var VariablePtr typeinfo_variable_ptr= typeinfo_cache_.find(t).try_deref().variable;

	var ClassTypePtr typeinfo_class= typeinfo_variable_ptr.lock_imut().deref().t.GetClassType().try_deref();
	if( typeinfo_class.lock_imut().deref().is_complete )
	{
		return typeinfo_variable_ptr;
	}

	if( !EnsureTypeComplete( t ) )
	{
		// Ignore incomplete types here, generate error in "typeinfo" operator evaluation instead.
		// TODO - what if user try to access incomplete member of incomplete typeinfo class?
		return typeinfo_variable_ptr;
	}

	var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;
	var NamesScopePtr root_namespace= class_members.lock_imut().deref().GetParent().try_to_non_nullable();

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
	var ust::vector</LLVMValueRef/> mut fields_initializers;

	{
		var LLVMTypeRef llvm_type= t.GetLLVMType();
		// see llvm/lib/IR/DataLayout.cpp:40
		ADD_SIZE_FIELD( "size_of", LLVMABISizeOfType( data_layout_, llvm_type ) )
		ADD_SIZE_FIELD( "align_of", LLVMABIAlignmentOfType( data_layout_, llvm_type ) )
	}

	ADD_SIZE_FIELD( "references_tags_count", select( t.GetInnerReferenceKind() == InnerReferenceKind::None ? 0s : 1s ) )
	ADD_BOOL_FIELD( "contains_mutable_references", t.GetInnerReferenceKind() == InnerReferenceKind::Mut )

	ADD_BOOL_FIELD( "is_fundamental"     , !t.GetFundamentalType    ().empty() )
	ADD_BOOL_FIELD( "is_array"           , !t.GetArrayType          ().empty() )
	ADD_BOOL_FIELD( "is_tuple"           , !t.GetTupleType          ().empty() )
	ADD_BOOL_FIELD( "is_raw_pointer"     , !t.GetRawPointerType     ().empty() )
	ADD_BOOL_FIELD( "is_function_pointer", !t.GetFunctionPointerType().empty() )
	ADD_BOOL_FIELD( "is_class"           , !t.GetClassType          ().empty() )
	ADD_BOOL_FIELD( "is_enum"            , !t.GetEnumType           ().empty() )

	ADD_BOOL_FIELD( "is_default_constructible", t.IsDefaultConstructible() )
	ADD_BOOL_FIELD( "is_copy_constructible"   , t.IsCopyConstructible()    )
	ADD_BOOL_FIELD( "is_copy_assignable"      , t.IsCopyAssignable()       )
	ADD_BOOL_FIELD( "is_equality_comparable"  , t.IsEqualityComparable()   )

	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		ADD_BOOL_FIELD( "is_integer"         , IsInteger        ( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_numeric"         , IsNumericType    ( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_signed_integer"  , IsSignedInteger  ( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_unsigned_integer", IsUnsignedInteger( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_float"           , IsFloatingPoint  ( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_char"            , IsChar           ( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_byte"            , IsByte           ( fundamental_type.fundamental_type ) )
		ADD_BOOL_FIELD( "is_bool"            , fundamental_type.fundamental_type == U_FundamentalType::bool_ )
		ADD_BOOL_FIELD( "is_void"            , fundamental_type.fundamental_type == U_FundamentalType::void_ )
	}
	else if_var( &array_type : t.GetArrayType() )
	{
		ADD_TYPEINFO_FIELD( "element_type", array_type.element_type )
		ADD_SIZE_FIELD( "element_count", array_type.element_count )
	}
	else if_var( &tuple_type : t.GetTupleType() )
	{
		ADD_SIZE_FIELD( "element_count", tuple_type.element_types.size() )
	}
	else if_var( &pointer_type : t.GetRawPointerType() )
	{
		ADD_TYPEINFO_FIELD( "element_type", pointer_type.element_type )
	}
	else if_var( &function_pointer_type : t.GetFunctionPointerType() )
	{
		var FunctionType& function_type= function_pointer_type.function_type;
		ADD_TYPEINFO_FIELD( "return_type", function_type.return_type )
		ADD_BOOL_FIELD( "return_value_is_reference", function_type.return_value_type != ValueType::Value )
		ADD_BOOL_FIELD( "return_value_is_mutable"  , function_type.return_value_type == ValueType::ReferenceMut )
		ADD_BOOL_FIELD( "unsafe"                   , function_type.is_unsafe )
		// SPRACHE_TODO - add also reference pollution.
	}
	else if_var( &class_ptr : t.GetClassType() )
	{
		auto lock= class_ptr.lock_imut();
		var ClassType& class_= lock.deref();

		var bool is_polymorph=
			class_.kind == ClassType::Kind::Interface ||
			class_.kind == ClassType::Kind::Abstract ||
			class_.kind == ClassType::Kind::PolymorphNonFinal ||
			class_.kind == ClassType::Kind::PolymorphFinal;

		var size_type mut field_count= 0s;
		foreach( &member : class_.members.lock_imut().deref() )
		{
			field_count+= select( member.value().Get</ClassField/>().empty() ? 0s : 1s );
		}
		ADD_SIZE_FIELD( "field_count", field_count )

		ADD_SIZE_FIELD( "parent_count", class_.parents.size() )

		if( is_polymorph )
		{
			var ClassField mut class_field
			{
				.t= size_type_,
				.is_mutable= false,
				.is_reference= true,
				.index= u32(fields_llvm_types.size()),
				.syntax_element= dummy_syntax_element,
				.source_class= typeinfo_class,
			};

			unsafe
			{
				auto dummy_function_context= CreateGlobalFunctionContext();
				var [ LLVMValueRef, 3 ] mut indices[ GetZeroGEPIndex(), GetZeroGEPIndex(), GetZeroGEPIndex() ];
				var LLVMValueRef address=
					LLVMBuildGEP2(
						dummy_function_context.llvm_ir_builder,
						LLVMTypeOf( LLVMGetInitializer(class_.polymorph_type_id_table) ),
						class_.polymorph_type_id_table,
						$<(indices[0]), 3u, g_null_string );
				fields_initializers.push_back( address );
				fields_llvm_types.push_back( LLVMPointerType( class_field.t.GetLLVMType(), 0u ) );
			}

			auto mut members_lock= class_members.lock_mut();
			members_lock.deref().AddName( "type_id", move(class_field) );
		}

		ADD_BOOL_FIELD( "is_struct", class_.kind == ClassType::Kind::Struct )
		ADD_BOOL_FIELD( "is_polymorph", is_polymorph )
		ADD_BOOL_FIELD( "is_final",
			class_.kind == ClassType::Kind::Struct ||
			class_.kind == ClassType::Kind::NonPolymorph ||
			class_.kind == ClassType::Kind::PolymorphFinal )
		ADD_BOOL_FIELD( "is_abstract",
			class_.kind == ClassType::Kind::Abstract ||
			class_.kind == ClassType::Kind::Interface )

		ADD_BOOL_FIELD( "is_interface", class_.kind == ClassType::Kind::Interface )

		ADD_BOOL_FIELD( "is_typeinfo", !class_.generated_class_data.get</ TypeinfoClassDescription />().empty() )

		if_var( &coroutine_type_description : class_.generated_class_data.get</ CoroutineTypeDescription />() )
		{
			ADD_BOOL_FIELD( "is_coroutine", true )

			ADD_BOOL_FIELD( "is_generator", coroutine_type_description.kind == CoroutineKind::Generator )

			ADD_TYPEINFO_FIELD( "coroutine_return_type", coroutine_type_description.return_type )
			ADD_BOOL_FIELD( "coroutine_return_value_is_reference", coroutine_type_description.return_value_type != ValueType::Value )
			ADD_BOOL_FIELD( "coroutine_return_value_is_mutable"  , coroutine_type_description.return_value_type == ValueType::ReferenceMut )
		}
		else
		{
			ADD_BOOL_FIELD( "is_coroutine", false )
		}
	}
	else if_var( &enum_ptr : t.GetEnumType() )
	{
		auto lock= enum_ptr.lock_imut();
		var Enum& enum_= lock.deref();

		ADD_SIZE_FIELD( "element_count", enum_.elements.size() )
		ADD_TYPEINFO_FIELD( "underlaying_type", enum_.underlaying_type )
	}
	else { halt; }

	FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

	auto mut v_lock= typeinfo_variable_ptr.lock_mut();
	var Variable &mut v= v_lock.deref();
	unsafe
	{
		auto initializer= LLVMConstNamedStruct( v.t.GetLLVMType(), fields_initializers.data(), u32(fields_initializers.size()) );
		LLVMSetInitializer( v.llvm_value, initializer );

		v.constexpr_value= initializer;
	}

	return typeinfo_variable_ptr;
}

fn CodeBuilder::CreateTypeinfoClass( mut this, NamesScopePtr& root_namespace, Type& src_type, ust::string8 mut name, bool is_main_class ) : ClassTypePtr
{
	var NamesScopeMutPtr class_members( NamesScope( move(name), root_namespace ) );
	var TypeinfoClassDescription mut typeinfo_class_description{ .source_type = src_type, .is_main_class= is_main_class };
	var ClassType mut class_type
	{
		.members= class_members,
		.members_initial= class_members,
		.generated_class_data( move(typeinfo_class_description) ),
		.can_be_constexpr= true,
		.inner_reference_kind= InnerReferenceKind::Imut,
	};

	var ClassTypePtr mut class_type_ptr( move(class_type) );

	with( mut lock : class_members.lock_mut() )
	{
		// Create functions set for constructors/assignment operators.
		var FunctionsSet functions_set{ .class_= class_type_ptr };
		lock.deref().AddName( KeywordToString( Keyword::constructor_ ), functions_set );
		lock.deref().AddName( OverloadedOperatorToString( OverloadedOperator::Assign ), functions_set );

		// Add special member to names scope to identify it as class names scope.
		lock.deref().SetClass( class_type_ptr );
	}

	with( mut lock : class_type_ptr.lock_mut() )
	{
		lock.deref().llvm_type= unsafe( LLVMStructCreateNamed( llvm_context_, g_null_string ) );
	}

	typeinfo_class_table_.push_back( class_type_ptr );

	return move(class_type_ptr);
}

fn CodeBuilder::CreateTypeinfoHelperClass( mut this, NamesScopePtr& root_namespace, Type& src_type, ust::string8 mut name ) : ClassTypePtr
{
	return CreateTypeinfoClass( root_namespace, src_type, move(name), false );
}

fn CodeBuilder::FinishTypeinfoClass( mut this, ClassTypePtr& typeinfo_class, ust::array_view_imut</LLVMTypeRef/> fields_llvm_types )
{
	with( mut lock : typeinfo_class.lock_mut() )
	{
		var ClassType &mut class_= lock.deref();

		unsafe( LLVMStructSetBody( class_.llvm_type, cast_mut(fields_llvm_types).data(), u32(fields_llvm_types.size()), LLVMBool::False ) );

		class_.is_complete= true;
	}
}

fn CodeBuilder::TryFetchTypeinfoClassLazyField( mut this, Type& typeinfo_type, ust::string_view8 name ) : VariableNullablePtr
{
	// Generate typeinfo list fields on-demand, instead of creating lists as typeinfo class fields as usual.
	// The main reason to do this - for faster compilation.
	// Building typeinfo lists is too costly - requires creation of bunch of node classes, each with members namespace, destructor, fields, etc.
	// So, avoid doing this unless typeinfo list isn't direclty accessed.
	// Such optimization also reduces total memory usage by the compiler frontend.

	auto class_type_opt= typeinfo_type.GetClassType();
	if( class_type_opt.empty() )
	{
		return VariableNullablePtr();
	}
	var ClassTypePtr class_type= class_type_opt.try_deref();

	var Type mut source_type;
	if_var( & typeinfo_type_description : class_type.lock_imut().deref().generated_class_data.get</ TypeinfoClassDescription />() )
	{
		if( !typeinfo_type_description.is_main_class )
		{
			// This is some helper typeinfo class (like list node class), not main class (type of "typeinfo") operator.
			return VariableNullablePtr();
		}
		source_type= typeinfo_type_description.source_type;
	}
	else
	{
		return VariableNullablePtr();
	}

	var TypeinfoCacheElement mut cache_element= typeinfo_cache_.find( source_type ).try_deref();

	var NamesScopePtr root_namespace= GetRootNamespace( class_type.lock_imut().deref().members );

	if( !source_type.GetFundamentalType().empty() ||
		!source_type.GetArrayType().empty() ||
		!source_type.GetRawPointerType().empty() )
	{
		// These kinds of types have no lists.
	}
	else if_var( enum_type : source_type.GetEnumType() )
	{
		if( name == "elements_list" )
		{
			if( cache_element.elements_list.empty() )
			{
				cache_element.elements_list= BuildTypeinfoEnumElementsList( root_namespace, enum_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.elements_list;
		}
	}
	else if_var( &tuple_type : source_type.GetTupleType() )
	{
		if( name == "elements_list" )
		{
			if( cache_element.elements_list.empty() )
			{
				cache_element.elements_list= BuildTypeinfoTupleElementsList( root_namespace, tuple_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.elements_list;
		}
	}
	else if_var( class_type : source_type.GetClassType() )
	{
		if( name == "fields_list" )
		{
			if( cache_element.fields_list.empty() )
			{
				cache_element.fields_list= BuildTypeinfoClassFieldsList( root_namespace, class_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.fields_list;
		}
		if( name == "types_list" )
		{
			if( cache_element.types_list.empty() )
			{
				cache_element.types_list= BuildTypeinfoClassTypesList( root_namespace, class_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.types_list;
		}
		if( name == "functions_list" )
		{
			if( cache_element.functions_list.empty() )
			{
				cache_element.functions_list= BuildTypeinfoClassFunctionsList( root_namespace, class_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.functions_list;
		}
		if( name == "parents_list" )
		{
			if( cache_element.parents_list.empty() )
			{
				cache_element.parents_list= BuildTypeinfoClassParentsList( root_namespace, class_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.parents_list;
		}
	}
	else if_var( function_pointer_type : source_type.GetFunctionPointerType() )
	{
		if( name == "arguments_list" )
		{
			if( cache_element.arguments_list.empty() )
			{
				cache_element.arguments_list= BuildTypeinfoFunctionParamsList( root_namespace, function_pointer_type.function_type );
				typeinfo_cache_[ source_type ]= cache_element;
			}
			return cache_element.arguments_list;
		}
	}
	else { halt; }

	// Unknown member.
	return VariableNullablePtr();
}

fn CodeBuilder::BuildTypeinfoTupleElementsList( mut this, NamesScopePtr& root_namespace, TupleType& tuple_type ) : VariablePtr
{
	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
	{
		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, tuple_type, g_typeinfo_tuple_elements_list_node_class_name + ust::to_string8(i) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		ADD_TYPEINFO_FIELD( "type", tuple_type.element_types[i] )

		ADD_SIZE_FIELD( "index", i )
		ADD_SIZE_FIELD( "offset", unsafe(LLVMOffsetOfElement( data_layout_, tuple_type.llvm_type, u32(i) )) )

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::BuildTypeinfoFunctionParamsList( mut this, NamesScopePtr& root_namespace, FunctionType& function_type ) : VariablePtr
{
	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	var FunctionPointerType function_pointer_type= FunctionTypeToPointer( function_type );

	for( auto mut i= 0s; i < function_type.params.size(); ++i )
	{
		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, function_pointer_type, g_typeinfo_function_params_list_node_class_name + ust::to_string8(i) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		auto& param= function_type.params[i];
		ADD_TYPEINFO_FIELD( "type", param.t )
		ADD_BOOL_FIELD( "is_reference", param.value_type != ValueType::Value )
		ADD_BOOL_FIELD( "is_mutable"  , param.value_type == ValueType::ReferenceMut )

		// SPRACHE_TODO - add reference pollution

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::BuildTypeinfoClassFieldsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr
{
	var ust::vector</ ClassFieldForTypeinfo /> mut class_fields;
	{
		auto class_members_ptr= class_type.lock_imut().deref().members;
		auto class_members_lock= class_members_ptr.lock_imut();
		var NamesScope& class_members= class_members_lock.deref();

		foreach( &member : class_members )
		{
			auto field_ptr= member.value().Get</ClassField/>();
			if( !field_ptr.empty() )
			{
				var ClassFieldForTypeinfo mut f{ .class_field= field_ptr.try_to_non_nullable(), .name= member.key() };
				class_fields.push_back( move(f) );
			}
		}
	}

	// Sort class fields in typeinfo by name, because we need strong order.
	ust::sort( class_fields.range() );

	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	foreach( &class_field_for_typeinfo : class_fields )
	{
		auto field_lock= class_field_for_typeinfo.class_field.lock_imut();
		var ClassField& field= field_lock.deref();

		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, class_type, g_typeinfo_class_fields_list_node_class_name + ust::to_string8(list_types.size()) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		ADD_TYPEINFO_FIELD( "type", field.t )
		ADD_TYPEINFO_FIELD( "class_type", field.source_class )

		// Base class always have zero offset, so, we can just use offset of class field in its own class.
		auto field_source_class_llvm_type= field.source_class.lock_imut().deref().llvm_type;
		ADD_SIZE_FIELD( "offset", unsafe( LLVMOffsetOfElement( data_layout_, field_source_class_llvm_type, u32(field.index) ) ) )

		ADD_BOOL_FIELD( "is_mutable", field.is_mutable )
		ADD_BOOL_FIELD( "is_reference", field.is_reference )

		ADD_CLASS_MEMBER_COMMON_FIELDS( class_field_for_typeinfo.name )

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::BuildTypeinfoClassFunctionsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr
{
	var ust::vector</ClassFunctionForTypeinfo/> mut functions_list;

	with( class_members_ptr : class_type.lock_imut().deref().members )
	{
		foreach( &class_member : class_members_ptr.lock_imut().deref() )
		{
			auto functions_set_ptr= class_member.value().Get</FunctionsSet/>();
			if( functions_set_ptr.empty() )
			{
				continue;
			}

			foreach( &function : functions_set_ptr.try_lock_imut().deref().functions )
			{
				var ClassFunctionForTypeinfo mut f
				{
					.function= function,
					.name= class_member.key(),
					.mangled_name= function.llvm_function.lock_imut().deref().name_mangled
				};

				functions_list.push_back( move(f) );
			}
		}
	}

	// Sort class functions in typeinfo by mangled name, because we need strong order.
	ust::sort( functions_list.range() );

	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	foreach( &class_function : functions_list)
	{
		var FunctionVariable& function= class_function.function;

		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, class_type, g_typeinfo_class_functions_list_node_class_name + ust::to_string8(list_types.size()) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		var FunctionPointerType function_pointer_type= FunctionTypeToPointer(function.t);
		ADD_TYPEINFO_FIELD( "type", function_pointer_type )

		ADD_BOOL_FIELD( "is_this_call" , function.is_this_call )
		ADD_BOOL_FIELD( "is_generated" , function.is_generated )
		ADD_BOOL_FIELD( "is_deleted"   , function.is_deleted   )
		ADD_BOOL_FIELD( "is_virtual"   , function.virtual_table_index != ~0u )

		ADD_CLASS_MEMBER_COMMON_FIELDS( class_function.name )

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::BuildTypeinfoClassTypesList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr
{
	var ust::vector</ClassInnerTypeForTypeinfo/> mut class_inner_types;
	{
		auto class_members_ptr= class_type.lock_imut().deref().members;
		auto class_members_lock= class_members_ptr.lock_imut();
		var NamesScope& class_members= class_members_lock.deref();

		foreach( &class_member : class_members)
		{
			var Type mut t;

			auto type_ptr= class_member.value().Get</Type/>();
			auto type_alias_ptr= class_member.value().Get</TypeAlias/>();
			auto class_ptr= class_member.value().Get</ClassType/>();
			auto enum_ptr= class_member.value().Get</Enum/>();
			if( !type_ptr.empty() )
			{
				t= type_ptr.try_lock_imut().deref();
			}
			else if( !type_alias_ptr.empty() )
			{
				var ust::optional</ Type /> inner_type= type_alias_ptr.try_lock_imut().deref().t;
				if( inner_type.empty() ) { continue; }// WTF?
				t= inner_type.try_deref();
			}
			else if( !class_ptr.empty() )
			{
				t= class_ptr.try_to_non_nullable();
			}
			else if( !enum_ptr.empty() )
			{
				t= enum_ptr.try_to_non_nullable();
			}
			else
			{
				continue;
			}

			var ClassInnerTypeForTypeinfo mut inner_type{ .t= move(t), .name= class_member.key() };
			class_inner_types.push_back( move(inner_type) );
		}
	}

	// Sort class types in typeinfo by name, because we need strong order.
	ust::sort( class_inner_types.range() );

	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	foreach( &inner_type : class_inner_types )
	{
		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, class_type, g_typeinfo_class_types_list_node_class_name + ust::to_string8(list_types.size()) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		ADD_TYPEINFO_FIELD( "type", inner_type.t )

		ADD_CLASS_MEMBER_COMMON_FIELDS( inner_type.name )

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::BuildTypeinfoClassParentsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr
{
	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	auto class_lock= class_type.lock_imut();
	var ClassType& class_= class_lock.deref();
	foreach( &parent : class_.parents )
	{
		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, class_type, g_typeinfo_class_parents_list_node_class_name + ust::to_string8(list_types.size()) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		ADD_TYPEINFO_FIELD( "type", parent.class_ )

		ADD_SIZE_FIELD( "offset", unsafe( LLVMOffsetOfElement( data_layout_, class_.llvm_type, parent.field_number ) ) )

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::BuildTypeinfoEnumElementsList( mut this, NamesScopePtr& root_namespace, EnumTypePtr& enum_type ) : VariablePtr
{
	auto enum_lock= enum_type.lock_imut();
	var Enum& enum_= enum_lock.deref();

	var ust::vector</EnumElementForTypeinfo/> mut enum_elemens_list;

	foreach( &enum_element : enum_.elements )
	{
		var EnumElementForTypeinfo mut el
		{
			.value= enum_element.value().constexpr_value,
			.name= enum_element.key()
		};

		enum_elemens_list.push_back( move(el) );
	}

	// Sort enum elements in typeinfo by name, because we need strong order.
	ust::sort( enum_elemens_list.range() );

	var ust::vector</Type/> mut list_types;
	var ust::vector</LLVMValueRef/> mut list_initializers;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	foreach( &enum_element : enum_elemens_list )
	{
		var ClassTypePtr typeinfo_class= CreateTypeinfoHelperClass( root_namespace, enum_type, g_typeinfo_enum_elements_list_node_class_name + ust::to_string8(list_types.size()) );
		var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().deref().members;

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		var ust::vector</LLVMValueRef/> mut fields_initializers;

		ADD_NAME_FIELD( enum_element.name )

		{
			var ClassField mut class_field
			{
				.t= enum_.underlaying_type,
				.is_mutable= true,
				.is_reference= false,
				.index= u32(fields_llvm_types.size()),
				.syntax_element= dummy_syntax_element,
				.source_class= typeinfo_class,
			};

			fields_llvm_types.push_back( class_field.t.GetLLVMType() );
			fields_initializers.push_back( enum_element.value );

			auto mut members_lock= class_members.lock_mut();
			members_lock.deref().AddName( "value", move(class_field) );
		}

		FinishTypeinfoClass( typeinfo_class, fields_llvm_types.range() );

		list_types.push_back( typeinfo_class );
		list_initializers.push_back( unsafe( LLVMConstNamedStruct( typeinfo_class.lock_imut().deref().llvm_type, fields_initializers.data(), u32(fields_initializers.size()) ) ) );
	}

	return FinishTypeinfoList( move(list_types), list_initializers.range() );
}

fn CodeBuilder::FinishTypeinfoList( mut this, ust::vector</Type/> mut element_types, ust::array_view_imut</LLVMValueRef/> initializers ) : VariablePtr
{
	debug_assert( element_types.size() == initializers.size(), "typeinfo list types/initializers size mismatch!" );

	var TupleType mut tuple_type{ .element_types= move(element_types) };

	var ust::vector</LLVMTypeRef/> mut element_llvm_types;
	foreach( &element_type : tuple_type.element_types )
	{
		element_llvm_types.push_back( element_type.GetLLVMType() );
	}

	tuple_type.llvm_type= unsafe( LLVMStructTypeInContext( llvm_context_, element_llvm_types.data(), u32(element_llvm_types.size()), LLVMBool::False ) );

	var Variable mut v
	{
		.t= move(tuple_type),
		.value_type= ValueType::ReferenceImut,
		.location= Variable::Location::Pointer,
		.name= "typeinfo_list", // TODO - set something more relevant?
		.constexpr_value= unsafe( LLVMConstStructInContext( llvm_context_, cast_mut(initializers).data(), u32(initializers.size()), LLVMBool::False ) )
	};

	auto name_nt= "\0"; // Save some space - avoid to give LLVM variable a name. This is irrelevant, since this variable has private visibility.
	v.llvm_value= unsafe( AddGlobalConstantVariable( name_nt, v.t.GetLLVMType(), v.constexpr_value ) );

	return move(v).CreatePtr();
}

} // namespace U1
