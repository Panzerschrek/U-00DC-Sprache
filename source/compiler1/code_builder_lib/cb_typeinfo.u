import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"
import "mangling.uh"
?macro <? ADD_BOOL_FIELD:block( ?name:expr, ?value:expr ) ?>
->
<?
	{
		var ClassField mut class_field
		{
			.t= bool_type_,
			.is_mutable= true,
			.is_reference= false,
			.index= fields_llvm_types.size(),
			.syntax_element= dummy_syntax_element,
		};

		fields_llvm_types.push_back( class_field.t.GetLLVMType() );

		unsafe{  fields_initializers.push_back( LLVMConstInt( class_field.t.GetLLVMType(), select( ?value ? 1u64 : 0u64 ), LLVMBool::True ) );  }

		auto mut members_lock= class_members.lock_mut();
		members_lock.get_ref().AddName( ?name, move(class_field) );
	}
?>

namespace U
{

fn CodeBuilder::BuildTypeinfo( mut this, Type& t, NamesScopePtr& root_namespace ) : Variable
{
	var ClassTypePtr typeinfo_class= CreateTypeinfoClass( root_namespace, t, "TODO - name" );
	var NamesScopeMutPtr class_members= typeinfo_class.lock_imut().get_ref().members;

	var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

	var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
	var ust::vector</LLVMValueRef/> mut fields_initializers;

	ADD_BOOL_FIELD( "is_fundamental"     , !t.GetFundamentalType    ().empty() )
	ADD_BOOL_FIELD( "is_array"           , !t.GetArrayType          ().empty() )
	ADD_BOOL_FIELD( "is_function"        , !t.GetFunctionType       ().empty() )
	ADD_BOOL_FIELD( "is_function_pointer", !t.GetFunctionPointerType().empty() )
	ADD_BOOL_FIELD( "is_class"           , !t.GetClassType          ().empty() )
	ADD_BOOL_FIELD( "is_enum"            , !t.GetEnumType           ().empty() )

	{
		auto mut class_lock= typeinfo_class.lock_mut();
		var ClassType &mut class_= class_lock.get_ref();

		unsafe{  LLVMStructSetBody( class_.llvm_type, cast_imut(fields_llvm_types).front(), u32(fields_llvm_types.size()), LLVMBool::False );  }

		class_.is_complete= true;
	}

	var Variable mut v
	{
		.t= typeinfo_class,
		.value_type= ValueType::ReferenceImut,
		.location= Variable::Location::Pointer,
	};
	unsafe
	{
		auto initializer= LLVMConstNamedStruct( v.t.GetLLVMType(), cast_imut(fields_initializers).front(), u32(fields_initializers.size()) );
		auto global_variable= LLVMAddGlobal( module_, v.t.GetLLVMType(), "TODO - name\0"[0] );
		LLVMSetLinkage( global_variable, LLVMLinkage::Internal );
		LLVMSetGlobalConstant( global_variable, LLVMBool::True );
		LLVMSetInitializer( global_variable, initializer );

		v.llvm_value= global_variable;
		v.constexpr_value= initializer;
	}

	return v;
}

fn CodeBuilder::CreateTypeinfoClass( this, NamesScopePtr& root_namespace, Type& src_type, ust::string8& name ) : ClassTypePtr
{
	var NamesScopeMutPtr class_members( NamesScope( name, root_namespace ) );
	var ClassType mut class_type{ .members= class_members };

	unsafe{  class_type.llvm_type= LLVMStructCreateNamed( llvm_context_, "TODO - name\0"[0] );  }

	return ClassTypePtr( class_type );
}


} // namespace U
