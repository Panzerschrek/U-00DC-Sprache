import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr ) : BlockElementBuildInfo
{
	return BuildBlockElement( names_scope, function_context, block_ptr.get_ref() );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo
{
	var NamesScopeMutPtr block_names_scope( NamesScope( "", names_scope ) );

	var BlockElementBuildInfo mut block_element_build_info;
	foreach( &block_element : block.elements )
	{
		if( block_element_build_info.have_terminal_instruction_inside )
		{
			REPORT_ERROR( UnreachableCode, block_names_scope, Synt::GetFilePos(block_element) )
		}

		variant_visit( &el : block_element )
		{
			auto info = BuildBlockElement( block_names_scope, function_context, el );
			block_element_build_info.have_terminal_instruction_inside |= info.have_terminal_instruction_inside;
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo
{
	auto t= PrepareType( names_scope, variables_declaration.t );
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, variables_declaration.file_pos, t )
		return BlockElementBuildInfo();
	}

	foreach( &variable_declaration : variables_declaration.variables )
	{
		if( IsKeyword( variable_declaration.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope, variable_declaration.file_pos )
		}

		var NamesScopeVariable mut out_variable
		{
			.t= t,
			.is_mutable= variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable,
		};

		if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
		{
			unsafe
			{
				out_variable.llvm_value=
					LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), (variable_declaration.name + "\0").front() );
			}

			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				BuildEmptyInitializer( names_scope, function_context, out_variable, variable_declaration.name, variable_declaration.file_pos );

			}
			else
			{
				BuildInitializer( names_scope, function_context, out_variable, variable_declaration.initializer );
			}
		}
		else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				REPORT_ERROR( ExpectedInitializer, names_scope, variable_declaration.file_pos, variable_declaration.name )
				return BlockElementBuildInfo(); // TODO - continue instead
			}

			var ust::optional_ref</Synt::Expression, false/> mut initializer_expression;
			if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
			{
				initializer_expression.reset(expression_initializer);
			}
			if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
			{
				if( constructor_initializer.args.size() != 1s )
				{
					REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope, constructor_initializer.file_pos )
					return BlockElementBuildInfo(); // TODO - continue instead
				}

				initializer_expression.reset( constructor_initializer.args.front() );
			}

			if( initializer_expression.empty() )
			{
				REPORT_ERROR( UnsupportedInitializerForReference, names_scope, variable_declaration.file_pos )
				return BlockElementBuildInfo(); // TODO - continue instead
			}

			auto expression_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, initializer_expression.get_ref() );
			// TODO - allow reference conversion
			if( expression_result.t != t )
			{
				REPORT_ERROR( TypesMismatch, names_scope, variable_declaration.file_pos, t, expression_result.t )
				return BlockElementBuildInfo(); // TODO - continue instead
			}
			if( expression_result.value_type == ValueType::Value )
			{
				REPORT_ERROR( ExpectedReferenceValue, names_scope, variable_declaration.file_pos )
				return BlockElementBuildInfo(); // TODO - continue instead
			}
			if( out_variable.is_mutable && expression_result.value_type == ValueType::ReferenceImut )
			{
				REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, variable_declaration.file_pos )
				return BlockElementBuildInfo(); // TODO - continue instead
			}

			out_variable.llvm_value= expression_result.llvm_value;
		}
		else{ halt; }

		var bool mut insert_not_ok= false;
		{
			auto mut lock= names_scope.lock_mut();
			insert_not_ok= lock.get_ref().AddName( variable_declaration.name, NamesScopeValue( move(out_variable) ) ).empty();
		}
		if( insert_not_ok )
		{
			REPORT_ERROR( Redefinition, names_scope, variable_declaration.file_pos, variable_declaration.name )
		}
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration )  : BlockElementBuildInfo
{
	if( IsKeyword( auto_variable_declaration.name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope, auto_variable_declaration.file_pos )
	}

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );
	if( expr.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
		return BlockElementBuildInfo();
	}

	var NamesScopeVariable mut out_variable
	{
		.t= expr.t,
		.is_mutable= auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable,
	};

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue,  names_scope, auto_variable_declaration.file_pos )
			return BlockElementBuildInfo();
		}
		if( out_variable.is_mutable && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference,  names_scope, auto_variable_declaration.file_pos )
			return BlockElementBuildInfo();
		}

		out_variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		if( expr.t.GetFundamentalType().empty() )
		{
			REPORT_ERROR( NotImplemented, names_scope, auto_variable_declaration.file_pos, ust::string8("auto variables except fundamentals") )
			return BlockElementBuildInfo();
		}

		unsafe
		{
			out_variable.llvm_value=
				LLVMBuildAlloca( function_context.alloca_ir_builder, out_variable.t.GetLLVMType(), (auto_variable_declaration.name + "\0").front() );

			auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
			LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, out_variable.llvm_value );
		}
	}
	else { halt; }

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope.lock_mut();
		insert_not_ok= lock.get_ref().AddName( auto_variable_declaration.name, NamesScopeValue( move(out_variable) ) ).empty();
	}
	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( !return_operator.expr.get</Synt::EmptyVariant/>().empty() )
	{
		if( !( function_context.return_type == void_type_ && !function_context.return_value_is_reference ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, void_type_ )
			return block_element_build_info;
		}
		unsafe{  LLVMBuildRetVoid( function_context.llvm_ir_builder );  }
		return block_element_build_info;
	}

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, return_operator.expr );

	// TODO - enable type conversions in "return".
	if( expr.t != function_context.return_type )
	{
		REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, expr.t )
		return block_element_build_info;
	}

	if( function_context.return_value_is_reference )
	{
		unsafe{  LLVMBuildRet( function_context.llvm_ir_builder, expr.llvm_value );  }
	}
	else
	{
		unsafe
		{
			auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
			LLVMBuildRet( function_context.llvm_ir_builder, value_in_register );
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo
{
	auto r= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.r );
	if( r.t.GetFundamentalType().empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, assignment_operator.file_pos, r.t )
		return BlockElementBuildInfo();
	}

	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

	auto l= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.l );

	if( r.t != l.t )
	{
		REPORT_ERROR( TypesMismatch, names_scope, assignment_operator.file_pos, l.t, r.t )
		return BlockElementBuildInfo();
	}
	if( l.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, assignment_operator.file_pos )
		return BlockElementBuildInfo();
	}

	unsafe
	{
		LLVMBuildStore( function_context.llvm_ir_builder, r_in_register, l.llvm_value );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo
{
	BuildExpressionCode( names_scope, function_context, expression );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo
{
	var LLVMBasicBlockRef mut block_after_if= zero_init, mut next_condition_block= zero_init;

	unsafe
	{
		block_after_if= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to first condition. We must push terminal instruction at end of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, next_condition_block );
	}

	var BlockElementBuildInfo mut block_element_build_info{ .have_terminal_instruction_inside= true };

	auto mut i= 0s;
	while( i < if_operator.branches.size() )
	{
		auto& branch= if_operator.branches[i];

		var LLVMBasicBlockRef mut body_block= zero_init, current_condition_block= next_condition_block;
		unsafe{  body_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }

		if( i + 1s < if_operator.branches.size() )
		{
			unsafe{  next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }
		}
		else
		{
			next_condition_block= block_after_if;
		}

		// Build condition block.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, current_condition_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, current_condition_block );
		}

		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Make empty condition block - move to it unconditional break to body.
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, body_block );  }
		}
		else
		{
			var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition );
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					Synt::GetFilePos( branch.condition ),
					bool_type_,
					condition_expression.t )

				// TODO - continue here and create stub
			}
			else
			{
				auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );

				unsafe{  LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, body_block, next_condition_block );  }
			}
		}

		// Make body block code.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, body_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, body_block );
		}

		auto info= BuildBlockElement( names_scope, function_context, branch.block );
		if( !info.have_terminal_instruction_inside )
		{
			block_element_build_info.have_terminal_instruction_inside= false;
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, block_after_if );  }
		}

		++i;
	}

	if( if_operator.branches.back().condition.get</Synt::EmptyVariant/>().empty() )
	{
		block_element_build_info.have_terminal_instruction_inside= false;
	}

	if( block_element_build_info.have_terminal_instruction_inside )
	{
		// Normally we should "delete block_after_if", but llvm-c interface have no such method.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMDeleteBasicBlock( block_after_if );
		}
	}
	else
	{
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_if );
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo
{
	var LLVMBasicBlockRef mut test_block= zero_init, mut while_block= zero_init, mut block_after_while= zero_init;
	unsafe
	{
		test_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to test block. We must push terminal instruction at and of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, test_block );

		LLVMAppendExistingBasicBlock( function_context.llvm_function, test_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, test_block );
	}

	// Test block code.

	var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, while_operator.condition );
	var FilePos condition_file_pos= Synt::GetFilePos( while_operator.condition );
	if( condition_expression.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch,
				names_scope,
				condition_file_pos,
				bool_type_,
				condition_expression.t )
		return BlockElementBuildInfo();
	}

	auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );

	unsafe
	{
		while_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		block_after_while= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, while_block, block_after_while );
	}

	// While block code.

	var LoopFrame loop_frame
	{
		.block_for_break= block_after_while,
		.block_for_continue= test_block,
	};
	function_context.loops_stack.push_back(loop_frame);

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, while_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, while_block );
	}

	BuildBlockElement( names_scope, function_context, while_operator.block );
	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, test_block );  }

	function_context.loops_stack.pop_back();

	// Block after while code.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_while );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_while );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( BreakOutsideLoop, names_scope, break_operator.file_pos )
		return block_element_build_info;
	}

	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_break );  }

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( ContinueOutsideLoop, names_scope, continue_operator.file_pos )
		return block_element_build_info;
	}

	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_continue );  }

	return block_element_build_info;
}

} // namespace U
