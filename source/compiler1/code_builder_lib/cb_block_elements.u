import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr )
{
	return BuildBlockElement( names_scope, function_context, block_ptr.get_ref() );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block )
{
	var NamesScopeMutPtr block_names_scope( NamesScope( "", names_scope ) );

	foreach( &block_element : block.elements )
	{
		variant_visit( &el : block_element )
		{
			BuildBlockElement( block_names_scope, function_context, el );
		}
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration )
{
	auto t= PrepareType( names_scope, variables_declaration.t );
	foreach( &variable_declaration : variables_declaration.variables )
	{
		var NamesScopeVariable mut out_variable;
		out_variable.t= t;

		unsafe
		{
			out_variable.llvm_value=
				LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), (variable_declaration.name + "\0").front() );
		}

		BuildInitializer( names_scope, function_context, out_variable, variable_declaration.initializer );

		auto mut lock= names_scope.lock_mut();
		lock.get_ref().AddName( variable_declaration.name, NamesScopeValue( move(out_variable) ) );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration )
{
	// TODO - improve this, report about errors.
	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );

	var NamesScopeVariable mut out_variable;
	out_variable.t= expr.t;

	unsafe
	{
		out_variable.llvm_value=
			LLVMBuildAlloca( function_context.alloca_ir_builder, out_variable.t.GetLLVMType(), (auto_variable_declaration.name + "\0").front() );

		auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
		LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, out_variable.llvm_value );
	}

	auto mut lock= names_scope.lock_mut();
	lock.get_ref().AddName( auto_variable_declaration.name, NamesScopeValue( move(out_variable) ) );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator )
{
	if( !return_operator.expr.get</Synt::EmptyVariant/>().empty() )
	{
		if( function_context.return_type != void_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, void_type_ )
			return;
		}
		unsafe{  LLVMBuildRetVoid( function_context.llvm_ir_builder );  }
		return;
	}

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, return_operator.expr );

	// TODO - enable type conversions in "return".
	if( expr.t != function_context.return_type )
	{
		REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, expr.t )
		return;
	}

	unsafe
	{
		auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
		LLVMBuildRet( function_context.llvm_ir_builder, value_in_register );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator )
{
	// TODO - check for errors, check types, echec overloaded operator.

	auto r= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.r );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

	auto l= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.l );

	if( r.t != l.t )
	{
		REPORT_ERROR( TypesMismatch, names_scope, assignment_operator.file_pos, l.t, r.t )
		return;
	}

	unsafe
	{
		LLVMBuildStore( function_context.llvm_ir_builder, r_in_register, l.llvm_value );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression )
{
	BuildExpressionCode( names_scope, function_context, expression );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator )
{
	var LLVMBasicBlockRef mut block_after_if= zero_init, mut next_condition_block=zero_init;

	unsafe
	{
		block_after_if= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to first condition. We must push terminal instruction at end of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, next_condition_block );
	}

	auto mut i= 0s;
	while( i < if_operator.branches.size() )
	{
		auto& branch= if_operator.branches[i];

		var LLVMBasicBlockRef mut body_block= zero_init, current_condition_block= next_condition_block;
		unsafe{  body_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }

		if( i + 1s < if_operator.branches.size() )
		{
			unsafe{  next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }
		}
		else
		{
			next_condition_block= block_after_if;
		}

		// Build condition block.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, current_condition_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, current_condition_block );
		}

		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Make empty condition block - move to it unconditional break to body.
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, body_block );  }
		}
		else
		{
			var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition );
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					FilePos(), // TODO - set file_pos
					bool_type_,
					condition_expression.t )

				return; // TODO - continue, but create stub
			}
			else
			{
				auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );

				unsafe{  LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, body_block, next_condition_block );  }
			}
		}

		// Make body block code.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, body_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, body_block );
		}

		BuildBlockElement( names_scope, function_context, branch.block );

		// TODO - Create break instruction, only if block does not contains terminal instructions.
		unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, block_after_if );  }

		++i;
	}

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_if );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator )
{
	// TODO
	halt;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator )
{
	// TODO
	halt;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator )
{
	// TODO
	halt;
}

} // namespace U
