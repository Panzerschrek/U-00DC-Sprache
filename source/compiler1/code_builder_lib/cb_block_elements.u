import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : BlockElementBuildInfo
{
	// Empty variant - legal element kind for C style "for" operator variables declaration part.
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr ) : BlockElementBuildInfo
{
	return BuildBlockElement( names_scope, function_context, block_ptr.get_ref() );
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo
{
	var NamesScopeMutPtr block_names_scope( NamesScope( "", names_scope ) );

	var VariablesFrameHolder variables_frame_hodler(function_context);
	auto& mut function_context= variables_frame_hodler.GetFunctionContext();

	auto prev_safety= function_context.is_in_unsafe_block;

	if( block.safety == Synt::Block::Safety::None ) {}// Keep old safety
	else if( block.safety == Synt::Block::Safety::Safe )
	{
		function_context.is_in_unsafe_block= false;
	}
	else if( block.safety == Synt::Block::Safety::Unsafe )
	{
		function_context.is_in_unsafe_block=  true;
		function_context.have_non_constexpr_operations_inside= true; // Unsafe operations can not be used in constexpr functions.
	}

	var BlockElementBuildInfo mut block_element_build_info;
	foreach( &block_element : block.elements )
	{
		if( block_element_build_info.have_terminal_instruction_inside )
		{
			REPORT_ERROR( UnreachableCode, block_names_scope, Synt::GetFilePos(block_element) )
		}

		variant_visit( &el : block_element )
		{
			auto info = BuildBlockElement( block_names_scope, function_context, el );
			block_element_build_info.have_terminal_instruction_inside |= info.have_terminal_instruction_inside;
		}
	}

	if( !block_element_build_info.have_terminal_instruction_inside )
	{
		CallDestructorsForTopVariablesFrame( names_scope, function_context, block.end_file_pos );
	}

	function_context.is_in_unsafe_block= prev_safety;

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo
{
	auto t= PrepareType( names_scope, function_context, variables_declaration.t );
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, variables_declaration.file_pos, t )
		return BlockElementBuildInfo();
	}

	foreach( &variable_declaration : variables_declaration.variables )
	{
		if( IsKeyword( variable_declaration.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope, variable_declaration.file_pos )
		}

		if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && !t.CanBeConstexpr() )
		{
			REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope, variable_declaration.file_pos )
		}

		if( variable_declaration.reference_modifier != Synt::ReferenceModifier::Reference && !t.CanBeConstexpr() )
		{
			function_context.have_non_constexpr_operations_inside= true; // Declaring variable with non-constexpr type in constexpr function not allowed.
		}

		var NamesScopeVariable mut out_variable
		{
			.t= t,
			.is_mutable= variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable,
		};

		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var ReferencesGraph::NodeKind mut node_kind= zero_init;
		if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None ) { node_kind= ReferencesGraph::NodeKind::Variable; }
		else if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable ){ node_kind= ReferencesGraph::NodeKind::ReferenceMut; }
		else{ node_kind= ReferencesGraph::NodeKind::ReferenceImut; }

		out_variable.node_id= function_context.references_graph.AddNode( node_kind, variable_declaration.name );

		if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
		{
			if( t.IsAbstract() )
			{
				REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, variable_declaration.file_pos, t )
				continue;
			}

			unsafe
			{
				out_variable.llvm_value=
					LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), (variable_declaration.name + "\0").front() );
			}

			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				BuildEmptyInitializer( names_scope, function_context, out_variable, variable_declaration.name, variable_declaration.file_pos );
			}
			else
			{
				out_variable.constexpr_value= BuildInitializer( names_scope, function_context, out_variable, variable_declaration.initializer );
			}
		}
		else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				REPORT_ERROR( ExpectedInitializer, names_scope, variable_declaration.file_pos, variable_declaration.name )
				continue;
			}

			var ust::optional_ref</Synt::Expression, false/> mut initializer_expression;
			if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
			{
				initializer_expression.reset(expression_initializer);
			}
			if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
			{
				if( constructor_initializer.args.size() != 1s )
				{
					REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope, constructor_initializer.file_pos )
					continue;
				}

				initializer_expression.reset( constructor_initializer.args.front().get_ref() );
			}

			if( initializer_expression.empty() )
			{
				REPORT_ERROR( UnsupportedInitializerForReference, names_scope, variable_declaration.file_pos )
				continue;
			}

			auto expression_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, initializer_expression.get_ref() );
			if( expression_result.t != t && !expression_result.t.ReferenceIsConvertibleTo( t ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, variable_declaration.file_pos, t, expression_result.t )
				continue;
			}
			if( expression_result.value_type == ValueType::Value )
			{
				REPORT_ERROR( ExpectedReferenceValue, names_scope, variable_declaration.file_pos )
				continue;
			}
			if( out_variable.is_mutable && expression_result.value_type == ValueType::ReferenceImut )
			{
				REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, variable_declaration.file_pos )
				continue;
			}

			out_variable.llvm_value= CreateReferenceCast( expression_result.llvm_value, expression_result.t, t, function_context );
			out_variable.constexpr_value= expression_result.constexpr_value;
		}
		else{ halt; }

		if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && out_variable.constexpr_value == LLVMValueRef::Null )
		{
			REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, variable_declaration.file_pos )
		}

		// Reset constant value for mutable variable
		if( out_variable.is_mutable )
		{
			out_variable.constexpr_value= LLVMValueRef::Null;
		}

		// Register variable for destruction and reference checking.
		auto frame_index= function_context.variables_frames.size() - 2s;
		function_context.variables_frames[ frame_index ].push_back( out_variable );

		var bool mut insert_not_ok= false;
		{
			auto mut lock= names_scope.lock_mut();
			insert_not_ok= lock.get_ref().AddName( variable_declaration.name, NamesScopeValue( move(out_variable) ) ).empty();
		}
		if( insert_not_ok )
		{
			REPORT_ERROR( Redefinition, names_scope, variable_declaration.file_pos, variable_declaration.name )
		}

		CallDestructorsForTopVariablesFrame( names_scope, function_context, variable_declaration.file_pos );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration )  : BlockElementBuildInfo
{
	if( IsKeyword( auto_variable_declaration.name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope, auto_variable_declaration.file_pos )
	}

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );
	if( expr.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
		return BlockElementBuildInfo();
	}

	var NamesScopeVariable mut out_variable
	{
		.t= expr.t,
		.is_mutable= auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable,
		.constexpr_value= expr.constexpr_value
	};

	var ReferencesGraph::NodeKind mut node_kind= zero_init;
	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None ) { node_kind= ReferencesGraph::NodeKind::Variable; }
	else if( auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable ){ node_kind= ReferencesGraph::NodeKind::ReferenceMut; }
	else{ node_kind= ReferencesGraph::NodeKind::ReferenceImut; }

	out_variable.node_id= function_context.references_graph.AddNode( node_kind, auto_variable_declaration.name );

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue,  names_scope, auto_variable_declaration.file_pos )
			return BlockElementBuildInfo();
		}
		if( out_variable.is_mutable && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference,  names_scope, auto_variable_declaration.file_pos )
			return BlockElementBuildInfo();
		}

		out_variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		if( expr.t.IsAbstract() )
		{
			REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, auto_variable_declaration.file_pos, expr.t )
			return BlockElementBuildInfo();
		}

		if( !expr.t.CanBeConstexpr() )
		{
			function_context.have_non_constexpr_operations_inside= true; // Declaring variable with non-constexpr type in constexpr function not allowed.
		}

		unsafe
		{
			out_variable.llvm_value=
				LLVMBuildAlloca( function_context.alloca_ir_builder, out_variable.t.GetLLVMType(), (auto_variable_declaration.name + "\0").front() );
		}

		if( !expr.t.IsCopyConstructible() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, auto_variable_declaration.file_pos, out_variable.t )
			return BlockElementBuildInfo();
		}

		BuildCopyConstructorPart( names_scope, function_context, out_variable.llvm_value, expr.llvm_value, out_variable.t, auto_variable_declaration.file_pos );
	}
	else { halt; }

	if( auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && out_variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, auto_variable_declaration.file_pos )
	}

	// Reset constant value for mutable variable
	if( out_variable.is_mutable )
	{
		out_variable.constexpr_value= LLVMValueRef::Null;
	}

	// Register variable for destruction and reference checking.
	auto frame_index= function_context.variables_frames.size() - 2s;
	function_context.variables_frames[ frame_index ].push_back( out_variable );

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope.lock_mut();
		insert_not_ok= lock.get_ref().AddName( auto_variable_declaration.name, NamesScopeValue( move(out_variable) ) ).empty();
	}
	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, auto_variable_declaration.file_pos );

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( !return_operator.expr.get</Synt::EmptyVariant/>().empty() )
	{
		if( !( function_context.return_type == void_type_ && !function_context.return_value_is_reference ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, void_type_ )
			return block_element_build_info;
		}
		CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.file_pos );
		unsafe
		{
			if( function_context.destructor_end_block != LLVMBasicBlockRef::Null )
			{
				LLVMBuildBr( function_context.llvm_ir_builder, function_context.destructor_end_block );
			}
			else
			{
				LLVMBuildRetVoid( function_context.llvm_ir_builder );
			}
		}
		return block_element_build_info;
	}

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, return_operator.expr );

	if( function_context.return_value_is_reference )
	{
		if( expr.t != function_context.return_type && !expr.t.ReferenceIsConvertibleTo( function_context.return_type ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, expr.t )
			return block_element_build_info;
		}
		if( function_context.return_value_is_mutable && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, return_operator.file_pos )
		}
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, return_operator.file_pos )
			return block_element_build_info;
		}

		CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.file_pos );

		auto reference_converted= CreateReferenceCast( expr.llvm_value, expr.t, function_context.return_type, function_context );
		unsafe{  LLVMBuildRet( function_context.llvm_ir_builder, reference_converted );  }
	}
	else
	{
		if( expr.t != function_context.return_type )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, expr.t )
			return block_element_build_info;
		}

		auto ret_type= function_context.return_type;
		if( !ret_type.GetClassType().empty() || !ret_type.GetTupleType().empty() )
		{
			auto s_ret= function_context.s_ret;
			BuildCopyConstructorPart( names_scope, function_context, s_ret, expr.llvm_value, expr.t, return_operator.file_pos );
			CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.file_pos );
			unsafe{  LLVMBuildRetVoid( function_context.llvm_ir_builder );  }
			return block_element_build_info;
		}

		unsafe
		{
			auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
			CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.file_pos );
			LLVMBuildRet( function_context.llvm_ir_builder, value_in_register );
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	if( !TryCallOverloadedBinaryOperator(
			names_scope,
			function_context,
			OverloadedOperator::Assign,
			assignment_operator.l,
			assignment_operator.r,
			ArgsEvaluationOrder::Reversed,
			assignment_operator.file_pos ).empty() )
	{}
	else
	{
		auto r= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.r.get_ref() );
		if( r.t.GetFundamentalType().empty() && r.t.GetEnumType().empty() && r.t.GetFunctionPointerType().empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, assignment_operator.file_pos, r.t )
			return BlockElementBuildInfo();
		}

		auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

		auto l= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.l.get_ref() );

		if( r.t != l.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, assignment_operator.file_pos, l.t, r.t )
			return BlockElementBuildInfo();
		}
		if( l.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, assignment_operator.file_pos )
			return BlockElementBuildInfo();
		}

		unsafe
		{
			LLVMBuildStore( function_context.llvm_ir_builder, r_in_register, l.llvm_value );
		}
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, assignment_operator.file_pos );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	if( !TryCallOverloadedBinaryOperator(
			names_scope,
			function_context,
			GetOverloadedOperatorForAdditiveAssignmentOperator( additive_assignment_operator.operator ),
			additive_assignment_operator.l,
			additive_assignment_operator.r,
			ArgsEvaluationOrder::Reversed,
			additive_assignment_operator.file_pos ).empty() )
	{}
	else
	{
		auto mut r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, additive_assignment_operator.r.get_ref() );
		// Save r_var in register, prevent its modification during l_var calculation.
		r_var.llvm_value= CreateMoveToLLVMRegisterInstruction( r_var, function_context );
		r_var.location= Variable::Location::LLVMRegister;
		r_var.value_type= ValueType::Value;

		auto l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, additive_assignment_operator.l.get_ref() );
		if( l_var.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, additive_assignment_operator.file_pos )
			return BlockElementBuildInfo();
		}

		auto op_result= BuildBinaryOperator( names_scope, function_context, l_var, r_var, additive_assignment_operator.operator, additive_assignment_operator.file_pos );
		auto op_result_variable_ref= op_result.get</Variable/>();
		if( op_result_variable_ref.empty() )
		{
			return BlockElementBuildInfo();
		}

		unsafe
		{
			LLVMBuildStore(
				function_context.llvm_ir_builder,
				CreateMoveToLLVMRegisterInstruction( op_result_variable_ref.get_ref(), function_context ),
				l_var.llvm_value );
		}
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, additive_assignment_operator.file_pos );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo
{
	BuildDeltaOneOperator( names_scope, function_context, increment_operator.expression, increment_operator.file_pos, +1 );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo
{
	BuildDeltaOneOperator( names_scope, function_context, decrement_operator.expression, decrement_operator.file_pos, -1 );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	BuildExpressionCode( names_scope, function_context, expression );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo
{
	auto mut references_graph_before= function_context.references_graph;
	var LLVMBasicBlockRef mut block_after_if= zero_init, mut next_condition_block= zero_init;

	unsafe
	{
		block_after_if= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to first condition. We must push terminal instruction at end of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, next_condition_block );
	}

	var BlockElementBuildInfo mut block_element_build_info{ .have_terminal_instruction_inside= true };

	for( auto mut i= 0s; i < if_operator.branches.size(); ++i )
	{
		auto& branch= if_operator.branches[i];

		var LLVMBasicBlockRef mut body_block= zero_init, current_condition_block= next_condition_block;
		unsafe{  body_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }

		if( i + 1s < if_operator.branches.size() )
		{
			unsafe{  next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }
		}
		else
		{
			next_condition_block= block_after_if;
		}

		// Build condition block.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, current_condition_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, current_condition_block );
		}

		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Make empty condition block - move to it unconditional break to body.
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, body_block );  }
		}
		else
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition );
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					Synt::GetFilePos( branch.condition ),
					bool_type_,
					condition_expression.t )

				// TODO - continue here and create stub
			}
			else
			{
				auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );
				CallDestructorsForTopVariablesFrame( names_scope, function_context, branch.file_pos );

				unsafe{  LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, body_block, next_condition_block );  }
			}
		}

		// Make body block code.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, body_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, body_block );
		}

		auto mut references_graph_before_this_branch= function_context.references_graph;

		auto info= BuildBlockElement( names_scope, function_context, branch.block );
		if( !info.have_terminal_instruction_inside )
		{
			block_element_build_info.have_terminal_instruction_inside= false;
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, block_after_if );  }
		}

		function_context.references_graph= move(references_graph_before_this_branch);
	}

	if( if_operator.branches.back().condition.get</Synt::EmptyVariant/>().empty() )
	{
		block_element_build_info.have_terminal_instruction_inside= false;
	}

	if( block_element_build_info.have_terminal_instruction_inside )
	{
		// Normally we should "delete block_after_if", but llvm-c interface have no such method.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMDeleteBasicBlock( block_after_if );
		}
	}
	else
	{
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_if );
		}
	}

	// TODO - merge references graph of all branches.

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticIfOperator& static_if_operator ) : BlockElementBuildInfo
{
	foreach( &branch : static_if_operator.if_operator.branches )
	{
		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Last unconditional "else"
			return BuildBlockElement( names_scope, function_context, branch.block );
		}
		else
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition );
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					Synt::GetFilePos( branch.condition ),
					bool_type_,
					condition_expression.t )
				return BlockElementBuildInfo();
			}
			if( condition_expression.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, Synt::GetFilePos( branch.condition ) )
				return BlockElementBuildInfo();
			}

			CallDestructorsForTopVariablesFrame( names_scope, function_context, branch.file_pos );

			var u64 mut constexpr_value= 0u64;
			unsafe{  constexpr_value= LLVMConstIntGetZExtValue( condition_expression.constexpr_value );  }
			if( constexpr_value != 0u64 )
			{
				return BuildBlockElement( names_scope, function_context, branch.block );
			}
		}
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo
{
	auto mut references_graph_before= function_context.references_graph;

	var LLVMBasicBlockRef mut test_block= zero_init, mut while_block= zero_init, mut block_after_while= zero_init;
	unsafe
	{
		test_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to test block. We must push terminal instruction at and of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, test_block );

		LLVMAppendExistingBasicBlock( function_context.llvm_function, test_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, test_block );
	}

	// Test block code.
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, while_operator.condition );
		var FilePos condition_file_pos= Synt::GetFilePos( while_operator.condition );
		if( condition_expression.t != bool_type_ )
		{
			REPORT_ERROR( TypesMismatch,
					names_scope,
					condition_file_pos,
					bool_type_,
					condition_expression.t )
			return BlockElementBuildInfo();
		}

		auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );
		CallDestructorsForTopVariablesFrame( names_scope, function_context, condition_file_pos );

		unsafe
		{
			while_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
			block_after_while= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
			LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, while_block, block_after_while );
		}
	}

	// While block code.

	var LoopFrame loop_frame
	{
		.block_for_break= block_after_while,
		.block_for_continue= test_block,
		.variable_frames_stack_size= function_context.variables_frames.size(),
	};
	function_context.loops_stack.push_back(loop_frame);

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, while_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, while_block );
	}

	auto info= BuildBlockElement( names_scope, function_context, while_operator.block );
	if( !info.have_terminal_instruction_inside )
	{
		unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, test_block );  }
	}

	function_context.loops_stack.pop_back();

	// Block after while code.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_while );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_while );
	}

	// TODO - process references graph changes in loop.
	function_context.references_graph= move(references_graph_before);

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RangeForOperator& range_for_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var Variable sequence_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, range_for_operator.sequence );

	if_var( &tuple_type : sequence_expression.t.GetTupleType() )
	{
		auto mut finish_basic_block= LLVMBasicBlockRef::Null;
		if( !tuple_type.element_types.empty() )
		{
			unsafe{  finish_basic_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }
		}

		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			// Create separate names_scope for loop variable.
			var NamesScopeMutPtr names_scope( NamesScope( "", names_scope ) );

			var VariablesFrameHolder element_pass_temp_variables_frame_hodler(function_context);
			auto& mut function_context= element_pass_temp_variables_frame_hodler.GetFunctionContext();

			var NamesScopeVariable mut variable
			{
				.t= tuple_type.element_types[i],
				.is_mutable= range_for_operator.mutability_modifier == Synt::MutabilityModifier::Mutable,
				//.constexpr_value= expr.constexpr_value
			};

			auto src_element_llvm_value= CreateTupleElementGEP( sequence_expression.llvm_value, i, function_context );

			if( range_for_operator.reference_modifier == Synt::ReferenceModifier::Reference )
			{
				if( sequence_expression.value_type == ValueType::Value )
				{
					REPORT_ERROR( ExpectedReferenceValue, names_scope, range_for_operator.file_pos )
					return BlockElementBuildInfo();
				}
				if( variable.is_mutable && sequence_expression.value_type != ValueType::ReferenceMut )
				{
					REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, range_for_operator.file_pos )
					return BlockElementBuildInfo();
				}

				variable.llvm_value= src_element_llvm_value;
			}
			else if( range_for_operator.reference_modifier == Synt::ReferenceModifier::None )
			{
				unsafe
				{
					variable.llvm_value=
						LLVMBuildAlloca( function_context.alloca_ir_builder, variable.t.GetLLVMType(), (range_for_operator.loop_variable_name + "\0").front() );
				}

				if( !sequence_expression.t.IsCopyConstructible() )
				{
					REPORT_ERROR( OperationNotSupportedForThisType, names_scope, range_for_operator.file_pos, variable.t )
					return BlockElementBuildInfo();
				}

				BuildCopyConstructorPart( names_scope, function_context, variable.llvm_value, src_element_llvm_value, variable.t, range_for_operator.file_pos );
			}
			else{ halt; }

			{
				auto mut lock= names_scope.lock_mut();
				lock.get_ref().AddName( range_for_operator.loop_variable_name, NamesScopeValue( move(variable) ) ).empty();
			}

			auto mut next_basic_block= LLVMBasicBlockRef::Null;
			if( i + 1s < tuple_type.element_types.size() )
			{
				unsafe{  next_basic_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }
			}
			else
			{
				next_basic_block= finish_basic_block;
			}

			var LoopFrame loop_frame
			{
				.block_for_break= finish_basic_block,
				.block_for_continue= next_basic_block,
				.variable_frames_stack_size= function_context.variables_frames.size(),
			};
			function_context.loops_stack.push_back(loop_frame);

			auto block_build_info= BuildBlockElement( names_scope, function_context, range_for_operator.block.get_ref() );

			function_context.loops_stack.pop_back();

			CallDestructorsForTopVariablesFrame( names_scope, function_context, range_for_operator.file_pos ); // destroy loop variable

			if( !block_build_info.have_terminal_instruction_inside )
			{
				unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, next_basic_block );  }
			}
			unsafe
			{
				LLVMAppendExistingBasicBlock( function_context.llvm_function, next_basic_block );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, next_basic_block );
			}

			// Clear args preevaluation cache because we evaluationg same expressions multiple times in different context.
			function_context.args_preevaluation_cache.clear();
		}

		CallDestructorsForTopVariablesFrame( names_scope, function_context, range_for_operator.file_pos );
		return BlockElementBuildInfo();
	}

	// TODO - support array types.
	REPORT_ERROR( OperationNotSupportedForThisType, names_scope, range_for_operator.file_pos, sequence_expression.t )
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CStyleForOperator& c_style_for_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder loop_variables_frame_hodler(function_context);
	auto& mut function_context= loop_variables_frame_hodler.GetFunctionContext();

	// Create separate names_scope for loop variables.
	var NamesScopeMutPtr names_scope( NamesScope( "", names_scope ) );

	// Variables declaration part.
	variant_visit( &element : c_style_for_operator.variable_declaration_part )
	{
		BuildBlockElement( names_scope, function_context, element );
	}

	var LLVMBasicBlockRef mut test_block= zero_init, mut loop_block= zero_init, mut loop_iteration_block= zero_init, mut block_after_loop= zero_init;
	unsafe
	{
		test_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		loop_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		loop_iteration_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		block_after_loop= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
	}

	// Test block.
	unsafe
	{
		LLVMBuildBr( function_context.llvm_ir_builder, test_block );
		LLVMAppendExistingBasicBlock( function_context.llvm_function, test_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, test_block );
	}

	if( !c_style_for_operator.loop_condition.get</Synt::EmptyVariant/>().empty() )
	{
		// No condition.
		unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, loop_block );  }
	}
	else
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, c_style_for_operator.loop_condition );
		var FilePos condition_file_pos= Synt::GetFilePos( c_style_for_operator.loop_condition );
		if( condition_expression.t != bool_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, condition_file_pos, bool_type_, condition_expression.t )
			return BlockElementBuildInfo();
		}

		auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );
		CallDestructorsForTopVariablesFrame( names_scope, function_context, condition_file_pos );

		unsafe{  LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, loop_block, block_after_loop );  }
	}

	// Loop block code.
	var LoopFrame loop_frame
	{
		.block_for_break= block_after_loop,
		.block_for_continue= loop_iteration_block,
		.variable_frames_stack_size= function_context.variables_frames.size(),
	};
	function_context.loops_stack.push_back(loop_frame);

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, loop_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, loop_block );
	}

	auto info= BuildBlockElement( names_scope, function_context, c_style_for_operator.block );
	if( !info.have_terminal_instruction_inside )
	{
		unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, loop_iteration_block );  }
	}

	function_context.loops_stack.pop_back();

	// Loop iteration block.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, loop_iteration_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, loop_iteration_block );
	}
	foreach( &element : c_style_for_operator.iteration_part_elements )
	{
		variant_visit( &el : element )
		{
			BuildBlockElement( names_scope, function_context, el );
		}
	}

	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, test_block );  }

	// Block after loop.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_loop );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_loop );
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, c_style_for_operator.file_pos );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( BreakOutsideLoop, names_scope, break_operator.file_pos )
		return block_element_build_info;
	}

	CallDestructorsForLoopInnerVariables( names_scope, function_context, break_operator.file_pos );
	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_break );  }

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( ContinueOutsideLoop, names_scope, continue_operator.file_pos )
		return block_element_build_info;
	}

	CallDestructorsForLoopInnerVariables( names_scope, function_context, continue_operator.file_pos );
	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_continue );  }

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo
{
	var Variable mut condition_variable;
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		auto instructions_state= SaveInstructionsState( function_context );
		condition_variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, static_assert_.expression );
		RestoreInstructionsState( function_context, instructions_state );
	}

	if( condition_variable.t != bool_type_ )
	{
		REPORT_ERROR( StaticAssertExpressionMustHaveBoolType, names_scope, static_assert_.file_pos )
		return BlockElementBuildInfo();
	}
	if( condition_variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( StaticAssertExpressionIsNotConstant, names_scope, static_assert_.file_pos )
		return BlockElementBuildInfo();
	}

	var u64 mut val= zero_init;
	unsafe{  val= LLVMConstIntGetZExtValue( condition_variable.constexpr_value );  }
	if( val == 0u64 )
	{
		REPORT_ERROR( StaticAssertionFailed, names_scope, static_assert_.file_pos )
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	unsafe
	{
		LLVMBuildCall( function_context.llvm_ir_builder, halt_function_, LLVMValueRef::Null, 0u, "\0"[0] );
		LLVMBuildUnreachable( function_context.llvm_ir_builder );
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	auto condition= BuildExpressionCodeEnsureVariable( names_scope, function_context, halt_if.condition );
	if( condition.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch, names_scope, Synt::GetFilePos( halt_if.condition ), bool_type_, condition.t )
		return BlockElementBuildInfo();
	}

	auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition, function_context );
	CallDestructorsForTopVariablesFrame( names_scope, function_context, halt_if.file_pos );

	unsafe
	{
		auto true_block = LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		auto false_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, true_block, false_block );

		// True branch
		LLVMAppendExistingBasicBlock( function_context.llvm_function, true_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, true_block );

		LLVMBuildCall( function_context.llvm_ir_builder, halt_function_, LLVMValueRef::Null, 0u, "\0"[0] );
		LLVMBuildUnreachable( function_context.llvm_ir_builder );

		// False branch
		LLVMAppendExistingBasicBlock( function_context.llvm_function, false_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, false_block );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildDeltaOneOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, FilePos& file_pos, i32 delta )
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression );

	if( variable.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, file_pos )
		return;
	}

	// Try process overloaded operator.
	if( ! variable.t.GetClassType().empty() )
	{
		var [ FunctionType::Param, 1 ] args
		[ {
			.t(variable.t),
			.is_mutable= variable.value_type == ValueType::ReferenceMut,
			.is_reference= variable.value_type != ValueType::Value,
		} ];

		auto operator= select( delta == 1 ? OverloadedOperator::Increment : OverloadedOperator::Decrement );
		if_var( mut overloaded_operator : GetOverloadedOperator( args, operator, names_scope, file_pos ) )
		{
			if( overloaded_operator.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
			{
				function_context.have_non_constexpr_operations_inside= true;
			}

			auto fetch_result= TryFetchVirtualFunction( variable, overloaded_operator, function_context );
			overloaded_operator.llvm_function= fetch_result[1];

			DoCallFunction(
				names_scope,
				function_context,
				ust::optional_ref</ Variable, false />(fetch_result[0]),
				overloaded_operator,
				ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />(),
				file_pos );
			CallDestructorsForTopVariablesFrame( names_scope, function_context, file_pos );
			return;
		}
	}

	// Process operator for fundamental type.

	if( variable.t.GetFundamentalType().empty() || !IsInteger( variable.t.GetFundamentalType().get_ref().fundamental_type ) )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, variable.t )
		return;
	}

	unsafe
	{
		auto operand_value= CreateMoveToLLVMRegisterInstruction( variable, function_context );
		auto delta_value= LLVMConstInt( variable.t.GetLLVMType(), u64(delta), LLVMBool::True );
		auto result_value= LLVMBuildAdd( function_context.llvm_ir_builder, operand_value, delta_value, "\0"[0] );
		LLVMBuildStore( function_context.llvm_ir_builder, result_value, variable.llvm_value );
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, file_pos );
}

} // namespace U1
