import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr )
{
	return BuildBlockElement( names_scope, function_context, block_ptr.get_ref() );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block )
{
	var NamesScopePtr block_names_scope( NamesScope( "", names_scope ) );

	foreach( &block_element : block.elements )
	{
		variant_visit( &el : block_element )
		{
			BuildBlockElement( block_names_scope, function_context, el );
		}
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration )
{
	auto t= PrepareType( names_scope, variables_declaration.t );
	foreach( &variable_declaration : variables_declaration.variables )
	{
		var NamesScopeVariable mut out_variable;
		out_variable.t= t;

		unsafe
		{
			out_variable.llvm_value=
				LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), (variable_declaration.name + "\0").front() );
		}

		BuildInitializer( names_scope, function_context, out_variable, variable_declaration.initializer );

		auto mut lock= names_scope.lock_mut();
		lock.get_ref().AddName( variable_declaration.name, NamesScopeValue( move(out_variable) ) );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration )
{
	// TODO - improve this, report about errors.
	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );

	var NamesScopeVariable mut out_variable;
	out_variable.t= expr.t;

	unsafe
	{
		out_variable.llvm_value=
			LLVMBuildAlloca( function_context.alloca_ir_builder, out_variable.t.GetLLVMType(), (auto_variable_declaration.name + "\0").front() );

		auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
		LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, out_variable.llvm_value );
	}

	auto mut lock= names_scope.lock_mut();
	lock.get_ref().AddName( auto_variable_declaration.name, NamesScopeValue( move(out_variable) ) );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator )
{
	if( !return_operator.expr.get</Synt::EmptyVariant/>().empty() )
	{
		if( function_context.return_type != void_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, void_type_ )
			return;
		}
		unsafe{  LLVMBuildRetVoid( function_context.llvm_ir_builder );  }
		return;
	}

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, return_operator.expr );

	// TODO - enable type conversions in "return".
	if( expr.t != function_context.return_type )
	{
		REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, expr.t )
		return;
	}

	unsafe
	{
		auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
		LLVMBuildRet( function_context.llvm_ir_builder, value_in_register );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator )
{
	// TODO - check for errors, check types, echec overloaded operator.

	auto r= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.r );
	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

	auto l= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.l );

	unsafe
	{
		LLVMBuildStore( function_context.llvm_ir_builder, r_in_register, l.llvm_value );
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression )
{
	// TODO
	halt;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator )
{
	// TODO
	halt;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator )
{
	// TODO
	halt;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator )
{
	// TODO
	halt;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator )
{
	// TODO
	halt;
}

} // namespace U
