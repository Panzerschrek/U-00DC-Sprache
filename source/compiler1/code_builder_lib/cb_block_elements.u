import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr ) : BlockElementBuildInfo
{
	return BuildBlockElement( names_scope, function_context, block_ptr.get_ref() );
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo
{
	var NamesScopeMutPtr block_names_scope( NamesScope( "", names_scope ) );

	var VariablesFrameHolder variables_frame_hodler(function_context);
	auto& mut function_context= variables_frame_hodler.GetFunctionContext();

	var BlockElementBuildInfo mut block_element_build_info;
	foreach( &block_element : block.elements )
	{
		if( block_element_build_info.have_terminal_instruction_inside )
		{
			REPORT_ERROR( UnreachableCode, block_names_scope, Synt::GetFilePos(block_element) )
		}

		variant_visit( &el : block_element )
		{
			auto info = BuildBlockElement( block_names_scope, function_context, el );
			block_element_build_info.have_terminal_instruction_inside |= info.have_terminal_instruction_inside;
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo
{
	auto t= PrepareType( names_scope, function_context, variables_declaration.t );
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, variables_declaration.file_pos, t )
		return BlockElementBuildInfo();
	}

	foreach( &variable_declaration : variables_declaration.variables )
	{
		if( IsKeyword( variable_declaration.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope, variable_declaration.file_pos )
		}

		if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && !t.CanBeConstexpr() )
		{
			REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope, variable_declaration.file_pos )
		}

		var NamesScopeVariable mut out_variable
		{
			.t= t,
			.is_mutable= variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable,
		};

		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
		{
			unsafe
			{
				out_variable.llvm_value=
					LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), (variable_declaration.name + "\0").front() );
			}

			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				BuildEmptyInitializer( names_scope, function_context, out_variable, variable_declaration.name, variable_declaration.file_pos );

			}
			else
			{
				out_variable.constexpr_value= BuildInitializer( names_scope, function_context, out_variable, variable_declaration.initializer );
			}
		}
		else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				REPORT_ERROR( ExpectedInitializer, names_scope, variable_declaration.file_pos, variable_declaration.name )
				continue;
			}

			var ust::optional_ref</Synt::Expression, false/> mut initializer_expression;
			if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
			{
				initializer_expression.reset(expression_initializer);
			}
			if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
			{
				if( constructor_initializer.args.size() != 1s )
				{
					REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope, constructor_initializer.file_pos )
					continue;
				}

				initializer_expression.reset( constructor_initializer.args.front().get_ref() );
			}

			if( initializer_expression.empty() )
			{
				REPORT_ERROR( UnsupportedInitializerForReference, names_scope, variable_declaration.file_pos )
				continue;
			}

			auto expression_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, initializer_expression.get_ref() );
			// TODO - allow reference conversion
			if( expression_result.t != t )
			{
				REPORT_ERROR( TypesMismatch, names_scope, variable_declaration.file_pos, t, expression_result.t )
				continue;
			}
			if( expression_result.value_type == ValueType::Value )
			{
				REPORT_ERROR( ExpectedReferenceValue, names_scope, variable_declaration.file_pos )
				continue;
			}
			if( out_variable.is_mutable && expression_result.value_type == ValueType::ReferenceImut )
			{
				REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, variable_declaration.file_pos )
				continue;
			}

			out_variable.llvm_value= expression_result.llvm_value;
			out_variable.constexpr_value= expression_result.constexpr_value;
		}
		else{ halt; }

		if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && out_variable.constexpr_value == LLVMValueRef::Null )
		{
			REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, variable_declaration.file_pos )
		}

		// Reset constant value for mutable variable
		if( out_variable.is_mutable )
		{
			out_variable.constexpr_value= LLVMValueRef::Null;
		}

		var bool mut insert_not_ok= false;
		{
			auto mut lock= names_scope.lock_mut();
			insert_not_ok= lock.get_ref().AddName( variable_declaration.name, NamesScopeValue( move(out_variable) ) ).empty();
		}
		if( insert_not_ok )
		{
			REPORT_ERROR( Redefinition, names_scope, variable_declaration.file_pos, variable_declaration.name )
		}
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration )  : BlockElementBuildInfo
{
	if( IsKeyword( auto_variable_declaration.name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope, auto_variable_declaration.file_pos )
	}

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );
	if( expr.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
		return BlockElementBuildInfo();
	}

	var NamesScopeVariable mut out_variable
	{
		.t= expr.t,
		.is_mutable= auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable,
		.constexpr_value= expr.constexpr_value
	};

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue,  names_scope, auto_variable_declaration.file_pos )
			return BlockElementBuildInfo();
		}
		if( out_variable.is_mutable && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference,  names_scope, auto_variable_declaration.file_pos )
			return BlockElementBuildInfo();
		}

		out_variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		unsafe
		{
			out_variable.llvm_value=
				LLVMBuildAlloca( function_context.alloca_ir_builder, out_variable.t.GetLLVMType(), (auto_variable_declaration.name + "\0").front() );
		}

		if( !expr.t.IsCopyConstructible() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, auto_variable_declaration.file_pos, out_variable.t )
			return BlockElementBuildInfo();
		}

		BuildCopyConstructorPart( function_context, out_variable.llvm_value, expr.llvm_value, out_variable.t );
	}
	else { halt; }

	if( auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && out_variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, auto_variable_declaration.file_pos )
	}

	// Reset constant value for mutable variable
	if( out_variable.is_mutable )
	{
		out_variable.constexpr_value= LLVMValueRef::Null;
	}

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope.lock_mut();
		insert_not_ok= lock.get_ref().AddName( auto_variable_declaration.name, NamesScopeValue( move(out_variable) ) ).empty();
	}
	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( !return_operator.expr.get</Synt::EmptyVariant/>().empty() )
	{
		if( !( function_context.return_type == void_type_ && !function_context.return_value_is_reference ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, void_type_ )
			return block_element_build_info;
		}
		unsafe{  LLVMBuildRetVoid( function_context.llvm_ir_builder );  }
		return block_element_build_info;
	}

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, return_operator.expr );

	// TODO - enable type conversions in "return".
	if( expr.t != function_context.return_type )
	{
		REPORT_ERROR( TypesMismatch, names_scope, return_operator.file_pos, function_context.return_type, expr.t )
		return block_element_build_info;
	}

	if( function_context.return_value_is_reference )
	{
		if( function_context.return_value_is_mutable && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, return_operator.file_pos )
		}
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, return_operator.file_pos )
			return block_element_build_info;
		}

		unsafe{  LLVMBuildRet( function_context.llvm_ir_builder, expr.llvm_value );  }
	}
	else
	{
		auto ret_type= function_context.return_type;
		if_var( &class_type : ret_type.GetClassType() )
		{
			auto s_ret= function_context.s_ret;
			TryCallCopyConstructor( names_scope, function_context, s_ret, expr.llvm_value, class_type, return_operator.file_pos );
			unsafe{  LLVMBuildRetVoid( function_context.llvm_ir_builder );  }
			return block_element_build_info;
		}

		unsafe
		{
			auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
			LLVMBuildRet( function_context.llvm_ir_builder, value_in_register );
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	auto r= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.r );
	if( r.t.GetFundamentalType().empty() && r.t.GetEnumType().empty() )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, assignment_operator.file_pos, r.t )
		return BlockElementBuildInfo();
	}

	auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

	auto l= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.l );

	if( r.t != l.t )
	{
		REPORT_ERROR( TypesMismatch, names_scope, assignment_operator.file_pos, l.t, r.t )
		return BlockElementBuildInfo();
	}
	if( l.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, assignment_operator.file_pos )
		return BlockElementBuildInfo();
	}

	unsafe
	{
		LLVMBuildStore( function_context.llvm_ir_builder, r_in_register, l.llvm_value );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	auto mut r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, additive_assignment_operator.r );
	// Save r_var in register, prevent its modification during l_var calculation.
	r_var.llvm_value= CreateMoveToLLVMRegisterInstruction( r_var, function_context );
	r_var.location= Variable::Location::LLVMRegister;
	r_var.value_type= ValueType::Value;

	auto l_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, additive_assignment_operator.l );
	if( l_var.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, additive_assignment_operator.file_pos )
		return BlockElementBuildInfo();
	}

	auto op_result= BuildBinaryOperator( names_scope, function_context, l_var, r_var, additive_assignment_operator.operator, additive_assignment_operator.file_pos );
	auto op_result_variable_ref= op_result.get</Variable/>();
	if( op_result_variable_ref.empty() )
	{
		return BlockElementBuildInfo();
	}

	unsafe
	{
		LLVMBuildStore(
			function_context.llvm_ir_builder,
			CreateMoveToLLVMRegisterInstruction( op_result_variable_ref.get_ref(), function_context ),
			l_var.llvm_value );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo
{
	BuildDeltaOneOperator( names_scope, function_context, increment_operator.expression, increment_operator.file_pos, +1 );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo
{
	BuildDeltaOneOperator( names_scope, function_context, decrement_operator.expression, decrement_operator.file_pos, -1 );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	BuildExpressionCode( names_scope, function_context, expression );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo
{
	var LLVMBasicBlockRef mut block_after_if= zero_init, mut next_condition_block= zero_init;

	unsafe
	{
		block_after_if= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to first condition. We must push terminal instruction at end of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, next_condition_block );
	}

	var BlockElementBuildInfo mut block_element_build_info{ .have_terminal_instruction_inside= true };

	for( auto mut i= 0s; i < if_operator.branches.size(); ++i )
	{
		auto& branch= if_operator.branches[i];

		var LLVMBasicBlockRef mut body_block= zero_init, current_condition_block= next_condition_block;
		unsafe{  body_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }

		if( i + 1s < if_operator.branches.size() )
		{
			unsafe{  next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );  }
		}
		else
		{
			next_condition_block= block_after_if;
		}

		// Build condition block.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, current_condition_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, current_condition_block );
		}

		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Make empty condition block - move to it unconditional break to body.
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, body_block );  }
		}
		else
		{
			var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition );
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					Synt::GetFilePos( branch.condition ),
					bool_type_,
					condition_expression.t )

				// TODO - continue here and create stub
			}
			else
			{
				auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );

				unsafe{  LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, body_block, next_condition_block );  }
			}
		}

		// Make body block code.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, body_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, body_block );
		}

		auto info= BuildBlockElement( names_scope, function_context, branch.block );
		if( !info.have_terminal_instruction_inside )
		{
			block_element_build_info.have_terminal_instruction_inside= false;
			unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, block_after_if );  }
		}
	}

	if( if_operator.branches.back().condition.get</Synt::EmptyVariant/>().empty() )
	{
		block_element_build_info.have_terminal_instruction_inside= false;
	}

	if( block_element_build_info.have_terminal_instruction_inside )
	{
		// Normally we should "delete block_after_if", but llvm-c interface have no such method.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMDeleteBasicBlock( block_after_if );
		}
	}
	else
	{
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_if );
		}
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo
{
	var LLVMBasicBlockRef mut test_block= zero_init, mut while_block= zero_init, mut block_after_while= zero_init;
	unsafe
	{
		test_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		// Break to test block. We must push terminal instruction at and of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, test_block );

		LLVMAppendExistingBasicBlock( function_context.llvm_function, test_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, test_block );
	}

	// Test block code.

	var Variable condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, while_operator.condition );
	var FilePos condition_file_pos= Synt::GetFilePos( while_operator.condition );
	if( condition_expression.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch,
				names_scope,
				condition_file_pos,
				bool_type_,
				condition_expression.t )
		return BlockElementBuildInfo();
	}

	auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );

	unsafe
	{
		while_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		block_after_while= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, while_block, block_after_while );
	}

	// While block code.

	var LoopFrame loop_frame
	{
		.block_for_break= block_after_while,
		.block_for_continue= test_block,
	};
	function_context.loops_stack.push_back(loop_frame);

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, while_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, while_block );
	}

	BuildBlockElement( names_scope, function_context, while_operator.block );
	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, test_block );  }

	function_context.loops_stack.pop_back();

	// Block after while code.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_while );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_while );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( BreakOutsideLoop, names_scope, break_operator.file_pos )
		return block_element_build_info;
	}

	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_break );  }

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( ContinueOutsideLoop, names_scope, continue_operator.file_pos )
		return block_element_build_info;
	}

	unsafe{  LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_continue );  }

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo
{
	var Variable mut condition_variable;
	{
		auto instructions_state= SaveInstructionsState( function_context );
		condition_variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, static_assert_.expression );
		RestoreInstructionsState( function_context, instructions_state );
	}

	if( condition_variable.t != bool_type_ )
	{
		REPORT_ERROR( StaticAssertExpressionMustHaveBoolType, names_scope, static_assert_.file_pos )
		return BlockElementBuildInfo();
	}
	if( condition_variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( StaticAssertExpressionIsNotConstant, names_scope, static_assert_.file_pos )
		return BlockElementBuildInfo();
	}

	var u64 mut val= zero_init;
	unsafe{  val= LLVMConstIntGetZExtValue( condition_variable.constexpr_value );  }
	if( val == 0u64 )
	{
		REPORT_ERROR( StaticAssertionFailed, names_scope, static_assert_.file_pos )
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	unsafe
	{
		LLVMBuildCall( function_context.llvm_ir_builder, halt_function_, LLVMValueRef::Null, 0u, "\0"[0] );
		LLVMBuildUnreachable( function_context.llvm_ir_builder );
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	auto condition= BuildExpressionCodeEnsureVariable( names_scope, function_context, halt_if.condition );
	if( condition.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch, names_scope, Synt::GetFilePos( halt_if.condition ), bool_type_, condition.t )
		return BlockElementBuildInfo();
	}

	unsafe
	{
		auto true_block = LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
		auto false_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

		LLVMBuildCondBr( function_context.llvm_ir_builder, CreateMoveToLLVMRegisterInstruction( condition, function_context ), true_block, false_block );

		// True branch
		LLVMAppendExistingBasicBlock( function_context.llvm_function, true_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, true_block );

		LLVMBuildCall( function_context.llvm_ir_builder, halt_function_, LLVMValueRef::Null, 0u, "\0"[0] );
		LLVMBuildUnreachable( function_context.llvm_ir_builder );

		// False branch
		LLVMAppendExistingBasicBlock( function_context.llvm_function, false_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, false_block );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildDeltaOneOperator( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, FilePos& file_pos, i32 delta )
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	auto variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression );
	if( variable.t.GetFundamentalType().empty() || !IsInteger( variable.t.GetFundamentalType().get_ref().fundamental_type ) )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, variable.t )
		return;
	}
	if( variable.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, file_pos )
		return;
	}

	unsafe
	{
		auto operand_value= CreateMoveToLLVMRegisterInstruction( variable, function_context );
		auto delta_value= LLVMConstInt( variable.t.GetLLVMType(), u64(delta), LLVMBool::True );
		auto result_value= LLVMBuildAdd( function_context.llvm_ir_builder, operand_value, delta_value, "\0"[0] );
		LLVMBuildStore( function_context.llvm_ir_builder, result_value, variable.llvm_value );
	}
}

} // namespace U
