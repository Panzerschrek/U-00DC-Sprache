import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"
import "/string_conversions.u"

namespace U1
{

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : BlockElementBuildInfo
{
	// Empty variant - legal element kind for C style "for" operator variables declaration part.
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr ) : BlockElementBuildInfo
{
	return BuildBlockElement( names_scope, function_context, block_ptr.deref() );
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo
{
	var NamesScopeMutPtr block_names_scope( NamesScope( "", names_scope ) );

	var VariablesFrameHolder variables_frame_hodler(function_context);
	auto& mut function_context= variables_frame_hodler.GetFunctionContext();

	auto prev_safety= function_context.is_in_unsafe_block;

	if( block.safety == Synt::Block::Safety::None ) {}// Keep old safety
	else if( block.safety == Synt::Block::Safety::Safe )
	{
		function_context.is_in_unsafe_block= false;
	}
	else if( block.safety == Synt::Block::Safety::Unsafe )
	{
		function_context.is_in_unsafe_block=  true;
		function_context.have_non_constexpr_operations_inside= true; // Unsafe operations can not be used in constexpr functions.
	}

	auto prev_debug_info_block= debug_info_builder_.try_deref().StartBlock( function_context, block.src_loc );

	var BlockElementBuildInfo mut block_element_build_info;
	foreach( &block_element : block.elements )
	{
		if( block_element_build_info.have_terminal_instruction_inside )
		{
			REPORT_ERROR( UnreachableCode, block_names_scope, Synt::GetSrcLoc(block_element) )
		}

		debug_info_builder_.try_deref().SetCurrentLocation( function_context, Synt::GetSrcLoc(block_element) );

		variant_visit( &el : block_element )
		{
			auto info = BuildBlockElement( block_names_scope, function_context, el );
			block_element_build_info.have_terminal_instruction_inside |= info.have_terminal_instruction_inside;
		}
	}

	if( !block_element_build_info.have_terminal_instruction_inside )
	{
		CallDestructorsForTopVariablesFrame( names_scope, function_context, block.end_src_loc );
	}

	debug_info_builder_.try_deref().EndBlock( function_context, prev_debug_info_block );

	function_context.is_in_unsafe_block= prev_safety;

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo
{
	auto t= PrepareType( names_scope, function_context, variables_declaration.t );
	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, variables_declaration.src_loc, t )
		return BlockElementBuildInfo();
	}

	foreach( &variable_declaration : variables_declaration.variables )
	{
		if( IsKeyword( variable_declaration.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope, variable_declaration.src_loc )
		}

		if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && !t.CanBeConstexpr() )
		{
			REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope, variable_declaration.src_loc )
		}

		if( variable_declaration.reference_modifier != Synt::ReferenceModifier::Reference && !t.CanBeConstexpr() )
		{
			function_context.have_non_constexpr_operations_inside= true; // Declaring variable with non-constexpr type in constexpr function not allowed.
		}

		var bool is_mutable= variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable;

		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var Variable mut variable_reference_variable
		{
			.t= t,
			.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			.location= Variable::Location::Pointer,
			.name= variable_declaration.name,
		};
		auto mut variable_reference= VariablePtr( move(variable_reference_variable) );
		// Do not forget to remove node in case of error-return!!!
		function_context.references_graph.AddNode( variable_reference );

		auto mut constexpr_value= LLVMValueRef::Null;
		if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
		{
			if( t.IsAbstract() )
			{
				REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, variable_declaration.src_loc, t )
				function_context.references_graph.RemoveNode( variable_reference );
				continue;
			}

			var LLVMValueRef llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, t.GetLLVMType(), (variable_declaration.name + "\0").front() ) );
			CreateLifetimeStart( function_context, llvm_value );

			var Variable mut variable
			{
				.t= t,
				.value_type= ValueType::Value,
				.location= Variable::Location::Pointer,
				.llvm_value= llvm_value,
				.name= variable_declaration.name,
			};

			debug_info_builder_.try_deref().CreateVariableInfo( function_context, variable, variable_declaration.name, variable_declaration.src_loc );

			var VariablePtr variable_ptr( move(variable) );
			function_context.references_graph.AddNode( variable_ptr );
			function_context.references_graph.AddLink( variable_ptr, variable_reference );
			RegisterFrameVariable( function_context, variable_ptr, 1s );

			{
				var Variable mut variable_for_initialization
				{
					.t= t,
					.value_type= ValueType::ReferenceMut,
					.location= Variable::Location::Pointer,
					.llvm_value= llvm_value,
					.name= variable_declaration.name,
				};

				var VariablePtr variable_for_initialization_ptr( move(variable_for_initialization) );
				function_context.references_graph.AddNode( variable_for_initialization_ptr );
				function_context.references_graph.AddLink( variable_ptr, variable_for_initialization_ptr );

				if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
				{
					constexpr_value= BuildEmptyInitializer( names_scope, function_context, variable_for_initialization_ptr, variable_declaration.name, variable_declaration.src_loc );
				}
				else
				{
					constexpr_value= BuildInitializer( names_scope, function_context, variable_for_initialization_ptr, variable_declaration.initializer );
				}

				function_context.references_graph.RemoveNode( variable_for_initialization_ptr );
			}

			with( &mut lock : variable_reference.lock_mut() )
			{
				lock.deref().llvm_value= llvm_value;
			}
		}
		else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				REPORT_ERROR( ExpectedInitializer, names_scope, variable_declaration.src_loc, variable_declaration.name )
				function_context.references_graph.RemoveNode( variable_reference );
				continue;
			}

			var ust::optional_ref_imut</Synt::Expression/> mut initializer_expression;
			if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
			{
				initializer_expression.reset(expression_initializer);
			}
			if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
			{
				if( constructor_initializer.args.size() != 1s )
				{
					REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope, constructor_initializer.src_loc )
					function_context.references_graph.RemoveNode( variable_reference );
					continue;
				}

				initializer_expression.reset( constructor_initializer.args.front().deref() );
			}

			if( initializer_expression.empty() )
			{
				REPORT_ERROR( UnsupportedInitializerForReference, names_scope, variable_declaration.src_loc )
				function_context.references_graph.RemoveNode( variable_reference );
				continue;
			}

			var VariablePtr expression_result_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, initializer_expression.try_deref() );
			auto expression_result_lock= expression_result_ptr.lock_imut();
			var Variable& expression_result= expression_result_lock.deref();

			if( expression_result.t != t && !expression_result.t.ReferenceIsConvertibleTo( t ) )
			{
				REPORT_ERROR( TypesMismatch, names_scope, variable_declaration.src_loc, t, expression_result.t )
				function_context.references_graph.RemoveNode( variable_reference );
				continue;
			}
			if( expression_result.value_type == ValueType::Value )
			{
				REPORT_ERROR( ExpectedReferenceValue, names_scope, variable_declaration.src_loc )
				function_context.references_graph.RemoveNode( variable_reference );
				continue;
			}
			if( is_mutable && expression_result.value_type == ValueType::ReferenceImut )
			{
				REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, variable_declaration.src_loc )
				function_context.references_graph.RemoveNode( variable_reference );
				continue;
			}

			function_context.references_graph.TryAddLink( expression_result_ptr, variable_reference, names_scope, variable_declaration.src_loc );

			with( &mut lock : variable_reference.lock_mut() )
			{
				lock.deref().llvm_value= CreateReferenceCast( expression_result.llvm_value, expression_result.t, t, function_context );
			}
			constexpr_value= expression_result.constexpr_value;

			debug_info_builder_.try_deref().CreateReferenceVariableInfo( function_context, variable_reference.lock_imut().deref(), variable_declaration.name, variable_declaration.src_loc );
		}
		else{ halt; }

		if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && constexpr_value == LLVMValueRef::Null )
		{
			REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, variable_declaration.src_loc )
		}

		if( !is_mutable )
		{
			// Set constexpr value only for immutable variables.
			with( &mut lock : variable_reference.lock_mut() )
			{
				lock.deref().constexpr_value= constexpr_value;
			}
		}

		// Register variable for destruction and reference checking.
		RegisterFrameVariable( function_context, variable_reference, 1s );

		var bool mut insert_not_ok= false;
		with( &mut lock : names_scope.lock_mut() )
		{
			insert_not_ok= lock.deref().AddName( variable_declaration.name, move(variable_reference) ).empty();
		}
		if( insert_not_ok )
		{
			REPORT_ERROR( Redefinition, names_scope, variable_declaration.src_loc, variable_declaration.name )
		}

		CallDestructorsForTopVariablesFrame( names_scope, function_context, variable_declaration.src_loc );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration )  : BlockElementBuildInfo
{
	if( IsKeyword( auto_variable_declaration.name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope, auto_variable_declaration.src_loc )
	}

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var VariablePtr expr_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );
	var VariableLite expr= expr_ptr.lock_imut().deref();
	if( expr.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope, auto_variable_declaration.src_loc, auto_variable_declaration.name )
		return BlockElementBuildInfo();
	}

	if( auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Constexpr && expr.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, auto_variable_declaration.src_loc )
	}

	var bool is_mutable= auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable;

	var Variable mut variable_reference_variable
	{
		.t= expr.t,
		.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.constexpr_value= select( is_mutable ? LLVMValueRef::Null : expr.constexpr_value ),
		.name= auto_variable_declaration.name,
	};
	var VariablePtr mut variable_reference( move(variable_reference_variable) );
	// Do not forget to remove node in case of errror-return!!!
	function_context.references_graph.AddNode( variable_reference );

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, auto_variable_declaration.src_loc )
			function_context.references_graph.RemoveNode( variable_reference );
			return BlockElementBuildInfo();
		}
		if( is_mutable && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference,  names_scope, auto_variable_declaration.src_loc )
			function_context.references_graph.RemoveNode( variable_reference );
			return BlockElementBuildInfo();
		}

		function_context.references_graph.TryAddLink( expr_ptr, variable_reference, names_scope, auto_variable_declaration.src_loc );

		with( &mut lock : variable_reference.lock_mut() )
		{
			lock.deref().llvm_value= expr.llvm_value;
		}

		debug_info_builder_.try_deref().CreateReferenceVariableInfo( function_context, variable_reference.lock_imut().deref(), auto_variable_declaration.name, auto_variable_declaration.src_loc );
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		if( expr.t.IsAbstract() )
		{
			REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, auto_variable_declaration.src_loc, expr.t )
			function_context.references_graph.RemoveNode( variable_reference );
			return BlockElementBuildInfo();
		}

		if( !expr.t.CanBeConstexpr() )
		{
			function_context.have_non_constexpr_operations_inside= true; // Declaring variable with non-constexpr type in constexpr function not allowed.
		}

		auto mut llvm_value= LLVMValueRef::Null;
		unsafe
		{
			if( expr.value_type == ValueType::Value &&
				expr.location == Variable::Location::Pointer &&
				LLVMTypeOf( expr.llvm_value ) == LLVMPointerType( expr.t.GetLLVMType(), 0u ) &&
				( LLVMIsAAllocaInst( expr.llvm_value ) != LLVMValueRef::Null || LLVMIsAArgument( expr.llvm_value ) != LLVMValueRef::Null ) )
			{
				// Just reuse "alloca" instruction or argument for move-initialization, avoid copying value into new memory location.
				llvm_value= expr.llvm_value;
			}
			else
			{
				llvm_value=
					LLVMBuildAlloca( function_context.alloca_ir_builder, expr.t.GetLLVMType(), (auto_variable_declaration.name + "\0").front() );
				CreateLifetimeStart( function_context, llvm_value );
			}
		}

		var Variable mut variable
		{
			.t= expr.t,
			.value_type= ValueType::Value,
			.location= Variable::Location::Pointer,
			.llvm_value= llvm_value,
			.name= auto_variable_declaration.name,
		};

		debug_info_builder_.try_deref().CreateVariableInfo( function_context, variable, auto_variable_declaration.name, auto_variable_declaration.src_loc );

		var VariablePtr variable_ptr( move(variable) );
		function_context.references_graph.AddNode( variable_ptr );
		function_context.references_graph.AddLink( variable_ptr, variable_reference );
		RegisterFrameVariable( function_context, variable_ptr, 1s );

		SetupReferencesInCopyOrMove( names_scope, function_context, variable_ptr, expr_ptr, auto_variable_declaration.src_loc );

		if( expr.value_type == ValueType::Value )
		{
			// Move.
			function_context.references_graph.MoveNode( expr_ptr );

			if( llvm_value != expr.llvm_value )
			{
				if( expr.location == Variable::Location::Pointer )
				{
					CopyBytes( llvm_value, expr.llvm_value, expr.t, function_context );
					CreateLifetimeEnd( function_context, expr.llvm_value );
				}
				else
				{
					CreateTypedStore( function_context, expr.t, expr.llvm_value, llvm_value );
				}
			}
		}
		else
		{
			// Copy.
			if( !expr.t.IsCopyConstructible() )
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, auto_variable_declaration.src_loc, expr.t )
				function_context.references_graph.RemoveNode( variable_reference );
				return BlockElementBuildInfo();
			}

			if( expr.location == Variable::Location::Pointer )
			{
				BuildCopyConstructorPart( names_scope, function_context, llvm_value, expr.llvm_value, expr.t, auto_variable_declaration.src_loc );
			}
			else
			{
				CreateTypedStore( function_context, expr.t, expr.llvm_value, llvm_value );
			}
		}

		with( &mut lock : variable_reference.lock_mut() )
		{
			lock.deref().llvm_value= llvm_value;
		}
	}
	else { halt; }

	// Register variable for destruction and reference checking.
	RegisterFrameVariable( function_context, variable_reference, 1s );

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope.lock_mut();
		insert_not_ok= lock.deref().AddName( auto_variable_declaration.name, move(variable_reference) ).empty();
	}
	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope, auto_variable_declaration.src_loc, auto_variable_declaration.name )
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, auto_variable_declaration.src_loc );

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( !return_operator.expr.get</Synt::EmptyVariant/>().empty() )
	{
		if( !( function_context.function_type.return_type == void_type_ && function_context.function_type.return_value_type == ValueType::Value ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.src_loc, function_context.function_type.return_type, void_type_ )
			return block_element_build_info;
		}
		CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.src_loc );
		CheckReferencesPollutionBeforeReturn( names_scope, function_context, return_operator.src_loc );

		if( function_context.destructor_end_block != LLVMBasicBlockRef::Null )
		{
			unsafe( LLVMBuildBr( function_context.llvm_ir_builder, function_context.destructor_end_block ) );
		}
		else
		{
			unsafe( LLVMBuildRetVoid( function_context.llvm_ir_builder ) );
		}
		return block_element_build_info;
	}

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var VariablePtr mut expr_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, return_operator.expr );

	if( function_context.function_type.return_value_type == ValueType::Value )
	{
		var Type ret_type= function_context.function_type.return_type;
		var Type expr_initial_type= expr_ptr.lock_imut().deref().t;
		if( expr_initial_type != ret_type )
		{
			if_var( &conversion_constructor_ : GetConversionConstructor( names_scope, ret_type, expr_initial_type, return_operator.src_loc ) )
			{
				expr_ptr= ConvertVariable( names_scope, function_context, expr_ptr, ret_type, conversion_constructor_, return_operator.src_loc );
			}
		}

		var VariableLite expr= expr_ptr.lock_imut().deref();

		if( expr.t != ret_type )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.src_loc, function_context.function_type.return_type, expr.t )
			return block_element_build_info;
		}

		if( ret_type.GetInnerReferenceKind() != InnerReferenceKind::None )
		{
			foreach( &inner_reference_node : function_context.references_graph.GetAccessibleVariableNodesInnerReferences( expr_ptr ) )
			{
				foreach( &variable_node : function_context.references_graph.GetAllAccessibleVariableNodes( inner_reference_node ) )
				{
					if( !IsReferenceAllowedForReturn( function_context, variable_node ) )
					{
						REPORT_ERROR( ReturningUnallowedReference, names_scope, return_operator.src_loc )
					}
				}
			}
		}

		auto s_ret= function_context.s_ret;
		if( s_ret != LLVMValueRef::Null )
		{
			if( expr.value_type == ValueType::Value && expr.t == function_context.function_type.return_type )
			{
				// Move
				function_context.references_graph.MoveNode( expr_ptr );

				CopyBytes( s_ret, expr.llvm_value, expr.t, function_context );
				if( expr.location == Variable::Location::Pointer )
				{
					CreateLifetimeEnd( function_context, expr.llvm_value );
				}
			}
			else
			{
				// Copy
				BuildCopyConstructorPart( names_scope, function_context, s_ret, expr.llvm_value, expr.t, return_operator.src_loc );
			}

			CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.src_loc );
			CheckReferencesPollutionBeforeReturn( names_scope, function_context, return_operator.src_loc );
			unsafe( LLVMBuildRetVoid( function_context.llvm_ir_builder ) );
		}
		else
		{
			if( ret_type == void_type_ )
			{
				CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.src_loc );
				CheckReferencesPollutionBeforeReturn( names_scope, function_context, return_operator.src_loc );

				if( function_context.destructor_end_block != LLVMBasicBlockRef::Null )
				{
					unsafe( LLVMBuildBr( function_context.llvm_ir_builder, function_context.destructor_end_block ) );
				}
				else
				{
					unsafe( LLVMBuildRetVoid( function_context.llvm_ir_builder ) );
				}
			}
			else
			{
				auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr, function_context );
				CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.src_loc );
				CheckReferencesPollutionBeforeReturn( names_scope, function_context, return_operator.src_loc );
				unsafe( LLVMBuildRet( function_context.llvm_ir_builder, value_in_register ) );
			}
		}
		return block_element_build_info;
	}
	else
	{
		var VariableLite expr= expr_ptr.lock_imut().deref();

		if( expr.t != function_context.function_type.return_type && !expr.t.ReferenceIsConvertibleTo( function_context.function_type.return_type ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, return_operator.src_loc, function_context.function_type.return_type, expr.t )
			return block_element_build_info;
		}
		if( function_context.function_type.return_value_type == ValueType::ReferenceMut && expr.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, return_operator.src_loc )
		}
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, return_operator.src_loc )
			return block_element_build_info;
		}
		foreach( &node : function_context.references_graph.GetAllAccessibleVariableNodes( expr_ptr ) )
		{
			if( !IsReferenceAllowedForReturn( function_context, node ) )
			{
				REPORT_ERROR( ReturningUnallowedReference, names_scope, return_operator.src_loc )
			}
		}

		// Create return reference node and link it with expression node.
		var Variable mut return_node_variable
		{
			.value_type= function_context.function_type.return_value_type,
			.location= Variable::Location::Pointer,
			.name= "return value",
		};
		var VariablePtr return_node( move(return_node_variable) );
		function_context.references_graph.AddNode( return_node );
		function_context.references_graph.AddLink( expr_ptr, return_node );

		// Call destructors. In this process we check if destroyed variables still have references.
		// This allow us to prevent returning of reference to local variable.
		CallDestructorsForAllVariablesFrames( names_scope, function_context, return_operator.src_loc );
		CheckReferencesPollutionBeforeReturn( names_scope, function_context, return_operator.src_loc );

		function_context.references_graph.RemoveNode( return_node );

		auto reference_converted= CreateReferenceCast( expr.llvm_value, expr.t, function_context.function_type.return_type, function_context );
		unsafe( LLVMBuildRet( function_context.llvm_ir_builder, reference_converted ) );
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	if( !TryCallOverloadedBinaryOperator(
			names_scope,
			function_context,
			OverloadedOperator::Assign,
			assignment_operator.l,
			assignment_operator.r,
			ArgsEvaluationOrder::Reversed,
			assignment_operator.src_loc ).empty() )
	{}
	else
	{
		var VariableLite r= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.r.deref() ).lock_imut().deref();
		if( r.t.GetFundamentalType().empty() && r.t.GetEnumType().empty() && r.t.GetRawPointerType().empty() && r.t.GetFunctionPointerType().empty() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, assignment_operator.src_loc, r.t )
			return BlockElementBuildInfo();
		}

		auto r_in_register= CreateMoveToLLVMRegisterInstruction( r, function_context );

		// Destroy temporaries of right part.
		DestroyUnusedTemporaryVariables( names_scope, function_context, assignment_operator.src_loc );

		var VariablePtr l_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, assignment_operator.l.deref() );
		auto l_lock= l_ptr.lock_imut();
		var Variable& l= l_lock.deref();

		if( r.t != l.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, assignment_operator.src_loc, l.t, r.t )
			return BlockElementBuildInfo();
		}
		if( l.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, assignment_operator.src_loc )
			return BlockElementBuildInfo();
		}
		function_context.references_graph.EnsureHaveNoOutgoingLinks( l_ptr, names_scope, assignment_operator.src_loc );

		CreateTypedStore( function_context, r.t, r_in_register, l.llvm_value );
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, assignment_operator.src_loc );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	if( !TryCallOverloadedBinaryOperator(
			names_scope,
			function_context,
			GetOverloadedOperatorForAdditiveAssignmentOperator( additive_assignment_operator.operator ),
			additive_assignment_operator.l,
			additive_assignment_operator.r,
			ArgsEvaluationOrder::Reversed,
			additive_assignment_operator.src_loc ).empty() )
	{}
	else
	{
		var VariableLite mut r_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, additive_assignment_operator.r.deref() ).lock_imut().deref();
		// Save r_var in register, prevent its modification during l_var calculation.
		r_var.llvm_value= CreateMoveToLLVMRegisterInstruction( r_var, function_context );
		r_var.location= Variable::Location::LLVMRegister;
		r_var.value_type= ValueType::Value;

		// Destroy temporaries of right part.
		DestroyUnusedTemporaryVariables( names_scope, function_context, additive_assignment_operator.src_loc );

		var VariablePtr l_var_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, additive_assignment_operator.l.deref() );
		var VariableLite l_var= l_var_ptr.lock_imut().deref();
		if( l_var.value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope, additive_assignment_operator.src_loc )
			return BlockElementBuildInfo();
		}
		function_context.references_graph.EnsureHaveNoOutgoingLinks( l_var_ptr, names_scope, additive_assignment_operator.src_loc );

		auto op_result= BuildBinaryOperator( names_scope, function_context, l_var, r_var, additive_assignment_operator.operator, additive_assignment_operator.src_loc );
		auto op_result_variable_ptr_ref= op_result.get</VariablePtr/>();
		if( op_result_variable_ptr_ref.empty() )
		{
			return BlockElementBuildInfo();
		}
		with( &op_result_variable: op_result_variable_ptr_ref.try_deref().lock_imut().deref() )
		{
			if( op_result_variable.t != l_var.t )
			{
				REPORT_ERROR( TypesMismatch, names_scope, additive_assignment_operator.src_loc, l_var.t, op_result_variable.t )
				return BlockElementBuildInfo();
			}

			auto val= CreateMoveToLLVMRegisterInstruction( op_result_variable, function_context );
			CreateTypedStore( function_context, l_var.t, val, l_var.llvm_value );
		}
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, additive_assignment_operator.src_loc );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo
{
	BuildDeltaOneOperator( names_scope, function_context, increment_operator.expression, increment_operator.src_loc, +1 );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo
{
	BuildDeltaOneOperator( names_scope, function_context, decrement_operator.expression, decrement_operator.src_loc, -1 );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	BuildExpressionCode( names_scope, function_context, expression );

	CallDestructorsForTopVariablesFrame( names_scope, function_context, Synt::GetSrcLoc(expression) );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo
{
	var LLVMBasicBlockRef mut block_after_if= zero_init, mut next_condition_block= zero_init;

	unsafe
	{
		block_after_if= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
		next_condition_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

		// Break to first condition. We must push terminal instruction at end of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, next_condition_block );
	}

	var BlockElementBuildInfo mut block_element_build_info{ .have_terminal_instruction_inside= true };

	var ust::vector</ReferencesGraph/> mut branches_references_graphs;

	for( auto mut i= 0s; i < if_operator.branches.size(); ++i )
	{
		auto& branch= if_operator.branches[i];

		var LLVMBasicBlockRef mut body_block= zero_init, current_condition_block= next_condition_block;
		body_block= unsafe( LLVMCreateBasicBlockInContext( llvm_context_, g_null_string ) );

		if( i + 1s < if_operator.branches.size() )
		{
			next_condition_block= unsafe( LLVMCreateBasicBlockInContext( llvm_context_, g_null_string ) );
		}
		else
		{
			next_condition_block= block_after_if;
		}

		// Build condition block.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, current_condition_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, current_condition_block );
		}

		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Make empty condition block - move to it unconditional break to body.
			unsafe( LLVMBuildBr( function_context.llvm_ir_builder, body_block ) );
		}
		else
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			var VariableLite condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition ).lock_imut().deref();
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					Synt::GetSrcLoc( branch.condition ),
					bool_type_,
					condition_expression.t )

				CallDestructorsForTopVariablesFrame( names_scope, function_context, branch.src_loc );
				unsafe( LLVMBuildBr( function_context.llvm_ir_builder, body_block ) );
			}
			else
			{
				auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );
				CallDestructorsForTopVariablesFrame( names_scope, function_context, branch.src_loc );

				unsafe( LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, body_block, next_condition_block ) );
			}
		}

		// Make body block code.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, body_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, body_block );
		}

		auto mut references_graph_before_this_branch= function_context.references_graph;

		auto info= BuildBlockElement( names_scope, function_context, branch.block );
		if( !info.have_terminal_instruction_inside )
		{
			branches_references_graphs.push_back( take(function_context.references_graph) );
			block_element_build_info.have_terminal_instruction_inside= false;
			unsafe( LLVMBuildBr( function_context.llvm_ir_builder, block_after_if ) );
		}

		function_context.references_graph= move(references_graph_before_this_branch);
	}

	if( if_operator.branches.back().condition.get</Synt::EmptyVariant/>().empty() )
	{
		block_element_build_info.have_terminal_instruction_inside= false;
		branches_references_graphs.push_back( function_context.references_graph );
	}

	if( block_element_build_info.have_terminal_instruction_inside )
	{
		// Normally we should "delete block_after_if", but llvm-c interface have no such method.
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMDeleteBasicBlock( block_after_if );
		}
	}
	else
	{
		unsafe
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_if );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_if );
		}
	}

	if( !branches_references_graphs.empty() )
	{
		function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( branches_references_graphs.range(), names_scope, if_operator.end_src_loc );
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticIfOperator& static_if_operator ) : BlockElementBuildInfo
{
	foreach( &branch : static_if_operator.if_operator.branches )
	{
		if( !branch.condition.get</Synt::EmptyVariant/>().empty() )
		{
			// Last unconditional "else"
			return BuildBlockElement( names_scope, function_context, branch.block );
		}
		else
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

			var VariableLite condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, branch.condition ).lock_imut().deref();
			if( condition_expression.t != bool_type_ )
			{
				REPORT_ERROR( TypesMismatch,
					names_scope,
					Synt::GetSrcLoc( branch.condition ),
					bool_type_,
					condition_expression.t )
				return BlockElementBuildInfo();
			}
			if( condition_expression.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, Synt::GetSrcLoc( branch.condition ) )
				return BlockElementBuildInfo();
			}

			if( unsafe( LLVMConstIntGetZExtValue( condition_expression.constexpr_value ) ) != 0u64 )
			{
				return BuildBlockElement( names_scope, function_context, branch.block );
			}

			CallDestructorsForTopVariablesFrame( names_scope, function_context, branch.src_loc );
		}
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo
{
	auto mut references_graph_before_loop= function_context.references_graph;

	var LLVMBasicBlockRef mut test_block= zero_init, mut while_block= zero_init, mut block_after_while= zero_init;
	unsafe
	{
		test_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

		// Break to test block. We must push terminal instruction at and of current block.
		LLVMBuildBr( function_context.llvm_ir_builder, test_block );

		LLVMAppendExistingBasicBlock( function_context.llvm_function, test_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, test_block );
	}

	// Test block code.
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var VariableLite condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, while_operator.condition ).lock_imut().deref();
		var SrcLoc condition_src_loc= Synt::GetSrcLoc( while_operator.condition );
		if( condition_expression.t != bool_type_ )
		{
			REPORT_ERROR( TypesMismatch,
					names_scope,
					condition_src_loc,
					bool_type_,
					condition_expression.t )
			return BlockElementBuildInfo();
		}

		auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );
		CallDestructorsForTopVariablesFrame( names_scope, function_context, condition_src_loc );

		unsafe
		{
			while_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
			block_after_while= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
			LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, while_block, block_after_while );
		}
	}

	// While block code.

	var LoopFrame loop_frame
	{
		.block_for_break= block_after_while,
		.block_for_continue= test_block,
		.variable_frames_stack_size= function_context.variables_frames.size(),
	};
	function_context.loops_stack.push_back(loop_frame);

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, while_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, while_block );
	}

	auto info= BuildBlockElement( names_scope, function_context, while_operator.block );
	if( !info.have_terminal_instruction_inside )
	{
		unsafe( LLVMBuildBr( function_context.llvm_ir_builder, test_block ) );
		function_context.loops_stack.back().continue_references_graphs.push_back( function_context.references_graph );
	}

	// Disallow outer variables state change in "continue" branches.
	foreach( &state_after : function_context.loops_stack.back().continue_references_graphs )
	{
		CheckReferencesGraphAfterLoop( references_graph_before_loop, state_after, names_scope, while_operator.block.deref().end_src_loc );
	}

	// Result graph state is combination of graph state before loop and graph state of all branches terminated with "break".
	var ust::vector</ReferencesGraph/> mut references_graphs_for_merge= take( function_context.loops_stack.back().break_references_graphs );
	references_graphs_for_merge.push_back( move( references_graph_before_loop ) );
	function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( references_graphs_for_merge.range(), names_scope, while_operator.block.deref().end_src_loc );

	function_context.loops_stack.pop_back();

	// Block after while code.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_while );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_while );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RangeForOperator& range_for_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo mut block_element_build_info;

	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var VariablePtr sequence_expression_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, range_for_operator.sequence );
	var VariableLite sequence_expression= sequence_expression_ptr.lock_imut().deref();

	auto is_mutable= range_for_operator.mutability_modifier == Synt::MutabilityModifier::Mutable;

	var Variable mut lock_variable
	{
		.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.name= sequence_expression_ptr.lock_imut().deref().name + " sequence lock",
	};
	var VariablePtr sequence_lock_node( move(lock_variable) );
	function_context.references_graph.AddNode( sequence_lock_node );
	function_context.references_graph.TryAddLink( sequence_expression_ptr, sequence_lock_node, names_scope, range_for_operator.src_loc );

	function_context.variables_frames.back().push_back( sequence_lock_node );

	if( !sequence_expression.t.GetTupleType().empty() )
	{
		var TupleType& tuple_type= sequence_expression.t.GetTupleType().try_deref();

		auto mut finish_basic_block= LLVMBasicBlockRef::Null;
		if( !tuple_type.element_types.empty() )
		{
			finish_basic_block= unsafe( LLVMCreateBasicBlockInContext( llvm_context_, g_null_string ) );
		}

		var ust::vector</ReferencesGraph/> mut references_graphs_for_merge;
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			var ust::string8 variable_name= range_for_operator.loop_variable_name + ust::to_string8(i);

			var Type& variable_type= tuple_type.element_types[i];

			// Create separate names_scope for loop variable.
			var NamesScopeMutPtr names_scope( NamesScope( "", names_scope ) );

			var VariablesFrameHolder element_pass_temp_variables_frame_hodler(function_context);
			auto& mut function_context= element_pass_temp_variables_frame_hodler.GetFunctionContext();

			var Variable mut variable_reference_variable
			{
				.t= variable_type,
				.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.location= Variable::Location::Pointer,
				.constexpr_value=
					select(
						is_mutable || sequence_expression.constexpr_value == LLVMValueRef::Null
							? LLVMValueRef::Null
							: unsafe( LLVMGetAggregateElement( sequence_expression.constexpr_value, u32(i) ) ) ),
				.name= range_for_operator.loop_variable_name,
			};
			var VariablePtr mut variable_reference( move(variable_reference_variable) );
			// Do not forget to remove node in case of error-return!!!
			function_context.references_graph.AddNode( variable_reference );

			auto src_element_llvm_value= CreateTupleElementGEP( function_context, sequence_expression, u32(i) );

			if( range_for_operator.reference_modifier == Synt::ReferenceModifier::Reference )
			{
				if( sequence_expression.value_type == ValueType::Value )
				{
					REPORT_ERROR( ExpectedReferenceValue, names_scope, range_for_operator.src_loc )
					function_context.references_graph.RemoveNode( variable_reference );
					return BlockElementBuildInfo();
				}
				if( is_mutable && sequence_expression.value_type != ValueType::ReferenceMut )
				{
					REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, range_for_operator.src_loc )
					function_context.references_graph.RemoveNode( variable_reference );
					return BlockElementBuildInfo();
				}

				with( &mut lock: variable_reference.lock_mut() )
				{
					lock.deref().llvm_value= src_element_llvm_value;
				}

				debug_info_builder_.try_deref().CreateReferenceVariableInfo( function_context, variable_reference.lock_imut().deref(), variable_name, range_for_operator.src_loc );

				function_context.references_graph.TryAddLink( sequence_lock_node, variable_reference, names_scope, range_for_operator.src_loc );
			}
			else if( range_for_operator.reference_modifier == Synt::ReferenceModifier::None )
			{
				var Variable mut variable
				{
					.t= variable_type,
					.value_type= ValueType::Value,
					.location= Variable::Location::Pointer,
					.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, variable_type.GetLLVMType(), (range_for_operator.loop_variable_name + "\0").front() ) ),
					.name= range_for_operator.loop_variable_name,
				};

				CreateLifetimeStart( function_context, variable.llvm_value );
				debug_info_builder_.try_deref().CreateVariableInfo( function_context, variable, variable_name, range_for_operator.src_loc );

				with( &mut lock: variable_reference.lock_mut() )
				{
					lock.deref().llvm_value= variable.llvm_value;
				}

				if( !sequence_expression.t.IsCopyConstructible() )
				{
					REPORT_ERROR( OperationNotSupportedForThisType, names_scope, range_for_operator.src_loc, variable.t )
				}
				else
				{
					BuildCopyConstructorPart( names_scope, function_context, variable.llvm_value, src_element_llvm_value, variable.t, range_for_operator.src_loc );
				}

				var VariablePtr variable_ptr( move(variable) );
				function_context.references_graph.AddNode( variable_ptr );
				function_context.references_graph.AddLink( variable_ptr, variable_reference );
				RegisterTopFrameVariable( function_context, variable_ptr );

				SetupReferencesInCopyOrMove( names_scope, function_context, variable_ptr, sequence_lock_node, range_for_operator.src_loc );
			}
			else{ halt; }

			// Register variable for destruction and reference checking.
			RegisterTopFrameVariable( function_context, variable_reference );

			{
				auto mut lock= names_scope.lock_mut();
				lock.deref().AddName( range_for_operator.loop_variable_name, move(variable_reference) ).empty();
			}

			var bool is_last_iteration= i + 1s == tuple_type.element_types.size();
			auto mut next_basic_block= LLVMBasicBlockRef::Null;
			if( is_last_iteration )
			{
				next_basic_block= finish_basic_block;
			}
			else
			{
				next_basic_block= unsafe( LLVMCreateBasicBlockInContext( llvm_context_, g_null_string ) );
			}

			var LoopFrame loop_frame
			{
				.block_for_break= finish_basic_block,
				.block_for_continue= next_basic_block,
				.variable_frames_stack_size= function_context.variables_frames.size() - 1s, // Extra 1 for loop variable destruction in 'break' or 'continue'.
			};
			function_context.loops_stack.push_back(loop_frame);

			auto block_build_info= BuildBlockElement( names_scope, function_context, range_for_operator.block.deref() );

			if( !block_build_info.have_terminal_instruction_inside )
			{
				CallDestructorsForTopVariablesFrame( names_scope, function_context, range_for_operator.src_loc ); // destroy loop variable
				function_context.loops_stack.back().continue_references_graphs.push_back( function_context.references_graph );
				unsafe( LLVMBuildBr( function_context.llvm_ir_builder, next_basic_block ) );
			}

			// Graph state in next iteration is combination of graph state of all branches with "continue" on previous iteration.
			var bool continue_branches_is_empty= function_context.loops_stack.back().continue_references_graphs.empty();
			if( !continue_branches_is_empty )
			{
				function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( function_context.loops_stack.back().continue_references_graphs.range(), names_scope, range_for_operator.block.deref().end_src_loc );
			}

			foreach( &mut break_refences_graph : function_context.loops_stack.back().break_references_graphs )
			{
				references_graphs_for_merge.push_back( take(break_refences_graph) );
			}

			function_context.loops_stack.pop_back();

			// Clear args preevaluation cache because we evaluationg same expressions multiple times in different context.
			function_context.args_preevaluation_cache.clear();

			if( !continue_branches_is_empty )
			{
				unsafe
				{
					LLVMAppendExistingBasicBlock( function_context.llvm_function, next_basic_block );
					LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, next_basic_block );
				}

				if( is_last_iteration )
				{
					references_graphs_for_merge.push_back( function_context.references_graph );
				}
			}
			else
			{
				// Finish building tuple-for if current iteration have no "continue" branches.
				unsafe
				{
					if( !is_last_iteration )
					{
						LLVMAppendExistingBasicBlock( function_context.llvm_function, next_basic_block );
						LLVMDeleteBasicBlock( next_basic_block );
					}
					if( !references_graphs_for_merge.empty() )
					{
						LLVMAppendExistingBasicBlock( function_context.llvm_function, finish_basic_block );
						LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, finish_basic_block );
					}
					else
					{
						LLVMAppendExistingBasicBlock( function_context.llvm_function, finish_basic_block );
						LLVMDeleteBasicBlock( finish_basic_block );
					}
				}
				break;
			}
		}

		if( tuple_type.element_types.empty() )
		{} // Just keep references graph state.
		// References graph state after tuple-for is combination of graph state of all branches with "break" of all iterations.
		else if( !references_graphs_for_merge.empty() )
		{
			function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( references_graphs_for_merge.range(), names_scope, range_for_operator.block.deref().end_src_loc );
		}
		else
		{
			block_element_build_info.have_terminal_instruction_inside= true;
		}
	}
	else
	{
		// TODO - support array types.
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, range_for_operator.src_loc, sequence_expression.t )
	}

	if( !block_element_build_info.have_terminal_instruction_inside )
	{
		CallDestructorsForTopVariablesFrame( names_scope, function_context, range_for_operator.src_loc );
	}
	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CStyleForOperator& c_style_for_operator ) : BlockElementBuildInfo
{	
	var VariablesFrameHolder loop_variables_frame_hodler(function_context);
	auto& mut function_context= loop_variables_frame_hodler.GetFunctionContext();

	// Create separate names_scope for loop variables.
	var NamesScopeMutPtr names_scope( NamesScope( "", names_scope ) );

	// Variables declaration part.
	variant_visit( &element : c_style_for_operator.variable_declaration_part )
	{
		BuildBlockElement( names_scope, function_context, element );
	}

	auto references_graph_before_loop= function_context.references_graph;

	var LLVMBasicBlockRef mut test_block= zero_init, mut loop_block= zero_init, mut loop_iteration_block= zero_init, mut block_after_loop= zero_init;
	unsafe
	{
		test_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
		loop_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
		loop_iteration_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
		block_after_loop= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
	}

	// Test block.
	unsafe
	{
		LLVMBuildBr( function_context.llvm_ir_builder, test_block );
		LLVMAppendExistingBasicBlock( function_context.llvm_function, test_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, test_block );
	}

	if( !c_style_for_operator.loop_condition.get</Synt::EmptyVariant/>().empty() )
	{
		// No condition.
		unsafe( LLVMBuildBr( function_context.llvm_ir_builder, loop_block ) );
	}
	else
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var VariableLite condition_expression= BuildExpressionCodeEnsureVariable( names_scope, function_context, c_style_for_operator.loop_condition ).lock_imut().deref();
		var SrcLoc condition_src_loc= Synt::GetSrcLoc( c_style_for_operator.loop_condition );
		if( condition_expression.t != bool_type_ )
		{
			REPORT_ERROR( TypesMismatch, names_scope, condition_src_loc, bool_type_, condition_expression.t )
			return BlockElementBuildInfo();
		}

		auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition_expression, function_context );
		CallDestructorsForTopVariablesFrame( names_scope, function_context, condition_src_loc );

		unsafe( LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, loop_block, block_after_loop ) );
	}

	auto mut references_graph_after_test_block= function_context.references_graph;

	// Loop block code.
	var LoopFrame loop_frame
	{
		.block_for_break= block_after_loop,
		.block_for_continue= loop_iteration_block,
		.variable_frames_stack_size= function_context.variables_frames.size(),
	};
	function_context.loops_stack.push_back(loop_frame);

	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, loop_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, loop_block );
	}

	auto info= BuildBlockElement( names_scope, function_context, c_style_for_operator.block );
	if( !info.have_terminal_instruction_inside )
	{
		unsafe( LLVMBuildBr( function_context.llvm_ir_builder, loop_iteration_block ) );
		function_context.loops_stack.back().continue_references_graphs.push_back( function_context.references_graph );
	}

	// References graph state before loop iteration block is combination of references graph states of each branch terminated with "continue".
	if( !function_context.loops_stack.back().continue_references_graphs.empty() )
	{
		function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( function_context.loops_stack.back().continue_references_graphs.range(), names_scope, c_style_for_operator.block.deref().end_src_loc );
	}

	var ust::vector</ReferencesGraph/> mut references_graphs_for_merge= take( function_context.loops_stack.back().break_references_graphs );
	references_graphs_for_merge.push_back( move(references_graph_after_test_block) );

	function_context.loops_stack.pop_back();

	// Loop iteration block.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, loop_iteration_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, loop_iteration_block );
	}
	foreach( &element : c_style_for_operator.iteration_part_elements )
	{
		variant_visit( &el : element )
		{
			BuildBlockElement( names_scope, function_context, el );
		}
	}

	unsafe( LLVMBuildBr( function_context.llvm_ir_builder, test_block ) );

	CheckReferencesGraphAfterLoop( references_graph_before_loop, function_context.references_graph, names_scope, c_style_for_operator.block.deref().end_src_loc );
	function_context.references_graph= MergeReferencesGraphsAfterConditionalBranches( references_graphs_for_merge.range(), names_scope, c_style_for_operator.block.deref().end_src_loc );

	// Block after loop.
	unsafe
	{
		LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_loop );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_loop );
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, c_style_for_operator.src_loc );
	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( BreakOutsideLoop, names_scope, break_operator.src_loc )
		return block_element_build_info;
	}

	CallDestructorsForLoopInnerVariables( names_scope, function_context, break_operator.src_loc );
	unsafe( LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_break ) );

	function_context.loops_stack.back().break_references_graphs.push_back( function_context.references_graph );

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WithOperator& with_operator ) : BlockElementBuildInfo
{
	var VariablesFrameHolder variables_frame_hodler(function_context);
	auto& mut function_context= variables_frame_hodler.GetFunctionContext();

	var VariablePtr expr_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, with_operator.expression );
	var VariableLite expr= expr_ptr.lock_imut().deref();
	if( expr.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope, with_operator.src_loc, with_operator.variable_name )
		return BlockElementBuildInfo();
	}

	var bool is_mutable= with_operator.mutability_modifier == Synt::MutabilityModifier::Mutable;

	var Variable mut variable_reference_variable
	{
		.t= expr.t,
		.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.constexpr_value= select( is_mutable ? LLVMValueRef::Null : expr.constexpr_value ), // Constexpr is preserved for move/copy.
		.name= with_operator.variable_name,
	};
	var VariablePtr mut variable_reference( move(variable_reference_variable) );
	// Do not forget to remove node in case of error-return!!!
	function_context.references_graph.AddNode( variable_reference );

	if( with_operator.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( is_mutable && expr.value_type == ValueType::ReferenceImut )
		{
			REPORT_ERROR( BindingConstReferenceToNonconstReference,  names_scope, with_operator.src_loc )
			function_context.references_graph.RemoveNode( variable_reference );
			return BlockElementBuildInfo();
		}

		auto mut llvm_value= LLVMValueRef::Null;
		if( expr.location == Variable::Location::LLVMRegister )
		{
			// Binding value to reference.
			unsafe
			{
				llvm_value=
					LLVMBuildAlloca( function_context.alloca_ir_builder, expr.t.GetLLVMType(), (with_operator.variable_name + "\0").front() );
				CreateLifetimeStart( function_context, llvm_value );
				CreateTypedStore( function_context, expr.t, expr.llvm_value, llvm_value );
			}
		}
		else
		{
			llvm_value= expr.llvm_value;
		}

		with( &mut lock : variable_reference.lock_mut() )
		{
			lock.deref().llvm_value= llvm_value;
		}

		debug_info_builder_.try_deref().CreateReferenceVariableInfo( function_context, variable_reference.lock_imut().deref(), with_operator.variable_name, with_operator.src_loc );

		function_context.references_graph.TryAddLink( expr_ptr, variable_reference, names_scope, with_operator.src_loc );
	}
	else if( with_operator.reference_modifier == Synt::ReferenceModifier::None )
	{
		if( expr.t.IsAbstract() )
		{
			REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope, with_operator.src_loc, expr.t )
			function_context.references_graph.RemoveNode( variable_reference );
			return BlockElementBuildInfo();
		}

		if( !expr.t.CanBeConstexpr() )
		{
			function_context.have_non_constexpr_operations_inside= true; // Declaring variable with non-constexpr type in constexpr function not allowed.
		}

		auto mut llvm_value= LLVMValueRef::Null;
		unsafe
		{
			if( expr.value_type == ValueType::Value &&
				expr.location == Variable::Location::Pointer &&
				LLVMTypeOf( expr.llvm_value ) == LLVMPointerType( expr.t.GetLLVMType(), 0u ) &&
				( LLVMIsAAllocaInst( expr.llvm_value ) != LLVMValueRef::Null || LLVMIsAArgument( expr.llvm_value ) != LLVMValueRef::Null ) )
			{
				// Just reuse "alloca" instruction or argument for move-initialization, avoid copying value into new memory location.
				llvm_value= expr.llvm_value;
			}
			else
			{
				llvm_value=
					LLVMBuildAlloca( function_context.alloca_ir_builder, expr.t.GetLLVMType(), (with_operator.variable_name + "\0").front() );
				CreateLifetimeStart( function_context, llvm_value );
			}
		}

		var Variable mut variable
		{
			.t= expr.t,
			.value_type= ValueType::Value,
			.location= Variable::Location::Pointer,
			.llvm_value= llvm_value,
			.name= with_operator.variable_name,
		};

		debug_info_builder_.try_deref().CreateVariableInfo( function_context, variable, with_operator.variable_name, with_operator.src_loc );

		var VariablePtr variable_ptr( move(variable) );
		function_context.references_graph.AddNode( variable_ptr );
		function_context.references_graph.AddLink( variable_ptr, variable_reference );
		RegisterTopFrameVariable( function_context, variable_ptr );

		SetupReferencesInCopyOrMove( names_scope, function_context, variable_ptr, expr_ptr, with_operator.src_loc );

		if( expr.value_type == ValueType::Value )
		{
			// Move.
			function_context.references_graph.MoveNode( expr_ptr );

			if( llvm_value != expr.llvm_value )
			{
				if( expr.location == Variable::Location::Pointer )
				{
					CopyBytes( llvm_value, expr.llvm_value, expr.t, function_context );
					CreateLifetimeEnd( function_context, expr.llvm_value );
				}
				else
				{
					CreateTypedStore( function_context, expr.t, expr.llvm_value, llvm_value );
				}
			}
		}
		else
		{
			// Copy.
			if( !expr.t.IsCopyConstructible() )
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, with_operator.src_loc, expr.t )
			}
			else if( expr.location == Variable::Location::Pointer )
			{
				BuildCopyConstructorPart( names_scope, function_context, llvm_value, expr.llvm_value, expr.t, with_operator.src_loc );
			}
			else
			{
				CreateTypedStore( function_context, expr.t, expr.llvm_value, llvm_value );
			}
		}

		with( &mut lock: variable_reference.lock_mut() )
		{
			lock.deref().llvm_value= llvm_value;
		}
	}
	else { halt; }

	// Destroy temporary variables of initializer expression. Do it before registretion of variable to prevent its destruction.
	DestroyUnusedTemporaryVariables( names_scope, function_context, with_operator.src_loc );

	// Register variable for destruction and reference checking.
	RegisterTopFrameVariable( function_context, variable_reference );

	if( IsKeyword( with_operator.variable_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope, with_operator.src_loc )
	}

	// Create separate namespace for variable. Redefinition here is not possible.
	var NamesScopeMutPtr varaible_names_scope( NamesScope( "", names_scope ) );
	{
		auto mut lock= varaible_names_scope.lock_mut();
		lock.deref().AddName( with_operator.variable_name, move(variable_reference) ).empty();
	}

	// Build block. This creates new variables frame and prevents destruction of initializer expression and/or created variable.
	var BlockElementBuildInfo block_element_build_info= BuildBlockElement( varaible_names_scope, function_context, with_operator.block.deref() );

	if( !block_element_build_info.have_terminal_instruction_inside )
	{
		// Destroy loop variable and linked temporaries.
		CallDestructorsForTopVariablesFrame( names_scope, function_context, with_operator.src_loc );
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	if( function_context.loops_stack.empty() )
	{
		REPORT_ERROR( ContinueOutsideLoop, names_scope, continue_operator.src_loc )
		return block_element_build_info;
	}

	CallDestructorsForLoopInnerVariables( names_scope, function_context, continue_operator.src_loc );
	unsafe( LLVMBuildBr( function_context.llvm_ir_builder, function_context.loops_stack.back().block_for_continue ) );

	function_context.loops_stack.back().continue_references_graphs.push_back( function_context.references_graph );

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var bool prev_is_functionless_context= function_context.is_functionless_context;
	function_context.is_functionless_context= true;

	auto state= SaveFunctionContextState( function_context );

	with( &condition_variable: BuildExpressionCodeEnsureVariable( names_scope, function_context, static_assert_.expression ).lock_imut().deref() )
	{
		if( condition_variable.t == bool_type_ )
		{
			if( condition_variable.constexpr_value != LLVMValueRef::Null )
			{
				if( unsafe( LLVMConstIntGetZExtValue( condition_variable.constexpr_value ) ) == 0u64 )
				{
					REPORT_ERROR( StaticAssertionFailed, names_scope, static_assert_.src_loc )
				}
			}
			else
			{
				REPORT_ERROR( StaticAssertExpressionIsNotConstant, names_scope, static_assert_.src_loc )
			}
		}
		else
		{
			REPORT_ERROR( StaticAssertExpressionMustHaveBoolType, names_scope, static_assert_.src_loc )
		}
	}

	RestoreFunctionContextState( function_context, state );
	function_context.is_functionless_context= prev_is_functionless_context;

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::TypeAlias& type_alias ) : BlockElementBuildInfo
{
	if( IsKeyword( type_alias.name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope, type_alias.src_loc )
	}

	var Type mut t= PrepareType( names_scope, function_context, type_alias.type_name );

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope.lock_mut();
		insert_not_ok= lock.deref().AddName( type_alias.name, NamesScopeValue( move(t) ) ).empty();
	}
	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope, type_alias.src_loc, type_alias.name )
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo
{
	var BlockElementBuildInfo block_element_build_info{ .have_terminal_instruction_inside= true };

	unsafe
	{
		LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(halt_function_), halt_function_, ust::nullptr</LLVMValueRef/>(), 0u, g_null_string );
		LLVMBuildUnreachable( function_context.llvm_ir_builder );
	}

	return block_element_build_info;
}

fn CodeBuilder::BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var VariableLite condition= BuildExpressionCodeEnsureVariable( names_scope, function_context, halt_if.condition ).lock_imut().deref();
	if( condition.t != bool_type_ )
	{
		REPORT_ERROR( TypesMismatch, names_scope, Synt::GetSrcLoc( halt_if.condition ), bool_type_, condition.t )
		return BlockElementBuildInfo();
	}

	auto condition_in_register= CreateMoveToLLVMRegisterInstruction( condition, function_context );
	CallDestructorsForTopVariablesFrame( names_scope, function_context, halt_if.src_loc );

	unsafe
	{
		auto true_block = LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
		auto false_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

		LLVMBuildCondBr( function_context.llvm_ir_builder, condition_in_register, true_block, false_block );

		// True branch
		LLVMAppendExistingBasicBlock( function_context.llvm_function, true_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, true_block );

		LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(halt_function_), halt_function_, ust::nullptr</LLVMValueRef/>(), 0u, g_null_string );
		LLVMBuildUnreachable( function_context.llvm_ir_builder );

		// False branch
		LLVMAppendExistingBasicBlock( function_context.llvm_function, false_block );
		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, false_block );
	}

	return BlockElementBuildInfo();
}

fn CodeBuilder::BuildDeltaOneOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc, i32 delta )
{
	var VariablesFrameHolder temp_variables_frame_hodler(function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var VariablePtr variable_ptr= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression );
	var VariableLite variable= variable_ptr.lock_imut().deref();

	if( variable.value_type != ValueType::ReferenceMut )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, src_loc )
		return;
	}
	function_context.references_graph.EnsureHaveNoOutgoingLinks( variable_ptr, names_scope, src_loc );

	// Try process overloaded operator.
	if( ! variable.t.GetClassType().empty() )
	{
		var [ VariableTypeExtended, 1 ] args
		[ {
			.t(variable.t),
			.value_type= variable.value_type,
		} ];

		auto operator= select( delta == 1 ? OverloadedOperator::Increment : OverloadedOperator::Decrement );
		if_var( mut overloaded_operator : GetOverloadedOperator( args, operator, names_scope, src_loc ) )
		{
			auto fetch_result= TryFetchVirtualFunction( variable_ptr, overloaded_operator, names_scope, function_context, src_loc );
			overloaded_operator.llvm_function= fetch_result[1];

			DoCallFunction(
				names_scope,
				function_context,
				fetch_result[0],
				overloaded_operator,
				ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />(),
				src_loc );
			CallDestructorsForTopVariablesFrame( names_scope, function_context, src_loc );
			return;
		}
	}

	if( !variable.t.GetFundamentalType().empty() )
	{
		// Process operator for fundamental type.
		if( !IsInteger( variable.t.GetFundamentalType().try_deref().fundamental_type ) )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, variable.t )
			return;
		}

		unsafe
		{
			auto operand_value= CreateMoveToLLVMRegisterInstruction( variable, function_context );
			auto one_value= LLVMConstInt( variable.t.GetLLVMType(), 1u64, LLVMBool::True );
			auto result_value= select( delta > 0
				? LLVMBuildAdd( function_context.llvm_ir_builder, operand_value, one_value, "++\0"[0] )
				: LLVMBuildSub( function_context.llvm_ir_builder, operand_value, one_value, "--\0"[0] ) );
			CreateTypedStore( function_context, variable.t, result_value, variable.llvm_value );
		}
	}
	else if( !variable.t.GetRawPointerType().empty() )
	{
		var Type& element_type= variable.t.GetRawPointerType().try_deref().element_type;
		if( !EnsureTypeComplete( element_type ) )
		{
			// Complete types required for pointer arithmetic.
			REPORT_ERROR( UsingIncompleteType, names_scope, src_loc, element_type )
			return;
		}

		var LLVMValueRef pointer_value= CreateMoveToLLVMRegisterInstruction( variable, function_context );
		auto& op_name= select( delta > 0 ? "++\0" : "--\0" );
		unsafe
		{
			var LLVMValueRef
				mut delta_value= LLVMConstInt( size_type_.GetLLVMType(), u64(i64(delta)), LLVMBool::True ),
				result_value= LLVMBuildGEP2( function_context.llvm_ir_builder, element_type.GetLLVMType(), pointer_value, $<(delta_value), 1u, op_name[0] );
			CreateTypedStore( function_context, variable.t, result_value, variable.llvm_value );
		}
	}
	else
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, variable.t )
		return;
	}

	CallDestructorsForTopVariablesFrame( names_scope, function_context, src_loc );
}

} // namespace U1
