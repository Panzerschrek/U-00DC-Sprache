import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuiltTypeTemplatesSet( this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().get_ref().syntax_elements.empty() )
	{
		return;
	}

	auto mut type_templates_set_lock= type_templates_set_ptr.lock_mut();
	auto &mut type_templates_set= type_templates_set_lock.get_ref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto mut template_prepared= PrepareTypeTemplate( names_scope, type_templates_set.syntax_elements.back() );
		if( !template_prepared.empty() )
		{
			type_templates_set.type_templates.push_back( TypeTemplatePtr( template_prepared.get_ref() ) );
		}

		type_templates_set.syntax_elements.pop_back();
	}
	type_templates_set.syntax_elements.clear();
}

fn CodeBuilder::PrepareTypeTemplate(
	this,
	NamesScopePtr& names_scope,
	ust::shared_ptr_final</Synt::ClassTemplate/>& class_template_syntax_element ) : ust::optional</TypeTemplate/>
{
	auto& syntax_element= class_template_syntax_element.get_ref();

	auto mut first_default_param= syntax_element.signature_args.size();
	for( auto mut i= 0s; i < syntax_element.signature_args.size(); ++i )
	{
		if( syntax_element.signature_args[i].default_value.get</ Synt::EmptyVariant />().empty() )
		{
			first_default_param= ust::min( first_default_param, i );
		}
		else if( first_default_param < i )
		{
			REPORT_ERROR( MandatoryTemplateSignatureArgumentAfterOptionalArgument, names_scope, syntax_element.file_pos )
			return ust::optional</TypeTemplate/>();
		}
	}

	var TypeTemplate mut type_template
	{
		.syntax_element= class_template_syntax_element,
		.parent_names_scope= names_scope,
		.first_default_param= first_default_param,
	};

	// TODO - add some checks here

	return move(type_template);
}

fn CodeBuilder::GenTemplateType(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
	Synt::TemplateParameters& template_parameters ) : ust::optional</Type/>
{
	auto type_templates_set_lock= type_templates_set_ptr.lock_imut();
	var TypeTemplatesSet& type_templates_set= type_templates_set_lock.get_ref();
	if( type_templates_set.type_templates.size() != 1s )
	{
		return ust::optional</Type/>();
	}

	auto& type_template_ptr= type_templates_set.type_templates.front();
	var TypeTemplate& type_template= type_template_ptr.get_ref();

	var Synt::ClassTemplate& syntax_element= type_template.syntax_element.get_ref();
	if( syntax_element.is_short_form )
	{
		if( template_parameters.size() != syntax_element.args.size() )
		{
			return ust::optional</Type/>();
		}
	}
	else
	{
		if( template_parameters.size() < type_template.first_default_param )
		{
			return ust::optional</Type/>();
		}
	}

	var NamesScopePtr names_scope= ust::to_non_nullable( type_template.parent_names_scope.lock() ); // Parent namespace of type template
	var NamesScopeMutPtr result_names_scope( NamesScope( "", names_scope ) ); // Where we place template arguments

	{
		auto mut result_names_scope_lock= result_names_scope.lock_mut();
		for( auto mut i= 0s; i < syntax_element.args.size(); ++i )
		{
			// Should be simple name
			auto& name= syntax_element.args[i].name.get</Synt::ComplexName/>().get_ref().name;

			var TemplateArg mut template_arg{ .index= i };
			result_names_scope_lock.get_ref().AddName( name, move(template_arg ) );
		}
	}

	auto mut all_ok= true;
	var TemplateArgsFinished mut result_signature_template_args;

	if( syntax_element.is_short_form )
	{
		for( auto mut i= 0s; i < template_parameters.size(); ++i )
		{
			auto arg= BuildExpressionCode( args_names_scope, function_context, template_parameters[i] );
			all_ok&= MatchTemplateArgument( result_names_scope, type_template, syntax_element.args[i].name, arg );

			if_var( &t : arg.get</Type/>() )
			{
				result_signature_template_args.push_back( t );
			}
			if_var( &v : arg.get</Variable/>() )
			{
				result_signature_template_args.push_back( v );
			}
		}
	}
	else
	{
		for( auto mut i= 0s; i < syntax_element.signature_args.size(); ++i )
		{
			var Value mut arg;
			if( i < template_parameters.size() )
			{
				arg= BuildExpressionCode( args_names_scope, function_context, template_parameters[i] );
			}
			else
			{
				arg= BuildExpressionCode( result_names_scope, function_context, syntax_element.signature_args[i].default_value );
			}
			all_ok&= MatchTemplateArgument( result_names_scope, type_template, syntax_element.signature_args[i].name, arg );

			if_var( &t : arg.get</Type/>() )
			{
				result_signature_template_args.push_back( t );
			}
			if_var( &v : arg.get</Variable/>() )
			{
				result_signature_template_args.push_back( v );
			}
		}
	}

	if( !all_ok )
	{
		return ust::optional</Type/>();
	}

	auto template_key=
		ust::to_string8( ust::ref_to_int( type_template ) ) +
		MangleTemplateArgs( result_signature_template_args );

	var ust::string8 template_class_name= "_";

	if_var( prev_names_scope : generated_template_things_.find( template_key ) )
	{
		if_var( result_class_name : prev_names_scope.lock_imut().get_ref().GetThisScopeValue( template_class_name ) )
		{
			auto class_type= result_class_name.Get</ClassType/>();
			if( !class_type.empty() )
			{
				return Type( ust::to_non_nullable( class_type ) );
			}
		}
	}

	auto class_type= NamesScopeAddClass( result_names_scope, syntax_element.class_, template_class_name );
	if( class_type.empty() )
	{
		return ust::optional</Type/>();
	}

	{
		var ClassType::BaseTemplate mut base_template
		{
			.class_template= type_template_ptr,
			.signature_args= result_signature_template_args,
		};

		auto mut lock= class_type.lock_mut();
		lock.get_ref().base_template= move(base_template);
	}

	auto mangled_llvm_type_name= MangleType( ust::to_non_nullable( class_type ) );
	unsafe{  U1_SetStructName( class_type.lock_imut().get_ref().llvm_type, mangled_llvm_type_name.front() );  }

	generated_template_things_.insert( template_key, result_names_scope );
	return Type( ust::to_non_nullable( class_type ) );
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	Synt::Expression& param,
	Value& given_arg ) : bool
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		return MatchTemplateArgument( names_scope, type_template, complex_name, given_arg );
	}
	if_var( &bracket_expression : param.get</ Synt::BracketExpression />() )
	{
		return MatchTemplateArgument( names_scope, type_template, bracket_expression.expr.get_ref(), given_arg );
	}
	if_var( &array_type_expression : param.get</ ust::box</ Synt::ArrayType/> />() )
	{
		return MatchTemplateArgument( names_scope, type_template, array_type_expression.get_ref(), given_arg );
	}

	// If this is nothing special - process template parameter as regular expression.
	auto mut global_function_context= CreateGlobalFunctionContext();
	auto param_res= BuildExpressionCode( names_scope, global_function_context, param );

	return MatchTemplateArgumentExpressions( param_res, given_arg );
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	Synt::ComplexName& param,
	Value& given_arg ) : bool
{
	if( !param.name.empty() && param.tail.empty() )
	{
		if_var( result_name : names_scope.lock_imut().get_ref().GetThisScopeValue( param.name ) )
		{
			auto template_arg_ptr= result_name.Get</TemplateArg/>();
			if( !template_arg_ptr.empty() )
			{
				auto mut template_arg_lock= template_arg_ptr.lock_mut();
				auto &mut template_arg= template_arg_lock.get_ref();

				auto& value_param_type_name= type_template.syntax_element.get_ref().args[ template_arg.index ].t;
				if( value_param_type_name.get</Synt::EmptyVariant/>().empty() )
				{
					// Value param
					if_var( &given_variable : given_arg.get</Variable/>() )
					{
						if( !MatchTemplateArgument( names_scope, type_template, value_param_type_name, given_variable.t ) )
						{
							return false;
						}
						if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
						{
							var NamesScopeVariable mut out_var
							{
								.t= given_variable.t,
								.constexpr_value= given_variable.constexpr_value,
							};
							unsafe
							{
								out_var.llvm_value= LLVMAddGlobal( module_, out_var.t.GetLLVMType(), (param.name + "\0").front() );
								LLVMSetLinkage( out_var.llvm_value, LLVMLinkage::Internal );
								LLVMSetGlobalConstant( out_var.llvm_value, LLVMBool::True );
								LLVMSetInitializer( out_var.llvm_value, out_var.constexpr_value );
							}

							template_arg.something= move(out_var);
							return true;
						}
					}
				}
				else
				{
					// Type param
					if_var( &given_type : given_arg.get</Type/>() )
					{
						if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
						{
							template_arg.something= given_type;
							return true;
						}
					}
				}
			}
		}
	}

	// If this is nothing special - process template parameter as regular expression.
	auto mut global_function_context= CreateGlobalFunctionContext();
	auto param_res= BuildExpressionCode( names_scope, global_function_context, param );

	return MatchTemplateArgumentExpressions( param_res, given_arg );
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	Synt::ArrayType& param,
	Value& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_array_type : given_type.GetArrayType() )
		{
			if( !MatchTemplateArgument( names_scope, type_template, param.element_type, given_array_type.element_type.get_ref() ) )
			{
				return false;
			}

			var Variable mut size_var
			{
				.t= size_type_,
				.value_type= ValueType::Value,
				.location= Variable::Location::LLVMRegister,
			};
			unsafe
			{
				size_var.constexpr_value= LLVMConstInt( size_type_.GetLLVMType(), given_array_type.element_count, LLVMBool::False );
				size_var.llvm_value= size_var.constexpr_value;
			}

			if( !MatchTemplateArgument( names_scope, type_template, param.element_count, move(size_var) ) )
			{
				return false;
			}
			return true;
		}
		return false;
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	Synt::TypeName& param,
	Value& given_arg ) : bool
{
	if_var( &complex_name : param.get</ Synt::ComplexName />() )
	{
		return MatchTemplateArgument( names_scope, type_template, complex_name, given_arg );
	}
	if_var( &array_type : param.get</ ust::box</ Synt::ArrayType /> />() )
	{
		return MatchTemplateArgument( names_scope, type_template, array_type.get_ref(), given_arg );
	}
	return false;
}

fn CodeBuilder::MatchTemplateArgumentExpressions(
	mut this,
	Value& param,
	Value& arg ) : bool
{
	if_var( &given_type : arg.get</Type/>() )
	{
		if_var( &param_type : param.get</Type/>() )
		{
			return given_type == param_type;
		}
	}

	if_var( &given_variable : arg.get</Variable/>() )
	{
		if_var( &param_variable : param.get</Variable/>() )
		{
			if( given_variable.t != param_variable.t )
			{
				return false;
			}

			if( given_variable.t.GetFundamentalType().empty() && given_variable.t.GetEnumType().empty() )
			{
				return false;
			}
			if_var( &fundamental_type : given_variable.t.GetFundamentalType() )
			{
				if( !(
					IsInteger( fundamental_type.fundamental_type ) ||
					IsChar( fundamental_type.fundamental_type ) ||
					fundamental_type.fundamental_type == U_FundamentalType::bool_ ) )
				{
					return false;
				}
			}

			if( given_variable.constexpr_value == LLVMValueRef::Null || param_variable.constexpr_value == LLVMValueRef::Null )
			{
				return false;
			}

			unsafe
			{
				return LLVMConstIntGetZExtValue( given_variable.constexpr_value ) == LLVMConstIntGetZExtValue( param_variable.constexpr_value );
			}
		}
	}

	return false;
}

} // namespace U
