import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuiltTypeTemplatesSet( this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().get_ref().syntax_elements.empty() )
	{
		return;
	}

	auto mut type_templates_set_lock= type_templates_set_ptr.lock_mut();
	auto &mut type_templates_set= type_templates_set_lock.get_ref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto mut template_prepared= PrepareTypeTemplate( names_scope, type_templates_set.syntax_elements.back() );
		if( !template_prepared.empty() )
		{
			type_templates_set.type_templates.push_back( TypeTemplatePtr( template_prepared.get_ref() ) );
		}

		type_templates_set.syntax_elements.pop_back();
	}
	type_templates_set.syntax_elements.clear();
}

fn CodeBuilder::PrepareTypeTemplate(
	this,
	NamesScopePtr& names_scope,
	ust::shared_ptr_final</Synt::ClassTemplate/>& class_template_syntax_element ) : ust::optional</TypeTemplate/>
{
	var TypeTemplate mut type_template
	{
		.syntax_element= class_template_syntax_element,
		.parent_names_scope= names_scope,
	};

	// TODO - add some checks here

	return move(type_template);
}

fn CodeBuilder::GenTemplateType(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
	Synt::TemplateParameters& template_parameters ) : ust::optional</Type/>
{
	auto type_templates_set_lock= type_templates_set_ptr.lock_imut();
	var TypeTemplatesSet& type_templates_set= type_templates_set_lock.get_ref();
	if( type_templates_set.type_templates.size() != 1s )
	{
		return ust::optional</Type/>();
	}

	auto& type_template_ptr= type_templates_set.type_templates.front();
	var TypeTemplate& type_template= type_template_ptr.get_ref();

	var Synt::ClassTemplate& syntax_element= type_template.syntax_element.get_ref();
	if( template_parameters.size() != syntax_element.signature_args.size() )
	{
		return ust::optional</Type/>();
	}

	var NamesScopePtr names_scope= ust::to_non_nullable( type_template.parent_names_scope.lock() ); // Parent namespace of type template
	var NamesScopeMutPtr result_names_scope( NamesScope( "", names_scope ) ); // Where we place template arguments

	{
		auto mut result_names_scope_lock= result_names_scope.lock_mut();
		for( auto mut i= 0s; i < syntax_element.args.size(); ++i )
		{
			// Should be simple name
			auto& name= syntax_element.args[i].name.get</Synt::ComplexName/>().get_ref().name;

			var TemplateArg mut template_arg{ .index= i };
			result_names_scope_lock.get_ref().AddName( name, move(template_arg ) );
		}
	}

	auto mut all_ok= true;
	var TemplateArgsFinished mut result_signature_template_args;
	for( auto mut i= 0s; i < template_parameters.size(); ++i )
	{
		auto arg= BuildExpressionCode( args_names_scope, function_context, template_parameters[i] );
		all_ok|= MatchTemplateArgument( result_names_scope, type_template, syntax_element.signature_args[i].name, arg );

		if_var( &t : arg.get</Type/>() )
		{
			result_signature_template_args.push_back( t );
		}
		if_var( &v : arg.get</Variable/>() )
		{
			result_signature_template_args.push_back( v );
		}
	}

	if( !all_ok )
	{
		return ust::optional</Type/>();
	}

	auto template_key=
		ust::to_string8( ust::ref_to_int( type_template ) ) +
		MangleTemplateArgs( result_signature_template_args );

	var ust::string8 template_class_name= "_";

	if_var( prev_names_scope : generated_template_things_.find( template_key ) )
	{
		if_var( result_class_name : prev_names_scope.lock_imut().get_ref().GetThisScopeValue( template_class_name ) )
		{
			auto class_type= result_class_name.Get</ClassType/>();
			if( !class_type.empty() )
			{
				return Type( ust::to_non_nullable( class_type ) );
			}
		}
	}

	auto class_type= NamesScopeAddClass( result_names_scope, syntax_element.class_, template_class_name );
	if( class_type.empty() )
	{
		return ust::optional</Type/>();
	}

	{
		var ClassType::BaseTemplate mut base_template
		{
			.class_template= type_template_ptr,
			.signature_args= result_signature_template_args,
		};

		auto mut lock= class_type.lock_mut();
		lock.get_ref().base_template= move(base_template);
		// TODO - change here also name of LLVM type
	}

	generated_template_things_.insert( template_key, result_names_scope );
	return Type( ust::to_non_nullable( class_type ) );
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	Synt::Expression& param,
	Value& given_arg ) : bool
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		if( !complex_name.name.empty() && complex_name.tail.empty() )
		{
			if_var( result_name : names_scope.lock_imut().get_ref().GetThisScopeValue( complex_name.name ) )
			{
				auto template_arg_ptr= result_name.Get</TemplateArg/>();
				if( !template_arg_ptr.empty() )
				{
					auto mut template_arg_lock= template_arg_ptr.lock_mut();
					auto &mut template_arg= template_arg_lock.get_ref();

					auto& value_param_type_name= type_template.syntax_element.get_ref().args[ template_arg.index ].t;
					if( value_param_type_name.get</Synt::EmptyVariant/>().empty() )
					{
						// Value param
						if_var( &given_variable : given_arg.get</Variable/>() )
						{
							if( !MatchTemplateArgument( names_scope, type_template, value_param_type_name, given_variable.t ) )
							{
								return false;
							}
							if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
							{
								var NamesScopeVariable mut out_var
								{
									.t= given_variable.t,
									.constexpr_value= given_variable.constexpr_value,
								};
								unsafe
								{
									out_var.llvm_value= LLVMAddGlobal( module_, out_var.t.GetLLVMType(), (complex_name.name + "\0").front() );
									LLVMSetLinkage( out_var.llvm_value, LLVMLinkage::Internal );
									LLVMSetGlobalConstant( out_var.llvm_value, LLVMBool::True );
									LLVMSetInitializer( out_var.llvm_value, out_var.constexpr_value );
								}

								template_arg.something= move(out_var);
								return true;
							}
						}
					}
					else
					{
						// Type param
						if_var( &given_type : given_arg.get</Type/>() )
						{
							if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
							{
								template_arg.something= given_type;
								return true;
							}
						}
					}
				}
			}
		}
	}

	// If this is nothing special - process template parameter as regular expression.
	auto mut global_function_context= CreateGlobalFunctionContext();
	auto param_res= BuildExpressionCode( names_scope, global_function_context, param );

	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &param_type : param_res.get</Type/>() )
		{
			return given_type == param_type;
		}
	}

	return false;
}

} // namespace U
