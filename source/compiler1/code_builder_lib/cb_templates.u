import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().get_ref().syntax_elements.empty() )
	{
		return;
	}

	auto mut type_templates_set_lock= type_templates_set_ptr.lock_mut();
	auto &mut type_templates_set= type_templates_set_lock.get_ref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto syntax_element= type_templates_set.syntax_elements.back();
		PrepareTypeTemplate( names_scope, syntax_element, type_templates_set );

		type_templates_set.syntax_elements.pop_back();
	}
	type_templates_set.syntax_elements.clear();
}

fn CodeBuilder::PrepareTypeTemplate(
	mut this,
	NamesScopePtr& names_scope,
	ust::shared_ptr_final</Synt::TypeTemplate/>& type_template_syntax_element,
	TypeTemplatesSet &mut out_templates_set )
{
	auto& syntax_element= type_template_syntax_element.get_ref();

	// Check for template params redefinition, fill params vector.
	var ust::vector</ust::string8/> mut template_params;
	foreach( &param : syntax_element.params )
	{
		auto& name= param.name.get</Synt::ComplexName/>().get_ref().name;

		foreach( &prev_param_name : template_params )
		{
			if( prev_param_name == name )
			{
				REPORT_ERROR( Redefinition, names_scope, Synt::GetFilePos( param.name ), name )
			}
		}

		template_params.push_back(name);
	}

	// Fill signature params and check correctness.
	var ust::vector</bool/> mut template_param_usage_flags;

	var ust::vector</ TemplateSignatureParam /> mut signature_params;
	var ust::vector</ ust::box_nullable</ TemplateSignatureParam /> /> mut params_types;

	template_param_usage_flags.resize( template_params.size(), false );
	{
		auto mut global_function_context= CreateGlobalFunctionContext();

		foreach( &signature_param : syntax_element.signature_params )
		{
			signature_params.push_back(
				CreateTemplateSignatureParam( names_scope, global_function_context, template_params, signature_param.name, template_param_usage_flags ) );

			// TODO - is this correct usage of "CreateTemplateSignatureParam" function?
			if( signature_param.default_value.get</Synt::EmptyVariant/>().empty() )
			{
				CreateTemplateSignatureParam( names_scope, global_function_context, template_params, signature_param.default_value, template_param_usage_flags );
			}
		}

		foreach( &template_param : syntax_element.params )
		{
			if( syntax_element.is_short_form )
			{
				signature_params.push_back(
					CreateTemplateSignatureParam( names_scope, global_function_context, template_params, template_param.name, template_param_usage_flags ) );
			}
			if( template_param.t.get</Synt::EmptyVariant/>().empty() )
			{
				params_types.push_back(
					ust::box_nullable</ TemplateSignatureParam /> (
						CreateTemplateSignatureParam( names_scope, global_function_context, template_params, template_param.t, template_param_usage_flags ) ) );
			}
			else
			{
				params_types.push_back( ust::box_nullable</ TemplateSignatureParam />() );
			}
		}
	}
	if( !syntax_element.is_short_form )
	{
		for( auto mut i= 0s; i < template_param_usage_flags.size(); ++i )
		{
			if( !template_param_usage_flags[i] )
			{
				REPORT_ERROR( TemplateArgumentNotUsedInSignature, names_scope, Synt::GetFilePos(syntax_element.params[i].name), template_params[i] )
			}
		}
	}

	// Check default signature params correctness.
	auto mut first_default_param= syntax_element.signature_params.size();
	for( auto mut i= 0s; i < syntax_element.signature_params.size(); ++i )
	{
		if( syntax_element.signature_params[i].default_value.get</ Synt::EmptyVariant />().empty() )
		{
			first_default_param= ust::min( first_default_param, i );
		}
		else if( first_default_param < i )
		{
			REPORT_ERROR( MandatoryTemplateSignatureArgumentAfterOptionalArgument, names_scope, syntax_element.file_pos )
			return;
		}
	}

	var TypeTemplate mut type_template
	{
		.syntax_element= type_template_syntax_element,
		.parent_names_scope= names_scope,
		.first_default_param= first_default_param,
		.signature_params= move(signature_params),
		.params_types= move(params_types),
	};

	// TODO - add some checks here

	out_templates_set.type_templates.push_back( TypeTemplatePtr( move(type_template) ) );
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::vector</ust::string8/>& template_params,
	Synt::Expression& param,
	ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, complex_name, template_params_usage_flags );
	}
	if_var( &bracket_exptession : param.get</Synt::BracketExpression/>() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, bracket_exptession.expr.get_ref(), template_params_usage_flags );
	}
	if_var( &array_type : param.get</ ust::box</ Synt::ArrayType /> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, array_type.get_ref(), template_params_usage_flags );
	}
	if_var( &function_type : param.get</ ust::box</Synt::FunctionType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, function_type.get_ref(), template_params_usage_flags );
	}

	// Nothing special - process as regular expression
	auto expression_value= BuildExpressionCode( names_scope, function_context, param );
	return CreateTemplateSignatureParam( expression_value );
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::vector</ust::string8/>& template_params,
	Synt::ComplexName& param,
	ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam
{
	if( !param.name.empty() && param.tail.empty() )
	{
		for( auto mut i= 0s; i < template_params.size(); ++i )
		{
			if( param.name == template_params[i] )
			{
				template_params_usage_flags[i]= true;

				var TemplateSignatureParam::TemplateParam mut res{ .index= i, .name= param.name };
				return move(res);
			}
		}
	}

	auto value= ResolveValue( names_scope, function_context, param, true );
	if_var( &type_templates_set_ptr : value.get</ ust::shared_ptr_imut</ TypeTemplatesSet /> />() )
	{
		if( !param.tail.empty() )
		{
			if_var( &template_args : param.tail.back().get</ ust::box</ Synt::TemplateArgs /> />() )
			{
				var TemplateSignatureParam::SpecializedTemplateParam mut specialized_template_param
				{
					.type_templates_set= type_templates_set_ptr,
				};

				auto mut all_params_are_known= true;
				foreach( &arg : template_args.get_ref() )
				{
					auto mut out_param= CreateTemplateSignatureParam( names_scope, function_context, template_params, arg, template_params_usage_flags );

					all_params_are_known&= !out_param.GetTypeParam().empty() || !out_param.GetVariableParam().empty();

					specialized_template_param.params.push_back(move(out_param));
				}

				if( all_params_are_known )
				{
					auto value= ResolveValue( names_scope, function_context, param );
					if_var( &t : value.get</Type/>() )
					{
						var TemplateSignatureParam::TypeParam mut type_param{ .t= t };
						return move(type_param);
					}
				}

				return move(specialized_template_param);
			}
		}
		// TODO - report error - expected template args
	}

	// Nothing special - process as regular expression
	auto expression_value= BuildExpressionCode( names_scope, function_context, param );
	return CreateTemplateSignatureParam( expression_value );
}

fn CodeBuilder::CreateTemplateSignatureParam( mut this, Value& value ) : TemplateSignatureParam
{
	if_var( &t : value.get</Type/>() )
	{
		var TemplateSignatureParam::TypeParam mut type_param{ .t= t };
		return move(type_param);
	}
	if_var( &v : value.get</Variable/>() )
	{
		// TODO - check type.
		var TemplateSignatureParam::VariableParam mut variable_param{ .v= v };
		return move(variable_param);
	}

	// TODO - produce some error here.
	return TemplateSignatureParam::TypeParam();
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::vector</ust::string8/>& template_params,
	Synt::TypeName& param,
	ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, complex_name, template_params_usage_flags );
	}
	if_var( &array_type : param.get</ ust::box</Synt::ArrayType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, array_type.get_ref(), template_params_usage_flags );
	}
	if_var( &function_type : param.get</ ust::box</Synt::FunctionType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, function_type.get_ref(), template_params_usage_flags );
	}

	// Nothing special - process as regular type name.
	var TemplateSignatureParam::TypeParam mut t
	{
		.t= PrepareType( names_scope, function_context, param )
	};
	return move(t);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::vector</ust::string8/>& template_params,
	Synt::ArrayType& param,
	ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam::ArrayTypeParam mut array_type_param
	{
		.element_type= CreateTemplateSignatureParam( names_scope, function_context, template_params, param.element_type, template_params_usage_flags ),
		.element_count= CreateTemplateSignatureParam( names_scope, function_context, template_params, param.element_count, template_params_usage_flags ),
	};

	if( !array_type_param.element_type.GetTypeParam().empty() && !array_type_param.element_count.GetVariableParam().empty() )
	{
		// All params are known types/variables, so, this is just a type.
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, param )
		};
		return move(t);
	}
	return move(array_type_param);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::vector</ust::string8/>& template_params,
	Synt::FunctionType& signature_param,
	ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam::FunctionTypeParam mut function_type_param
	{
		.return_type( TemplateSignatureParam::TypeParam() )
		.return_value_is_mutable= signature_param.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable,
		.return_value_is_reference= signature_param.return_value_reference_modifier == Synt::ReferenceModifier::Reference,
		.is_unsafe= signature_param.is_unsafe,
	};

	auto mut all_types_are_known= true;
	if( !signature_param.return_type.empty() )
	{
		function_type_param.return_type=
			CreateTemplateSignatureParam( names_scope, function_context, template_params, signature_param.return_type.get_ref(), template_params_usage_flags );
		all_types_are_known &= !function_type_param.return_type.GetTypeParam().empty();
	}
	else
	{
		var TemplateSignatureParam::TypeParam mut t{ .t= void_type_for_ret_ };
		function_type_param.return_type= TemplateSignatureParam(move(t));
	}
	foreach( &param : signature_param.args )
	{
		var TemplateSignatureParam::FunctionTypeParam::Param mut out_param
		{
			.t= CreateTemplateSignatureParam( names_scope, function_context, template_params, param.arg_type, template_params_usage_flags ),
			.is_mutable= param.mutability_modifier == Synt::MutabilityModifier::Mutable,
			.is_reference= param.reference_modifier == Synt::ReferenceModifier::Reference,
		};

		all_types_are_known &= !out_param.t.GetTypeParam().empty();

		function_type_param.params.push_back( move(out_param) );
	}

	if( all_types_are_known )
	{
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, signature_param )
		};
		return move(t);
	}

	return move(function_type_param);
}

fn CodeBuilder::GenTemplateType(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
	Synt::TemplateArgs& template_args,
	FilePos& template_instantiation_file_pos ) : ust::optional</Type/>
{
	auto type_templates_set_lock= type_templates_set_ptr.lock_imut();
	var TypeTemplatesSet& type_templates_set= type_templates_set_lock.get_ref();
	if( type_templates_set.type_templates.size() != 1s )
	{
		return ust::optional</Type/>();
	}

	auto& type_template_ptr= type_templates_set.type_templates.front();
	auto mut res= GenTemplateType(
		args_names_scope,
		function_context,
		type_template_ptr,
		template_args,
		template_instantiation_file_pos );

	if( res.empty() )
	{
		REPORT_ERROR( TemplateParametersDeductionFailed, args_names_scope, template_instantiation_file_pos )
	}

	return move(res);
}

fn CodeBuilder::GenTemplateType(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	TypeTemplatePtr& type_template_ptr,
	Synt::TemplateArgs& template_args,
	FilePos& template_instantiation_file_pos ) : ust::optional</Type/>
{
	var TypeTemplate& type_template= type_template_ptr.get_ref();

	var Synt::TypeTemplate& syntax_element= type_template.syntax_element.get_ref();
	if( syntax_element.is_short_form )
	{
		if( template_args.size() != syntax_element.params.size() )
		{
			return ust::optional</Type/>();
		}
	}
	else
	{
		if( template_args.size() < type_template.first_default_param )
		{
			return ust::optional</Type/>();
		}
	}

	var NamesScopePtr names_scope= ust::to_non_nullable( type_template.parent_names_scope.lock() ); // Parent namespace of type template
	var NamesScopeMutPtr result_names_scope( NamesScope( "", names_scope ) ); // Where we place template arguments

	{
		auto mut result_names_scope_lock= result_names_scope.lock_mut();
		for( auto mut i= 0s; i < syntax_element.params.size(); ++i )
		{
			// Should be simple name
			auto& name= syntax_element.params[i].name.get</Synt::ComplexName/>().get_ref().name;

			var TemplateArg mut template_arg{ .index= i };
			result_names_scope_lock.get_ref().AddName( name, move(template_arg ) );
		}
	}

	auto mut all_ok= true;
	var TemplateArgsFinished mut result_signature_template_args;

	if( syntax_element.is_short_form )
	{
		for( auto mut i= 0s; i < template_args.size(); ++i )
		{
			auto arg= BuildExpressionCode( args_names_scope, function_context, template_args[i] );
			if( arg.get</Type/>().empty() && arg.get</Variable/>().empty() )
			{
				REPORT_ERROR( InvalidValueAsTemplateArgument, args_names_scope, Synt::GetFilePos(template_args[i]), GetValueKindName(arg) )
				all_ok= false;
			}

			all_ok&= MatchTemplateArgument( result_names_scope, type_template, type_template.signature_params[i], arg, Synt::GetFilePos(template_args[i]) );

			if_var( &t : arg.get</Type/>() )
			{
				result_signature_template_args.push_back( t );
			}
			if_var( &v : arg.get</Variable/>() )
			{
				result_signature_template_args.push_back( v );
			}
		}
	}
	else
	{
		for( auto mut i= 0s; i < syntax_element.signature_params.size(); ++i )
		{
			var Value mut arg;
			var FilePos mut file_pos;
			if( i < template_args.size() )
			{
				file_pos= Synt::GetFilePos( template_args[i] );
				arg= BuildExpressionCode( args_names_scope, function_context, template_args[i] );
			}
			else
			{
				file_pos= Synt::GetFilePos( syntax_element.signature_params[i].default_value );
				arg= BuildExpressionCode( result_names_scope, function_context, syntax_element.signature_params[i].default_value );
			}

			if( arg.get</Type/>().empty() && arg.get</Variable/>().empty() )
			{
				REPORT_ERROR( InvalidValueAsTemplateArgument, args_names_scope, file_pos, GetValueKindName(arg) )
				all_ok= false;
			}

			all_ok&= MatchTemplateArgument( result_names_scope, type_template, type_template.signature_params[i], arg, file_pos );

			if_var( &t : arg.get</Type/>() )
			{
				result_signature_template_args.push_back( t );
			}
			if_var( &v : arg.get</Variable/>() )
			{
				result_signature_template_args.push_back( v );
			}
		}
	}

	if( !all_ok )
	{
		return ust::optional</Type/>();
	}

	auto template_key=
		ust::to_string8( ust::ref_to_int( type_template ) ) +
		MangleTemplateArgs( result_signature_template_args );

	var ust::string8 template_class_name= "_";

	if_var( prev_names_scope : generated_template_things_.find( template_key ) )
	{
		if_var( result_name : prev_names_scope.lock_imut().get_ref().GetThisScopeValue( template_class_name ) )
		{
			auto class_type= result_name.Get</ClassType/>();
			if( !class_type.empty() )
			{
				return Type( ust::to_non_nullable( class_type ) );
			}
			auto t= result_name.Get</Type/>();
			if( !t.empty() )
			{
				return t.lock_imut().get_ref();
			}
		}
	}

	if_var( &class_syntax_element : syntax_element.something.get</ ust::shared_ptr_final</ Synt::Class /> />() )
	{
		auto class_type= NamesScopeAddClass( result_names_scope, class_syntax_element );
		if( class_type.empty() )
		{
			return ust::optional</Type/>();
		}

		{
			var ClassType::BaseTemplate mut base_template
			{
				.class_template= type_template_ptr,
				.signature_args= result_signature_template_args,
			};

			auto mut lock= class_type.lock_mut();
			lock.get_ref().base_template= move(base_template);
		}

		auto mangled_llvm_type_name= MangleType( ust::to_non_nullable( class_type ) );
		unsafe{  U1_SetStructName( class_type.lock_imut().get_ref().llvm_type, mangled_llvm_type_name.front() );  }

		generated_template_things_.insert( template_key, result_names_scope );
		return Type( ust::to_non_nullable( class_type ) );
	}
	if_var( &type_alias_syntax_element : syntax_element.something.get</ ust::shared_ptr_final</ Synt::TypeAlias /> />() )
	{
		// Prepare type
		var Type mut t;
		{
			auto mut global_function_context= CreateGlobalFunctionContext();
			t= PrepareType( result_names_scope, global_function_context, type_alias_syntax_element.get_ref().type_name );
		}

		// Cache result.
		{
			auto mut names_scope_lock= result_names_scope.lock_mut();
			names_scope_lock.get_ref().AddName( template_class_name, t );
		}

		generated_template_things_.insert( template_key, result_names_scope );

		return t;
	}

	halt; // Unhandled type template kind.
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam& param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	if_var( &template_param : param.GetTemplateParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, type_template, template_param, given_arg, file_pos );
	}
	if_var( &type_param : param.GetTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, type_template, type_param, given_arg, file_pos );
	}
	if_var( &variable_param : param.GetVariableParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, type_template, variable_param, given_arg, file_pos );
	}
	if_var( &array_type_param : param.GetArrayTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, type_template, array_type_param, given_arg, file_pos );
	}
	if_var( &function_type_param : param.GetFunctionTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, type_template, function_type_param, given_arg, file_pos );
	}
	if_var( &specialized_template_param : param.GetSpecializedTemplateParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, type_template, specialized_template_param, given_arg, file_pos );
	}

	halt;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam::TemplateParam& template_param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	auto template_arg_name= names_scope.lock_imut().get_ref().GetThisScopeValue( template_param.name ).get_ref();
	auto template_arg_ptr= template_arg_name.Get</TemplateArg/>();

	auto mut template_arg_lock= template_arg_ptr.lock_mut();
	auto &mut template_arg= template_arg_lock.get_ref();

	auto& param_type= type_template.params_types[template_param.index];

	if( !param_type.empty() )
	{
		// Value param
		if_var( &given_variable : given_arg.get</Variable/>() )
		{
			if( !TypeIsValidForTemplateVariableArgument( given_variable.t ) )
			{
				REPORT_ERROR( InvalidTypeOfTemplateVariableArgument, names_scope, file_pos, given_variable.t )
				return false;
			}
			if( given_variable.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, file_pos )
				return false;
			}

			if( !MatchTemplateArgument( names_scope, type_template, param_type.get_ref(), given_variable.t, file_pos ) )
			{
				return false;
			}

			if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
			{
				var NamesScopeVariable mut out_var
				{
					.t= given_variable.t,
					.constexpr_value= given_variable.constexpr_value,
				};
				unsafe
				{
					out_var.llvm_value= LLVMAddGlobal( module_, out_var.t.GetLLVMType(), "\0"[0] );
					LLVMSetLinkage( out_var.llvm_value, LLVMLinkage::Internal );
					LLVMSetGlobalConstant( out_var.llvm_value, LLVMBool::True );
					LLVMSetInitializer( out_var.llvm_value, out_var.constexpr_value );
				}

				template_arg.something= move(out_var);
				return true;
			}
			if_var( &v : template_arg.something.get</NamesScopeVariable/>() )
			{
				if( given_variable.t != v.t )
				{
					return false;
				}

				if( given_variable.constexpr_value == LLVMValueRef::Null || v.constexpr_value == LLVMValueRef::Null )
				{
					REPORT_ERROR( ExpectedConstantExpression, names_scope, file_pos )
					return false;
				}

				unsafe
				{
					return
						LLVMConstIntGetZExtValue( given_variable.constexpr_value ) ==
						LLVMConstIntGetZExtValue( v.constexpr_value );
				}
			}
		}
	}
	else
	{
		// Type param
		if_var( &given_type : given_arg.get</Type/>() )
		{
			if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
			{
				template_arg.something= given_type;
				return true;
			}
			if_var( &t : template_arg.something.get</Type/>() )
			{
				return given_type == t;
			}
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam::TypeParam& type_param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		return type_param.t == given_type;
	}
	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam::VariableParam& variable_param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	if_var( &given_variable : given_arg.get</Variable/>() )
	{
		if( given_variable.t != variable_param.v.t )
		{
			return false;
		}

		if( given_variable.constexpr_value == LLVMValueRef::Null || variable_param.v.constexpr_value == LLVMValueRef::Null )
		{
			REPORT_ERROR( ExpectedConstantExpression, names_scope, file_pos )
			return false;
		}

		unsafe
		{
			return
				LLVMConstIntGetZExtValue( given_variable.constexpr_value ) ==
				LLVMConstIntGetZExtValue( variable_param.v.constexpr_value );
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam::ArrayTypeParam& array_type_param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_array_type : given_type.GetArrayType() )
		{
			if( !MatchTemplateArgument( names_scope, type_template, array_type_param.element_type, given_array_type.element_type.get_ref(), file_pos ) )
			{
				return false;
			}

			var Variable mut size_var
			{
				.t= size_type_,
				.value_type= ValueType::Value,
				.location= Variable::Location::LLVMRegister,
			};
			unsafe
			{
				size_var.constexpr_value= LLVMConstInt( size_type_.GetLLVMType(), given_array_type.element_count, LLVMBool::False );
				size_var.llvm_value= size_var.constexpr_value;
			}

			if( !MatchTemplateArgument( names_scope, type_template, array_type_param.element_count, move(size_var), file_pos ) )
			{
				return false;
			}
			return true;
		}
	}
	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam::FunctionTypeParam& function_type_param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_function_pointer_type : given_type.GetFunctionPointerType() )
		{
			var FunctionType given_function_type= given_function_pointer_type.function_type;

			if( given_function_type.return_value_is_mutable != function_type_param.return_value_is_mutable ||
				given_function_type.return_value_is_reference != function_type_param.return_value_is_reference ||
				given_function_type.is_unsafe != function_type_param.is_unsafe )
			{
				return false;
			}

			if( !MatchTemplateArgument( names_scope, type_template, function_type_param.return_type, given_function_type.return_type.get_ref(), file_pos ) )
			{
				return false;
			}

			if( given_function_type.args.size() != function_type_param.params.size() )
			{
				return false;
			}

			for( auto mut i= 0s; i < function_type_param.params.size(); ++i )
			{
				auto& expected_param= function_type_param.params[i];
				auto& given_arg= given_function_type.args[i];

				if( expected_param.is_mutable != given_arg.is_mutable ||
					expected_param.is_reference != given_arg.is_reference )
				{
					return false;
				}
				if( !MatchTemplateArgument( names_scope, type_template, expected_param.t, given_arg.arg_type.get_ref(), file_pos ) )
				{
					return false;
				}
			}

			return true;
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TypeTemplate& type_template,
	TemplateSignatureParam::SpecializedTemplateParam& specialized_template_param,
	Value& given_arg,
	FilePos& file_pos ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &class_type : given_type.GetClassType() )
		{
			auto class_type_lock= class_type.lock_imut();
			if_var( &base_template : class_type_lock.get_ref().base_template )
			{
				auto mut is_one_of_templates= false;
				foreach( &type_template_ptr : specialized_template_param.type_templates_set.lock_imut().get_ref().type_templates )
				{
					if( base_template.class_template == type_template_ptr )
					{
						is_one_of_templates= true;
						break;
					}
				}

				if( !is_one_of_templates )
				{
					return false;
				}

				if( base_template.signature_args.size() != specialized_template_param.params.size() )
				{
					return false;
				}
				for( auto mut i= 0s; i < specialized_template_param.params.size(); ++i )
				{
					var Value mut val;
					if_var( &v : base_template.signature_args[i].get</Variable/>() )
					{
						val= v;
					}
					if_var( &t : base_template.signature_args[i].get</Type/>() )
					{
						val= t;
					}

					if( !MatchTemplateArgument( names_scope, type_template, specialized_template_param.params[i], val, file_pos ) )
					{
						return false;
					}
				}

				return true;
			}
		}
	}

	return false;
}

fn CodeBuilder::TypeIsValidForTemplateVariableArgument( Type& t ) : bool
{
	if( !t.GetEnumType().empty() )
	{
		// All enums are valid.
		return true;
	}

	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		return
			IsInteger( fundamental_type.fundamental_type ) ||
			IsChar( fundamental_type.fundamental_type ) ||
			fundamental_type.fundamental_type == U_FundamentalType::bool_;
	}

	return false;
}

} // namespace U
