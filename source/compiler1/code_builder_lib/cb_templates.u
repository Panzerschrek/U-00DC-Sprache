import "/assert.u"
import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

template</type TemplateT/>
fn CreateTemplateErrorsContext(
	TemplateT& template_, // type template or function template
	NamesScopePtr& instantiation_point_names_scope_ptr,
	NamesScopeMutPtr& args_names_scope_ptr,
	SrcLoc& instantiation_src_loc )
{
	var ust::shared_ptr_mut</ErrorsContainer/> errors_container( ErrorsContainer() );

	var TemplateErrorsContext mut result
	{
		.errors= errors_container,
		.context_declaration_src_loc= instantiation_src_loc,
		.context_name= template_.syntax_element.deref().name,
	};

	{
		auto args_names_scope_lock= args_names_scope_ptr.lock_imut();
		var NamesScope& args_names_scope= args_names_scope_lock.deref();

		result.args_description+= "[ with ";
		foreach( &param : template_.params )
		{
			result.args_description+= param.name;
			result.args_description+= " = ";

			auto arg_ptr= args_names_scope.GetThisScopeValue( param.name ).try_deref().Get</TemplateArg/>();
			auto arg_lock= arg_ptr.try_lock_imut();
			var TemplateArg& arg= arg_lock.deref();
			if_var( &t : arg.something.get</Type/>() )
			{
				result.args_description+= t.ToString();
			}
			else if_var( &v_ptr : arg.something.get</VariablePtr/>() )
			{
				auto lock= v_ptr.lock_imut();
				auto& v= lock.deref();
				result.args_description+= ConstantVariableToString( v.t, v.constexpr_value );
			}
			else { halt; }

			if( ust::ref_cmp_ne( param, template_.params.front() ) )
			{
				result.args_description+= ", ";
			}
		}
		result.args_description+= " ]";
	}

	with( mut lock : instantiation_point_names_scope_ptr.lock_imut().deref().GetErrors().try_lock_mut() )
	{
		var CodeBuilderError mut template_context_error
		{
			.code= CodeBuilderErrorCode::TemplateContext,
			.src_loc= instantiation_src_loc,
			.errors_context( move(result) ),
		};

		lock.deref().push_back( move(template_context_error) );
	}

	with( mut lock : args_names_scope_ptr.lock_mut() )
	{
		lock.deref().SetErrors( errors_container );
	}
}

fn CodeBuilder::PrepareTypeTemplate(
	mut this,
	NamesScopePtr& names_scope,
	ust::shared_ptr_final</Synt::TypeTemplate/>& type_template_syntax_element,
	TypeTemplatesSet &mut out_templates_set )
{
	auto& syntax_element= type_template_syntax_element.deref();

	auto mut template_params= PrepareTemplateParams( names_scope, syntax_element.params.range() );

	// Fill signature params and check correctness.
	var ust::vector</bool/> mut template_params_usage_flags;
	template_params_usage_flags.resize( template_params.size(), false );

	var ust::vector</ TemplateSignatureParam /> mut signature_params;
	{
		auto mut global_function_context= CreateGlobalFunctionContext();

		if( syntax_element.is_short_form )
		{
			for( auto mut i= 0s; i < template_params.size(); ++i )
			{
				var TemplateSignatureParam::TemplateParam mut p{ .index= u32(i) };
				signature_params.push_back( move(p) );
				template_params_usage_flags[i]= true;
			}
		}
		else
		{
			foreach( &signature_param : syntax_element.signature_params )
			{
				signature_params.push_back(
					CreateTemplateSignatureParam( names_scope, global_function_context, template_params.range(), signature_param.name, template_params_usage_flags.range() ) );

				// TODO - is this correct usage of "CreateTemplateSignatureParam" function?
				if( signature_param.default_value.get</Synt::EmptyVariant/>().empty() )
				{
					CreateTemplateSignatureParam( names_scope, global_function_context, template_params.range(), signature_param.default_value, template_params_usage_flags.range() );
				}
			}
		}
	}

	FillVariableTemplateParamsTypes( names_scope, syntax_element.params.range(), template_params.range(), template_params_usage_flags.range() );

	// Check for usage of all template params in signature.
	for( auto mut i= 0s; i < template_params_usage_flags.size(); ++i )
	{
		if( !template_params_usage_flags[i] )
		{
			REPORT_ERROR( TemplateArgumentNotUsedInSignature, names_scope, syntax_element.params[i].src_loc, template_params[i].name )
		}
	}

	// Check default signature params correctness.
	auto mut first_default_param= syntax_element.signature_params.size();
	for( auto mut i= 0s; i < syntax_element.signature_params.size(); ++i )
	{
		if( syntax_element.signature_params[i].default_value.get</ Synt::EmptyVariant />().empty() )
		{
			first_default_param= ust::min( first_default_param, i );
		}
		else if( first_default_param < i )
		{
			REPORT_ERROR( MandatoryTemplateSignatureArgumentAfterOptionalArgument, names_scope, syntax_element.src_loc )
			return;
		}
	}

	var TypeTemplate mut type_template(
		move(template_params),
		move(signature_params),
		names_scope,
		type_template_syntax_element,
		first_default_param );

	// Check for redefinition.
	foreach( &prev_template_ptr : out_templates_set.type_templates )
	{
		if( type_template.signature_params == prev_template_ptr.lock_imut().deref().signature_params )
		{
			REPORT_ERROR( TypeTemplateRedefinition, names_scope, syntax_element.src_loc, syntax_element.name )
			return;
		}
	}

	out_templates_set.type_templates.push_back( TypeTemplatePtr( move(type_template) ) );
}

fn CodeBuilder::PrepareFunctionTemplate(
	mut this,
	NamesScopePtr& names_scope,
	ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template_syntax_element,
	ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionTemplatePtr
{
	auto& syntax_element= function_template_syntax_element.deref();
	auto& function_template_name= function_template_syntax_element.deref().name;

	if( syntax_element.function.deref().block.empty() )
	{
		REPORT_ERROR( IncompleteMemberOfClassTemplate, names_scope, function_template_syntax_element.deref().src_loc, function_template_name )
	}
	if( syntax_element.function.deref().virtual_kind != Synt::Function::VirtualKind::None )
	{
		REPORT_ERROR( VirtualForFunctionTemplate, names_scope, function_template_syntax_element.deref().src_loc, function_template_name )
	}

	auto mut template_params= PrepareTemplateParams( names_scope, syntax_element.params.range() );

	var ust::vector</bool/> mut template_params_usage_flags;
	template_params_usage_flags.resize( template_params.size(), false );

	// Create signature params.
	var ust::vector</ TemplateSignatureParam /> mut signature_params;
	{
		auto mut global_function_context= CreateGlobalFunctionContext();

		foreach( &param : syntax_element.function.deref().function_type.params )
		{
			if( !class_type.empty() && param.name == KeywordToString( Keyword::this_ ) )
			{
				var TemplateSignatureParam::TypeParam mut t{ .t= class_type.try_to_non_nullable() };
				signature_params.push_back( move(t) );
			}
			else
			{
				signature_params.push_back(
					CreateTemplateSignatureParam( names_scope, global_function_context, template_params.range(), param.t, template_params_usage_flags.range() ) );
			}
		}
	}

	FillVariableTemplateParamsTypes( names_scope, syntax_element.params.range(), template_params.range(), template_params_usage_flags.range() );

	var FunctionTemplate mut function_template(
		move(template_params),
		move(signature_params),
		names_scope,
		function_template_syntax_element,
		class_type );

	return FunctionTemplatePtr( move(function_template) );
}

fn CodeBuilder::PrepareTemplateParams(
	mut this,
	NamesScopePtr& names_scope,
	ust::array_view_imut</Synt::TemplateParam/> in_params ) : ust::vector</ TemplateBase::Param />
{
	// Check for template params redefinition, fill params vector.
	var ust::vector</ TemplateBase::Param /> mut template_params;
	foreach( &param : in_params )
	{
		foreach( &prev_param : template_params )
		{
			if( param.name == prev_param.name )
			{
				REPORT_ERROR( Redefinition, names_scope, param.src_loc, param.name )
			}
		}

		var TemplateBase::Param mut out_param{ .name= param.name };
		template_params.push_back( move(out_param) );
	}

	return move(template_params);
}

fn CodeBuilder::FillVariableTemplateParamsTypes(
	mut this,
	NamesScopePtr& names_scope,
	ust::array_view_imut</Synt::TemplateParam/> in_params,
	ust::array_view_mut</TemplateBase::Param/> template_params,
	ust::array_view_mut</bool/> template_params_usage_flags )
{
	halt if( in_params.size() != template_params.size() );
	halt if( template_params_usage_flags.size() != template_params.size() );

	auto mut global_function_context= CreateGlobalFunctionContext();

	for( auto mut i= 0s; i < in_params.size(); ++i )
	{
		auto& template_param= in_params[i];
		if( template_param.t.get</Synt::EmptyVariant/>().empty() )
		{
			var TemplateSignatureParam mut param=
				CreateTemplateSignatureParam( names_scope, global_function_context, template_params.range(), template_param.t, template_params_usage_flags.range() );
			if_var( &type_param : param.GetTypeParam() )
			{
				if( !TypeIsValidForTemplateVariableArgument(type_param.t) )
				{
					REPORT_ERROR( InvalidTypeOfTemplateVariableArgument, names_scope, Synt::GetSrcLoc(template_param.t), type_param.t )
				}
			}
			template_params[i].t= move(param);

		}
	}
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::Expression& param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, complex_name, template_params_usage_flags );
	}
	if_var( &array_type : param.get</ ust::box</ Synt::ArrayType /> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, array_type.deref(), template_params_usage_flags );
	}
	if_var( &tuple_type : param.get</ ust::box</ Synt::TupleType /> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, tuple_type.deref(), template_params_usage_flags );
	}
	if_var( &raw_pointer_type : param.get</ ust::box</ Synt::RawPointerType /> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, raw_pointer_type.deref(), template_params_usage_flags );
	}
	if_var( &function_type : param.get</ ust::box</Synt::FunctionType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, function_type.deref(), template_params_usage_flags );
	}
	if_var( &coroutine_type : param.get</ ust::box</Synt::CoroutineType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, coroutine_type.deref(), template_params_usage_flags );
	}

	// Nothing special - process as regular expression
	auto expression_value= BuildExpressionCode( names_scope, function_context, param );
	return CreateTemplateSignatureParam( names_scope, expression_value, Synt::GetSrcLoc(param) );
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::ComplexName& param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	if_var( &name_lookup : param.get</Synt::NameLookup/>() )
	{
		for( auto mut i= 0s; i < template_params.size(); ++i )
		{
			if( name_lookup.name == template_params[i].name )
			{
				template_params_usage_flags[i]= true;

				var TemplateSignatureParam::TemplateParam mut res{ .index= u32(i) };
				return move(res);
			}
		}
	}

	if_var( &template_parameterization : param.get</Synt::TemplateParameterization/>() )
	{
		if_var( &type_templates_set_ptr : ResolveValue( names_scope, function_context, template_parameterization.base_.deref() ).get</ ust::shared_ptr_imut</TypeTemplatesSet/> />() )
		{
			var TemplateSignatureParam::SpecializedTemplateParam mut specialized_template_param
			{
				.type_templates_set= type_templates_set_ptr,
			};

			auto mut all_params_are_known= true;
			foreach( &arg : template_parameterization.template_args.deref() )
			{
				auto mut out_param= CreateTemplateSignatureParam( names_scope, function_context, template_params, arg, template_params_usage_flags );

				all_params_are_known&= !out_param.GetTypeParam().empty() || !out_param.GetVariableParam().empty();

				specialized_template_param.params.push_back(move(out_param));
			}

			if( all_params_are_known )
			{
				auto value= ResolveValue( names_scope, function_context, param );
				if_var( &t : value.get</Type/>() )
				{
					var TemplateSignatureParam::TypeParam mut type_param{ .t= t };
					return move(type_param);
				}
			}

			return move(specialized_template_param);
		}
	}

	// Nothing special - process as regular expression
	auto expression_value= BuildExpressionCode( names_scope, function_context, param );
	return CreateTemplateSignatureParam( names_scope, expression_value, Synt::GetSrcLoc(param) );
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::TypeName& param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, complex_name, template_params_usage_flags );
	}
	if_var( &array_type : param.get</ ust::box</Synt::ArrayType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, array_type.deref(), template_params_usage_flags );
	}
	if_var( &tuple_type : param.get</ ust::box</Synt::TupleType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, tuple_type.deref(), template_params_usage_flags );
	}
	if_var( &raw_pointer_type : param.get</ ust::box</Synt::RawPointerType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, raw_pointer_type.deref(), template_params_usage_flags );
	}
	if_var( &function_type : param.get</ ust::box</Synt::FunctionType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, function_type.deref(), template_params_usage_flags );
	}
	if_var( &coroutine_type : param.get</ ust::box</Synt::CoroutineType/> />() )
	{
		return CreateTemplateSignatureParam( names_scope, function_context, template_params, coroutine_type.deref(), template_params_usage_flags );
	}

	// Nothing special - process as regular type name.
	var TemplateSignatureParam::TypeParam mut t
	{
		.t= PrepareType( names_scope, function_context, param )
	};
	return move(t);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::ArrayType& param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam::ArrayTypeParam mut array_type_param
	{
		.element_type= CreateTemplateSignatureParam( names_scope, function_context, template_params, param.element_type, template_params_usage_flags ),
		.element_count= CreateTemplateSignatureParam( names_scope, function_context, template_params, param.element_count, template_params_usage_flags ),
	};

	if( !array_type_param.element_type.GetTypeParam().empty() && !array_type_param.element_count.GetVariableParam().empty() )
	{
		// All params are known types/variables, so, this is just a type.
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, param )
		};
		return move(t);
	}
	return move(array_type_param);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::TupleType& signature_param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam::TupleTypeParam mut tuple_type_param;

	var bool mut all_types_are_known= true;
	foreach( &element_type : signature_param.elements )
	{
		auto mut param= CreateTemplateSignatureParam( names_scope, function_context, template_params, element_type, template_params_usage_flags );
		all_types_are_known&= !param.GetTypeParam().empty();
		tuple_type_param.element_types.push_back( move(param) );
	}

	if( all_types_are_known )
	{
		// All params are known types, so, this is just a type.
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, signature_param )
		};
		return move(t);
	}

	return move(tuple_type_param);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::RawPointerType& signature_param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam::RawPointerTypeParam mut raw_pointer_type_param
	{
		.element_type= CreateTemplateSignatureParam( names_scope, function_context, template_params, signature_param.element_type, template_params_usage_flags )
	};

	if( !raw_pointer_type_param.element_type.GetTypeParam().empty() )
	{
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, signature_param )
		};
		return move(t);
	}

	return move(raw_pointer_type_param);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::FunctionType& signature_param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam::FunctionTypeParam mut function_type_param
	{
		.return_type( TemplateSignatureParam::TypeParam() ),
		.is_unsafe= signature_param.is_unsafe,
		.calling_convention= GetLLVMCallingConvention( signature_param.calling_convention, names_scope, signature_param.src_loc ),
		.return_value_type= ValueType::Value,
	};

	if( signature_param.return_value_reference_modifier == Synt::ReferenceModifier::Reference )
	{
		function_type_param.return_value_type= select( signature_param.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );
	}

	auto mut all_types_are_known= true;
	if( !signature_param.return_type.empty() )
	{
		function_type_param.return_type=
			CreateTemplateSignatureParam( names_scope, function_context, template_params, signature_param.return_type.try_deref(), template_params_usage_flags );
		all_types_are_known &= !function_type_param.return_type.GetTypeParam().empty();
	}
	else
	{
		var TemplateSignatureParam::TypeParam mut t{ .t= void_type_ };
		function_type_param.return_type= TemplateSignatureParam(move(t));
	}
	foreach( &param : signature_param.params )
	{
		var TemplateSignatureParam::FunctionTypeParam::Param mut out_param
		{
			.t= CreateTemplateSignatureParam( names_scope, function_context, template_params, param.t, template_params_usage_flags ),
			.value_type= ValueType::Value,
		};

		if( param.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			out_param.value_type= select( param.mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );
		}

		all_types_are_known &= !out_param.t.GetTypeParam().empty();

		function_type_param.params.push_back( move(out_param) );
	}

	if( all_types_are_known )
	{
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, signature_param )
		};
		return move(t);
	}

	return move(function_type_param);
}

fn CodeBuilder::CreateTemplateSignatureParam(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	ust::array_view_imut</TemplateBase::Param/> template_params,
	Synt::CoroutineType& signature_param,
	ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam
{
	var TemplateSignatureParam mut return_type=
		CreateTemplateSignatureParam( names_scope, function_context, template_params, signature_param.return_type, template_params_usage_flags );
	if( !return_type.GetTypeParam().empty() )
	{
		var TemplateSignatureParam::TypeParam mut t
		{
			.t= PrepareType( names_scope, function_context, signature_param )
		};
		return move(t);
	}

	var TemplateSignatureParam::CoroutineTypeParam mut coroutine_type_param
	{
		.kind= signature_param.kind,
		.return_type= move(return_type),
		.return_value_type= select(
			signature_param.return_value_reference_modifier == Synt::ReferenceModifier::Reference
				? select(
					signature_param.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable
						? ValueType::ReferenceMut
						: ValueType::ReferenceImut )
				: ValueType::Value ),
		.non_sync_= ImmediateEvaluateNonSyncTag( names_scope, function_context, signature_param.non_sync_tag ),
	};

	foreach( &m : signature_param.inner_reference_tags )
	{
		coroutine_type_param.inner_references.push_back( select( m == Synt::MutabilityModifier::Mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut ) );
	}

	auto num_params= 1s;
	if_var( &return_value_reference_expression : signature_param.return_value_reference_expression )
	{
		coroutine_type_param.return_references= EvaluateFunctionReturnReferences( names_scope, return_value_reference_expression, num_params );
	}
	if_var( &return_value_inner_references_expression : signature_param.return_value_inner_references_expression )
	{
		coroutine_type_param.return_inner_references= EvaluateFunctionReturnInnerReferences( names_scope, return_value_inner_references_expression, num_params );
	}

	return move(coroutine_type_param);
}

fn CodeBuilder::CreateTemplateSignatureParam( mut this, NamesScopePtr& names_scope, Value& value, SrcLoc& src_loc ) : TemplateSignatureParam
{
	if_var( &t : value.get</Type/>() )
	{
		var TemplateSignatureParam::TypeParam mut type_param{ .t= t };
		return move(type_param);
	}
	else if_var( &v_ptr : value.get</VariablePtr/>() )
	{
		with( &v : v_ptr.lock_imut().deref() )
		{
			if( !TypeIsValidForTemplateVariableArgument( v.t ) )
			{
				REPORT_ERROR( InvalidTypeOfTemplateVariableArgument, names_scope, src_loc, v.t )
				var TemplateSignatureParam::TypeParam mut type_param{ .t= invalid_type_ };
				return move(type_param);
			}
			if( v.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, src_loc )
				var TemplateSignatureParam::TypeParam mut type_param{ .t= invalid_type_ };
				return move(type_param);
			}

			var TemplateSignatureParam::VariableParam mut variable_param{ .t= v.t, .constexpr_value= v.constexpr_value };
			return move(variable_param);
		}
	}
	else if( !value.get</ ust::shared_ptr_imut</TypeTemplatesSet/> />().empty() )
	{
		REPORT_ERROR( TemplateInstantiationRequired, names_scope, src_loc, "" )
		var TemplateSignatureParam::TypeParam mut type_param{ .t= invalid_type_ };
		return move(type_param);
	}
	else
	{
		REPORT_ERROR( InvalidValueAsTemplateArgument, names_scope, src_loc, GetValueKindName( value ) )
		var TemplateSignatureParam::TypeParam mut type_param{ .t= invalid_type_ };
		return move(type_param);
	}
}

fn CodeBuilder::GenTemplateType(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
	Synt::TemplateArgs& template_args,
	SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>
{
	var TemplateArgsFinished template_args_finished= EvaluateTemplateArgs( args_names_scope, function_context, template_args, template_instantiation_src_loc );
	if( template_args_finished.size() != template_args.size() )
	{
		REPORT_ERROR( TemplateParametersDeductionFailed, args_names_scope, template_instantiation_src_loc )
		return ust::null_optional;
	}

	auto type_templates_set_lock= type_templates_set_ptr.lock_imut();
	var TypeTemplatesSet& type_templates_set= type_templates_set_lock.deref();

	var ust::vector</ TemplateTypeArgsEvaluationResult /> mut candidate_type_templates;
	foreach( &type_template_ptr : type_templates_set.type_templates )
	{
		auto mut res= EvaluateTemplateTypeArgs( type_template_ptr, template_args_finished.range() );
		if( !res.empty() )
		{
			candidate_type_templates.push_back( res.try_take() );
		}
	}

	if( candidate_type_templates.empty() )
	{
		REPORT_ERROR( TemplateParametersDeductionFailed, args_names_scope, template_instantiation_src_loc )
		return ust::null_optional;
	}
	if( candidate_type_templates.size() == 1s )
	{
		return FinishTypeTemplateGeneration( candidate_type_templates.front(), args_names_scope, template_instantiation_src_loc );
	}

	var ust::vector</TypeTemplatePtr/> mut templates_for_check;
	foreach( &candidate : candidate_type_templates )
	{
		templates_for_check.push_back( candidate.type_template );
	}

	auto index= SelectMoreSpecializedTemplate( templates_for_check.range(), template_args.size() );
	if( index == ~0s )
	{
		REPORT_ERROR( CouldNotSelectMoreSpicializedTypeTemplate, args_names_scope, template_instantiation_src_loc )
		return ust::null_optional;
	}

	return FinishTypeTemplateGeneration( candidate_type_templates[index], args_names_scope, template_instantiation_src_loc );
}

fn CodeBuilder::EvaluateTemplateTypeArgs(
	mut this,
	TypeTemplatePtr& type_template_ptr,
	ust::array_view_imut</TemplateArgFinished/> template_args ) : ust::optional</TemplateTypeArgsEvaluationResult/>
{
	// Avoid performing single lock of type template pointer - lock it multiple times instead where it is needed.
	// Do this in order to avoid holding lock in recursive calls.
	with( &type_template : type_template_ptr.lock_imut().deref() )
	{
		if( type_template.syntax_element.deref().is_short_form )
		{
			if( template_args.size() != type_template.syntax_element.deref().params.size() )
			{
				return ust::null_optional;
			}
		}
		else
		{
			if( template_args.size() < type_template.first_default_param ||
				template_args.size() > type_template.signature_params.size() )
			{
				return ust::null_optional;
			}
		}
	}

	var NamesScopePtr names_scope= type_template_ptr.lock_imut().deref().parent_names_scope.lock().try_to_non_nullable(); // Parent namespace of type template
	var NamesScopeMutPtr result_names_scope( NamesScope( NamesScope::c_template_args_namespace_name, names_scope ) ); // Where we place template arguments

	with( &type_template : type_template_ptr.lock_imut().deref() )
	{
		with( mut lock : result_names_scope.lock_mut() )
		{
			for( auto mut i= 0s; i < type_template.params.size(); ++i )
			{
				var TemplateArg mut template_arg{ .index= u32(i) };
				lock.deref().AddName( type_template.params[i].name, move(template_arg) );
			}
		}
	}

	auto mut all_ok= true;
	var TemplateArgsFinished mut result_signature_template_args;

	// Copy and match passed args.
	with( &type_template : type_template_ptr.lock_imut().deref() )
	{
		for( auto mut i= 0s; i < template_args.size(); ++i )
		{
			result_signature_template_args.push_back( template_args[i] );
			all_ok&= MatchTemplateArgument( result_names_scope, type_template, type_template.signature_params[i], result_signature_template_args[i] );
		}
		debug_assert( result_signature_template_args.size() == template_args.size(), "Wrong args count!" );
	}

	auto syntax_element_ptr= type_template_ptr.lock_imut().deref().syntax_element;
	var Synt::TypeTemplate& syntax_element= syntax_element_ptr.deref();

	// Evaluate and match default args (if needed).
	if( !syntax_element.is_short_form && template_args.size() < syntax_element.signature_params.size() )
	{
		auto mut global_function_context= CreateGlobalFunctionContext();
		for( auto mut i= template_args.size(); i < syntax_element.signature_params.size(); ++i )
		{
			var Synt::Expression& expr= syntax_element.signature_params[i].default_value;
			var Value value= BuildExpressionCode( result_names_scope, global_function_context, expr );
			auto mut template_arg_opt= ValueToTemplateArg( result_names_scope, Synt::GetSrcLoc( expr ), value );
			if( !template_arg_opt.empty() )
			{
				result_signature_template_args.push_back( template_arg_opt.try_take() );
			}
			else
			{
				all_ok= false;
				continue;
			}

			with( &type_template : type_template_ptr.lock_imut().deref() )
			{
				all_ok&= MatchTemplateArgument( result_names_scope, type_template, type_template.signature_params[i], result_signature_template_args.back() );
			}
		}
	}

	if( !all_ok )
	{
		return ust::null_optional;
	}

	var TemplateTypeArgsEvaluationResult mut result
	{
		.type_template= type_template_ptr,
		.args_names_scope= result_names_scope,
		.signature_args= move(result_signature_template_args),
	};

	return move(result);
}

fn CodeBuilder::FinishTypeTemplateGeneration(
	mut this,
	TemplateTypeArgsEvaluationResult& template_args_evaluation_result,
	NamesScopePtr& instantiation_point_names_scope,
	SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>
{
	var TypeTemplatePtr& type_template_ptr= template_args_evaluation_result.type_template;

	with( mut lock : type_template_ptr.lock_mut() )
	{
		lock.deref().used= true;
	}

	var TemplateKey mut template_key
	{
		.template_= ust::shared_ptr_imut</TypeTemplate/>( type_template_ptr ),
		.template_args= template_args_evaluation_result.signature_args,
	};

	var ust::string8 template_class_name= "_";

	if_var( prev_names_scope : generated_template_things_.find( template_key ) )
	{
		if_var( result_name : prev_names_scope.lock_imut().deref().GetThisScopeValue( template_class_name ) )
		{
			auto class_type= result_name.Get</ClassType/>();
			if( !class_type.empty() )
			{
				return Type( class_type.try_to_non_nullable() );
			}
			auto t= result_name.Get</Type/>();
			if( !t.empty() )
			{
				return t.try_lock_imut().deref();
			}
		}
	}

	auto syntax_element_ptr= type_template_ptr.lock_imut().deref().syntax_element;
	var Synt::TypeTemplate& syntax_element= syntax_element_ptr.deref();
	var NamesScopeMutPtr& args_names_scope= template_args_evaluation_result.args_names_scope;

	CreateTemplateErrorsContext(
		type_template_ptr.lock_imut().deref(),
		instantiation_point_names_scope,
		args_names_scope,
		template_instantiation_src_loc );

	if_var( &class_syntax_element : syntax_element.something.get</ ust::shared_ptr_final</ Synt::Class /> />() )
	{
		var ClassType::BaseTemplate mut base_template
		{
			.class_template= type_template_ptr,
			.signature_args= template_args_evaluation_result.signature_args,
		};

		auto class_type= NamesScopeAddClass( args_names_scope, class_syntax_element, move(base_template) );
		if( class_type.empty() )
		{
			return ust::null_optional;
		}

		AddNewTemplateThing( move(template_key), args_names_scope );
		return Type( class_type.try_to_non_nullable() );
	}
	else if_var( &type_alias_syntax_element : syntax_element.something.get</ ust::shared_ptr_final</ Synt::TypeAlias /> />() )
	{
		// Prepare type
		var Type mut t;
		{
			auto mut global_function_context= CreateGlobalFunctionContext();
			t= PrepareType( args_names_scope, global_function_context, type_alias_syntax_element.deref().type_name );
		}

		// Cache result.
		with( mut lock : args_names_scope.lock_mut() )
		{
			lock.deref().AddName( template_class_name, t );
		}

		AddNewTemplateThing( move(template_key), args_names_scope );

		return move(t);
	}
	else { halt; } // Unhandled type template kind.
}

fn CodeBuilder::PrepareTemplateFunction(
	mut this,
	FunctionTemplatePtr& function_template_ptr,
	ust::array_view_imut</TemplateArgFinished/> known_template_args,
	ust::array_view_imut</VariableTypeExtended/> mut args,
	bool first_arg_is_this,
	SrcLoc& src_loc ) : ust::optional</TemplateFunctionPreparationResult/>
{
	auto function_template_lock= function_template_ptr.lock_imut();
	var FunctionTemplate& function_template= function_template_lock.deref();

	var Synt::FunctionTemplate& template_syntax_element= function_template.syntax_element.deref();
	var Synt::Function& function_syntax_element= template_syntax_element.function.deref();

	if( first_arg_is_this &&
		( function_syntax_element.function_type.params.empty() ||
		function_syntax_element.function_type.params.front().name != KeywordToString( Keyword::this_ ) ) )
	{
		args.drop_front();
	}
	if( args.size() != function_syntax_element.function_type.params.size() )
	{
		return ust::null_optional;
	}

	var NamesScopePtr names_scope= function_template.parent_names_scope.lock().try_to_non_nullable(); // Parent namespace of type template
	var NamesScopeMutPtr result_names_scope( NamesScope( NamesScope::c_template_args_namespace_name, names_scope ) ); // Where we place template arguments

	FillKnownFunctionTemplateArgsIntoNamespace( function_template, known_template_args, result_names_scope );

	auto mut all_ok= true;
	for( auto mut i= 0s; i < args.size(); ++i )
	{
		var Synt::FunctionType::Param& function_param= function_syntax_element.function_type.params[i];
		var VariableTypeExtended& arg= args[i];

		auto param_is_mutable_reference=
			function_param.reference_modifier == Synt::ReferenceModifier::Reference &&
			function_param.mutability_modifier == Synt::MutabilityModifier::Mutable;
		if( param_is_mutable_reference && arg.value_type != ValueType::ReferenceMut )
		{
			return ust::null_optional;
		}

		auto& param= function_template.signature_params[i];
		if_var( &template_param : param.GetTemplateParam() )
		{
			auto& param_name= function_template.params[ size_type(template_param.index) ].name;
			auto template_arg_value= result_names_scope.lock_imut().deref().GetThisScopeValue( param_name ).try_deref();
			auto template_arg_ptr= template_arg_value.Get</TemplateArg/>();

			auto template_arg_lock= template_arg_ptr.try_lock_imut();
			auto& template_arg= template_arg_lock.deref();

			if_var( &t : template_arg.something.get</Type/>() )
			{
				// TODO - maybe forbid type conversion for copy and conversion constructors?
				all_ok&=
					arg.t.ReferenceIsConvertibleTo( t ) ||
					( !param_is_mutable_reference && HasConversionConstructor( result_names_scope, t, arg.t, src_loc ) );
				continue;
			}
		}
		if_var( &type_param : param.GetTypeParam() )
		{
			// TODO - maybe forbid type conversion for copy and conversion constructors?
			all_ok&=
				arg.t.ReferenceIsConvertibleTo( type_param.t ) ||
				( !param_is_mutable_reference && HasConversionConstructor( result_names_scope, type_param.t, arg.t, src_loc ) );
			continue;
		}

		all_ok&= MatchTemplateArgument( result_names_scope, function_template, param, arg.t );
	}

	if( !all_ok )
	{
		return ust::null_optional;
	}

	// Process "enable_if" here - fail template function preparation if condition is false.
	if_var( &expr : function_syntax_element.condition )
	{
		var FunctionContext mut global_function_context= CreateGlobalFunctionContext();
		if( !EvaluateBoolConstantExpression( result_names_scope, global_function_context, expr ) )
		{
			return ust::null_optional; // Function disabled
		}
	}

	var TemplateFunctionPreparationResult mut result{ .function_template= function_template_ptr, .args_names_scope= result_names_scope };
	return move(result);
}

fn CodeBuilder::FinishFunctionTemplateParameterization(
	mut this,
	ParameterizedFunctionTemplate& parameterized_function_template,
	SrcLoc& src_loc ) : ust::optional</FunctionVariable/>
{
	auto function_template_lock= parameterized_function_template.base_template.lock_imut();
	var FunctionTemplate& function_template= function_template_lock.deref();
	auto& known_template_args= parameterized_function_template.known_args;

	halt if( function_template.params.size() != known_template_args.size() );

	var NamesScopeMutPtr result_names_scope(
		NamesScope(
			"",
			function_template.parent_names_scope.lock().try_to_non_nullable() ) ); // Where we place template arguments

	FillKnownFunctionTemplateArgsIntoNamespace( function_template, known_template_args.range(), result_names_scope );

	return FinishTemplateFunctionGeneration(
		parameterized_function_template.base_template,
		result_names_scope,
		parameterized_function_template.instantiation_point_names_scope,
		src_loc );
}

fn CodeBuilder::FinishTemplateFunctionGeneration(
	mut this,
	FunctionTemplatePtr& function_template_ptr,
	NamesScopeMutPtr& result_names_scope,
	NamesScopePtr& instantiation_point_names_scope,
	SrcLoc& src_loc ) : ust::optional</FunctionVariable/>
{
	auto function_template_lock= function_template_ptr.lock_imut();
	var FunctionTemplate& function_template= function_template_lock.deref();
	var Synt::FunctionTemplate& template_syntax_element= function_template.syntax_element.deref();
	var Synt::Function& function_syntax_element= template_syntax_element.function.deref();

	var TemplateArgsFinished mut result_template_args;
	{
		auto mut result_names_scope_lock= result_names_scope.lock_imut();
		for( auto mut i= 0s; i < function_template.params.size(); ++i )
		{
			auto arg_value= result_names_scope_lock.deref().GetThisScopeValue( function_template.params[i].name ).try_deref();
			auto template_arg_ptr= arg_value.Get</TemplateArg/>();

			auto template_arg_lock= template_arg_ptr.try_lock_imut();
			auto& something= template_arg_lock.deref().something;
			if_var( &t : something.get</Type/>() )
			{
				result_template_args.push_back(t);
			}
			else if_var( &v_ptr : something.get</VariablePtr/>() )
			{
				result_template_args.push_back( v_ptr );
			}
			else
			{
				REPORT_ERROR( TemplateParametersDeductionFailed, result_names_scope, src_loc )
				return ust::null_optional;
			}
		}
	}

	var TemplateKey mut template_key{ .template_= function_template_ptr, .template_args= result_template_args };

	auto& function_name= function_syntax_element.name.back();
	if_var( prev_names_scope : generated_template_things_.find( template_key ) )
	{
		auto namespace_value= prev_names_scope.lock_imut().deref().GetThisScopeValue( function_name ).try_deref();

		auto functions_set_ptr= namespace_value.Get</FunctionsSet/>();
		auto functions_set_lock= functions_set_ptr.try_lock_imut();
		auto & functions_set= functions_set_lock.deref();

		if( functions_set.functions.size() == 1s )
		{
			return functions_set.functions.front();
		}

		return ust::null_optional;
	}
	AddNewTemplateThing( move(template_key), result_names_scope );

	CreateTemplateErrorsContext(
		function_template,
		instantiation_point_names_scope,
		result_names_scope,
		src_loc );

	NamesScopeFill( result_names_scope, template_syntax_element.function, function_template.class_, Synt::ClassVisibility::Public /* TODO - set correct visibility */ );
	auto result_namespace_value= result_names_scope.lock_imut().deref().GetThisScopeValue( function_name ).try_deref();

	auto result_functions_set_ptr= result_namespace_value.Get</FunctionsSet/>();
	BuildFunctionsSet( result_names_scope, result_functions_set_ptr.try_to_non_nullable(), false );

	if( result_functions_set_ptr.try_lock_imut().deref().functions.size() != 1s )
	{
		return ust::null_optional;
	}

	// Set base template and mangled name.
	auto mut function_variable= result_functions_set_ptr.try_lock_imut().deref().functions.front();

	auto mut name_mangled=
		mangler_.deref().MangleFunction( function_template.parent_names_scope.lock().try_lock_imut().deref(), function_name.range(), function_variable.t, result_template_args );
	with( &mut lock : function_variable.llvm_function.lock_mut() )
	{
		if( lock.deref().function != LLVMValueRef::Null )
		{
			unsafe( LLVMSetValueName2( lock.deref().function, name_mangled.data(), name_mangled.size() - 1s ) );
		}
		lock.deref().name_mangled= move(name_mangled);
	}

	with( mut lock : result_functions_set_ptr.try_lock_mut() )
	{
		lock.deref().functions.front()= function_variable;
	}

	// Build func code to know constexpr-ness.
	// TODO - do not even try to build func code right now, if function can't be constexpr because of types in signature.
	if( function_variable.constexpr_kind != FunctionVariable::ConstexprKind::ConstexprComplete )
	{
		function_variable.constexpr_kind= FunctionVariable::ConstexprKind::ConstexprAuto;
		BuildFuncCode(
			result_names_scope,
			function_variable,
			ust::shared_ptr_nullable_mut</ ReturnTypeDeductionContext />(),
			ust::shared_ptr_nullable_mut</ ReferenceNotationDeductionContext />(),
			ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext />() );
	}

	with( mut lock : result_functions_set_ptr.try_lock_mut() )
	{
		lock.deref().functions.front()= function_variable;
	}

	return move(function_variable);
}

fn CodeBuilder::ParameterizeTemplateFunctions(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	FunctionsSetPtr& functions_set_ptr,
	Synt::TemplateArgs& template_args,
	SrcLoc& src_loc ) : ust::shared_ptr_nullable_mut</FunctionsSet/>
{
	var TemplateArgsFinished template_args_finished= EvaluateTemplateArgs( args_names_scope, function_context, template_args, src_loc );
	if( template_args_finished.size() != template_args.size() )
	{
		return ust::shared_ptr_nullable_mut</FunctionsSet/>();
	}

	var ParameterizedFunctionTemplateKey mut cache_key{ .functions_set= functions_set_ptr, .template_args= template_args_finished };

	if_var( &prev_value : parameterized_template_functions_cache_.find( cache_key ) )
	{
		return prev_value;
	}

	auto functions_set_lock= functions_set_ptr.lock_imut();
	var FunctionsSet& functions_set= functions_set_lock.deref();

	var FunctionsSet mut result_functions_set;
	result_functions_set.class_= functions_set.class_;
	foreach( &function_template_ptr : functions_set.function_templates )
	{
		auto function_template_lock= function_template_ptr.lock_imut();
		var FunctionTemplate& function_template= function_template_lock.deref();

		if( function_template.params.size() < template_args_finished.size() )
		{
			continue;
		}

		var NamesScopeMutPtr result_names_scope(
			NamesScope(
				"",
				function_template.parent_names_scope.lock().try_to_non_nullable() ) );

		with( mut lock : result_names_scope.lock_mut() )
		{
			for( auto mut i= 0s; i < function_template.params.size(); ++i )
			{
				var TemplateArg mut template_arg{ .index= u32(i) };
				lock.deref().AddName( function_template.params[i].name, move(template_arg) );
			}
		}

		auto mut all_ok= true;
		for( auto mut i= 0s; i < template_args_finished.size(); ++i )
		{
			var TemplateSignatureParam::TemplateParam mut signature_param{ .index= u32(i) };
			var TemplateSignatureParam signature_param_abstract( move(signature_param) );

			if( !MatchTemplateArgument( result_names_scope, function_template, signature_param_abstract, template_args_finished[i] ) )
			{
				all_ok= false;
				break;
			}
		}

		if( !all_ok )
		{
			continue;
		}

		var ParameterizedFunctionTemplate mut parameterized_function_template
		{
			.known_args= template_args_finished,
			.base_template= function_template_ptr,
			.instantiation_point_names_scope= args_names_scope,
		};

		result_functions_set.parameterized_function_templates.push_back( move(parameterized_function_template) );
	}

	if( result_functions_set.parameterized_function_templates.empty() )
	{
		REPORT_ERROR( TemplateFunctionGenerationFailed, args_names_scope, src_loc, ust::string8("TODO - name") )
		return ust::shared_ptr_nullable_mut</FunctionsSet/>();
	}

	var ust::shared_ptr_mut</FunctionsSet/> mut result( move(result_functions_set) );
	parameterized_template_functions_cache_.insert( move(cache_key), result );
	return move(result);
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam& param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &template_param : param.GetTemplateParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, template_param, given_arg );
	}
	if_var( &type_param : param.GetTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, type_param, given_arg );
	}
	if_var( &variable_param : param.GetVariableParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, variable_param, given_arg );
	}
	if_var( &array_type_param : param.GetArrayTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, array_type_param, given_arg );
	}
	if_var( &tuple_type_param : param.GetTupleTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, tuple_type_param, given_arg );
	}
	if_var( &raw_pointer_type_param : param.GetRawPointerTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, raw_pointer_type_param, given_arg );
	}
	if_var( &function_type_param : param.GetFunctionTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, function_type_param, given_arg );
	}
	if_var( &coroutine_type_param : param.GetCoroutineTypeParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, coroutine_type_param, given_arg );
	}
	if_var( &specialized_template_param : param.GetSpecializedTemplateParam() )
	{
		return MatchTemplateArgumentImpl( names_scope, template_, specialized_template_param, given_arg );
	}

	halt;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::TemplateParam& template_param,
	TemplateArgFinished& given_arg ) : bool
{
	auto& param_name= template_.params[ size_type(template_param.index) ].name;
	auto template_arg_value= names_scope.lock_imut().deref().GetThisScopeValue( param_name ).try_deref();
	auto template_arg_ptr= template_arg_value.Get</TemplateArg/>();

	auto mut template_arg_lock= template_arg_ptr.try_lock_mut();
	auto &mut template_arg= template_arg_lock.deref();

	auto& param_type= template_.params[ size_type(template_param.index) ].t;
	if( !param_type.empty() )
	{
		// Value param
		if_var( &given_variable_ptr : given_arg.get</VariablePtr/>() )
		{
			auto given_variable_lock= given_variable_ptr.lock_imut();
			var Variable& given_variable= given_variable_lock.deref();

			if( !TypeIsValidForTemplateVariableArgument( given_variable.t ) || given_variable.constexpr_value == LLVMValueRef::Null )
			{
				// May be in case of error.
				return false;
			}

			if( !MatchTemplateArgument( names_scope, template_, param_type.try_deref(), given_variable.t ) )
			{
				return false;
			}

			if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
			{
				var Variable mut out_var
				{
					.t= given_variable.t,
					.value_type= ValueType::ReferenceImut,
					.location= Variable::Location::Pointer,
					.constexpr_value= given_variable.constexpr_value,
					.llvm_value= AddGlobalConstantVariable( (param_name + "\0").range(), given_variable.t.GetLLVMType(), given_variable.constexpr_value ),
					.name= param_name,
				};

				template_arg.something= VariablePtr( move(out_var) );
				return true;
			}
			if_var( &v_ptr : template_arg.something.get</VariablePtr/>() )
			{
				auto lock= v_ptr.lock_imut();
				var Variable& v= lock.deref();

				if( given_variable.t != v.t )
				{
					return false;
				}

				if( given_variable.constexpr_value == LLVMValueRef::Null || v.constexpr_value == LLVMValueRef::Null )
				{
					return false;
				}

				return unsafe(
					LLVMConstIntGetZExtValue( given_variable.constexpr_value ) ==
					LLVMConstIntGetZExtValue( v.constexpr_value ) );
			}
		}
	}
	else
	{
		// Type param
		if_var( &given_type : given_arg.get</Type/>() )
		{
			if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
			{
				template_arg.something= given_type;
				return true;
			}
			if_var( &t : template_arg.something.get</Type/>() )
			{
				return given_type == t;
			}
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::TypeParam& type_param,
	TemplateArgFinished& given_arg ) : bool
{
	ust::ignore_unused(names_scope);
	ust::ignore_unused(template_);

	if_var( &given_type : given_arg.get</Type/>() )
	{
		return type_param.t == given_type;
	}
	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::VariableParam& variable_param,
	TemplateArgFinished& given_arg ) : bool
{
	ust::ignore_unused( names_scope );
	ust::ignore_unused( template_ );

	if_var( &given_variable_ptr : given_arg.get</VariablePtr/>() )
	{
		auto given_variable_lock= given_variable_ptr.lock_imut();
		auto& given_variable= given_variable_lock.deref();

		if( given_variable.t != variable_param.t )
		{
			return false;
		}

		if( given_variable.constexpr_value == LLVMValueRef::Null || variable_param.constexpr_value == LLVMValueRef::Null )
		{
			// May be in case of error.
			return false;
		}

		return unsafe(
			LLVMConstIntGetZExtValue( given_variable.constexpr_value ) ==
			LLVMConstIntGetZExtValue( variable_param.constexpr_value ) );
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::ArrayTypeParam& array_type_param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_array_type : given_type.GetArrayType() )
		{
			if( !MatchTemplateArgument( names_scope, template_, array_type_param.element_type, given_array_type.element_type ) )
			{
				return false;
			}

			var Variable mut size_var
			{
				.t= size_type_,
				.value_type= ValueType::Value,
				.location= Variable::Location::LLVMRegister,
				.name= "array_size",
			};
			size_var.constexpr_value= unsafe( LLVMConstInt( size_type_.GetLLVMType(), given_array_type.element_count, LLVMBool::False ) );
			size_var.llvm_value= size_var.constexpr_value;

			if( !MatchTemplateArgument( names_scope, template_, array_type_param.element_count, VariablePtr( move(size_var) ) ) )
			{
				return false;
			}
			return true;
		}
	}
	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::TupleTypeParam& tuple_type_param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_tuple_type : given_type.GetTupleType() )
		{
			if( given_tuple_type.element_types.size() != tuple_type_param.element_types.size() )
			{
				return false;
			}

			for( auto mut i= 0s; i < given_tuple_type.element_types.size(); ++i )
			{
				if( !MatchTemplateArgument( names_scope, template_, tuple_type_param.element_types[i], given_tuple_type.element_types[i] ) )
				{
					return false;
				}
			}

			return true;
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::RawPointerTypeParam& raw_pointer_type_param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_raw_pointer_type : given_type.GetRawPointerType() )
		{
			return MatchTemplateArgument( names_scope, template_, raw_pointer_type_param.element_type, given_raw_pointer_type.element_type );
		}
	}
	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::FunctionTypeParam& function_type_param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &given_function_pointer_type : given_type.GetFunctionPointerType() )
		{
			var FunctionType& given_function_type= given_function_pointer_type.function_type;

			if( given_function_type.return_value_type != function_type_param.return_value_type ||
				given_function_type.is_unsafe != function_type_param.is_unsafe ||
				given_function_type.calling_convention != function_type_param.calling_convention )
			{
				return false;
			}

			if( !MatchTemplateArgument( names_scope, template_, function_type_param.return_type, given_function_type.return_type ) )
			{
				return false;
			}

			if( given_function_type.params.size() != function_type_param.params.size() )
			{
				return false;
			}

			for( auto mut i= 0s; i < function_type_param.params.size(); ++i )
			{
				auto& expected_param= function_type_param.params[i];
				auto& given_arg= given_function_type.params[i];

				if( expected_param.value_type != given_arg.value_type )
				{
					return false;
				}
				if( !MatchTemplateArgument( names_scope, template_, expected_param.t, given_arg.t ) )
				{
					return false;
				}
			}

			return true;
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::CoroutineTypeParam& coroutine_type_param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &class_type : given_type.GetClassType() )
		{
			if_var( &coroutine_type_description : class_type.lock_imut().deref().generated_class_data.get</ CoroutineTypeDescription />() )
			{
				return
					coroutine_type_description.kind == coroutine_type_param.kind &&
					coroutine_type_description.return_value_type == coroutine_type_param.return_value_type &&
					coroutine_type_description.inner_references == coroutine_type_param.inner_references &&
					coroutine_type_description.return_references == coroutine_type_param.return_references &&
					coroutine_type_description.return_inner_references == coroutine_type_param.return_inner_references &&
					coroutine_type_description.non_sync_ == coroutine_type_param.non_sync_ &&
					MatchTemplateArgument( names_scope, template_, coroutine_type_param.return_type, coroutine_type_description.return_type );
			}
		}
	}

	return false;
}

fn CodeBuilder::MatchTemplateArgumentImpl(
	mut this,
	NamesScopePtr& names_scope,
	TemplateBase& template_,
	TemplateSignatureParam::SpecializedTemplateParam& specialized_template_param,
	TemplateArgFinished& given_arg ) : bool
{
	if_var( &given_type : given_arg.get</Type/>() )
	{
		if_var( &class_type : given_type.GetClassType() )
		{
			if_var( &base_template : class_type.lock_imut().deref().generated_class_data.get</ ClassType::BaseTemplate />() )
			{
				auto mut is_one_of_templates= false;
				foreach( &type_template_ptr : specialized_template_param.type_templates_set.lock_imut().deref().type_templates )
				{
					if( base_template.class_template == type_template_ptr )
					{
						is_one_of_templates= true;
						break;
					}
				}

				if( !is_one_of_templates )
				{
					return false;
				}

				if( base_template.signature_args.size() != specialized_template_param.params.size() )
				{
					return false;
				}
				for( auto mut i= 0s; i < specialized_template_param.params.size(); ++i )
				{
					if( !MatchTemplateArgument( names_scope, template_, specialized_template_param.params[i], base_template.signature_args[i] ) )
					{
						return false;
					}
				}

				return true;
			}
		}
	}

	return false;
}

fn CodeBuilder::EvaluateTemplateArgs(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	Synt::TemplateArgs& template_args,
	SrcLoc& src_loc ) : TemplateArgsFinished
{
	var TemplateArgsFinished mut template_args_finished;
	foreach( &arg : template_args )
	{
		auto value= BuildExpressionCode( args_names_scope, function_context, arg );
		auto mut template_arg_opt= ValueToTemplateArg( args_names_scope, src_loc, value );
		if( !template_arg_opt.empty() )
		{
			template_args_finished.push_back( template_arg_opt.try_take() );
		}
	}

	return move(template_args_finished);
}

fn CodeBuilder::ValueToTemplateArg( NamesScopePtr& names_scope, SrcLoc& src_loc, Value& value ) : ust::optional</TemplateArgFinished/>
{
	if_var( &t : value.get</Type/>() )
	{
		return TemplateArgFinished(t);
	}

	if_var( &v_ptr : value.get</VariablePtr/>() )
	{
		with( &v : v_ptr.lock_imut().deref() )
		{
			if( !TypeIsValidForTemplateVariableArgument( v.t ) )
			{
				REPORT_ERROR( InvalidTypeOfTemplateVariableArgument, names_scope, src_loc, v.t )
				return ust::null_optional;
			}
			if( v.constexpr_value == LLVMValueRef::Null )
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, src_loc )
				return ust::null_optional;
			}
		}

		return TemplateArgFinished( v_ptr );
	}

	REPORT_ERROR( InvalidValueAsTemplateArgument, names_scope, src_loc, GetValueKindName(value) )
	return ust::null_optional;
}

fn CodeBuilder::FillKnownFunctionTemplateArgsIntoNamespace(
	mut this,
	FunctionTemplate& function_template,
	ust::array_view_imut</TemplateArgFinished/> known_template_args,
	NamesScopeMutPtr& target_namespace )
{
	auto mut lock= target_namespace.lock_mut();
	var NamesScope &mut target_namespace_ref= lock.deref();

	for( auto mut i= 0s; i < function_template.params.size(); ++i )
	{
		var ust::string8& param_name= function_template.params[i].name;

		var TemplateArg mut template_arg{ .index= u32(i) };

		if( i < known_template_args.size() )
		{
			if_var( &t : known_template_args[i].get</Type/>() )
			{
				template_arg.something= t;
			}
			else if_var( &v_ptr : known_template_args[i].get</VariablePtr/>() )
			{
				auto lock= v_ptr.lock_imut();
				var Variable& v= lock.deref();

				var Variable mut out_var
				{
					.t= v.t,
					.value_type= ValueType::ReferenceImut,
					.location= Variable::Location::Pointer,
					.llvm_value= AddGlobalConstantVariable( (param_name + "\0").range(), v.t.GetLLVMType(), v.constexpr_value ),
					.constexpr_value= v.constexpr_value,
					.name= param_name,
				};
				template_arg.something= VariablePtr( move(out_var) );
			}
			else { halt; }
		}
		target_namespace_ref.AddName( param_name, move(template_arg) );
	}
}

fn CodeBuilder::AddNewTemplateThing( mut this, TemplateKey mut key, NamesScopePtr mut thing )
{
	generated_template_things_.insert( key, move(thing) );
	generated_template_things_sequence_.push_back( move(key) );
}

fn CodeBuilder::TypeIsValidForTemplateVariableArgument( Type& t ) : bool
{
	if( !t.GetEnumType().empty() )
	{
		// All enums are valid.
		return true;
	}

	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		return
			IsInteger( fundamental_type.fundamental_type ) ||
			IsChar( fundamental_type.fundamental_type ) ||
			IsByte( fundamental_type.fundamental_type ) ||
			fundamental_type.fundamental_type == U_FundamentalType::bool_;
	}

	return false;
}

} // namespace U1
