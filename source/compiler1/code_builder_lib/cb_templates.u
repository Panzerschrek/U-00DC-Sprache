import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuiltTypeTemplatesSet( this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().get_ref().syntax_elements.empty() )
	{
		return;
	}

	auto mut type_templates_set_lock= type_templates_set_ptr.lock_mut();
	auto &mut type_templates_set= type_templates_set_lock.get_ref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto mut template_prepared= PrepareTypeTemplate( names_scope, type_templates_set.syntax_elements.back() );
		if( !template_prepared.empty() )
		{
			type_templates_set.type_templates.push_back( TypeTemplatePtr( template_prepared.get_ref() ) );
		}

		type_templates_set.syntax_elements.pop_back();
	}
	type_templates_set.syntax_elements.clear();
}

fn CodeBuilder::PrepareTypeTemplate(
	this,
	NamesScopePtr& names_scope,
	ust::shared_ptr_final</Synt::ClassTemplate/>& class_template_syntax_element ) : ust::optional</TypeTemplate/>
{
	var TypeTemplate mut type_template
	{
		.syntax_element= class_template_syntax_element,
		.parent_names_scope= names_scope,
	};

	// TODO - add some checks here

	return move(type_template);
}

fn CodeBuilder::GenTemplateType(
	mut this,
	NamesScopePtr& args_names_scope,
	FunctionContext &mut function_context,
	ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
	Synt::TemplateParameters& template_parameters ) : ust::optional</Type/>
{
	auto type_templates_set_lock= type_templates_set_ptr.lock_imut();
	var TypeTemplatesSet& type_templates_set= type_templates_set_lock.get_ref();
	if( type_templates_set.type_templates.size() != 1s )
	{
		return ust::optional</Type/>();
	}

	var TypeTemplate& type_template= type_templates_set.type_templates.front().get_ref();

	var Synt::ClassTemplate& syntax_element= type_template.syntax_element.get_ref();
	if( template_parameters.size() != syntax_element.signature_args.size() )
	{
		return ust::optional</Type/>();
	}

	var NamesScopePtr names_scope= ust::to_non_nullable( type_template.parent_names_scope.lock() ); // Parent namespace of type template
	var NamesScopeMutPtr result_names_scope( NamesScope( "_", names_scope ) ); // Where we place template arguments

	{
		auto mut result_names_scope_lock= result_names_scope.lock_mut();
		for( auto mut i= 0s; i < syntax_element.signature_args.size(); ++i )
		{
			// Should be simple name
			auto& name= syntax_element.signature_args[i].name.get</Synt::ComplexName/>().get_ref().name;

			var TemplateArg mut template_arg{ .index= i };
			result_names_scope_lock.get_ref().AddName( name, move(template_arg ) );
		}
	}

	auto mut all_ok= true;
	var TemplateArgsFinished mut result_signature_template_args;
	for( auto mut i= 0s; i < template_parameters.size(); ++i )
	{
		auto arg= BuildExpressionCode( args_names_scope, function_context, template_parameters[i] );
		all_ok|= MatchTemplateArgument( syntax_element.signature_args[i].name, arg, result_names_scope );

		if_var( &t : arg.get</Type/>() )
		{
			result_signature_template_args.push_back( t );
		}
		if_var( &v : arg.get</Variable/>() )
		{
			result_signature_template_args.push_back( v );
		}
	}

	if( !all_ok )
	{
		return ust::optional</Type/>();
	}

	auto template_key=
		ust::to_string8( ust::ref_to_int( type_template ) ) +
		MangleTemplateArgs( result_signature_template_args );

	if_var( prev_names_scope : generated_template_things_.find( template_key ) )
	{
		if_var( result_class_name : prev_names_scope.lock_imut().get_ref().GetThisScopeValue( syntax_element.class_.get_ref().name ) )
		{
			auto class_type= result_class_name.Get</ClassType/>();
			if( !class_type.empty() )
			{
				return Type( ust::to_non_nullable( class_type ) );
			}
		}
	}

	NamesScopeFill( result_names_scope, syntax_element.class_ );
	if_var( result_class_name : result_names_scope.lock_imut().get_ref().GetThisScopeValue( syntax_element.class_.get_ref().name ) )
	{
		auto class_type= result_class_name.Get</ClassType/>();
		if( !class_type.empty() )
		{
			generated_template_things_.insert( template_key, result_names_scope );
			return Type( ust::to_non_nullable( class_type ) );
		}
	}

	return ust::optional</Type/>();
}

fn CodeBuilder::MatchTemplateArgument(
	mut this,
	Synt::Expression& param,
	Value& given_arg,
	NamesScopePtr& names_scope ) : bool
{
	if_var( &complex_name : param.get</Synt::ComplexName/>() )
	{
		if( !complex_name.name.empty() && complex_name.tail.empty() )
		{
			if_var( result_name : names_scope.lock_imut().get_ref().GetThisScopeValue( complex_name.name ) )
			{
				auto template_arg_ptr= result_name.Get</TemplateArg/>();
				if( !template_arg_ptr.empty() )
				{
					auto mut template_arg_lock= template_arg_ptr.lock_mut();
					auto &mut template_arg= template_arg_lock.get_ref();
					if_var( &given_type : given_arg.get</Type/>() )
					{
						if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
						{
							template_arg.something= given_type;
							return true;
						}
					}
				}
			}
		}
	}

	return false;
}

} // namespace U
