import "/box.u"
import "/variant.u"
import "/vector.u"
import "lang_types.uh"
import "llvm.uh"

namespace U
{

struct FundamentalType
{
	U_FundamentalType fundamental_type= U_FundamentalType::InvalidType;
	LLVMTypeRef llvm_type= LLVMTypeRef::Null;

	fn constructor()= default;
	fn constructor( U_FundamentalType in_fundamental_type, LLVMTypeRef in_llvm_type );
}

struct FunctionType
{
	struct Arg
	{
		ust::box</Type/> arg_type; // HACK! prevent dependency because ust::vector requires complete type.
	}

	ust::vector</Arg/> args;
	ust::box</Type/> return_type; // HACK! prevent dependency loop

	LLVMTypeRef llvm_type= LLVMTypeRef::Null;

	fn constructor( mut this, FunctionType &imut other );
	op=( mut this, FunctionType &imut other );
}

class Type
{
public:
	fn constructor() = default;
	fn constructor( mut this, Type &imut other ) = default;
	op=( mut this, Type &imut other )= default;

	fn conversion_constructor( FundamentalType mut fundamental_type );
	fn conversion_constructor( FunctionType mut function_type );

	fn GetFundamentalType(  mut this ) : ust::optional_ref</FundamentalType, true  />'this';
	fn GetFundamentalType( imut this ) : ust::optional_ref</FundamentalType, false />'this';

	fn GetFunctionType(  mut this ) : ust::optional_ref</FunctionType, true  />'this';
	fn GetFunctionType( imut this ) : ust::optional_ref</FunctionType, false />'this';

	fn GetLLVMType( imut this ) : LLVMTypeRef;

private:
	ust::variant</ tup[
		FundamentalType,
		FunctionType
	] /> something_;
}

} // namespace U
