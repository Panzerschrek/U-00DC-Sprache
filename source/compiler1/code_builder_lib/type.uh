import "/box.u"
import "/variant.u"
import "/vector.u"
import "lang_types.uh"
import "llvm.uh"

namespace U
{

struct FundamentalType
{
	U_FundamentalType fundamental_type= U_FundamentalType::InvalidType;
	LLVMTypeRef llvm_type= LLVMTypeRef::Null;

	fn constructor()= default;
	fn constructor( U_FundamentalType in_fundamental_type, LLVMTypeRef in_llvm_type );

	op==( FundamentalType& l, FundamentalType& r ) : bool;
	op!=( FundamentalType& l, FundamentalType& r ) : bool;
}

struct ArrayType
{
	ust::box</Type/> element_type;
	u64 element_count= 0u64;
	LLVMTypeRef llvm_type= LLVMTypeRef::Null;

	fn constructor( mut this, ArrayType &imut other );
	op=( mut this, ArrayType &imut other );

	op==( ArrayType& l, ArrayType& r ) : bool;
	op!=( ArrayType& l, ArrayType& r ) : bool;
}

struct FunctionType
{
	struct Arg
	{
		ust::box</Type/> arg_type; // HACK! prevent dependency because ust::vector requires complete type.

		op==(Arg& l, Arg& r) : bool;
		op!=(Arg& l, Arg& r) : bool;
	}

	ust::vector</Arg/> args;
	ust::box</Type/> return_type; // HACK! prevent dependency loop

	LLVMTypeRef llvm_type= LLVMTypeRef::Null;

	fn constructor( mut this, FunctionType &imut other );
	op=( mut this, FunctionType &imut other );

	op==( FunctionType& l, FunctionType& r ) : bool;
	op!=( FunctionType& l, FunctionType& r ) : bool;
}

class Type
{
public:
	fn constructor() = default;
	fn constructor( mut this, Type &imut other ) = default;
	op=( mut this, Type &imut other )= default;

	fn conversion_constructor( FundamentalType mut fundamental_type );
	fn conversion_constructor( ArrayType mut array_type );
	fn conversion_constructor( FunctionType mut function_type );

	fn GetFundamentalType(  mut this ) : ust::optional_ref</FundamentalType, true  />'this';
	fn GetFundamentalType( imut this ) : ust::optional_ref</FundamentalType, false />'this';

	fn GetArrayType(  mut this ) : ust::optional_ref</ArrayType, true  />'this';
	fn GetArrayType( imut this ) : ust::optional_ref</ArrayType, false />'this';

	fn GetFunctionType(  mut this ) : ust::optional_ref</FunctionType, true  />'this';
	fn GetFunctionType( imut this ) : ust::optional_ref</FunctionType, false />'this';

	fn GetLLVMType( imut this ) : LLVMTypeRef;

	// Convert type name to human-readable format.
	fn ToString( this ) : ust::string8;

	op==( Type& l, Type& r ) : bool;
	op!=( Type& l, Type& r ) : bool;

private:
	ust::variant</ tup[
		FundamentalType,
		ArrayType,
		FunctionType
	] /> something_;
}

} // namespace U
