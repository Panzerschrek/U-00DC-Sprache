import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::TryGenerateDefaultConstructor( this, ClassTypePtr& class_type )
{
	auto class_members= class_type.lock_imut().get_ref().members;

	// Search for explicit default constructor.
	auto mut have_explicit_noncopy_constructors= false;
	if_var( & constructors_value : class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ) )
	{
		auto constructors_ptr= constructors_value.Get</NamesScopeFunctionsSet/>();
		foreach( &constructor_ : constructors_ptr.lock_imut().get_ref().functions_set.functions )
		{
			if( constructor_.t.GetFunctionType().get_ref().args.size() == 1s )
			{
				auto mut class_lock= class_type.lock_mut();
				class_lock.get_ref().is_default_constructible= true;
				return;
			}
			// TODO - check if copy constructor
			else
			{
				// Generation of default constructor disabled because class have explicit noncopy constructors.
				have_explicit_noncopy_constructors= true;
			}
		}
	}

	if( have_explicit_noncopy_constructors )
	{
		return;
	}

	// Check if all fields is default-constructible.
	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( !field_ptr.empty() )
		{
			if( !field_ptr.lock_imut().get_ref().t.IsDefaultConstructible() )
			{
				return;
			}
		}
	}

	// All ok - set default constructible flag.
	{
		auto mut class_lock= class_type.lock_mut();
		class_lock.get_ref().is_default_constructible= true;
	}

	// Prepare function type.
	var FunctionType mut function_type
	{
		.return_type( void_type_for_ret_ ),
		.return_value_is_mutable= false,
		.return_value_is_reference= false,
	};
	{
		var FunctionType::Arg mut this_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= true,
		};
		function_type.args.push_back( move(this_arg) );
	}

	unsafe
	{
		function_type.llvm_type=
			LLVMFunctionType(
				fundamental_llvm_types_.void_for_ret_,
				LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
				1u,
				LLVMBool::False );
	}

	// Prepare function variable.
	var FunctionVariable mut function_variable
	{
		.is_this_call= true,
		.is_generated= true,
		.t= function_type,
	};

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction(
					class_members.lock_imut().get_ref(),
					KeywordToString( Keyword::constructor_ ),
					function_variable.t.GetFunctionType().get_ref() ).front(),
				function_variable.t.GetLLVMType() );
	}

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		function_variable.llvm_function,
		function_type.return_type.get_ref(),
		function_type.return_value_is_reference,
		function_type.return_value_is_mutable );

	var NamesScopeVariable mut this_variable
	{
		.t= class_type,
		.is_mutable= true,
	};

	auto mut this_llvm_value= LLVMValueRef::Null;
	unsafe{  this_llvm_value= LLVMGetParam( function_variable.llvm_function, 0u );  }

	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( !field_ptr.empty() )
		{
			auto field_lock= field_ptr.lock_imut();
			var ClassField & class_field= field_lock.get_ref();

			var NamesScopeVariable mut field_variable
			{
				.t= class_field.t,
				.is_mutable= true,
			};

			auto op_name_nt= "." + member.key() + "\0";
			unsafe
			{
				var [ LLVMValueRef, 2 ] indexes
				[
					GetZeroGEPIndex(),
					LLVMConstInt( fundamental_llvm_types_.u32_, u64(class_field.index), LLVMBool::False )
				];

				field_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, this_llvm_value, indexes[0], 2u, op_name_nt.front() );
			}

			BuildEmptyInitializer( class_members, function_context, field_variable, member.key(), FilePos( /* TODO - set correct file_pos */ ) );
		}
	}

	// Finsih function - add remaining instructions
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	// Insert result variable
	if_var( & constructors_value : class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ) )
	{
		auto constructors_ptr= constructors_value.Get</NamesScopeFunctionsSet/>();
		auto mut constructors_lock= constructors_ptr.lock_mut();
		constructors_lock.get_ref().functions_set.functions.push_back( take(function_variable) );
		return;
	}

	var NamesScopeFunctionsSet mut new_functions_set;
	new_functions_set.functions_set.functions.push_back( move(function_variable) );

	// TODO Modifying names scope may be unsafe.
	// Maybe always create empty constructors value while filling names scope?
	auto mut members_lock= class_members.lock_mut();
	members_lock.get_ref().AddName( KeywordToString( Keyword::constructor_ ), NamesScopeValue( move(new_functions_set) ) );
}

} // namespace U
