import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::TryGenerateDefaultConstructor( mut this, ClassTypePtr& class_type )
{
	auto class_members= class_type.lock_imut().get_ref().members;

	// Search for explicit default constructor.
	auto mut have_explicit_noncopy_constructors= false;

	// Constructors value should always exists and should always be NamesScopeFunctionsSet.
	auto constructors_ptr= class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).get_ref().Get</NamesScopeFunctionsSet/>();
	foreach( &constructor_ : constructors_ptr.lock_imut().get_ref().functions_set.functions )
	{
		auto& function_type= constructor_.t;
		if( function_type.args.size() == 1s )
		{
			auto mut class_lock= class_type.lock_mut();
			class_lock.get_ref().is_default_constructible= !constructor_.is_deleted;
			return;
		}
		else if(
			function_type.args.size() == 2s &&
			function_type.args.back().is_reference &&
			!function_type.args.back().is_mutable &&
			function_type.args.back().arg_type.get_ref() == class_type ) // Copy constructor
		{}
		else
		{
			// Generation of default constructor disabled because class have explicit noncopy constructors.
			have_explicit_noncopy_constructors= true;
		}
	}

	if( have_explicit_noncopy_constructors )
	{
		return;
	}

	// Check if all fields is default-constructible.
	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}

		auto field_lock= field_ptr.lock_imut();
		auto& field= field_lock.get_ref();
		if( field.is_reference || !field.t.IsDefaultConstructible() )
		{
			return;
		}
	}

	auto base_class= class_type.lock_imut().get_ref().base_class;
	if( !base_class.empty() && !base_class.lock_imut().get_ref().is_default_constructible )
	{
		return;
	}

	// All ok - set default constructible flag.
	{
		auto mut class_lock= class_type.lock_mut();
		class_lock.get_ref().is_default_constructible= true;
	}

	// Prepare function type.
	var FunctionType mut function_type
	{
		.return_type( void_type_for_ret_ ),
		.return_value_is_mutable= false,
		.return_value_is_reference= false,
	};
	{
		var FunctionType::Arg mut this_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= true,
		};
		function_type.args.push_back( move(this_arg) );
	}

	unsafe
	{
		function_type.llvm_type=
			LLVMFunctionType(
				fundamental_llvm_types_.void_for_ret_,
				LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
				1u,
				LLVMBool::False );
	}

	// Prepare function variable.
	var FunctionVariable mut function_variable
	{
		.is_this_call= true,
		.is_generated= true,
		.t= function_type,
	};

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction(
					class_members.lock_imut().get_ref(),
					KeywordToString( Keyword::constructor_ ),
					function_variable.t ).front(),
				function_variable.t.llvm_type );
	}

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		function_variable.llvm_function,
		function_type.return_type.get_ref(),
		function_type.return_value_is_reference,
		function_type.return_value_is_mutable );

	auto mut this_llvm_value= LLVMValueRef::Null;
	unsafe{  this_llvm_value= LLVMGetParam( function_variable.llvm_function, 0u );  }

	if( !base_class.empty() )
	{
		var NamesScopeVariable base_variable
		{
			.t= ust::to_non_nullable(base_class),
			.is_mutable= true,
			.llvm_value= CreateBaseClassFieldGEP( this_llvm_value, function_context ),
		};

		BuildEmptyInitializer( class_members, function_context, base_variable, KeywordToString( Keyword::base_ ), FilePos( /* TODO - set correct file_pos */ ) );
	}

	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}

		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error

		var NamesScopeVariable field_variable
		{
			.t= class_field.t,
			.is_mutable= true,
			.llvm_value= CreateFieldGEP( this_llvm_value, class_field, function_context )
		};

		BuildEmptyInitializer( class_members, function_context, field_variable, member.key(), FilePos( /* TODO - set correct file_pos */ ) );
	}

	SetupVirtualTablePointers( this_llvm_value, class_type, function_context );

	// Finish function - add remaining instructions.
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	// Insert result variable
	auto mut constructors_lock= constructors_ptr.lock_mut();
	constructors_lock.get_ref().functions_set.functions.push_back( move(function_variable) );
}

fn CodeBuilder::TryGenerateCopyConstructor( mut this, ClassTypePtr& class_type )
{
	auto class_members= class_type.lock_imut().get_ref().members;

	// Constructors value should always exists and should always be NamesScopeFunctionsSet.
	auto constructors_ptr= class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).get_ref().Get</NamesScopeFunctionsSet/>();

	// Search for copy constructor.
	foreach( &constructor_ : constructors_ptr.lock_imut().get_ref().functions_set.functions )
	{
		auto& function_type= constructor_.t;
		if(
			function_type.args.size() == 2s &&
			function_type.args.back().is_reference &&
			!function_type.args.back().is_mutable &&
			function_type.args.back().arg_type.get_ref() == class_type ) // Copy constructor
		{
			auto mut class_lock= class_type.lock_mut();
			class_lock.get_ref().is_copy_constructible= !constructor_.is_deleted;
			return;
		}
	}

	// Check if all fields is copy-constructible.
	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}

		auto field_lock= field_ptr.lock_imut();
		auto& field= field_lock.get_ref();
		if( !field.is_reference && !field.t.IsCopyConstructible() )
		{
			return;
		}
	}

	auto base_class= class_type.lock_imut().get_ref().base_class;
	if( !base_class.empty() && !base_class.lock_imut().get_ref().is_copy_constructible )
	{
		return;
	}

	// All ok - set copy constructible flag.
	{
		auto mut class_lock= class_type.lock_mut();
		class_lock.get_ref().is_copy_constructible= true;
	}

	// Prepare function type.
	var FunctionType mut function_type
	{
		.return_type( void_type_for_ret_ ),
		.return_value_is_mutable= false,
		.return_value_is_reference= false,
	};
	{
		var FunctionType::Arg mut dst_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= true,
		};
		var FunctionType::Arg mut src_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= false,
		};
		function_type.args.push_back( move(dst_arg) );
		function_type.args.push_back( move(src_arg) );
	}

	unsafe
	{
		var[ LLVMTypeRef, 2 ] args_llvm_types
		[
			LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
			LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
		];

		function_type.llvm_type=
			LLVMFunctionType(
				fundamental_llvm_types_.void_for_ret_,
				args_llvm_types[0],
				2u,
				LLVMBool::False );
	}

	// Prepare function variable.
	var FunctionVariable mut function_variable
	{
		.is_this_call= true,
		.is_generated= true,
		.t= function_type,
	};

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction(
					class_members.lock_imut().get_ref(),
					KeywordToString( Keyword::constructor_ ),
					function_variable.t ).front(),
				function_variable.t.llvm_type );
	}

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		function_variable.llvm_function,
		function_type.return_type.get_ref(),
		function_type.return_value_is_reference,
		function_type.return_value_is_mutable );

	var LLVMValueRef mut dst_llvm_value= zero_init, mut src_llvm_value= zero_init;
	unsafe
	{
		dst_llvm_value= LLVMGetParam( function_variable.llvm_function, 0u );
		src_llvm_value= LLVMGetParam( function_variable.llvm_function, 1u );
	}

	auto file_pos= class_type.lock_imut().get_ref().syntax_element.get_ref().file_pos;

	if( !base_class.empty() )
	{
		auto dst_member_value= CreateBaseClassFieldGEP( dst_llvm_value, function_context );
		auto src_member_value= CreateBaseClassFieldGEP( src_llvm_value, function_context );

		BuildCopyConstructorPart( class_members, function_context, dst_member_value, src_member_value, ust::to_non_nullable(base_class), file_pos );
	}

	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error

		auto dst_member_value= CreateFieldGEP( dst_llvm_value, class_field, function_context );
		auto src_member_value= CreateFieldGEP( src_llvm_value, class_field, function_context );

		if( class_field.is_reference )
		{
			unsafe
			{
				LLVMBuildStore(
					function_context.llvm_ir_builder,
					LLVMBuildLoad( function_context.llvm_ir_builder, src_member_value, "\0"[0] ),
					dst_member_value );
			}
		}
		else
		{
			BuildCopyConstructorPart( class_members, function_context, dst_member_value, src_member_value, class_field.t, file_pos );
		}
	}

	SetupVirtualTablePointers( dst_llvm_value, class_type, function_context );

	// Finish function - add remaining instructions
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	// Insert result variable
	auto mut constructors_lock= constructors_ptr.lock_mut();
	constructors_lock.get_ref().functions_set.functions.push_back( move(function_variable) );
}

fn CodeBuilder::TryGenerateCopyAssignmentOperator( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().get_ref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	auto& class_members= class_members_lock.get_ref();

	// Assignment operators value should always exists and should always be NamesScopeFunctionsSet.
	auto operators_ptr= class_members.GetThisScopeValue( OverloadedOperatorToString( OverloadedOperator::Assign ) ).get_ref().Get</NamesScopeFunctionsSet/>();

	// Search for copy assignment operator.
	foreach( &operator : operators_ptr.lock_imut().get_ref().functions_set.functions )
	{
		auto& function_type= operator.t;
		if(
			function_type.args.size() == 2s &&
			function_type.args.front().is_reference &&  function_type.args.front().is_mutable && function_type.args.front().arg_type.get_ref() == class_type &&
			function_type.args.back ().is_reference && !function_type.args.back ().is_mutable && function_type.args.back ().arg_type.get_ref() == class_type )
		{
			auto mut class_lock= class_type.lock_mut();
			class_lock.get_ref().is_copy_assignable= !operator.is_deleted;
			return;
		}
	}

	// Check if all fields is copy-assignable.
	foreach( &member : class_members.GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}

		auto field_lock= field_ptr.lock_imut();
		auto& field= field_lock.get_ref();
		if( field.is_reference || !field.is_mutable || !field.t.IsCopyAssignable() )
		{
			return;
		}
	}

	auto base_class= class_type.lock_imut().get_ref().base_class;
	if( !base_class.empty() && !base_class.lock_imut().get_ref().is_copy_assignable )
	{
		return;
	}

	// All ok - set copy assignable flag.
	{
		auto mut class_lock= class_type.lock_mut();
		class_lock.get_ref().is_copy_assignable= true;
	}

	// Prepare function type.
	var FunctionType mut function_type
	{
		.return_type( void_type_for_ret_ ),
		.return_value_is_mutable= false,
		.return_value_is_reference= false,
	};
	{
		var FunctionType::Arg mut dst_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= true,
		};
		var FunctionType::Arg mut src_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= false,
		};
		function_type.args.push_back( move(dst_arg) );
		function_type.args.push_back( move(src_arg) );
	}

	unsafe
	{
		var[ LLVMTypeRef, 2 ] args_llvm_types
		[
			LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
			LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
		];

		function_type.llvm_type=
			LLVMFunctionType(
				fundamental_llvm_types_.void_for_ret_,
				args_llvm_types[0],
				2u,
				LLVMBool::False );
	}

	// Prepare function variable.
	var FunctionVariable mut function_variable
	{
		.is_this_call= true,
		.is_generated= true,
		.t= function_type,
	};

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction(
					class_members,
					OverloadedOperatorToString( OverloadedOperator::Assign ),
					function_variable.t ).front(),
				function_variable.t.llvm_type);
	}

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		function_variable.llvm_function,
		function_type.return_type.get_ref(),
		function_type.return_value_is_reference,
		function_type.return_value_is_mutable );

	var LLVMValueRef mut dst_llvm_value= zero_init, mut src_llvm_value= zero_init;
	unsafe
	{
		dst_llvm_value= LLVMGetParam( function_variable.llvm_function, 0u );
		src_llvm_value= LLVMGetParam( function_variable.llvm_function, 1u );
	}

	auto file_pos= class_type.lock_imut().get_ref().syntax_element.get_ref().file_pos;

	if( !base_class.empty() )
	{		
		auto dst_member_value= CreateBaseClassFieldGEP( dst_llvm_value, function_context );
		auto src_member_value= CreateBaseClassFieldGEP( src_llvm_value, function_context );

		BuildCopyAssignmentOperatorPart( class_members_ptr, function_context, dst_member_value, src_member_value, ust::to_non_nullable(base_class), file_pos );
	}

	foreach( &member : class_members.GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error

		auto dst_member_value= CreateFieldGEP( dst_llvm_value, class_field, function_context );
		auto src_member_value= CreateFieldGEP( src_llvm_value, class_field, function_context );

		BuildCopyAssignmentOperatorPart( class_members_ptr, function_context, dst_member_value, src_member_value, class_field.t, file_pos );
	}

	// Finish function - add remaining instructions.
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	// Insert result variable
	auto mut operators_lock= operators_ptr.lock_mut();
	operators_lock.get_ref().functions_set.functions.push_back( move(function_variable) );
}

fn CodeBuilder::TryGenerateDestructor( this, ClassTypePtr& class_type )
{
	auto class_members= class_type.lock_imut().get_ref().members;

	// Destructors value should always exists and should always be NamesScopeFunctionsSet.
	auto destructors_ptr= class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::destructor_ ) ).get_ref().Get</NamesScopeFunctionsSet/>();
	if( !destructors_ptr.lock_imut().get_ref().functions_set.functions.empty() )
	{
		return; // user already specified destructor.
	}

	// Prepare function type.
	var FunctionType mut function_type
	{
		.return_type( void_type_for_ret_ ),
		.return_value_is_mutable= false,
		.return_value_is_reference= false,
	};
	{
		var FunctionType::Arg mut this_arg
		{
			.arg_type( Type( class_type ) ),
			.is_reference= true,
			.is_mutable= true,
		};
		function_type.args.push_back( move(this_arg) );
	}

	unsafe
	{
		function_type.llvm_type=
			LLVMFunctionType(
				fundamental_llvm_types_.void_for_ret_,
				LLVMPointerType( class_type.lock_imut().get_ref().llvm_type, 0u ),
				1u,
				LLVMBool::False );
	}

	// Prepare function variable.
	var FunctionVariable mut function_variable
	{
		.is_this_call= true,
		.is_generated= true,
		.t= function_type,
	};

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction(
					class_members.lock_imut().get_ref(),
					KeywordToString( Keyword::destructor_ ),
					function_variable.t ).front(),
				function_variable.t.llvm_type );
	}

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		function_variable.llvm_function,
		function_type.return_type.get_ref(),
		function_type.return_value_is_reference,
		function_type.return_value_is_mutable );

	auto mut this_llvm_value= LLVMValueRef::Null;
	unsafe{  this_llvm_value= LLVMGetParam( function_variable.llvm_function, 0u );  }

	BuildMembersDestructors( function_context, this_llvm_value, class_type );

	// Finish function - add remaining instructions.
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	// Insert result variable
	auto mut destructors_lock= destructors_ptr.lock_mut();
	destructors_lock.get_ref().functions_set.functions.push_back( move(function_variable) );
}

fn CodeBuilder::BuildCopyConstructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, FilePos& file_pos )
{
	if( !t.GetFundamentalType().empty() || !t.GetEnumType().empty() || !t.GetFunctionPointerType().empty() )
	{
		unsafe
		{
			if( LLVMTypeOf( dst ) == LLVMTypeOf( src ) )
			{
				// two pointers - do load-store
				auto mut value= LLVMBuildLoad( function_context.llvm_ir_builder, src, "\0"[0] );
				LLVMBuildStore( function_context.llvm_ir_builder, value, dst );
			}
			else if( LLVMTypeOf( dst ) == LLVMPointerType( LLVMTypeOf( src ), 0u ) )
			{
				// pointer and value in llvm register - do simple store
				LLVMBuildStore( function_context.llvm_ir_builder, src, dst );
			}
			else{ halt; }
		}
		return;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		CB_GENERATE_LOOP(
			function_context,
			array_type.element_count,
			{
				var LLVMValueRef mut dst_element_value= zero_init, mut src_element_value= zero_init;

				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes[ GetZeroGEPIndex(), counter_value ];
					dst_element_value= LLVMBuildGEP( function_context.llvm_ir_builder, dst, indexes[0], 2u, "[]\0"[0] );
					src_element_value= LLVMBuildGEP( function_context.llvm_ir_builder, src, indexes[0], 2u, "[]\0"[0] );
				}

				BuildCopyConstructorPart( names_scope, function_context, dst_element_value, src_element_value, array_type.element_type.get_ref(), file_pos );
			}
		)
		return;
	}
	if_var( &class_type : t.GetClassType() )
	{
		if( !class_type.lock_imut().get_ref().is_copy_constructible )
		{
			// TODO - maybe generate error here?
			return;
		}

		// Constructors value should always exists and should always be NamesScopeFunctionsSet.
		auto constructors_ptr= class_type.lock_imut().get_ref().members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).get_ref().Get</NamesScopeFunctionsSet/>();

		// Search for copy constructor.
		foreach( &constructor_ : constructors_ptr.lock_imut().get_ref().functions_set.functions )
		{
			auto& function_type= constructor_.t;
			if( function_type.args.size() == 2s &&
				function_type.args.back().is_reference &&
				!function_type.args.back().is_mutable &&
				function_type.args.back().arg_type.get_ref() == class_type ) // Copy constructor
			{
				// SPRACHE_TODO - maybe disallow unsafe copy constructors?
				if( function_type.is_unsafe && !function_context.is_in_unsafe_block )
				{
					REPORT_ERROR( UnsafeFunctionCallOutsideUnsafeBlock, names_scope, file_pos )
				}

				// Call it.
				unsafe
				{
					var[ LLVMValueRef, 2 ] llvm_args[ dst, src ];
					LLVMBuildCall( function_context.llvm_ir_builder, constructor_.llvm_function, llvm_args[0], 2u, "\0"[0] );
				}
				break;
			}
		}
		return;
	}

	halt; // Unhandled type kind
}

fn CodeBuilder::BuildCopyAssignmentOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, FilePos& file_pos )
{
	if( !t.GetFundamentalType().empty() || !t.GetEnumType().empty() || !t.GetFunctionPointerType().empty() )
	{
		unsafe
		{
			if( LLVMTypeOf( dst ) == LLVMTypeOf( src ) )
			{
				// two pointers - do load-store
				auto mut value= LLVMBuildLoad( function_context.llvm_ir_builder, src, "\0"[0] );
				LLVMBuildStore( function_context.llvm_ir_builder, value, dst );
			}
			else if( LLVMTypeOf( dst ) == LLVMPointerType( LLVMTypeOf( src ), 0u ) )
			{
				// pointer and value in llvm register - do simple store
				LLVMBuildStore( function_context.llvm_ir_builder, src, dst );
			}
			else{ halt; }
		}
		return;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		CB_GENERATE_LOOP(
			function_context,
			array_type.element_count,
			{
				var LLVMValueRef mut dst_element_value= zero_init, mut src_element_value= zero_init;

				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes[ GetZeroGEPIndex(), counter_value ];
					dst_element_value= LLVMBuildGEP( function_context.llvm_ir_builder, dst, indexes[0], 2u, "[]\0"[0] );
					src_element_value= LLVMBuildGEP( function_context.llvm_ir_builder, src, indexes[0], 2u, "[]\0"[0] );
				}

				BuildCopyAssignmentOperatorPart( names_scope, function_context, dst_element_value, src_element_value, array_type.element_type.get_ref(), file_pos );
			}
		)
		return;
	}
	if_var( &class_type : t.GetClassType() )
	{
		if( !class_type.lock_imut().get_ref().is_copy_assignable )
		{
			// TODO - maybe generate error here?
			return;
		}

		// Assignment operators value should always exists and should always be NamesScopeFunctionsSet.
		auto operators_ptr= class_type.lock_imut().get_ref().members.lock_imut().get_ref().GetThisScopeValue( OverloadedOperatorToString( OverloadedOperator::Assign ) ).get_ref().Get</NamesScopeFunctionsSet/>();

		// Search for copy assignment operator.
		foreach( &operator_ : operators_ptr.lock_imut().get_ref().functions_set.functions )
		{
			auto& function_type= operator_.t;
			if(
				function_type.args.size() == 2s &&
				function_type.args.front().is_reference &&  function_type.args.front().is_mutable && function_type.args.front().arg_type.get_ref() == class_type &&
				function_type.args.back ().is_reference && !function_type.args.back ().is_mutable && function_type.args.back ().arg_type.get_ref() == class_type )
			{
				// SPRACHE_TODO - maybe disallow unsafe copy assignment operators?
				if( function_type.is_unsafe && !function_context.is_in_unsafe_block )
				{
					REPORT_ERROR( UnsafeFunctionCallOutsideUnsafeBlock, names_scope, file_pos )
				}

				// Call it.
				unsafe
				{
					var[ LLVMValueRef, 2 ] llvm_args[ dst, src ];
					LLVMBuildCall( function_context.llvm_ir_builder, operator_.llvm_function, llvm_args[0], 2u, "\0"[0] );
				}
				break;
			}
		}
		return;
	}

	halt; // Unhandled type kind
}

fn CodeBuilder::BuildDestructorPart( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef value, Type& t, FilePos& file_pos )
{
	if_var( &array_type : t.GetArrayType() )
	{
		CB_GENERATE_LOOP(
			function_context,
			array_type.element_count,
			{
				auto mut element_value= LLVMValueRef::Null;

				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes[ GetZeroGEPIndex(), counter_value ];
					element_value= LLVMBuildGEP( function_context.llvm_ir_builder, value, indexes[0], 2u, "[]\0"[0] );
				}

				BuildDestructorPart( names_scope, function_context, element_value, array_type.element_type.get_ref(), file_pos );
			}
		)
	}
	if_var( &class_type : t.GetClassType() )
	{
		// Destructors value should always exists and should always be NamesScopeFunctionsSet.
		auto destructors_ptr= class_type.lock_imut().get_ref().members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::destructor_ ) ).get_ref().Get</NamesScopeFunctionsSet/>();

		// Destructors set should contain exactly one function.
		auto destructors_lock= destructors_ptr.lock_imut();
		auto& destructor_= destructors_lock.get_ref().functions_set.functions.front();

		// SPRACHE_TODO - maybe disallow unsafe destructors?
		if( destructor_.t.is_unsafe && !function_context.is_in_unsafe_block )
		{
			REPORT_ERROR( UnsafeFunctionCallOutsideUnsafeBlock, names_scope, file_pos )
		}

		// Call it.
		unsafe
		{
			LLVMBuildCall( function_context.llvm_ir_builder, destructor_.llvm_function, value, 1u, "\0"[0] );
		}
	}
}

fn CodeBuilder::BuildMembersDestructors( this, FunctionContext &mut function_context, LLVMValueRef value, ClassTypePtr& class_type )
{
	auto class_members= class_type.lock_imut().get_ref().members;
	auto file_pos= class_type.lock_imut().get_ref().syntax_element.get_ref().file_pos;

	foreach( &parent : class_type.lock_imut().get_ref().parents )
	{
		auto mut parent_llvm_value= LLVMValueRef::Null;
		unsafe
		{
			var [ LLVMValueRef, 2 ] indexes
			[
				GetZeroGEPIndex(),
				LLVMConstInt( fundamental_llvm_types_.u32_, u64(parent.field_number), LLVMBool::False )
			];

			parent_llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, value, indexes[0], 2u, "\0"[0] );
		}

		BuildDestructorPart( class_members, function_context, parent_llvm_value, parent.class_, file_pos );
	}

	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			continue;
		}

		auto field_lock= field_ptr.lock_imut();
		var ClassField& class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error
		if( class_field.is_reference ) { continue; }

		auto field_llvm_value= CreateFieldGEP( value, class_field, function_context );

		BuildDestructorPart( class_members, function_context, field_llvm_value, class_field.t, file_pos ); // TODO - maybe use field file_pos instead?
	}
}

} // namespace U
