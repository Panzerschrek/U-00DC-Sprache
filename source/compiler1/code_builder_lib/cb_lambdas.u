import "/assert.u"
import "/sort.u"
import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::BuildLambda( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Lambda& lambda_ ) : Value
{
	var ClassTypePtr lambda_class= PrepareLambdaClass( names_scope, function_context, lambda_ );

	var Variable mut result_value
	{
		.t= lambda_class,
		.value_type= ValueType::Value,
		.location= Variable::Location::Pointer,
		.name= "value of " + Type(lambda_class).ToString(),
	};

	if( !function_context.is_functionless_context )
	{
		result_value.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, result_value.t.GetLLVMType(), g_null_string ) );
		CreateLifetimeStart( function_context, result_value.llvm_value );
	}

	var VariablePtr result= move(result_value).CreatePtr();
	function_context.references_graph.AddNode( result );

	var ust::vector</LLVMValueRef/> mut constexpr_initializers;
	with( &class_type : lambda_class.lock_imut().deref() )
	{
		if( class_type.can_be_constexpr )
		{
			constexpr_initializers.resize( class_type.fields_order.size(), LLVMValueRef::Null );
		}
	}
	var size_type mut num_constexpr_initializers= 0s;

	with( &class_type : lambda_class.lock_imut().deref() )
	{
		foreach( &capture : class_type.generated_class_data.get</ LambdaClassData />().try_deref().captures )
		{
			if_var( &lookup_result : LookupName( names_scope, function_context, capture.captured_variable_name, lambda_.src_loc ) )
			{
				auto variable_nullable= lookup_result[1].Get</Variable/>();
				if( !variable_nullable.empty() )
				{
					var VariablePtr variable= variable_nullable.try_to_non_nullable();
					with( &field : capture.field.lock_imut().deref() )
					{
						auto field_value= CreateClassFieldGEP( function_context, lambda_class, result.lock_imut().deref().llvm_value, field );
						if( field.is_reference )
						{
							// TODO
						}
						else
						{
							if( !field.t.IsCopyConstructible() )
							{
								REPORT_ERROR( CopyConstructValueOfNoncopyableType, names_scope, lambda_.src_loc, field.t )
							}
							else if( !function_context.is_functionless_context )
							{
								BuildCopyConstructorPart( names_scope, function_context, field_value, variable.lock_imut().deref().llvm_value, field.t, lambda_.src_loc );
							}
							// TODO - link references
						}
					}
				}
			}
		}

		if( class_type.can_be_constexpr && num_constexpr_initializers == constexpr_initializers.size() )
		{
			with ( mut lock : result.lock_mut() )
			{
				lock.deref().constexpr_value= unsafe( LLVMConstNamedStruct( class_type.llvm_type, constexpr_initializers.data(), u32(constexpr_initializers.size()) ) );
			}
		}
	}

	RegisterTemporaryVariable( function_context, result );
	return result;
}

fn CodeBuilder::PrepareLambdaClass( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Lambda& lambda_ ) : ClassTypePtr
{
	var NamesScopePtr parent_scope= GetClosestNamedSpaceOrRoot( names_scope );
	var LambdaKey key{ .parent_scope= parent_scope, .src_loc= lambda_.src_loc };

	// TODO - fill tuple indices.

	if_var( &existing_class : lambda_classes_table_.find( key ) )
	{
		return existing_class;
	}

	var NamesScopeMutPtr class_members( NamesScope( "_TODO - lambda name", parent_scope ) );
	var ClassType mut class_type
	{
		.members= class_members,
		.members_initial= class_members,
		.kind= ClassType::Kind::Struct, // Set temporary to struct in order to allow generation of some methods.
		.parents_list_prepared= true,
		.have_explicit_noncopy_constructors= false,
		.is_default_constructible= false,
		.can_be_constexpr= true, // Set later.
		.generated_class_data= LambdaClassData()
	};

	var ClassTypePtr class_type_ptr( move(class_type) );
	lambda_classes_table_.insert( key, class_type_ptr );

	with( mut members_lock : class_members.lock_mut() )
	{
		var NamesScope &mut members= members_lock.deref();

		// Create functions set for constructors/destructors/assignment operators. It's needed for later methods generation.
		// TODO - what about user-specified non-public constructors and assignment operators?
		var FunctionsSet functions_set{ .class_= class_type_ptr };
		members.AddName( KeywordToString( Keyword::constructor_ ), functions_set );
		members.AddName( KeywordToString( Keyword::destructor_  ), functions_set );
		members.AddName( OverloadedOperatorToString( OverloadedOperator::Assign ), functions_set );

		// Add special member to names scope to identify it as class names scope
		members.SetClass( class_type_ptr );

		// Allow accessing private members of class for all it's inner namespaces.
		members.AddAccessRightsFor( class_type_ptr, Synt::ClassVisibility::Private );
	}

	with( mangled_name : mangler_.deref().MangleType( class_type_ptr ) )
	{
		with( mut class_lock : class_type_ptr.lock_mut() )
		{
			class_lock.deref().llvm_type= unsafe( LLVMStructCreateNamed( llvm_context_, mangled_name.front() ) );
		}
	}

	auto lambda_this_value_type= ValueType::ReferenceImut; // TODO - allow to change it.

	var FunctionType::ParamReferences mut return_references;
	var ust::vector</  FunctionType::ParamReferences /> mut return_inner_references;

	// Run preprocessing.
	{
		var LambdaPreprocessingContext mut lambda_preprocessing_context
		{
			.parent= function_context.lambda_preprocessing_context,
			.external_variables= CollectCurrentFunctionVariables( function_context ),
			.lambda_this_value_type= lambda_this_value_type,
			.capture_by_value= !lambda_.capture.get</Synt::Lambda::CaptureAllByValue/>().empty()
		};

		if( !lambda_.capture.get</Synt::Lambda::CaptureNothing/>().empty() )
		{
			lambda_preprocessing_context.allowed_for_capture_variables= LambdaPreprocessingContext::AllowedForCaptureVariables();
		}
		else if(
			!lambda_.capture.get</Synt::Lambda::CaptureAllByValue/>().empty() ||
			!lambda_.capture.get</Synt::Lambda::CaptureAllByReference/>().empty() )
		{
			lambda_preprocessing_context.allowed_for_capture_variables= ust::null_optional;
		}
		else { halt; }

		var ust::shared_ptr_mut</LambdaPreprocessingContext/> lambda_preprocessing_context_ptr( move(lambda_preprocessing_context) );

		{
			var FunctionVariable mut function_variable
			{
				.body_syntax_element= lambda_.function,
				.llvm_function( LazyLLVMFunction( "\0" /* The name of temporary function is irrelevant. */ ) ),
				// It's fine to use incomplete lambda class here, since this class can't be accessed.
				.t= PrepareLambdaCallOperatorType( class_members, function_context, lambda_.function.deref().function_type, class_type_ptr, lambda_this_value_type ),
				.is_this_call= true,
			};

			BuildFuncCode( names_scope, function_variable, lambda_preprocessing_context_ptr );

			// Remove temp function.
			unsafe( LLVMDeleteFunction( function_variable.llvm_function.lock_imut().deref().function ) );
		}

		auto mut lock= lambda_preprocessing_context_ptr.lock_mut();
		var LambdaPreprocessingContext &mut lambda_preprocessing_context_result= lock.deref();

		// Extract captured variables and sort them to ensure stable order.
		var ust::vector</ CapturedVariableForSorting /> mut captured_variables;
		foreach( &captured_variable_pair : lambda_preprocessing_context_result.captured_external_variables )
		{
			auto capture_by_reference= !lambda_.capture.get</Synt::Lambda::CaptureAllByReference/>().empty();
			auto llvm_type= captured_variable_pair.value().source_variable.lock_imut().deref().t.GetLLVMType();

			var CapturedVariableForSorting mut v
			{
				.name= captured_variable_pair.key(),
				.data= captured_variable_pair.value(),
				.capture_by_reference= capture_by_reference,
				.alignment( unsafe( LLVMABIAlignmentOfType( data_layout_, select( capture_by_reference ? LLVMPointerType( llvm_type, 0u ) : llvm_type ) ) ) )
			};

			captured_variables.push_back( move(v) );
		}

		// We must sort fields in order to avoid creating fields list in hash-map iteration order (which is non-deterministic).
		// There should be no equal elements here, because this can prevent sorting to be stable.
		ust::sort( captured_variables.range() );

		with( mut class_lock : class_type_ptr.lock_mut() )
		{
			var ClassType &mut class_type= class_lock.deref();

			var ust::shared_ptr_final</ Synt::ClassField /> dummy_syntax_element( Synt::ClassField() );

			// Iterate over sorted captured variables, create fields for them, setup reference notation.
			foreach( &captured_variable : captured_variables )
			{
				var ClassField mut field
				{
					.source_class= class_type_ptr,
					.syntax_element= dummy_syntax_element,
					.t= captured_variable.data.source_variable.lock_imut().deref().t,
					.is_reference= captured_variable.capture_by_reference,
					.is_mutable= true, // Set later.
					.index= u32( class_type.fields_order.size() ),
				};

				if( captured_variable.capture_by_reference )
				{
					// TODO
				}
				else
				{
					// TODO - setup references.
				}

				var ClassFieldPtr mut field_ptr( move(field) );
				class_type.fields_order.push_back( ust::make_tuple( captured_variable.name, move(field_ptr) ) );
				class_type.SetMemberVisibility( captured_variable.name, Synt::ClassVisibility::Private );
			}

			with( mut members_lock : class_members.lock_mut() )
			{
				foreach( &field_pair : class_type.fields_order )
				{
					members_lock.deref().AddName( field_pair[0], field_pair[1] );
				}
			}

			with( &mut captures : class_type.generated_class_data.get</ LambdaClassData />().try_deref().captures )
			{
				foreach( &field_pair : class_type.fields_order )
				{
					var LambdaClassData::Capture mut capture
					{
						.captured_variable_name= field_pair[0],
						.field= field_pair[1],
					};
					captures.push_back( move(capture) );
				}
			}
		}

		// Prepare return references.
		return_references= take( lambda_preprocessing_context_result.return_references );
		NormalizeParamReferencesList( return_references );

		// Prepare return inner references.
		return_inner_references= take( lambda_preprocessing_context_result.return_inner_references );
		foreach( &mut list : return_inner_references )
		{
			NormalizeParamReferencesList( list );
		}
	}

	// Set LLVM struct type body.
	with( mut class_lock : class_type_ptr.lock_mut() )
	{
		var ClassType &mut class_type= class_lock.deref();

		var ust::vector</LLVMTypeRef/> mut fields_llvm_types;
		foreach( &field_pair : class_type.fields_order )
		{
			with( &field : field_pair[1].lock_imut().deref() )
			{
				var LLVMTypeRef llvm_type= field.t.GetLLVMType();
				fields_llvm_types.push_back( select( field.is_reference ? unsafe( LLVMPointerType( llvm_type, 0u ) ) : llvm_type ) );
			}
		}
		unsafe( LLVMStructSetBody( class_type.llvm_type, fields_llvm_types.data(), u32( fields_llvm_types.size() ), LLVMBool::False ) );

		class_type.is_complete= true;
	}

	// Try to generate important methods.
	TryGenerateCopyConstructor( class_type_ptr );
	TryGenerateCopyAssignmentOperator( class_type_ptr );
	TryGenerateDestructorPrototype( class_type_ptr );
	TryGenerateDestructor( class_type_ptr );
	// Equality compare operator is not needed for lambdas.

	with( mut class_lock : class_type_ptr.lock_mut() )
	{
		var ClassType &mut class_type= class_lock.deref();

		// Set to class after methods generation.
		class_type.kind= ClassType::Kind::NonPolymorph;

		// Calculate constexpr property.
		class_type.can_be_constexpr= true;
		foreach( &field_pair : class_type.fields_order )
		{
			with( &field : field_pair[1].lock_imut().deref() )
			{
				if( !field.t.CanBeConstexpr() || ( field.is_reference && field.is_mutable ) )
				{
					class_type.can_be_constexpr= false;
					break;
				}
			}
		}
	}

	// Create () operator.
	{
		var ust::string_view8 call_op_name= OverloadedOperatorToString( OverloadedOperator::Call );

		auto mut function_type= PrepareLambdaCallOperatorType( class_members, function_context, lambda_.function.deref().function_type, class_type_ptr, lambda_this_value_type );
		function_type.return_references= move(return_references);
		function_type.return_inner_references= move(return_inner_references);

		var FunctionVariable mut function_variable
		{
			.body_syntax_element= lambda_.function,
			.llvm_function( LazyLLVMFunction( mangler_.deref().MangleFunction( class_members.lock_imut().deref(), call_op_name, function_type ) ) ),
			.t= move(function_type),
			.is_this_call= true,
			.constexpr_kind= FunctionVariable::ConstexprKind::ConstexprAuto,
		};

		BuildFuncCode( names_scope, function_variable );

		var FunctionsSet mut functions_set;
		functions_set.functions.push_back( move(function_variable) );

		with( mut members_lock : class_members.lock_mut() )
		{
			members_lock.deref().AddName( call_op_name, NamesScopeValue( move(functions_set) ) );
		}
	}

	return class_type_ptr;
}

fn CodeBuilder::CollectCurrentFunctionVariables( FunctionContext &mut function_context ) : ust::unordered_set</VariablePtr/>
{
	var ust::unordered_set</VariablePtr/> mut result;
	foreach( &variables_frame : function_context.variables_frames )
	{
		foreach( &variable : variables_frame )
		{
			result.insert( variable );
		}
	}
	return move(result);
}

fn CodeBuilder::PrepareLambdaCallOperatorType(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	Synt::FunctionType& lambda_function_type,
	ClassTypePtr& lambda_class_type,
	ValueType lambda_this_value_type ) : FunctionType
{
	var FunctionType mut res
	{
		.return_type(
			select(
				lambda_function_type.return_type.empty()
					? Type( void_type_ )
					: PrepareType( names_scope, function_context, lambda_function_type.return_type.try_deref() ) ) ),
		.return_value_type= ValueType::Value,
		.is_unsafe= lambda_function_type.is_unsafe,
		.calling_convention= GetLLVMCallingConvention( lambda_function_type.calling_convention, names_scope, lambda_function_type.src_loc ),
	};

	if( lambda_function_type.return_value_reference_modifier == Synt::ReferenceModifier::Reference )
	{
		res.return_value_type= select( lambda_function_type.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );
	}

	// First param is always "this" of the lambda type.
	debug_assert( !lambda_function_type.params.empty() );
	var FunctionType::Param mut this_param
	{
		.t= lambda_class_type,
		.value_type= lambda_this_value_type,
	};
	res.params.push_back( move(this_param) );

	auto mut params_except_first= lambda_function_type.params.range();
	params_except_first.drop_front();

	foreach( &param : params_except_first )
	{
		if( IsKeyword( param.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope, param.src_loc )
		}

		var FunctionType::Param mut out_param
		{
			.t= PrepareType( names_scope, function_context, param.t ),
			.value_type= ValueType::Value,
		};

		if( param.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			out_param.value_type= select( param.mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );
		}

		res.params.push_back( move(out_param) );
	}

	return move(res);
}

fn CodeBuilder::LambdaPreprocessingAccessExternalVariable( mut this, FunctionContext &mut function_context, VariablePtr& variable, ust::string8& name ) : VariablePtr
{
	auto mut lock= function_context.lambda_preprocessing_context.try_lock_mut();
	var LambdaPreprocessingContext &mut lambda_preprocessing_context= lock.deref();

	debug_assert( lambda_preprocessing_context.external_variables.exists( variable ) );

	auto var_lock= variable.lock_imut();
	var Variable& v= var_lock.deref();

	var size_type reference_tag_count( v.t.ReferenceTagCount() );

	if( lambda_preprocessing_context.captured_external_variables.find( name ).empty() )
	{
		// Do not set "constexpr" values - make "constexpr" captured variables non-constexpr in lambdas.

		var Variable mut variable_node_value
		{
			.t= v.t,
			.value_type= ValueType::Value,
			.location= Variable::Location::Pointer,
			.name= v.name + " lambda copy",
			.llvm_value= v.llvm_value,
		};

		var ValueType mut value_type= ValueType::ReferenceImut;
		if( lambda_preprocessing_context.capture_by_value )
		{
			// If a variable is captured by value and lambda "this" is immutable captured variable can't be modified.
			if( lambda_preprocessing_context.lambda_this_value_type == ValueType::ReferenceImut )
			{
				value_type= ValueType::ReferenceImut;
			}
			else
			{
				value_type= ValueType::ReferenceMut;
			}
		}
		else
		{
			// While capturing by reference capture mutable values as mutable references, immutable values as immutable references.
			value_type= v.value_type;
		}

		var Variable mut reference_node_value
		{
			.t= v.t,
			.value_type= value_type,
			.location= Variable::Location::Pointer,
			.name= v.name + " lambda copy ref",
			.llvm_value= v.llvm_value,
		};

		var ust::vector</VariablePtr/> mut accessible_variables;
		for( auto mut i= 0s; i < reference_tag_count; ++i )
		{
			var ust::string8 mut name= "referenced variable ";
			name+= ust::to_string8(i);
			name+= " of captured lambda variable ";
			name+= v.name;

			var Variable mut accessible_variable
			{
				.t= invalid_type_,
				.value_type= ValueType::Value,
				.location= Variable::Location::Pointer,
				.name= move(name),
			};
			accessible_variables.push_back( move(accessible_variable).CreatePtr() );
		}

		var LambdaPreprocessingContext::CapturedVariableData mut captured_variable
		{
			.source_variable= variable,
			.variable_node= move(variable_node_value).CreatePtr(),
			.reference_node= move(reference_node_value).CreatePtr(),
			.accessible_variables= move(accessible_variables),
		};
		lambda_preprocessing_context.captured_external_variables.insert( name, move(captured_variable) );
	}

	var LambdaPreprocessingContext::CapturedVariableData mut captured_variable= lambda_preprocessing_context.captured_external_variables[name];

	function_context.references_graph.AddNodeIfNotExists( captured_variable.variable_node );
	function_context.references_graph.AddNodeIfNotExists( captured_variable.reference_node );
	function_context.references_graph.AddLink( captured_variable.variable_node, captured_variable.reference_node );

	for( auto mut i= 0s; i < reference_tag_count; ++i )
	{
		function_context.references_graph.AddNodeIfNotExists( captured_variable.accessible_variables[i] );

		function_context.references_graph.AddLink(
			captured_variable.accessible_variables[i],
			captured_variable.variable_node.lock_imut().deref().inner_reference_nodes[i] );

		function_context.references_graph.AddLink(
			captured_variable.variable_node.lock_imut().deref().inner_reference_nodes[i],
			captured_variable.reference_node.lock_imut().deref().inner_reference_nodes[i] );
	}

	return captured_variable.reference_node;
}

struct CapturedVariableForSorting
{
	ust::string8 name;
	LambdaPreprocessingContext::CapturedVariableData data;
	u64 alignment;
	bool capture_by_reference;

	op<=>( CapturedVariableForSorting& l, CapturedVariableForSorting& r ) : i32
	{
		// Sort in alignment descending order (to minimize padding).
		if( l.alignment != r.alignment )
		{
			return r.alignment <=> l.alignment;
		}
		// If alignment is the same - use name for ordering (it should be unique).
		return l.name <=> r.name;
	}
}

} // namespace U1
