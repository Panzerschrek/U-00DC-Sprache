import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

?macro <? GLOBALS_LOOP_DETECT:block ?value : expr ?>
->
<?
	if( DetectGlobalsLoop( ?value ) ){ return; }
	var GlobalThingHolder ??holder( global_things_stack_ptr_, ?value );
?>

namespace U1
{

class GlobalThingHolder
{
public:
	fn constructor( GlobalThingsStackPtr mut stack, NamesScopeValue mut value )
		( stack_(move(stack)) )
	{
		auto mut lock= stack_.lock_mut();
		lock.deref().push_back( move(value) );
	}

	fn destructor()
	{
		auto mut lock= stack_.lock_mut();
		lock.deref().drop_back();
	}

private:
	GlobalThingsStackPtr imut stack_;
}

fn GlobalValueToString( NamesScopeValue& global_thing ) : ust::string8
{
	{
		auto functions_set_ptr= global_thing.Get</FunctionsSet/>();
		if( !functions_set_ptr.empty() )
		{
			auto lock= functions_set_ptr.try_lock_imut();
			var FunctionsSet& functions_set= lock.deref();

			if( !functions_set.syntax_elements.empty() )
			{
				return functions_set.syntax_elements.front().deref().name.back();
			}
			if( !functions_set.out_of_line_syntax_elements.empty() )
			{
				return functions_set.out_of_line_syntax_elements.front().deref().name.back();
			}
			if( !functions_set.function_templates_syntax_elements.empty() )
			{
				return functions_set.function_templates_syntax_elements.front().deref().name;
			}

			foreach( &function : functions_set.functions )
			{
				if_var( &el : function.prototype_syntax_element )
				{
					return el.name.back();
				}
				if_var( &el : function.body_syntax_element )
				{
					return el.name.back();
				}
			}

			if( !functions_set.function_templates.empty() )
			{
				return functions_set.function_templates.front().lock_imut().deref().syntax_element.deref().name;
			}
		}
	}
	{
		auto class_type_ptr= global_thing.Get</ClassType/>();
		if( !class_type_ptr.empty() )
		{
			return Type( class_type_ptr.try_to_non_nullable() ).ToString();
		}
	}
	{
		auto enum_type_ptr= global_thing.Get</Enum/>();
		if( !enum_type_ptr.empty() )
		{
			return Type( enum_type_ptr.try_to_non_nullable() ).ToString();
		}
	}
	{
		auto type_alias_ptr= global_thing.Get</Enum/>();
		if( !type_alias_ptr.empty() )
		{
			return type_alias_ptr.try_lock_imut().deref().syntax_element.deref().name;
		}
	}
	{
		auto type_templates_set_ptr= global_thing.Get</TypeTemplatesSet/>();
		if( !type_templates_set_ptr.empty() )
		{
			auto lock= type_templates_set_ptr.try_lock_imut();
			var TypeTemplatesSet& type_templates_set= lock.deref();

			if( !type_templates_set.syntax_elements.empty() )
			{
				return type_templates_set.syntax_elements.front().deref().name;
			}
			if( !type_templates_set.type_templates.empty() )
			{
				return type_templates_set.type_templates.front().lock_imut().deref().syntax_element.deref().name;
			}
		}
	}
	{
		auto global_variable_ptr= global_thing.Get</GlobalVariable/>();
		if( !global_variable_ptr.empty() )
		{
			auto lock= global_variable_ptr.try_lock_imut();
			var GlobalVariable& global_variable= lock.deref();
			return global_variable.syntax_element.deref().variables[ size_type(global_variable.variable_index) ].name;
		}
	}
	{
		auto global_auto_variable_ptr= global_thing.Get</GlobalAutoVariable/>();
		if( !global_auto_variable_ptr.empty() )
		{
			return global_auto_variable_ptr.try_lock_imut().deref().syntax_element.deref().name;
		}
	}

	return "";
}

fn AddAncestorsAccessRights_r( NamesScope &mut dst_class_members, ClassTypePtr& ancestor_class )
{
	dst_class_members.AddAccessRightsFor( ancestor_class, Synt::ClassVisibility::Protected );
	foreach( &parent : ancestor_class.lock_imut().deref().parents )
	{
		AddAncestorsAccessRights_r( dst_class_members, parent.class_ );
	}
}

fn CodeBuilder::DetectGlobalsLoop( this, NamesScopeValue& global_thing ) : bool
{
	auto lock= global_things_stack_ptr_.lock_imut();
	var GlobalThingsStack& stack= lock.deref();

	auto mut i= 0s;
	while( i < stack.size() && stack[i] != global_thing ){ ++i; }

	if( i == stack.size() )
	{
		return false; // No loop detected
	}

	var ust::string8 mut description;
	for( ; i < stack.size(); ++i )
	{
		description+= GlobalValueToString(stack[i]);
		description+= " -> ";
	}
	description+= GlobalValueToString(global_thing);

	auto mut errors_container_lock= root_errors_container_.try_lock_mut();

	errors_container_lock.deref().push_back(
		ReportError( CodeBuilderErrorCode::GlobalsLoopDetected, GetValueSrcLoc(global_thing), description ) );

	return true;
}

fn CodeBuilder::BuildFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/> functions_set_ptr, bool build_body )
{
	if( !build_body )
	{
		{ // First, lock as imut and check if complete.
			auto l= functions_set_ptr.lock_imut();
			var FunctionsSet& functions_set= l.deref();
			if( functions_set.syntax_elements.empty() &&
				functions_set.out_of_line_syntax_elements.empty() &&
				functions_set.function_templates_syntax_elements.empty() ) // Already complete
			{
				return;
			}
		}
	}

	GLOBALS_LOOP_DETECT( functions_set_ptr )

	// Take copy, and make manipulations only with it. Update value inside shareed pointer in one operation.
	var FunctionsSet mut functions_set= functions_set_ptr.lock_imut().deref();

	// Preapare functions set itself.
	while( !functions_set.syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.syntax_elements.back();
		auto class_type_ptr= functions_set.class_;
		PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set, false );
		functions_set.syntax_elements.drop_back();
	}
	while( !functions_set.out_of_line_syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.out_of_line_syntax_elements.back();
		auto class_type_ptr= functions_set.class_;
		PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set, true );
		functions_set.out_of_line_syntax_elements.drop_back();
	}
	while( !functions_set.function_templates_syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.function_templates_syntax_elements.back();
		auto function_template= PrepareFunctionTemplate( names_scope_ptr, syntax_element_ptr, functions_set.class_ );
		functions_set.function_templates.push_back( function_template );
		functions_set.function_templates_syntax_elements.drop_back();
	}

	// Update functions set after prepareation process.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref()= functions_set;
	}

	var bool is_class_method= !functions_set.class_.empty();
	foreach( &mut func_variable : functions_set.functions )
	{
		// Immediately build body of "constexpr" functions.
		if( !func_variable.is_inherited )
		{
			if( build_body ||
				( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::NonConstexpr && !is_class_method ) )
			{
				BuildFuncCode( names_scope_ptr, func_variable );
			}
		}
	}

	// Update functions set again after body build process.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref()= move(functions_set);
	}
}

fn CodeBuilder::PrepareClassParentsList( mut this, ClassTypePtr& class_type )
{
	if( class_type.lock_imut().deref().parents_list_prepared )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( class_type )

	var ust::vector</ClassType::Parent/> mut parents;

	auto syntax_element_ptr= class_type.lock_imut().deref().syntax_element;
	if( !syntax_element_ptr.empty() )
	{
		auto& syntax_element= syntax_element_ptr.try_deref();

		var NamesScopeMutPtr class_members= class_type.lock_imut().deref().members;
		var NamesScopePtr names_scope_ptr= class_members.lock_imut().deref().GetParent().try_to_non_nullable();

		auto mut global_function_context= CreateGlobalFunctionContext();

		foreach( &parent_name : syntax_element.parents )
		{
			auto parent_type= PrepareType( names_scope_ptr, global_function_context, parent_name );
			if( parent_type.GetClassType().empty() )
			{
				REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.src_loc, parent_type )
				continue;
			}

			var ClassTypePtr parent_class= parent_type.GetClassType().try_deref();

			auto mut duplicated= false;
			foreach( &prev_parent : parents )
			{
				duplicated|= prev_parent.class_ == parent_class;
			}
			if( duplicated )
			{
				REPORT_ERROR( DuplicatedParentClass, names_scope_ptr, syntax_element.src_loc, parent_type )
				continue;
			}

			{ // Give access from this class to protected members of all ancestor classes.
				auto mut members_lock= class_members.lock_mut();
				AddAncestorsAccessRights_r( members_lock.deref(), parent_class );
			}

			var ClassType::Parent mut parent{ .class_= parent_class };
			parents.push_back( move(parent) );
		}
	}

	auto mut lock= class_type.lock_mut();
	var ClassType& mut class_= lock.deref();
	class_.parents_list_prepared= true;
	class_.parents= move(parents);
}

fn CodeBuilder::BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type )
{
	if( class_type.lock_imut().deref().is_complete )
	{
		return;
	}
	with( mut lock : class_type.lock_imut() )
	{
		auto mut description_opt= lock.deref().generated_class_data.get</ TypeinfoClassDescription />();
		if( !description_opt.empty() )
		{
			var Type t= description_opt.try_deref().source_type;
			move(description_opt);
			move(lock);
			BuildFullTypeinfo( t );
			return;
		}
	}
	if( class_type.lock_imut().deref().syntax_element.empty() )
	{
		return;
	}

	PrepareClassParentsList( class_type );

	GLOBALS_LOOP_DETECT( class_type )

	auto syntax_element_ptr= class_type.lock_imut().deref().syntax_element;
	auto& syntax_element= syntax_element_ptr.try_deref();

	auto mut global_function_context= CreateGlobalFunctionContext();

	// Perform remaining check of parents.
	{
		auto parents= class_type.lock_imut().deref().parents;

		var ust::shared_ptr_nullable_mut</ClassType/> mut base_class;
		foreach( &parent : parents )
		{
			var ClassTypePtr& parent_class= parent.class_;
			var Type parent_type= parent_class;

			if( !EnsureTypeComplete( parent_class ) )
			{
				REPORT_ERROR( UsingIncompleteType, names_scope_ptr, syntax_element.src_loc, parent_type )
				return;
			}

			auto parent_kind= parent_class.lock_imut().deref().kind;
			if( !( parent_kind == ClassType::Kind::Abstract || parent_kind == ClassType::Kind::Interface || parent_kind == ClassType::Kind::PolymorphNonFinal ) )
			{
				REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.src_loc, parent_type )
				return;
			}

			if( parent_kind != ClassType::Kind::Interface ) // not interface=base
			{
				if( !base_class.empty() )
				{
					REPORT_ERROR( DuplicatedBaseClass, names_scope_ptr, syntax_element.src_loc, parent_type )
					return;
				}
				base_class= parent_class;
			}
		}

		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.deref();
		class_.base_class= move(base_class);
	}

	// Pre-mark class as polymorph, because it's needed for functions checks. Exact kind of class we will known later.
	with( mut lock : class_type.lock_mut() )
	{
		auto &mut class_= lock.deref();

		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
			!syntax_element.parents.empty() )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else
		{
			class_.kind= ClassType::Kind::NonPolymorph;
		}
	}

	// Prepare fields types.
	auto class_members= class_type.lock_imut().deref().members;
	auto mut field_count= 0u;
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto field_ptr= member.value().Get</ ClassField />();
		if( !field_ptr.empty() )
		{
			++field_count;

			auto mut field_lock= field_ptr.try_lock_mut();
			var ClassField &mut field= field_lock.deref();

			field.t= PrepareType( class_members, global_function_context, field.syntax_element.deref().t );

			if( !EnsureTypeComplete( field.t ) )
			{
				REPORT_ERROR( UsingIncompleteType, class_members, field.syntax_element.deref().src_loc, field.t )
				field.t= invalid_type_;
				continue;
			}
			if( !field.is_reference && field.t.IsAbstract() )
			{
				REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope_ptr, field.syntax_element.deref().src_loc, field.t )
				continue;
			}
			if( field.is_reference && field.t.ReferenceTagCount() > 0u )
			{
				REPORT_ERROR( ReferenceFieldOfTypeWithReferencesInside, names_scope_ptr, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
				field.t= invalid_type_;
				continue;
			}
		}
	}

	// Allocate virtual table pointer, if class have no parents.
	// If class have at least one parent, reuse it's virtual table pointer.
	auto allocate_virtual_table_pointer= syntax_element.parents.empty() && (
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface );

	// Determine class data layout.
	var ust::vector</ LLVMTypeRef /> mut fields_llvm_types;

	if( allocate_virtual_table_pointer )
	{
		fields_llvm_types.push_back( unsafe( LLVMPointerType( fundamental_llvm_types_.int_ptr, 0u ) ) );// set exact type later.
	}

	with( mut lock : class_type.lock_mut() )
	{
		// Make base class first field. Add parent classes fields.
		auto &mut class_= lock.deref();

		auto base_class= class_.base_class;
		if( !base_class.empty() )
		{
			fields_llvm_types.push_back( base_class.try_lock_imut().deref().llvm_type );
		}

		foreach( &mut parent : class_.parents )
		{
			if( parent.class_ != base_class )
			{
				parent.field_number= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( parent.class_.lock_imut().deref().llvm_type );
			}
			else
			{
				parent.field_number= 0u;
			}
		}
	}
	{
		var ust::vector</ ust::shared_ptr_mut</ClassField/> /> mut fields_left;
		foreach( &member : class_members.lock_imut().deref() )
		{
			auto field_ptr= member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				fields_left.push_back( field_ptr.try_to_non_nullable() );
			}
		}

		// Calculate start offset, include parents fields, virtual table pointer.
		var u32 mut current_offset= 0u;
		foreach( llvm_type : fields_llvm_types )
		{
			unsafe
			{
				var u32 alignment= LLVMABIAlignmentOfType( data_layout_, llvm_type );
				var u32 padding= ( alignment - current_offset % alignment ) % alignment;
				current_offset+= padding;
				current_offset+= u32( LLVMABISizeOfType( data_layout_, llvm_type ) );
			}
		}

		var ust::vector</tup[ust::string8, ClassFieldPtr]/> mut fields_order;
		if( syntax_element.keep_fields_order )
		{
			// Sort fields by original index.
			// TODO - use libary sorting function.
			while( !fields_left.empty() )
			{
				var size_type mut min_index= ~0s;
				var size_type mut min_index_index= ~0s;
				for( auto mut i= 0s; i < fields_left.size(); ++i )
				{
					auto field_lock= fields_left[i].lock_imut();
					var ClassField& field= field_lock.deref();
					if( size_type(field.original_index) < min_index )
					{
						min_index= size_type(field.original_index);
						min_index_index= i;
					}
				}

				auto field_ptr= fields_left[min_index_index];

				if( min_index_index + 1s < fields_left.size() )
				{
					auto f= fields_left.back();
					fields_left[min_index_index]= f;
				}
				fields_left.pop_back();

				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				auto mut llvm_type= field.t.GetLLVMType();
				if( field.is_reference ) { llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) ); }

				field.index= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( llvm_type );
				fields_order.push_back( ust::make_tuple( field.syntax_element.deref().name, field_ptr ) );
			}
		}
		else
		{
			while( !fields_left.empty() )
			{
				// Find best fit field with minimal original index (try to keep original fields order).
				var u32 mut best_field_padding= ~0u;
				auto mut best_padding_field_index= 0s;
				for( auto mut i= 0s; i < fields_left.size(); ++i )
				{
					auto field_lock= fields_left[i].lock_imut();
					var ClassField& field= field_lock.deref();
					auto mut llvm_type= field.t.GetLLVMType();
					if( field.is_reference ) { llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) ); }

					unsafe
					{
						var u32 alignment= LLVMABIAlignmentOfType( data_layout_, llvm_type );
						var u32 padding= ( alignment - current_offset % alignment ) % alignment;
						if( padding < best_field_padding )
						{
							best_field_padding= padding;
							best_padding_field_index= i;
						}
						else if( padding == best_field_padding )
						{
							// Prefer first field with same padding.
							if( field.original_index < cast_imut(fields_left)[best_padding_field_index].lock_imut().deref().original_index )
							{
								best_padding_field_index= i;
							}
						}
					}
				}

				auto field_ptr= fields_left[best_padding_field_index];

				if( best_padding_field_index + 1s < fields_left.size() )
				{
					auto f= fields_left.back();
					fields_left[best_padding_field_index]= f;
				}
				fields_left.pop_back();

				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				auto mut llvm_type= field.t.GetLLVMType();
				if( field.is_reference ) { llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) ); }

				field.index= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( llvm_type );
				fields_order.push_back( ust::make_tuple( field.syntax_element.deref().name, field_ptr ) );

				unsafe
				{
					current_offset+= best_field_padding;
					current_offset+= u32( LLVMABISizeOfType( data_layout_, llvm_type ) );
				}
			}
		}

		auto mut lock= class_type.lock_mut();
		lock.deref().fields_order= move(fields_order);
	}

	// Setup inner reference kind. Do this before methods generation and virtual table preparation.
	{
		var ust::vector</ClassFieldPtr/> mut reference_fields;
		var ust::vector</ClassFieldPtr/> mut fields_with_references_inside;
		var ust::vector</ClassFieldPtr/> mut fields_with_no_references_inside_but_inner_references_notation;

		var bool mut has_parents_with_references_inside= false;
		var bool mut has_fields_with_reference_notation= false;

		with( mut lock : class_type.lock_mut() )
		{
			auto &mut class_= lock.deref();

			// Inherit inner references of parents.
			// Normally any reference may be inhhereted only from base, but not interfaces.
			class_.inner_references.clear();
			foreach( &parent : class_.parents )
			{
				with( &parent_class : parent.class_.lock_imut().deref() )
				{
					auto s= ust::max( class_.inner_references.size(), parent_class.inner_references.size() );
					class_.inner_references.resize( s, InnerReferenceKind::Imut );
					for( auto mut i= 0s; i < parent_class.inner_references.size(); ++i )
					{
						auto& mut t= class_.inner_references[i];
						t= ust::max( t, parent_class.inner_references[i] );
					}
				}
			}
			has_parents_with_references_inside= !class_.inner_references.empty();

			// Collect fields for which reference notation is required.
			foreach( &field_pair : class_.fields_order )
			{
				auto& field_ptr= field_pair[1];
				auto field_lock= field_ptr.lock_imut();
				var ClassField& field= field_lock.deref();

				if( field.is_reference )
				{
					reference_fields.push_back( field_ptr );
				}

				if( field.t.ReferenceTagCount() > 0u )
				{
					fields_with_references_inside.push_back( field_ptr );
				}
				else
				{
					fields_with_no_references_inside_but_inner_references_notation.push_back( field_ptr );
				}

				has_fields_with_reference_notation |=
					field.syntax_element.deref().reference_tag_expression.get</Synt::EmptyVariant/>().empty() ||
					field.syntax_element.deref().inner_reference_tags_expression.get</Synt::EmptyVariant/>().empty();
			}
		}

		foreach( & field_ptr : fields_with_no_references_inside_but_inner_references_notation )
		{
			auto field_lock= field_ptr.lock_imut();
			var ClassField& field= field_lock.deref();

			if( field.syntax_element.deref().inner_reference_tags_expression.get</Synt::EmptyVariant/>().empty() )
			{
				if_var( &reference_tags : EvaluateReferenceFieldInnerTags( class_members, field.syntax_element.deref().inner_reference_tags_expression ) )
				{
					if( !reference_tags.empty() )
					{
						REPORT_ERROR( InnerReferenceTagCountMismatch,class_members, field.syntax_element.deref().src_loc, 0, reference_tags.size() )
					}
				}
			}
		}

		if( reference_fields.size() == 1s && fields_with_references_inside.size() == 0s && !has_fields_with_reference_notation && !has_parents_with_references_inside )
		{
			// Special case - class contains single reference field.
			auto mut field_lock= reference_fields.front().lock_mut();
			var ClassField &mut field= field_lock.deref();

			auto mut class_lock= class_type.lock_mut();
			var ClassType& mut class_= class_lock.deref();

			field.reference_tag= 0u8;
			if( class_.inner_references.empty() )
			{
				class_.inner_references.push_back( InnerReferenceKind::Imut );
			}
			auto &mut t= class_.inner_references[ size_type(field.reference_tag) ];
			t= ust::max( t, select( field.is_mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut ) );
		}
		else if( reference_fields.size() == 0s && fields_with_references_inside.size() == 1s && !has_fields_with_reference_notation && !has_parents_with_references_inside )
		{
			// Special case - class contains single field with references inside. Map reference tags of this field to reference tags of the whole class.
			auto mut field_lock= fields_with_references_inside.front().lock_mut();
			var ClassField &mut field= field_lock.deref();

			auto mut class_lock= class_type.lock_mut();
			var ClassType& mut class_= class_lock.deref();

			auto reference_tag_count= field.t.ReferenceTagCount();
			field.inner_reference_tags.resize( size_type(reference_tag_count), u8(0) );
			class_.inner_references.resize( size_type(reference_tag_count), InnerReferenceKind::Imut );
			for( auto mut i= 0s; i < size_type(reference_tag_count); ++i )
			{
				field.inner_reference_tags[i]= u8(i);
				class_.inner_references[i]= field.t.GetInnerReferenceKind(i);
			}
		}
		else
		{
			// General case - require reference notation.

			foreach( &field_ptr : reference_fields )
			{
				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				var ust::optional</u8/> mut reference_tag;
				if( field.syntax_element.deref().reference_tag_expression.get</Synt::EmptyVariant/>().empty() )
				{
					reference_tag= EvaluateReferenceFieldTag( class_members, field.syntax_element.deref().reference_tag_expression );
				}
				else
				{
					REPORT_ERROR( ExpectedReferenceNotation, class_members, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
				}

				auto mut class_lock= class_type.lock_mut();
				var ClassType& mut class_= class_lock.deref();

				if_var( tag : reference_tag )
				{
					field.reference_tag= tag;

					auto s= ust::max( size_type(tag) + 1s, class_.inner_references.size() );
					class_.inner_references.resize( s, InnerReferenceKind::Imut );

					auto &mut t= class_.inner_references[ size_type(tag) ];
					t= ust::max( t, select( field.is_mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut ) );
				}
				else
				{
					// Fallback for cases with no notation - link reference field with tag 0.
					field.reference_tag= 0u8;
					if( class_.inner_references.empty() )
					{
						class_.inner_references.push_back( InnerReferenceKind::Imut );
					}
					auto &mut t= class_.inner_references[ size_type(field.reference_tag) ];
					t= ust::max( t, select( field.is_mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut ) );
				}
			}

			foreach( &field_ptr : fields_with_references_inside )
			{
				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				var ust::optional</ust::vector</u8/>/> mut reference_tags;
				if( field.syntax_element.deref().inner_reference_tags_expression.get</Synt::EmptyVariant/>().empty() )
				{
					reference_tags= EvaluateReferenceFieldInnerTags( class_members, field.syntax_element.deref().inner_reference_tags_expression );
				}
				else
				{
					REPORT_ERROR( ExpectedReferenceNotation, class_members, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
				}

				auto mut class_lock= class_type.lock_mut();
				var ClassType& mut class_= class_lock.deref();

				auto reference_tag_count= field.t.ReferenceTagCount();

				if( !reference_tags.empty() )
				{
					field.inner_reference_tags= reference_tags.try_take();
					if( field.inner_reference_tags.size() != size_type(reference_tag_count) )
					{
						REPORT_ERROR( InnerReferenceTagCountMismatch,class_.members, field.syntax_element.deref().src_loc, reference_tag_count, field.inner_reference_tags.size() )
						field.inner_reference_tags.resize( size_type(reference_tag_count), 0u8 );
					}

					for( auto mut i= 0s; i < size_type(reference_tag_count); ++i )
					{
						auto tag= field.inner_reference_tags[i];
						auto s= ust::max( size_type(tag) + 1s, class_.inner_references.size() );
						class_.inner_references.resize( s, InnerReferenceKind::Imut );

						auto &mut t= class_.inner_references[ size_type(tag) ];
						t= ust::max( t, field.t.GetInnerReferenceKind( size_type(i) ) );
					}
				}
				else
				{
					// Fallback for cases with no notation - link all field tags with tag 0.
					field.inner_reference_tags.resize( size_type(reference_tag_count), u8(0) );
					if( class_.inner_references.empty() )
					{
						class_.inner_references.push_back( InnerReferenceKind::Imut );
					}
				}
			}
		}

		with( &class_ : class_type.lock_imut().deref() )
		{
			// Perform additional checks.
			var ust::vector</bool/> mut reference_tags_usage_flags;
			reference_tags_usage_flags.resize( class_.inner_references.size(), false );

			foreach( &parent : class_.parents )
			{
				for( var size_type mut i= 0s, s= parent.class_.lock_imut().deref().inner_references.size(); i < s; ++i )
				{
					reference_tags_usage_flags[i] = true;
				}
			}

			foreach( &field_pair : class_.fields_order )
			{
				auto& field_ptr= field_pair[1];
				auto field_lock= field_ptr.lock_imut();
				var ClassField& field= field_lock.deref();

				if( field.is_reference )
				{
					reference_tags_usage_flags[ size_type(field.reference_tag) ]= true;
					if(
						(  field.is_mutable && class_.inner_references[ size_type(field.reference_tag) ] == InnerReferenceKind::Imut ) ||
						( !field.is_mutable && class_.inner_references[ size_type(field.reference_tag) ] == InnerReferenceKind::Mut ) )
					{
						var ust::string8 mut s;
						s.push_back( char8( size_type( "a"c8 ) + size_type(field.reference_tag) ) );
						REPORT_ERROR( MixingMutableAndImmutableReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
					}
				}

				for( auto mut i= 0s; i < field.inner_reference_tags.size(); ++i )
				{
					auto tag= field.inner_reference_tags[i];
					reference_tags_usage_flags[ size_type(tag) ]= true;

					if( class_.inner_references[ size_type(tag) ] != field.t.GetInnerReferenceKind(i) )
					{
						var ust::string8 mut s;
						s.push_back( char8( size_type( "a"c8 ) + size_type(tag) ) );
						REPORT_ERROR( MixingMutableAndImmutableReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
					}
				}
			}

			for( auto mut i= 0s; i < class_.inner_references.size(); ++i )
			{
				if( !reference_tags_usage_flags[i] )
				{
					var ust::string8 mut s;
					s.push_back( char8( size_type( "a"c8 ) + i ) );
					REPORT_ERROR( UnusedReferenceTag, class_.members, syntax_element.src_loc, s )
				}
			}
		}
	}

	// Build declarations for some necessary methods.
	// Do it before generating methods, but after setting up inner references.
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto functions_set_ptr= member.value().Get</ FunctionsSet />();
		if( !functions_set_ptr.empty() )
		{
			auto& name= member.key();

			// We need to build special methods.
			var bool mut need_to_build=
				name == KeywordToString( Keyword::constructor_ ) ||
				name == KeywordToString( Keyword::destructor_ ) ||
				name == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
				name == OverloadedOperatorToString( OverloadedOperator::CompareEqual );

			if( !need_to_build )
			{
				// Functions declared virtual requires building in order to build virtual table later.
				with( &functions_set : functions_set_ptr.try_lock_imut().deref() )
				{
					foreach( &function_variable : functions_set.functions )
					{
						need_to_build|=
							!function_variable.prototype_syntax_element.empty() &&
							function_variable.prototype_syntax_element.try_deref().virtual_kind != Synt::Function::VirtualKind::None;
					}
					foreach( &synt_function : functions_set.syntax_elements )
					{
						need_to_build|= synt_function.deref().virtual_kind != Synt::Function::VirtualKind::None;
					}
				}
			}
			if( !need_to_build )
			{
				// Also we need to check parent for virtual functions.
				foreach( &parent : class_type.lock_imut().deref().parents )
				{
					if_var( &parent_member : parent.class_.lock_imut().deref().members.lock_imut().deref().GetThisScopeValue( name ) )
					{
						auto parent_functions_set= parent_member.Get</ FunctionsSet />();
						if( !parent_functions_set.empty() )
						{
							foreach( &parent_function : parent_functions_set.try_lock_imut().deref().functions )
							{
								need_to_build|= parent_function.virtual_table_index != ~0u;
							}
						}
					}
				}
			}

			if( need_to_build )
			{
				BuildFunctionsSet( class_members, functions_set_ptr.try_to_non_nullable(), false );
			}
		}
	}

	// Generate destructor prototype before perparing virtual table to mark it as virtual and setup virtual table index.
	TryGenerateDestructorPrototype( class_type );

	// Prepare virtual table.
	if( !syntax_element.parents.empty() ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
	{
		PrepareClassVirtualTable( class_type );
		PrepareClassVirtualTableType( class_type );
		if( allocate_virtual_table_pointer )
		{
			fields_llvm_types.front()= unsafe( LLVMPointerType( class_type.lock_imut().deref().virtual_table_llvm_type, 0u ) );
		}
	}

	with( mut lock : class_type.lock_mut() )
	{
		var ClassType &mut class_= lock.deref();

		unsafe
		{
			// Check opaque before set body for cases of errors (class body duplication).
			if( LLVMIsOpaqueStruct( class_.llvm_type ) == LLVMBool::True )
			{
				LLVMStructSetBody( class_.llvm_type, fields_llvm_types.data(), u32(fields_llvm_types.size()), LLVMBool::False );
			}
		}
	}

	// Setup class kind.
	with( mut lock : class_type.lock_mut() )
	{
		auto &mut class_= lock.deref();

		auto mut class_contains_pure_virtual_functions= false;
		foreach( &virtual_table_entry : class_.virtual_table )
		{
			class_contains_pure_virtual_functions|= virtual_table_entry.is_pure;
		}

		auto have_parents= class_.parents.empty();
		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Class )
		{
			class_.kind= select( have_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphNonFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Final )
		{
			class_.kind= select( have_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface )
		{
			if( !class_.base_class.empty() )
			{
				REPORT_ERROR( BaseClassForInterface, names_scope_ptr, syntax_element.src_loc )
			}
			if( field_count != 0u )
			{
				REPORT_ERROR( FieldsForInterfacesNotAllowed, names_scope_ptr, syntax_element.src_loc )
			}

			{
				// Constructors value should always exists and should always be FunctionsSet.
				auto constructors_ptr= class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).try_deref().Get</FunctionsSet/>();
				auto constructors_lock= constructors_ptr.try_lock_imut();
				auto& constructors= constructors_lock.deref();
				if( !constructors.functions.empty() || !constructors.function_templates.empty() )
				{
					REPORT_ERROR( ConstructorForInterface, names_scope_ptr, syntax_element.src_loc )
				}
			}
			foreach( &virtual_table_entry : class_.virtual_table )
			{
				if( !virtual_table_entry.is_pure && virtual_table_entry.name != KeywordToString( Keyword::destructor_ ) )
				{
					// TODO - report using function src_loc for each function.
					REPORT_ERROR( NonPureVirtualFunctionInInterface, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
					break;
				}
			}

			class_.kind= ClassType::Kind::Interface;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
		{
			class_.kind= ClassType::Kind::Abstract;
		}
		else{ halt; }
	}

	with( mut lock : class_type.lock_mut() )
	{ // Setup "constexpr" property. Do this before methods generation.
		auto &mut class_= lock.deref();

		class_.can_be_constexpr= class_.kind == ClassType::Kind::Struct;

		foreach( &member : class_members.lock_imut().deref() )
		{
			auto field_ptr= member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				auto field_lock= field_ptr.try_lock_imut();
				auto& field= field_lock.deref();
				// Disable constexpr, if field type can not be constexpr, or if field is mutable reference.
				class_.can_be_constexpr&= field.t.CanBeConstexpr() && !( field.is_mutable && field.is_reference );
			}

			// Disable constexpr possibility for structs with:
			// * explicit destructors
			// * non-default copy-assignment operators
			// * non-default copy constructors
			// * non-default equality compare operators
			auto functions_set_ptr= member.value().Get</ FunctionsSet />();
			if( !functions_set_ptr.empty() )
			{
				foreach( &function : functions_set_ptr.try_lock_imut().deref().functions )
				{
					if( member.key() == KeywordToString( Keyword::destructor_ ) &&
						!function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == KeywordToString( Keyword::constructor_ ) &&
						IsCopyConstructor( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) &&
						IsCopyAssignmentOperator( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) &&
						IsEqualityCompareOperator( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
				}
			}
		}
	}

	BuildClassPolymorphTypeId( class_type );
	BuildClassVirtualTable( class_type );

	TryGenerateDefaultConstructor( class_type );
	TryGenerateCopyConstructor( class_type );
	TryGenerateCopyAssignmentOperator( class_type );
	TryGenerateEqualityCompareOperator( class_type );
	TryGenerateDestructor( class_type );

	with( mut lock : class_type.lock_mut() )
	{
		var ClassType &mut class_= lock.deref();

		// Search for explicit noncopy constructors.
		if_var( constructors : class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ) )
		{
			auto functions_set_ptr= constructors.Get</FunctionsSet/>();
			auto lock= functions_set_ptr.try_lock_imut();
			var FunctionsSet& functions_set= lock.deref();
			// Should be functions set 100%
			foreach( &function_variable : functions_set.functions )
			{
				if( function_variable.is_generated )
				{
					continue;
				}

				if( IsDefaultConstructor( function_variable, class_type ) )
				{
					class_.have_explicit_noncopy_constructors= true;
				}
				else if( IsCopyConstructor( function_variable, class_type ) ) {}
				else
				{
					class_.have_explicit_noncopy_constructors= true;
				}
			}
			class_.have_explicit_noncopy_constructors |= !functions_set.function_templates.empty();
		}
	}

	// Merge functions sets of parents into functions sets of this class.
	// Do the same for type templates sets.
	// Merge functions sets in order to have possibility to fetch functions sets, combined from sets of multiple parents.
	// Do not borrow other kinds of symbols (type aliases, variables, etc.) in order to avoid global things build inside wrong namespace.
	with( parents : class_type.lock_imut().deref().parents )
	{
		foreach( &parent : parents )
		{
			auto parent_members= parent.class_.lock_imut().deref().members;
			foreach( &member_value : parent_members.lock_imut().deref() )
			{
				auto parent_member_visibility= parent.class_.lock_imut().deref().GetMemberVisibility( member_value.key() );
				if( parent_member_visibility == Synt::ClassVisibility::Private )
				{
					continue; // Do not inherit private members.
				}

				var bool has_name = !class_members.lock_imut().deref().GetThisScopeValue( member_value.key() ).empty();

				auto src_functions_set_nullable_ptr= member_value.value().Get</FunctionsSet/>();
				if( !src_functions_set_nullable_ptr.empty() )
				{
					// SPARCHE_TODO - maybe also skip additive-assignment operators?
					if( member_value.key() == KeywordToString( Keyword::constructor_ ) ||
						member_value.key() == KeywordToString( Keyword::destructor_ ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::CompareOrder ) )
					{
						continue; // Did not inherit constructors, destructors, assignment operators, compare operators.
					}

					auto src_functions_set_ptr= src_functions_set_nullable_ptr.try_to_non_nullable();

					// Build source functions set before merging.
					BuildFunctionsSet( parent_members, src_functions_set_ptr, false );

					auto src_functions_set_lock= src_functions_set_ptr.lock_imut();
					auto& src_functions_set= src_functions_set_lock.deref();
					if( has_name )
					{
						auto result_functions_set_nullable_ptr= class_members.lock_imut().deref().GetThisScopeValue( member_value.key() ).try_deref().Get</FunctionsSet/>();
						if( !result_functions_set_nullable_ptr.empty() )
						{
							auto result_functions_set_ptr= result_functions_set_nullable_ptr.try_to_non_nullable();

							// Build destination functions set before merging.
							BuildFunctionsSet( class_members, result_functions_set_ptr, false );

							// Merge functions sets.
							auto mut result_functions_set_lock= result_functions_set_ptr.lock_mut();
							auto &mut result_functions_set= result_functions_set_lock.deref();

							if( parent_member_visibility != class_type.lock_imut().deref().GetMemberVisibility( member_value.key() ) )
							{
								var SrcLoc mut src_loc= syntax_element.src_loc;
								if( !result_functions_set.functions.empty() )
								{
									auto& f= result_functions_set.functions.front();
									if_var( &prototype_syntax_element : f.prototype_syntax_element )
									{
										src_loc= prototype_syntax_element.src_loc;
									}
									if_var( &body_syntax_element : f.body_syntax_element )
									{
										src_loc= body_syntax_element.src_loc;
									}
								}
								else if( !result_functions_set.function_templates.empty() )
								{
									src_loc= result_functions_set.function_templates.front().lock_imut().deref().syntax_element.deref().src_loc;
								}
								REPORT_ERROR( FunctionsVisibilityMismatch, names_scope_ptr, src_loc, member_value.key() )
							}

							foreach( &src_function : src_functions_set.functions )
							{
								if( !GetFunctionWithSameType( result_functions_set, src_function.t ).empty() )
								{
									continue; // New class function shadows function with same type in source class, so, skip it.
								}
								if( ApplyOverloadedFunction( result_functions_set, src_function, class_members, syntax_element.src_loc ) )
								{
									result_functions_set.functions.back().is_inherited= true;
								}
							}

							// TODO - merge function templates smarter.
							foreach( &function_template : src_functions_set.function_templates )
							{
								result_functions_set.function_templates.push_back( function_template );
							}
						}
					}
					else
					{
						// Copy functions set value itself, not just shared_ptr.
						var FunctionsSet mut functions_set_copy= src_functions_set;
						foreach( &mut function : functions_set_copy.functions )
						{
							function.is_inherited= true;
						}

						with( mut dst_members_lock : class_members.lock_mut() )
						{
							dst_members_lock.deref().AddName( member_value.key(), NamesScopeValue( move(functions_set_copy) ) );
						}

						auto mut lock= class_type.lock_mut();
						lock.deref().SetMemberVisibility( member_value.key(), parent_member_visibility );
					}
				} // if function set
				auto src_type_templates_set_nullable_ptr= member_value.value().Get</TypeTemplatesSet/>();
				if( !src_type_templates_set_nullable_ptr.empty() )
				{
					auto src_type_templates_set_ptr= src_type_templates_set_nullable_ptr.try_to_non_nullable();

					// Build source type templates set before merging.
					BuiltTypeTemplatesSet( parent_members, src_type_templates_set_ptr );

					auto src_type_templates_set_lock= src_type_templates_set_ptr.lock_imut();
					auto& src_type_templates_set= src_type_templates_set_lock.deref();

					if( has_name )
					{
						auto result_type_templates_set_ptr= class_members.lock_imut().deref().GetThisScopeValue( member_value.key() ).try_deref().Get</TypeTemplatesSet/>().try_to_non_nullable();

						// Build destination type templates set before merging.
						BuiltTypeTemplatesSet( class_members, result_type_templates_set_ptr );

						// Merge type template sets.
						auto mut result_type_templates_set_lock= result_type_templates_set_ptr.lock_mut();
						auto &mut result_type_templates_set= result_type_templates_set_lock.deref();

						if( parent_member_visibility != class_type.lock_imut().deref().GetMemberVisibility( member_value.key() ) )
						{
							var SrcLoc mut src_loc;
							if( !result_type_templates_set.type_templates.empty() )
							{
								src_loc= result_type_templates_set.type_templates.front().lock_imut().deref().syntax_element.deref().src_loc;
							}
							REPORT_ERROR( TypeTemplatesVisibilityMismatch, names_scope_ptr, src_loc, member_value.key() )
						}

						foreach( &src_type_template : src_type_templates_set.type_templates )
						{
							var bool mut overrides= false;
							foreach( &result_type_template : result_type_templates_set.type_templates )
							{
								if( src_type_template.lock_imut().deref().signature_params == result_type_template.lock_imut().deref().signature_params )
								{
									overrides= true;
									break;
								}
							}
							if( !overrides )
							{
								result_type_templates_set.type_templates.push_back( src_type_template );
							}
						}
					}
					else
					{
						// Copy type templates set value itself, not just shared_ptr.
						// TODO - set "inherited" flag.
						var NamesScopeValue mut value_for_copy(src_type_templates_set);

						with( mut dst_members_lock : class_members.lock_mut() )
						{
							dst_members_lock.deref().AddName( member_value.key(), move(value_for_copy) );
						}
						auto mut lock= class_type.lock_mut();
						lock.deref().SetMemberVisibility( member_value.key(), parent_member_visibility );
					}
				} // if type templates set
			} // for parent members
		} // for parents
	}

	// Finally, make class complete.
	with( mut lock : class_type.lock_mut() )
	{
		lock.deref().is_complete= true;
	}

	CheckClassFieldsInitializers( class_type );

	// Build constexpr methods after class completion.
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto functions_set_nullable_ptr= member.value().Get</ FunctionsSet />();
		if( functions_set_nullable_ptr.empty() )
		{
			continue;
		}
		auto functions_set_ptr= functions_set_nullable_ptr.try_to_non_nullable();

		var bool mut has_non_prepared_constexpr_functions= false;
		with( &functions_set : functions_set_ptr.lock_imut().deref() )
		{
			foreach( &synt_function : functions_set.syntax_elements )
			{
				has_non_prepared_constexpr_functions|= synt_function.deref().constexpr_;
			}
		}

		if( has_non_prepared_constexpr_functions )
		{
			BuildFunctionsSet( class_members, functions_set_ptr, false );
		}

		// Build body for copy, then update it. This needed to prevent function body build under lock.
		auto mut functions_copy= functions_set_ptr.lock_imut().deref().functions;
		foreach( &mut func_variable : functions_copy )
		{
			if( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::NonConstexpr )
			{
				BuildFuncCode( class_members, func_variable );
			}
		}

		auto mut lock= functions_set_ptr.lock_mut();
		lock.deref().functions= move(functions_copy);
	}
}

fn CodeBuilder::BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type )
{
	if( enum_type.lock_imut().deref().underlying_type.llvm_type != LLVMTypeRef::Null )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( enum_type )

	var NamesScopePtr enum_inernal_names_scope= enum_type.lock_imut().deref().names_scope;

	auto enum_declaration_ptr= enum_type.lock_imut().deref().syntax_element;
	auto& enum_declaration= enum_declaration_ptr.deref();

	var FundamentalType mut underlying_type;
	if( enum_declaration.elements.size() <= 256s )
	{
		underlying_type= FundamentalType( U_FundamentalType::u8_, fundamental_llvm_types_.u8_ );

	}
	else if( enum_declaration.elements.size() <= 65536s )
	{
		underlying_type= FundamentalType( U_FundamentalType::u16_, fundamental_llvm_types_.u16_ );
	}
	else
	{
		underlying_type= FundamentalType( U_FundamentalType::u32_, fundamental_llvm_types_.u32_ );
	}

	if_var( &underlying_type_name : enum_declaration.underlying_type )
	{
		var FunctionContext mut function_context= CreateGlobalFunctionContext();
		auto t= PrepareType( names_scope_ptr, function_context, underlying_type_name );

		auto fundamental_type= t.GetFundamentalType();
		if( fundamental_type.empty() || !IsInteger( fundamental_type.try_deref().fundamental_type ) )
		{
			// SPRACHE_TODO - maybe allow inheritance of enums?
			REPORT_ERROR( TypesMismatch, names_scope_ptr, enum_declaration.src_loc, ust::string8("any integer type"), t )
		}
		else
		{
			underlying_type= fundamental_type.try_deref();
		}
	}

	var ust::unordered_map</ ust::string8, Enum::Element /> mut enum_elements;
	foreach( &element : enum_declaration.elements )
	{
		if( IsKeyword( element.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, element.src_loc )
		}

		if( !enum_elements.find( element.name ).empty() )
		{
			REPORT_ERROR( Redefinition,  names_scope_ptr, element.src_loc, element.name )
		}

		var Enum::Element mut out_element;

		auto name_mangled= mangler_.deref().MangleGlobalVariable( enum_inernal_names_scope.lock_imut().deref(), element.name.range(), enum_type, true );
		out_element.constexpr_value= unsafe( LLVMConstInt( underlying_type.llvm_type, u64(enum_elements.size()), LLVMBool::False ) );
		out_element.llvm_value= AddGlobalConstantVariable( name_mangled.range(), underlying_type.llvm_type, out_element.constexpr_value );

		enum_elements.insert( element.name, move(out_element) );
	}

	var u64 bit_width(underlying_type.GetSize() * 8u);
	if( bit_width < 32u64 ) // Assume that 64 bits are enough for all enums.
	{
		auto max_value_plus_one=
			1u64 << ( bit_width - select( IsSignedInteger( underlying_type.fundamental_type ) ? 1u64 : 0u64 ) );
		auto max_value= max_value_plus_one - 1u64;

		if( u64(enum_elements.size()) > max_value )
		{
			REPORT_ERROR( UnderlyingTypeForEnumIsTooSmall, names_scope_ptr, enum_declaration.src_loc, enum_elements.size() - 1s, max_value )
		}
	}

	// Finally, update enum itself.
	auto mut lock= enum_type.lock_mut();
	var Enum &mut enum_= lock.deref();
	enum_.underlying_type= move(underlying_type);
	enum_.elements= move(enum_elements);
}

fn CodeBuilder::BuildTypeAlias( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr )
{
	if( !type_alias_ptr.lock_imut().deref().t.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( type_alias_ptr )

	auto syntax_element_ptr= type_alias_ptr.lock_imut().deref().syntax_element;

	var FunctionContext mut function_context= CreateGlobalFunctionContext();
	var Type mut t= PrepareType( names_scope_ptr, function_context, syntax_element_ptr.deref().type_name );

	// Finally, update type alias.
	auto mut lock= type_alias_ptr.lock_mut();
	lock.deref().t.reset( move(t) );
}

fn CodeBuilder::BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().deref().syntax_elements.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( type_templates_set_ptr )

	// Process copy of shared pointer value.
	var TypeTemplatesSet mut type_templates_set= type_templates_set_ptr.lock_imut().deref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto syntax_element= type_templates_set.syntax_elements.back();
		PrepareTypeTemplate( names_scope, syntax_element, type_templates_set );

		type_templates_set.syntax_elements.pop_back();
	}
	type_templates_set.syntax_elements.clear();

	// Finally, update value in shared pointer.
	auto mut lock= type_templates_set_ptr.lock_mut();
	lock.deref()= move(type_templates_set);
}

fn CodeBuilder::BuildGlobalVariable( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr )
{
	if( !global_variable_ptr.lock_imut().deref().variable.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( global_variable_ptr )

	auto variables_declaration_ptr= global_variable_ptr.lock_imut().deref().syntax_element;
	auto& variables_declaration= variables_declaration_ptr.deref();
	auto& variable_declaration= variables_declaration.variables[ size_type(global_variable_ptr.lock_imut().deref().variable_index) ];

	var bool externally_available= !IsSrcLocFromMainFile( variables_declaration.src_loc );

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	var bool is_mutable= variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable;
	var Type t= PrepareType( names_scope_ptr, function_context, variables_declaration.t );

	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope_ptr, variables_declaration.src_loc, t )
		return;
	}
	if( !t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope_ptr, variable_declaration.src_loc )
		return;
	}

	var Variable mut variable
	{
		.t= t,
		.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.location= Variable::Location::Pointer,
		.name= variable_declaration.name,
	};
	auto mut variable_ptr= move(variable).CreatePtr();

	auto mut constexpr_value= LLVMValueRef::Null;
	if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= mangler_.deref().MangleGlobalVariable( names_scope_ptr.lock_imut().deref(), variable_declaration.name.range(), t, !is_mutable );
		auto llvm_value= select( is_mutable
			? AddGlobalMutableVariable( name_mangled.range(), t.GetLLVMType(), externally_available )
			: AddGlobalConstantVariable( name_mangled.range(), t.GetLLVMType(), LLVMValueRef::Null ) );

		with( mut lock : variable_ptr.lock_mut() )
		{
			lock.deref().llvm_value= llvm_value;
		}

		function_context.references_graph.AddNode( variable_ptr );
		{
			var Variable mut variable_for_initialization
			{
				.t= t,
				.value_type= ValueType::ReferenceMut,
				.location= Variable::Location::Pointer,
				.name= variable_declaration.name,
				.llvm_value= llvm_value,
			};

			var VariablePtr variable_for_initialization_ptr= move(variable_for_initialization).CreatePtr();
			function_context.references_graph.AddNode( variable_for_initialization_ptr );
			function_context.references_graph.AddLink( variable_ptr, variable_for_initialization_ptr );

			if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
			{
				constexpr_value= BuildEmptyInitializer( names_scope_ptr, function_context, variable_ptr, variable_declaration.name, variable_declaration.src_loc );
			}
			else
			{
				constexpr_value= BuildInitializer( names_scope_ptr, function_context, variable_ptr, variable_declaration.initializer );
			}

			function_context.references_graph.RemoveNode( variable_for_initialization_ptr );
		}
		function_context.references_graph.RemoveNode( variable_ptr );

		if( constexpr_value != LLVMValueRef::Null ) // May be in case of error.
		{
			unsafe( LLVMSetInitializer( llvm_value, constexpr_value ) );
		}
	}
	else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( is_mutable ) // Disable global mutable references because of problems with initializers and references protection.
		{
			REPORT_ERROR( MutableGlobalReferencesAreNotAllowed, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
		{
			REPORT_ERROR( ExpectedInitializer, names_scope_ptr, variable_declaration.src_loc, variable_declaration.name )
			return;
		}

		var ust::optional_ref_imut</Synt::Expression/> mut initializer_expression;
		if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
		{
			initializer_expression.reset(expression_initializer);
		}
		if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
		{
			if( constructor_initializer.args.size() != 1s )
			{
				REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope_ptr, constructor_initializer.src_loc )
				return;
			}

			initializer_expression.reset( constructor_initializer.args.front().deref() );
		}

		if( initializer_expression.empty() )
		{
			REPORT_ERROR( UnsupportedInitializerForReference, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		with( &expression_result : BuildExpressionCodeEnsureVariable( names_scope_ptr, function_context, initializer_expression.try_deref() ).lock_imut().deref() )
		{
			if( expression_result.t != t )
			{
				REPORT_ERROR( TypesMismatch, names_scope_ptr, variable_declaration.src_loc, t, expression_result.t )
				return;
			}
			if( expression_result.value_type == ValueType::Value )
			{
				REPORT_ERROR( ExpectedReferenceValue, names_scope_ptr, variable_declaration.src_loc )
				return;
			}

			with( mut lock : variable_ptr.lock_mut() )
			{
				lock.deref().llvm_value= expression_result.llvm_value;
			}
			constexpr_value= expression_result.constexpr_value;
		}
	}
	else{ halt; }

	if( constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope_ptr, variable_declaration.src_loc )
		return;
	}

	if( !is_mutable )
	{
		// Set constexpr value only for immutable variables.
		with( &mut lock : variable_ptr.lock_mut() )
		{
			lock.deref().constexpr_value= constexpr_value;
		}
	}

	// TODO - maybe clear here dummy global function?

	// Finally, set result variable.
	auto mut lock= global_variable_ptr.lock_mut();
	lock.deref().variable= move(variable_ptr);
}

fn CodeBuilder::BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr )
{
	if( !global_auto_variable_ptr.lock_imut().deref().variable.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( global_auto_variable_ptr )

	auto auto_variable_declaration_ptr= global_auto_variable_ptr.lock_imut().deref().syntax_element;
	auto& auto_variable_declaration= auto_variable_declaration_ptr.deref();

	var bool externally_available= !IsSrcLocFromMainFile( auto_variable_declaration.src_loc );

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	var bool is_mutable= auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable;

	var Variable mut variable
	{
		.location= Variable::Location::Pointer,
		.value_type= select( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.name= auto_variable_declaration.name,
	};

	var VariablePtr expr_ptr= BuildExpressionCodeEnsureVariable( names_scope_ptr, function_context, auto_variable_declaration.initializer_expression );
	auto expr_lock= expr_ptr.lock_imut();
	var Variable& expr= expr_lock.deref();

	variable.t= expr.t;
	if( variable.t == invalid_type_ )
	{
		return; // Some error was generated before.
	}
	if( !variable.t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	// Disable global mutable references because of problems with initializers and references protection.
	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference && is_mutable )
	{
		REPORT_ERROR( MutableGlobalReferencesAreNotAllowed, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	variable.constexpr_value= expr.constexpr_value;
	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope_ptr, auto_variable_declaration.src_loc )
			return;
		}

		variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= mangler_.deref().MangleGlobalVariable( names_scope_ptr.lock_imut().deref(), auto_variable_declaration.name.range(), variable.t, !is_mutable );
		variable.llvm_value= select( is_mutable
			? AddGlobalMutableVariable( name_mangled.range(), variable.t.GetLLVMType(), externally_available )
			: AddGlobalConstantVariable( name_mangled.range(), variable.t.GetLLVMType(), expr.constexpr_value ) );

		unsafe( LLVMSetInitializer( variable.llvm_value, expr.constexpr_value ) );
	}
	else { halt; }

	if( is_mutable )
	{
		// Reset constexpr flag for mutable variables.
		variable.constexpr_value = LLVMValueRef::Null;
	}

	// Finally, set result variable.
	auto mut lock= global_auto_variable_ptr.lock_mut();
	lock.deref().variable= move(variable).CreatePtr();
}

} // namespace U1
