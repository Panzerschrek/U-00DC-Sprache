import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

?macro <? GLOBALS_LOOP_DETECT:block ?value : expr ?>
->
<?
	if( DetectGlobalsLoop( ?value ) ){ return; }
	var GlobalThingHolder ??holder( global_things_stack_ptr_, ?value );
?>

namespace U1
{

class GlobalThingHolder
{
public:
	fn constructor( GlobalThingsStackPtr mut stack, NamesScopeValue mut value )
		( stack_(move(stack)) )
	{
		auto mut lock= stack_.lock_mut();
		lock.deref().push_back( move(value) );
	}

	fn destructor()
	{
		auto mut lock= stack_.lock_mut();
		lock.deref().drop_back();
	}

private:
	GlobalThingsStackPtr imut stack_;
}

fn GlobalValueToString( NamesScopeValue& global_thing ) : ust::string8
{
	{
		auto functions_set_ptr= global_thing.Get</NamesScopeFunctionsSet/>();
		if( !functions_set_ptr.empty() )
		{
			auto lock= functions_set_ptr.try_lock_imut();
			var NamesScopeFunctionsSet& functions_set= lock.deref();

			if( !functions_set.syntax_elements.empty() )
			{
				return functions_set.syntax_elements.front().deref().name.back();
			}
			if( !functions_set.out_of_line_syntax_elements.empty() )
			{
				return functions_set.out_of_line_syntax_elements.front().deref().name.back();
			}
			if( !functions_set.function_templates_syntax_elements.empty() )
			{
				return functions_set.function_templates_syntax_elements.front().deref().name;
			}

			foreach( &function : functions_set.functions_set.functions )
			{
				if_var( &el : function.prototype_syntax_element )
				{
					return el.name.back();
				}
				if_var( &el : function.body_syntax_element )
				{
					return el.name.back();
				}
			}

			if( !functions_set.functions_set.function_templates.empty() )
			{
				return functions_set.functions_set.function_templates.front().deref().syntax_element.deref().name;
			}
		}
	}
	{
		auto class_type_ptr= global_thing.Get</ClassType/>();
		if( !class_type_ptr.empty() )
		{
			return Type( class_type_ptr.try_to_non_nullable() ).ToString();
		}
	}
	{
		auto enum_type_ptr= global_thing.Get</Enum/>();
		if( !enum_type_ptr.empty() )
		{
			return Type( enum_type_ptr.try_to_non_nullable() ).ToString();
		}
	}
	{
		auto type_alias_ptr= global_thing.Get</Enum/>();
		if( !type_alias_ptr.empty() )
		{
			return type_alias_ptr.try_lock_imut().deref().syntax_element.deref().name;
		}
	}
	{
		auto type_templates_set_ptr= global_thing.Get</TypeTemplatesSet/>();
		if( !type_templates_set_ptr.empty() )
		{
			auto lock= type_templates_set_ptr.try_lock_imut();
			var TypeTemplatesSet& type_templates_set= lock.deref();

			if( !type_templates_set.syntax_elements.empty() )
			{
				return type_templates_set.syntax_elements.front().deref().name;
			}
			if( !type_templates_set.type_templates.empty() )
			{
				return type_templates_set.type_templates.front().deref().syntax_element.deref().name;
			}
		}
	}
	{
		auto global_variable_ptr= global_thing.Get</GlobalVariable/>();
		if( !global_variable_ptr.empty() )
		{
			auto lock= global_variable_ptr.try_lock_imut();
			var GlobalVariable& global_variable= lock.deref();
			return global_variable.syntax_element.deref().variables[ global_variable.variable_index ].name;
		}
	}
	{
		auto global_auto_variable_ptr= global_thing.Get</GlobalAutoVariable/>();
		if( !global_auto_variable_ptr.empty() )
		{
			return global_auto_variable_ptr.try_lock_imut().deref().syntax_element.deref().name;
		}
	}

	return "";
}

fn AddAncestorsAccessRights_r( NamesScope &mut dst_class_members, ClassTypePtr& ancestor_class )
{
	dst_class_members.AddAccessRightsFor( ancestor_class, Synt::ClassVisibility::Protected );
	foreach( &parent : ancestor_class.lock_imut().deref().parents )
	{
		AddAncestorsAccessRights_r( dst_class_members, parent.class_ );
	}
}

fn CodeBuilder::DetectGlobalsLoop( this, NamesScopeValue& global_thing ) : bool
{
	auto lock= global_things_stack_ptr_.lock_imut();
	var GlobalThingsStack& stack= lock.deref();

	auto mut i= 0s;
	while( i < stack.size() && stack[i] != global_thing ){ ++i; }

	if( i == stack.size() )
	{
		return false; // No loop detected
	}

	var ust::string8 mut description;
	for( ; i < stack.size(); ++i )
	{
		description+= GlobalValueToString(stack[i]);
		description+= " -> ";
	}
	description+= GlobalValueToString(global_thing);

	auto mut errors_container_lock= root_errors_container_.try_lock_mut();

	errors_container_lock.deref().push_back(
		ReportError( CodeBuilderErrorCode::GlobalsLoopDetected, GetValueSrcLoc(global_thing), description ) );

	return true;
}

fn CodeBuilder::BuildFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeFunctionsSet/> functions_set_ptr, bool build_body )
{
	if( !build_body )
	{
		{ // First, lock as imut and check if complete.
			auto l= functions_set_ptr.lock_imut();
			var NamesScopeFunctionsSet& functions_set= l.deref();
			if( functions_set.syntax_elements.empty() &&
				functions_set.out_of_line_syntax_elements.empty() &&
				functions_set.function_templates_syntax_elements.empty() ) // Already complete
			{
				return;
			}
		}
	}

	GLOBALS_LOOP_DETECT( functions_set_ptr )

	// Take copy, and make manipulations only with it. Update value inside shareed pointer in one operation.
	var NamesScopeFunctionsSet mut functions_set= functions_set_ptr.lock_imut().deref();

	// Preapare functions set itself.
	while( !functions_set.syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.syntax_elements.back();
		auto class_type_ptr= functions_set.class_;
		PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set.functions_set, false );
		functions_set.syntax_elements.drop_back();
	}
	while( !functions_set.out_of_line_syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.out_of_line_syntax_elements.back();
		auto class_type_ptr= functions_set.class_;
		PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set.functions_set, true );
		functions_set.out_of_line_syntax_elements.drop_back();
	}
	while( !functions_set.function_templates_syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.function_templates_syntax_elements.back();
		auto function_template= PrepareFunctionTemplate( names_scope_ptr, syntax_element_ptr, functions_set.class_ );
		functions_set.functions_set.function_templates.push_back( function_template );
		functions_set.function_templates_syntax_elements.drop_back();
	}

	// Update functions set after prepareation process.
	{
		auto mut lock= functions_set_ptr.lock_mut();
		lock.deref()= functions_set;
	}

	var bool is_class_method= !functions_set.class_.empty();
	foreach( &mut func_variable : functions_set.functions_set.functions )
	{
		// Immediately build body of "constexpr" functions.
		if( build_body ||
			( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::NonConstexpr && !is_class_method ) )
		{
			BuildFuncCode( names_scope_ptr, func_variable );
		}
	}

	// Update functions set again after body build process.
	{
		auto mut lock= functions_set_ptr.lock_mut();
		lock.deref()= move(functions_set);
	}
}

fn CodeBuilder::BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type )
{
	if( class_type.lock_imut().deref().is_complete )
	{
		return;
	}
	{
		auto typeinfo_src_type= class_type.lock_imut().deref().typeinfo_src_type_;
		if( !typeinfo_src_type.empty() )
		{
			BuildFullTypeinfo( typeinfo_src_type.try_deref() );
			return;
		}
	}
	if( class_type.lock_imut().deref().syntax_element.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( class_type )

	auto syntax_element_ptr= class_type.lock_imut().deref().syntax_element;
	auto& syntax_element= syntax_element_ptr.try_deref();

	auto mut global_function_context= CreateGlobalFunctionContext();

	// Fill parents
	foreach( &parent_name : syntax_element.parents )
	{
		auto parent_type= PrepareType( names_scope_ptr, global_function_context, parent_name );
		if( parent_type.GetClassType().empty() )
		{
			REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.src_loc, parent_type )
			continue;
		}

		if( !EnsureTypeComplete( parent_type ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope_ptr, syntax_element.src_loc, parent_type )
			continue;
		}

		var ClassTypePtr parent_class= parent_type.GetClassType().try_deref();

		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.deref();

		auto mut duplicated= false;
		foreach( &prev_parent : class_.parents )
		{
			duplicated|= prev_parent.class_ == parent_class;
		}
		if( duplicated )
		{
			REPORT_ERROR( DuplicatedParentClass, names_scope_ptr, syntax_element.src_loc, parent_type )
			continue;
		}

		auto parent_kind= parent_class.lock_imut().deref().kind;
		if( !( parent_kind == ClassType::Kind::Abstract || parent_kind == ClassType::Kind::Interface || parent_kind == ClassType::Kind::PolymorphNonFinal ) )
		{
			REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.src_loc, parent_type )
			continue;
		}

		if( parent_kind != ClassType::Kind::Interface ) // not interface=base
		{
			if( !class_.base_class.empty() )
			{
				REPORT_ERROR( DuplicatedBaseClass, names_scope_ptr, syntax_element.src_loc, parent_type )
				continue;
			}
			class_.base_class= parent_class;
		}

		{ // Give access from this class to protected members of all ancestor classes.
			auto mut members_lock= class_.members.lock_mut();
			AddAncestorsAccessRights_r( members_lock.deref(), parent_class );
		}

		var ClassType::Parent mut parent{ .class_= parent_class };
		class_.parents.push_back( move(parent) );
	}

	{ // Pre-mark class as polymorph, because it's needed for functions checks. Exact kind of class we will known later.
		auto mut lock= class_type.lock_mut();
		auto &mut class_= lock.deref();

		class_.have_shared_state= syntax_element.have_shared_state;

		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
			!syntax_element.parents.empty() )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else
		{
			class_.kind= ClassType::Kind::NonPolymorph;
		}
	}

	// Prepare fields types.
	auto class_members= class_type.lock_imut().deref().members;
	auto mut field_count= 0u;
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto field_ptr= member.value().Get</ ClassField />();
		if( !field_ptr.empty() )
		{
			++field_count;

			auto mut field_lock= field_ptr.try_lock_mut();
			var ClassField &mut field= field_lock.deref();

			field.t= PrepareType( class_members, global_function_context, field.syntax_element.deref().t );

			if( !EnsureTypeComplete( field.t ) )
			{
				REPORT_ERROR( UsingIncompleteType, class_members, field.syntax_element.deref().src_loc, field.t )
				field.t= invalid_type_;
				continue;
			}
			if( !field.is_reference && field.t.IsAbstract() )
			{
				REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope_ptr, field.syntax_element.deref().src_loc, field.t )
				continue;
			}
			if( field.is_reference && field.t.GetInnerReferenceKind() != InnerReferenceKind::None )
			{
				REPORT_ERROR( ReferenceFieldOfTypeWithReferencesInside, names_scope_ptr, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
				field.t= invalid_type_;
				continue;
			}
		}

		auto functions_set_ptr= member.value().Get</ NamesScopeFunctionsSet />();
		if( !functions_set_ptr.empty() )
		{
			BuildFunctionsSet( class_members, functions_set_ptr.try_to_non_nullable(), false );
		}

		// Type aliases required for class completeness.
		auto type_alias_ptr= member.value().Get</ TypeAlias />();
		if( !type_alias_ptr.empty() )
		{
			BuildTypeAlias( class_members, type_alias_ptr.try_to_non_nullable() );
		}

		auto type_templates_set_ptr= member.value().Get</ TypeTemplatesSet />();
		if( !type_templates_set_ptr.empty() )
		{
			BuiltTypeTemplatesSet( class_members, type_templates_set_ptr.try_to_non_nullable() );
		}
	}

	// Allocate virtual table pointer, if class have no parents.
	// If class have at least one parent, reuse it's virtual table pointer.
	auto allocate_virtual_table_pointer= syntax_element.parents.empty() && (
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface );

	// Determine class data layout.
	var ust::vector</ LLVMTypeRef /> mut fields_llvm_types;

	if( allocate_virtual_table_pointer )
	{
		unsafe{  fields_llvm_types.push_back( LLVMPointerType( fundamental_llvm_types_.int_ptr, 0u ) );  } // set exact type later.
	}
	{
		// Make base class first field. Add parent classes fields.
		auto mut lock= class_type.lock_mut();
		auto &mut class_= lock.deref();

		auto base_class= class_.base_class;
		if( !base_class.empty() )
		{
			fields_llvm_types.push_back( base_class.try_lock_imut().deref().llvm_type );
		}

		foreach( &mut parent : class_.parents )
		{
			if( parent.class_ != base_class )
			{
				parent.field_number= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( parent.class_.lock_imut().deref().llvm_type );
			}
			else
			{
				parent.field_number= 0u;
			}
		}
	}
	{
		var ust::vector</ ust::shared_ptr_mut</ClassField/> /> mut fields_left;
		foreach( &member : class_members.lock_imut().deref() )
		{
			auto field_ptr= member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				fields_left.push_back( field_ptr.try_to_non_nullable() );
			}
		}

		// Calculate start offset, include parents fields, virtual table pointer.
		var u32 mut current_offset= 0u;
		foreach( llvm_type : fields_llvm_types )
		{
			unsafe
			{
				var u32 alignment= LLVMABIAlignmentOfType( data_layout_, llvm_type );
				var u32 padding= ( alignment - current_offset % alignment ) % alignment;
				current_offset+= padding;
				current_offset+= u32( LLVMABISizeOfType( data_layout_, llvm_type ) );
			}
		}

		var ust::vector</tup[ust::string8, ClassFieldPtr]/> mut fields_order;
		if( syntax_element.keep_fields_order )
		{
			// Sort fields by original index.
			// TODO - use libary sorting function.
			while( !fields_left.empty() )
			{
				var size_type mut min_index= ~0s;
				var size_type mut min_index_index= ~0s;
				for( auto mut i= 0s; i < fields_left.size(); ++i )
				{
					auto field_lock= fields_left[i].lock_imut();
					var ClassField& field= field_lock.deref();
					if( field.original_index < min_index )
					{
						min_index= field.original_index;
						min_index_index= i;
					}
				}

				auto field_ptr= fields_left[min_index_index];

				if( min_index_index + 1s < fields_left.size() )
				{
					auto f= fields_left.back();
					fields_left[min_index_index]= f;
				}
				fields_left.pop_back();

				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				auto mut llvm_type= field.t.GetLLVMType();
				if( field.is_reference ) { unsafe{  llvm_type= LLVMPointerType( llvm_type, 0u );  } }

				field.index= fields_llvm_types.size();
				fields_llvm_types.push_back( llvm_type );
				fields_order.push_back( ust::make_tuple( field.syntax_element.deref().name, field_ptr ) );
			}
		}
		else
		{
			while( !fields_left.empty() )
			{
				// Find best fit field with minimal original index (try to keep original fields order).
				var u32 mut best_field_padding= ~0u;
				auto mut best_padding_field_index= 0s;
				for( auto mut i= 0s; i < fields_left.size(); ++i )
				{
					auto field_lock= fields_left[i].lock_imut();
					var ClassField& field= field_lock.deref();
					auto mut llvm_type= field.t.GetLLVMType();
					if( field.is_reference ) { unsafe{  llvm_type= LLVMPointerType( llvm_type, 0u );  } }

					unsafe
					{
						var u32 alignment= LLVMABIAlignmentOfType( data_layout_, llvm_type );
						var u32 padding= ( alignment - current_offset % alignment ) % alignment;
						if( padding < best_field_padding )
						{
							best_field_padding= padding;
							best_padding_field_index= i;
						}
						else if( padding == best_field_padding )
						{
							// Prefer first field with same padding.
							if( field.original_index < cast_imut(fields_left)[best_padding_field_index].lock_imut().deref().original_index )
							{
								best_padding_field_index= i;
							}
						}
					}
				}

				auto field_ptr= fields_left[best_padding_field_index];

				if( best_padding_field_index + 1s < fields_left.size() )
				{
					auto f= fields_left.back();
					fields_left[best_padding_field_index]= f;
				}
				fields_left.pop_back();

				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				auto mut llvm_type= field.t.GetLLVMType();
				if( field.is_reference ) { unsafe{  llvm_type= LLVMPointerType( llvm_type, 0u );  } }

				field.index= fields_llvm_types.size();
				fields_llvm_types.push_back( llvm_type );
				fields_order.push_back( ust::make_tuple( field.syntax_element.deref().name, field_ptr ) );

				unsafe
				{
					current_offset+= best_field_padding;
					current_offset+= u32( LLVMABISizeOfType( data_layout_, llvm_type ) );
				}
			}
		}

		auto mut lock= class_type.lock_mut();
		lock.deref().fields_order= move(fields_order);
	}

	// Generate destructor prototype before perparing virtual table to mark it as virtual and setup virtual table index.
	TryGenerateDestructorPrototype( class_type );

	{ // Setup inner reference kind. Do this before methods generation and virtual table preparation.
		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.deref();

		var InnerReferenceKind mut class_inner_reference_kind= InnerReferenceKind::None;

		foreach( &parent : class_.parents )
		{
			auto parent_inner_reference_kind= parent.class_.lock_imut().deref().inner_reference_kind;
			if( u32(parent_inner_reference_kind) > u32(class_inner_reference_kind) )
			{
				class_inner_reference_kind= parent_inner_reference_kind;
			}
		}

		auto class_members_lock= class_members.lock_imut();

		foreach( &field_pair : class_.fields_order )
		{
			auto field_lock= field_pair[1].lock_imut();
			var ClassField& field= field_lock.deref();

			auto field_inner_reference_kind=
				select( field.is_reference
					? select( field.is_mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut )
					: field.t.GetInnerReferenceKind() );

			if( u32(field_inner_reference_kind) > u32(class_inner_reference_kind) )
			{
				class_inner_reference_kind= field_inner_reference_kind;
			}
		}

		class_.inner_reference_kind= class_inner_reference_kind;
	}

	// Prepare virtual table.
	if( !syntax_element.parents.empty() ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
	{
		PrepareClassVirtualTable( class_type );
		PrepareClassVirtualTableType( class_type );
		if( allocate_virtual_table_pointer )
		{
			unsafe
			{
				fields_llvm_types.front()= LLVMPointerType( class_type.lock_imut().deref().virtual_table_llvm_type, 0u );
			}
		}
	}

	{
		auto mut class_lock= class_type.lock_mut();
		var ClassType &mut class_= class_lock.deref();

		unsafe
		{
			// Check opaque before set body for cases of errors (class body duplication).
			if( LLVMIsOpaqueStruct( class_.llvm_type ) == LLVMBool::True )
			{
				LLVMStructSetBody( class_.llvm_type, fields_llvm_types.data(), u32(fields_llvm_types.size()), LLVMBool::False );
			}
		}
	}

	// Setup class kind.
	{
		auto mut lock= class_type.lock_mut();
		auto &mut class_= lock.deref();

		auto mut class_contains_pure_virtual_functions= false;
		foreach( &virtual_table_entry : class_.virtual_table )
		{
			class_contains_pure_virtual_functions|= virtual_table_entry.is_pure;
		}

		auto have_parents= class_.parents.empty();
		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Class )
		{
			class_.kind= select( have_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphNonFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Final )
		{
			class_.kind= select( have_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface )
		{
			if( !class_.base_class.empty() )
			{
				REPORT_ERROR( BaseClassForInterface, names_scope_ptr, syntax_element.src_loc )
			}
			if( field_count != 0u )
			{
				REPORT_ERROR( FieldsForInterfacesNotAllowed, names_scope_ptr, syntax_element.src_loc )
			}

			{
				// Constructors value should always exists and should always be NamesScopeFunctionsSet.
				auto constructors_ptr= class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).try_deref().Get</NamesScopeFunctionsSet/>();
				auto constructors_lock= constructors_ptr.try_lock_imut();
				auto& constructors= constructors_lock.deref();
				if( !constructors.functions_set.functions.empty() || !constructors.functions_set.function_templates.empty() )
				{
					REPORT_ERROR( ConstructorForInterface, names_scope_ptr, syntax_element.src_loc )
				}
			}
			foreach( &virtual_table_entry : class_.virtual_table )
			{
				if( !virtual_table_entry.is_pure && virtual_table_entry.name != KeywordToString( Keyword::destructor_ ) )
				{
					// TODO - report using function src_loc for each function.
					REPORT_ERROR( NonPureVirtualFunctionInInterface, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
					break;
				}
			}

			class_.kind= ClassType::Kind::Interface;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
		{
			class_.kind= ClassType::Kind::Abstract;
		}
		else{ halt; }
	}

	{ // Setup "constexpr" property. Do this before methods generation.
		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.deref();

		class_.can_be_constexpr= class_.kind == ClassType::Kind::Struct;

		foreach( &member : class_members.lock_imut().deref() )
		{
			auto field_ptr= member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				auto field_lock= field_ptr.try_lock_imut();
				auto& field= field_lock.deref();
				// Disable constexpr, if field type can not be constexpr, or if field is mutable reference.
				class_.can_be_constexpr&= field.t.CanBeConstexpr() && !( field.is_mutable && field.is_reference );
			}

			// Disable constexpr possibility for structs with:
			// * explicit destructors
			// * non-default copy-assignment operators
			// * non-default copy constructors
			// * non-default equality compare operators
			auto functions_set_ptr= member.value().Get</ NamesScopeFunctionsSet />();
			if( !functions_set_ptr.empty() )
			{
				foreach( &function : functions_set_ptr.try_lock_imut().deref().functions_set.functions )
				{
					if( member.key() == KeywordToString( Keyword::destructor_ ) &&
						!function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == KeywordToString( Keyword::constructor_ ) &&
						IsCopyConstructor( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) &&
						IsCopyAssignmentOperator( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) &&
						IsEqualityCompareOperator( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
				}
			}
		}
	}

	BuildClassPolymorphTypeId( class_type );
	BuildClassVirtualTable( class_type );

	TryGenerateDefaultConstructor( class_type );
	TryGenerateCopyConstructor( class_type );
	TryGenerateCopyAssignmentOperator( class_type );
	TryGenerateEqualityCompareOperator( class_type );
	TryGenerateDestructor( class_type );

	{
		auto mut class_lock= class_type.lock_mut();
		var ClassType &mut class_= class_lock.deref();

		// Search for explicit noncopy constructors.
		if_var( constructors : class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ) )
		{
			auto functions_set_ptr= constructors.Get</NamesScopeFunctionsSet/>();
			auto lock= functions_set_ptr.try_lock_imut();
			var FunctionsSet& functions_set= lock.deref().functions_set;
			// Should be functions set 100%
			foreach( &function_variable : functions_set.functions )
			{
				if( function_variable.is_generated )
				{
					continue;
				}

				if( IsDefaultConstructor( function_variable, class_type ) )
				{
					class_.have_explicit_noncopy_constructors= true;
				}
				else if( IsCopyConstructor( function_variable, class_type ) ) {}
				else
				{
					class_.have_explicit_noncopy_constructors= true;
				}
			}
			class_.have_explicit_noncopy_constructors |= !functions_set.function_templates.empty();
		}
	}

	// Merge namespaces of parents.
	with( parents : class_type.lock_imut().deref().parents )
	{
		foreach( &parent : parents )
		{
			auto parent_members= parent.class_.lock_imut().deref().members;
			foreach( &member_value : parent_members.lock_imut().deref() )
			{
				auto parent_member_visibility= parent.class_.lock_imut().deref().GetMemberVisibility( member_value.key() );
				if( parent_member_visibility == Synt::ClassVisibility::Private )
				{
					continue; // Do not inherit private members.
				}

				auto mut dst_members_lock= class_members.lock_mut();
				auto &mut dst_members_= dst_members_lock.deref();

				var bool has_name = !dst_members_.GetThisScopeValue( member_value.key() ).empty();

				auto src_functions_set_ptr= member_value.value().Get</NamesScopeFunctionsSet/>();
				if( !src_functions_set_ptr.empty() )
				{
					// SPARCHE_TODO - maybe also skip additive-assignment operators?
					if( member_value.key() == KeywordToString( Keyword::constructor_ ) ||
						member_value.key() == KeywordToString( Keyword::destructor_ ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::CompareOrder ) )
					{
						continue; // Did not inherit constructors, destructors, assignment operators, compare operators.
					}

					if( has_name )
					{
						auto result_class_value= dst_members_.GetThisScopeValue( member_value.key() );
						auto result_functions_set_ptr= result_class_value.try_deref().Get</NamesScopeFunctionsSet/>();
						if( !result_functions_set_ptr.empty() )
						{
							// Merge functions sets.
							auto src_functions_set_lock= src_functions_set_ptr.try_lock_imut();
							auto& src_functions_set= src_functions_set_lock.deref();

							auto mut result_functions_set_lock= result_functions_set_ptr.try_lock_mut();
							auto &mut result_functions_set= result_functions_set_lock.deref();

							if( parent_member_visibility != class_type.lock_imut().deref().GetMemberVisibility( member_value.key() ) )
							{
								var SrcLoc mut src_loc= syntax_element.src_loc;
								if( !result_functions_set.functions_set.functions.empty() )
								{
									auto& f= result_functions_set.functions_set.functions.front();
									if_var( &prototype_syntax_element : f.prototype_syntax_element )
									{
										src_loc= prototype_syntax_element.src_loc;
									}
									if_var( &body_syntax_element : f.body_syntax_element )
									{
										src_loc= body_syntax_element.src_loc;
									}
								}
								else if( !result_functions_set.functions_set.function_templates.empty() )
								{
									src_loc= result_functions_set.functions_set.function_templates.front().deref().syntax_element.deref().src_loc;
								}
								REPORT_ERROR( FunctionsVisibilityMismatch, names_scope_ptr, src_loc, member_value.key() )
							}

							foreach( &src_function : src_functions_set.functions_set.functions )
							{
								if( !GetFunctionWithSameType( result_functions_set.functions_set, src_function.t ).empty() )
								{
									continue; // New class function shadows function with same type in source class, so, skip it.
								}
								ApplyOverloadedFunction( result_functions_set.functions_set, src_function, class_members, syntax_element.src_loc );
							}

							// TODO - merge function templates smarter.
							foreach( &function_template : src_functions_set.functions_set.function_templates )
							{
								result_functions_set.functions_set.function_templates.push_back( function_template );
							}
						}
					}
				} // if function set
				auto src_type_templates_set_ptr= member_value.value().Get</TypeTemplatesSet/>();
				if( !src_type_templates_set_ptr.empty() && has_name )
				{
					auto result_class_value= dst_members_.GetThisScopeValue( member_value.key() );
					auto result_type_templates_set_ptr= result_class_value.try_deref().Get</TypeTemplatesSet/>();
					if( !result_type_templates_set_ptr.empty() )
					{
						// Merge type template sets.
						auto src_type_templates_set_lock= src_type_templates_set_ptr.try_lock_imut();
						auto& src_type_templates_set= src_type_templates_set_lock.deref();

						auto mut result_type_templates_set_lock= result_type_templates_set_ptr.try_lock_mut();
						auto &mut result_type_templates_set= result_type_templates_set_lock.deref();

						if( parent_member_visibility != class_type.lock_imut().deref().GetMemberVisibility( member_value.key() ) )
						{
							var SrcLoc mut src_loc;
							if( !result_type_templates_set.type_templates.empty() )
							{
								src_loc= result_type_templates_set.type_templates.front().deref().syntax_element.deref().src_loc;
							}
							REPORT_ERROR( TypeTemplatesVisibilityMismatch, names_scope_ptr, src_loc, member_value.key() )
						}

						foreach( &src_type_template : src_type_templates_set.type_templates )
						{
							var bool mut overrides= false;
							foreach( &result_type_template : result_type_templates_set.type_templates )
							{
								if( src_type_template.deref().signature_params == result_type_template.deref().signature_params )
								{
									overrides= true;
									break;
								}
							}
							if( !overrides )
							{
								result_type_templates_set.type_templates.push_back( src_type_template );
							}
						}
					}
				} // if type templates set

				if( !has_name )
				{
					dst_members_.AddName( member_value.key(), member_value.value() );
					auto mut lock= class_type.lock_mut();
					lock.deref().SetMemberVisibility( member_value.key(), parent_member_visibility );
				}
			} // for parent members
		} // for parents
	}

	// Finally, make class complete.
	{
		auto mut class_lock= class_type.lock_mut();
		class_lock.deref().is_complete= true;
	}

	CheckClassFieldsInitializers( class_type );

	// Build constexpr methods after class completion.
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto functions_set_ptr= member.value().Get</ NamesScopeFunctionsSet />();
		if( functions_set_ptr.empty() )
		{
			continue;
		}

		// Build body for copy, then update it. This needed to prevent function body build under lock.
		auto mut functions_set_copy= functions_set_ptr.try_lock_imut().deref().functions_set.functions;
		foreach( &mut func_variable : functions_set_copy )
		{
			if( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::NonConstexpr )
			{
				BuildFuncCode( class_members, func_variable );
			}
		}

		auto mut lock= functions_set_ptr.try_lock_mut();
		lock.deref().functions_set.functions= move(functions_set_copy);
	}
}

fn CodeBuilder::BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type )
{
	if( enum_type.lock_imut().deref().underlaying_type.llvm_type != LLVMTypeRef::Null )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( enum_type )

	var NamesScopePtr enum_inernal_names_scope= enum_type.lock_imut().deref().names_scope;

	auto enum_declaration_ptr= enum_type.lock_imut().deref().syntax_element;
	auto& enum_declaration= enum_declaration_ptr.deref();

	// Default underlaying type is 32bit. TODO - maybe do it platform-dependent?
	var FundamentalType mut underlaying_type( U_FundamentalType::u32_, fundamental_llvm_types_.u32_ );
	if( !( !enum_declaration.underlaying_type.start.get</Synt::EmptyVariant/>().empty() && enum_declaration.underlaying_type.tail.empty() ) )
	{
		var FunctionContext mut function_context= CreateGlobalFunctionContext();
		auto t= PrepareType( names_scope_ptr, function_context, enum_declaration.underlaying_type );

		auto fundamental_type= t.GetFundamentalType();
		if( fundamental_type.empty() || !IsInteger( fundamental_type.try_deref().fundamental_type ) )
		{
			// SPRACHE_TODO - maybe allow inheritance of enums?
			REPORT_ERROR( TypesMismatch, names_scope_ptr, enum_declaration.src_loc, ust::string8("any integer type"), t )
		}
		else
		{
			underlaying_type= fundamental_type.try_deref();
		}
	}

	var ust::unordered_map</ ust::string8, Enum::Element /> mut enum_elements;
	foreach( &element : enum_declaration.elements )
	{
		if( IsKeyword( element.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, element.src_loc )
		}

		if( !enum_elements.find( element.name ).empty() )
		{
			REPORT_ERROR( Redefinition,  names_scope_ptr, element.src_loc, element.name )
		}

		var Enum::Element mut out_element;

		auto name_mangled= mangler_.deref().MangleGlobalVariable( enum_inernal_names_scope.lock_imut().deref(), element.name, enum_type, true );
		unsafe{  out_element.constexpr_value= LLVMConstInt( underlaying_type.llvm_type, u64(enum_elements.size()), LLVMBool::False );  }
		out_element.llvm_value= AddGlobalConstantVariable( name_mangled, underlaying_type.llvm_type, out_element.constexpr_value );

		enum_elements.insert( element.name, move(out_element) );
	}

	var u64 bit_width(underlaying_type.GetSize() * 8s);
	if( bit_width < 32u64 ) // Assume that 64 bits are enough for all enums.
	{
		auto max_value_plus_one=
			1u64 << ( bit_width - select( IsSignedInteger( underlaying_type.fundamental_type ) ? 1u64 : 0u64 ) );
		auto max_value= max_value_plus_one - 1u64;

		if( u64(enum_elements.size()) > max_value )
		{
			REPORT_ERROR( UnderlayingTypeForEnumIsTooSmall, names_scope_ptr, enum_declaration.src_loc, enum_elements.size() - 1s, max_value )
		}
	}

	// Finally, update enum itself.
	auto mut lock= enum_type.lock_mut();
	var Enum &mut enum_= lock.deref();
	enum_.underlaying_type= move(underlaying_type);
	enum_.elements= move(enum_elements);
}

fn CodeBuilder::BuildTypeAlias( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr )
{
	if( !type_alias_ptr.lock_imut().deref().t.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( type_alias_ptr )

	auto syntax_element_ptr= type_alias_ptr.lock_imut().deref().syntax_element;

	var FunctionContext mut function_context= CreateGlobalFunctionContext();
	var Type mut t= PrepareType( names_scope_ptr, function_context, syntax_element_ptr.deref().type_name );

	// Finally, update type alias.
	auto mut lock= type_alias_ptr.lock_mut();
	lock.deref().t.reset( move(t) );
}

fn CodeBuilder::BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().deref().syntax_elements.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( type_templates_set_ptr )

	// Process copy of shared pointer value.
	var TypeTemplatesSet mut type_templates_set= type_templates_set_ptr.lock_imut().deref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto syntax_element= type_templates_set.syntax_elements.back();
		PrepareTypeTemplate( names_scope, syntax_element, type_templates_set );

		type_templates_set.syntax_elements.pop_back();
	}
	type_templates_set.syntax_elements.clear();

	// Finally, update value in shared pointer.
	auto mut lock= type_templates_set_ptr.lock_mut();
	lock.deref()= move(type_templates_set);
}

fn CodeBuilder::BuildGlobalVariable( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr )
{
	if( !global_variable_ptr.lock_imut().deref().variable.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( global_variable_ptr )

	auto variables_declaration_ptr= global_variable_ptr.lock_imut().deref().syntax_element;
	auto& variables_declaration= variables_declaration_ptr.deref();
	auto& variable_declaration= variables_declaration.variables[ global_variable_ptr.lock_imut().deref().variable_index ];

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	var NamesScopeVariable mut variable
	{
		.t= PrepareType( names_scope_ptr, function_context, variables_declaration.t ),
		.is_mutable = variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable
	};

	if( !EnsureTypeComplete( variable.t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope_ptr, variables_declaration.src_loc, variable.t )
		return;
	}
	if( !variable.t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope_ptr, variable_declaration.src_loc )
		return;
	}

	if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= mangler_.deref().MangleGlobalVariable( names_scope_ptr.lock_imut().deref(), variable_declaration.name, variable.t, !variable.is_mutable );
		variable.llvm_value= select( variable.is_mutable
			? AddGlobalMutableVariable( name_mangled, variable.t.GetLLVMType() )
			: AddGlobalConstantVariable( name_mangled, variable.t.GetLLVMType(), LLVMValueRef::Null ) );

		if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
		{
			variable.constexpr_value= BuildEmptyInitializer( names_scope_ptr, function_context, variable, variable_declaration.name, variable_declaration.src_loc );
		}
		else
		{
			variable.constexpr_value= BuildInitializer( names_scope_ptr, function_context, variable, variable_declaration.initializer );
		}

		if( variable.constexpr_value != LLVMValueRef::Null ) // May be in case of error.
		{
			unsafe{  LLVMSetInitializer( variable.llvm_value, variable.constexpr_value );  }
		}
	}
	else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( variable.is_mutable ) // Disable global mutable references because of problems with initializers and references protection.
		{
			REPORT_ERROR( MutableGlobalReferencesAreNotAllowed, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
		{
			REPORT_ERROR( ExpectedInitializer, names_scope_ptr, variable_declaration.src_loc, variable_declaration.name )
			return;
		}

		var ust::optional_ref_imut</Synt::Expression/> mut initializer_expression;
		if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
		{
			initializer_expression.reset(expression_initializer);
		}
		if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
		{
			if( constructor_initializer.args.size() != 1s )
			{
				REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope_ptr, constructor_initializer.src_loc )
				return;
			}

			initializer_expression.reset( constructor_initializer.args.front().deref() );
		}

		if( initializer_expression.empty() )
		{
			REPORT_ERROR( UnsupportedInitializerForReference, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		var Variable expression_result= BuildExpressionCodeEnsureVariable( names_scope_ptr, function_context, initializer_expression.try_deref() );
		if( expression_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope_ptr, variable_declaration.src_loc, variable.t, expression_result.t )
			return;
		}
		if( expression_result.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		variable.llvm_value= expression_result.llvm_value;
		variable.constexpr_value= expression_result.constexpr_value;
	}
	else{ halt; }

	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope_ptr, variable_declaration.src_loc )
		return;
	}
	if( variable.is_mutable )
	{
		// Reset constexpr flag for mutable variable.
		variable.constexpr_value = LLVMValueRef::Null;
	}

	// TODO - maybe clear here dummy global function?

	// Finally, set result variable.
	auto mut lock= global_variable_ptr.lock_mut();
	lock.deref().variable.reset( move(variable) );
}

fn CodeBuilder::BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr )
{
	if( !global_auto_variable_ptr.lock_imut().deref().variable.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( global_auto_variable_ptr )

	auto auto_variable_declaration_ptr= global_auto_variable_ptr.lock_imut().deref().syntax_element;
	auto& auto_variable_declaration= auto_variable_declaration_ptr.deref();

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	var NamesScopeVariable mut variable{ .is_mutable = auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable };

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope_ptr, function_context, auto_variable_declaration.initializer_expression );
	variable.t= expr.t;
	if( variable.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope_ptr, auto_variable_declaration.src_loc, auto_variable_declaration.name )
		return;
	}
	if( !variable.t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	// Disable global mutable references because of problems with initializers and references protection.
	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference && variable.is_mutable )
	{
		REPORT_ERROR( MutableGlobalReferencesAreNotAllowed, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	variable.constexpr_value= expr.constexpr_value;
	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope_ptr, auto_variable_declaration.src_loc )
			return;
		}

		variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= mangler_.deref().MangleGlobalVariable( names_scope_ptr.lock_imut().deref(), auto_variable_declaration.name, variable.t, !variable.is_mutable );
		variable.llvm_value= select( variable.is_mutable
			? AddGlobalMutableVariable( name_mangled, variable.t.GetLLVMType() )
			: AddGlobalConstantVariable( name_mangled, variable.t.GetLLVMType(), expr.constexpr_value ) );

		unsafe{  LLVMSetInitializer( variable.llvm_value, expr.constexpr_value );  }
	}
	else { halt; }

	if( variable.is_mutable )
	{
		// Reset constexpr flag for mutable variables.
		variable.constexpr_value = LLVMValueRef::Null;
	}

	// Finally, set result variable.
	auto mut lock= global_auto_variable_ptr.lock_mut();
	lock.deref().variable.reset( move(variable) );
}

} // namespace U1
