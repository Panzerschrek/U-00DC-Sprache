import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

// "Class" of function argument in terms of overloading.
enum ArgOverloadingClass
{
	// Value-args (both mutable and immutable), immutable references.
	ImmutableReference,
	// Mutable references.
	MutalbeReference,
}

fn GetArgOverloadingClass( bool is_reference, bool is_mutable ) : ArgOverloadingClass
{
	return select(
		is_reference && is_mutable
			? ArgOverloadingClass::MutalbeReference
			: ArgOverloadingClass::ImmutableReference );
}

fn GetArgOverloadingClass( FunctionType::Arg& arg ) : ArgOverloadingClass
{
	return GetArgOverloadingClass( arg.is_reference, arg.is_mutable );
}

enum ConversionsCompareResult
{
	Same,
	LeftIsBetter,
	RightIsBetter,
	Incomparable
}

fn CompareConversionsMutability(
	FunctionType::Arg& src,
	FunctionType::Arg& dst_left,
	FunctionType::Arg& dst_right ) : ConversionsCompareResult
{
	auto  left_overloding_class= GetArgOverloadingClass(dst_left );
	auto right_overloding_class= GetArgOverloadingClass(dst_right);

	if( left_overloding_class == right_overloding_class )
	{
		return ConversionsCompareResult::Same;
	}
	if( left_overloding_class == ArgOverloadingClass::MutalbeReference )
	{
		return ConversionsCompareResult::LeftIsBetter;
	}
	if( right_overloding_class == ArgOverloadingClass::MutalbeReference )
	{
		return ConversionsCompareResult::RightIsBetter;
	}

	return ConversionsCompareResult::Incomparable;
}

fn CompareConversions(
	FunctionType::Arg& src,
	FunctionType::Arg& dst_left,
	FunctionType::Arg& dst_right ) : ConversionsCompareResult
{
	// TODO - compare type conversions too
	return CompareConversionsMutability( src, dst_left, dst_right );
}

fn CodeBuilder::ApplyOverloadedFunction(
	FunctionsSet &mut functions_set,
	FunctionVariable mut function,
	NamesScopePtr& names_scope,
	FilePos& file_pos ) : bool
{
	if( functions_set.functions.empty() )
	{
		functions_set.functions.push_back(function);
		return true;
	}

	{
		auto& function_type= function.t;

		/*
		Algorithm for overloading applying:
		If parameter count differs - overload function.
		If "ArgOverloadingClass" of one or more arguments differs - overload function.
		*/
		foreach( & set_function : functions_set.functions )
		{
			auto& set_function_type= set_function.t;

			// If argument count differs - allow overloading.
			// SPRACHE_TODO - handle default arguments.
			if( function_type.args.size() != set_function_type.args.size() )
			{
				continue;
			}

			auto mut arg_is_same_count= 0s;
			for( auto mut i= 0s; i < function_type.args.size(); ++i )
			{
				auto& arg= function_type.args[i];
				auto& set_arg= set_function_type.args[i];
				if( arg.arg_type.get_ref() == set_arg.arg_type.get_ref() && GetArgOverloadingClass( arg ) == GetArgOverloadingClass( set_arg ) )
				{
					++arg_is_same_count;
				}
			}

			if( arg_is_same_count == function_type.args.size() )
			{
				REPORT_ERROR( CouldNotOverloadFunction, names_scope, file_pos )
				return false;
			}
		} // For functions in set.
	}

	// No error - add function to set.
	functions_set.functions.push_back( move(function) );
	return true;
}

// TODO - pass array of "Variable" instead of "FunctionType::Arg"
fn CodeBuilder::GetOverloadedFunction(
	FunctionsSet &'x functions_set,
	ust::array_view_imut</FunctionType::Arg/> actual_args,
	bool first_actual_arg_is_this,
	NamesScopePtr& names_scope,
	FilePos& file_pos,
	bool produce_errors ) : ust::optional_ref</FunctionVariable, false/>'x'
{
	var ust::vector</size_type/> mut match_functions;
	auto mut i= 0s;
	foreach( & function : functions_set.functions )
	{
		var FunctionType& function_type= function.t;

		auto mut actual_args_corrected= actual_args;
		if( first_actual_arg_is_this && !function.is_this_call )
		{
			actual_args_corrected.drop_front();
		}

		// TODO - fix foreach and use continue here.
		if( function_type.args.size() == actual_args_corrected.size() )
		{
			auto mut all_args_is_compatible= true;

			for( auto mut arg_n= 0s; arg_n < actual_args_corrected.size(); ++arg_n )
			{
				auto arg_overloading_class= GetArgOverloadingClass( actual_args_corrected[arg_n] );
				auto parameter_overloading_class= GetArgOverloadingClass( function_type.args[arg_n] );

				if( actual_args_corrected[arg_n].arg_type.get_ref() == function_type.args[arg_n].arg_type.get_ref() )
				{} // ok
				else
				{
					// TODO - apply here type/reference conversions
					all_args_is_compatible= false;
					break;
				}

				if( arg_overloading_class == parameter_overloading_class )
				{} // All ok, exact match
				else if( parameter_overloading_class == ArgOverloadingClass::MutalbeReference &&
					arg_overloading_class != ArgOverloadingClass::MutalbeReference )
				{
					// We can only bind nonconst-reference arg to nonconst-reference parameter.
					all_args_is_compatible= false;
					break;
				}
				else if( parameter_overloading_class == ArgOverloadingClass::ImmutableReference &&
					arg_overloading_class == ArgOverloadingClass::MutalbeReference )
				{} // Ok, mut to imut conversion.
				else{ halt; }
			}

			if( all_args_is_compatible )
			{
				match_functions.push_back(i);
			}
		}
		++i;
	}

	if( match_functions.empty() )
	{
		if( produce_errors )
		{
			REPORT_ERROR( CouldNotSelectOverloadedFunction, names_scope, file_pos )
		}
		return ust::optional_ref</FunctionVariable, false/>();
	}

	var ust::vector</bool/> mut best_functions;
	best_functions.resize( match_functions.size(), true );

	// For each argument search functions, which is better, than another functions.
	// For NOT better (four current arg) functions set flags to false.

	for( auto mut arg_n= 0s; arg_n < actual_args.size(); ++arg_n )
	{
		foreach( f_l : match_functions )
		{
			var FunctionVariable& l_function= functions_set.functions[f_l];
			var FunctionType& l_type= l_function.t;

			auto mut l_arg_n= arg_n;
			if( first_actual_arg_is_this && !l_function.is_this_call )
			{
				if( l_arg_n == 0s )
				{
					continue;
				}
				--l_arg_n;
			}

			auto mut is_best_function_for_current_arg= true;
			foreach( f_r : match_functions )
			{
				var FunctionVariable& r_function= functions_set.functions[f_r];
				var FunctionType& r_type= r_function.t;

				auto mut r_arg_n= arg_n;
				if( first_actual_arg_is_this && !r_function.is_this_call )
				{
					if( r_arg_n == 0s )
					{
						continue;
					}
					--r_arg_n;
				}

				auto comp=
					CompareConversions(
						actual_args[arg_n],
						l_type.args[l_arg_n],
						r_type.args[r_arg_n] );

				if( comp == ConversionsCompareResult::Same || comp == ConversionsCompareResult::LeftIsBetter )
				{}
				else
				{
					is_best_function_for_current_arg= false;
					break;
				}
			} // for functions right

			// Set best functions bits.
			if( is_best_function_for_current_arg )
			{
				for( auto mut func_n= 0s; func_n < match_functions.size(); ++func_n )
				{
					var FunctionVariable& r_function= functions_set.functions[cast_imut(match_functions)[func_n]];
					var FunctionType& r_type= r_function.t;

					auto mut r_arg_n= arg_n;
					if( first_actual_arg_is_this && !r_function.is_this_call )
					{
						if( r_arg_n == 0s )
						{
							continue;
						}
						--r_arg_n;
					}

					auto comp=
						CompareConversions(
							actual_args[arg_n],
							l_type.args[l_arg_n],
							r_type.args[r_arg_n] );
					if( comp != ConversionsCompareResult::Same )
					{
						best_functions[func_n]= false;
					}
				}
			}
		} // for functions left
	}

	var ust::optional_ref</FunctionVariable, false/> mut selected_function;
	for( auto mut func_n= 0s; func_n < match_functions.size(); ++func_n )
	{
		if( best_functions[func_n] )
		{
			if( selected_function.empty() )
			{
				selected_function.reset( functions_set.functions[ match_functions[func_n] ] );
			}
			else
			{
				selected_function.reset();
				break;
			}
		}
	}

	if( selected_function.empty() && produce_errors )
	{
		REPORT_ERROR( TooManySuitableOverloadedFunctions, names_scope, file_pos )
	}

	return selected_function;
}

fn CodeBuilder::GetOverloadedOperator(
	mut this,
	ust::array_view_imut</FunctionType::Arg/> args,
	OverloadedOperator operator,
	NamesScopePtr& names_scope, // Needed only for errors reporting
	FilePos& file_pos ) : ust::optional</FunctionVariable/>
{
	foreach( &arg : args )
	{
		if_var( &class_type : arg.arg_type.get_ref().GetClassType() )
		{
			auto class_members= class_type.lock_imut().get_ref().members;
			auto members_lock= class_members.lock_imut();
			auto& members= members_lock.get_ref();
			if_var( &operators_value : members.GetThisScopeValue( OverloadedOperatorToString( operator ) ) )
			{
				auto functions_set_ptr= operators_value.Get</NamesScopeFunctionsSet/>();
				if( !functions_set_ptr.empty() )
				{
					BuildFunctionsSet( class_members, ust::to_non_nullable( functions_set_ptr ), false );

					auto functions_set_lock= functions_set_ptr.lock_imut();
					if_var( &function_selected : GetOverloadedFunction( functions_set_lock.get_ref().functions_set, args, false, names_scope, file_pos, false ) )
					{
						return function_selected;
					}
				}
			}
		}

		if( operator == OverloadedOperator::Indexing || operator == OverloadedOperator::Call )
		{
			break; // For indexing and call operators only check first argument.
		}
	}

	return ust::optional</FunctionVariable/>();
}

} // namespace U
