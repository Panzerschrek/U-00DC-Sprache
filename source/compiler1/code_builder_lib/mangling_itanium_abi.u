import "/string_conversions.u"
import "/keywords.uh"
import "mangling.uh"
?macro <? ADD_NODE:block( ?mangler_state:ident ) ?b:block?>
->
<?
	{
		var ManglerState::NodeHolder ??node( ?mangler_state );
		auto &mut ?mangler_state= ??node.GetManglerState();
		?b
	}
?>

namespace U1
{

fn CreateManglerItaniumABI() : ust::box</IMangler/>
{
	return ust::make_box(ManglerItaniumABI());
}

class ManglerItaniumABI final : IMangler
{
public:
	fn virtual override MangleFunction(
		mut this,
		NamesScope& parent_scope,
		ust::string8& name,
		FunctionType& function_type ) : ust::string8;

	fn virtual override MangleFunction(
		mut this,
		NamesScope& parent_scope,
		ust::string8& name,
		FunctionType& function_type,
		TemplateArgsFinished& template_args ) : ust::string8;

	fn virtual override MangleGlobalVariable( mut this, NamesScope& parent_scope, ust::string8& variable_name, Type& t, bool is_constant ) : ust::string8;
	fn virtual override MangleType( mut this, Type& t ) : ust::string8;
	fn virtual override MangleTemplateArgs( mut this, TemplateArgsFinished& template_args ) : ust::string8;
	fn virtual override MangleVirtualTable( mut this, Type& t ) : ust::string8;

private:
	fn MangleFunctionImpl(
		mut this,
		NamesScope& parent_scope,
		ust::string8& name,
		FunctionType& function_type,
		ust::optional_ref_imut</TemplateArgsFinished/> template_args ) : ust::string8;

private:
	ManglerState state_;
}

fn ManglerItaniumABI::MangleFunction(
	mut this,
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type ) : ust::string8
{
	return MangleFunctionImpl( parent_scope, name, function_type, ust::optional_ref_imut</TemplateArgsFinished/>() );
}

fn ManglerItaniumABI::MangleFunction(
	mut this,
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type,
	TemplateArgsFinished& template_args ) : ust::string8
{
	return MangleFunctionImpl( parent_scope, name, function_type, ust::optional_ref_imut</TemplateArgsFinished/>(template_args) );
}

fn ManglerItaniumABI::MangleGlobalVariable( mut this, NamesScope& parent_scope, ust::string8& variable_name, Type& t, bool is_constant ) : ust::string8
{
	// Variables inside global namespace have simple names.
	if( parent_scope.GetParent().empty() )
	{
		return variable_name + "\0";
	}

	state_.Push( "_Z" );
	EncodeNestedName( state_, variable_name, parent_scope );
	return state_.TakeResult();
}

fn ManglerItaniumABI::MangleType( mut this, Type& t ) : ust::string8
{
	EncodeTypeName(state_, t);
	return state_.TakeResult();
}

fn ManglerItaniumABI::MangleTemplateArgs( mut this, TemplateArgsFinished& template_args ) : ust::string8
{
	EncodeTemplateArgs( state_, template_args );
	return state_.TakeResult();
}

fn ManglerItaniumABI::MangleVirtualTable( mut this,Type& t ) : ust::string8
{
	state_.Push( "_ZTV" );
	EncodeTypeName( state_, t );
	return state_.TakeResult();
}

fn ManglerItaniumABI::MangleFunctionImpl(
	mut this,
	NamesScope& parent_scope,
	ust::string8& name,
	FunctionType& function_type,
	ust::optional_ref_imut</TemplateArgsFinished/> template_args ) : ust::string8
{
	state_.Push( "_Z" );

	var ust::string8 mut name_prefixed= DecodeOperator( name );
	if( name_prefixed.empty() )
	{
		name_prefixed= ust::to_string8( name.size() );
		name_prefixed+= name;
	}

	if( !template_args.empty() )
	{
		ADD_NODE( state_ )
		{
			if( !parent_scope.GetParent().empty() )
			{
				state_.Push( "N" );
				ADD_NODE( state_ )
				{
					EncodeNamespacePrefix_r( state_, parent_scope );
					state_.Push( name_prefixed.range() );
				}

				EncodeTemplateArgs( state_, template_args.try_deref() );
				state_.Push( "Ev" );
			}
			else
			{
				ADD_NODE( state_ )
				{
					state_.Push( name_prefixed.range() );
				}

				EncodeTemplateArgs( state_, template_args.try_deref() );
				state_.Push( "v" );
			}
		}
	}
	else
	{
		if( !parent_scope.GetParent().empty() )
		{
			state_.Push( "N" );
			EncodeNamespacePrefix_r( state_, parent_scope );
			state_.Push( name_prefixed.range() );
			state_.Push( "E" );
		}
		else
		{
			state_.Push( name_prefixed.range() );
		}
	}

	EncodeFunctionParams( state_, function_type.params );

	return state_.TakeResult();
}

class ManglerState
{
public:
	fn Push( mut this, char8 c );
	fn Push( mut this, ust::array_view_imut</char8/> name );
	fn PushLengthPrefixed( mut this, ust::array_view_imut</char8/> name );
	fn PushDecimalNumber( mut this, u64 n );

	fn TakeResult( mut this ) : ust::string8;

public:
	class NodeHolder
	{
	public:
		fn constructor( mut this'a', ManglerState &'b mut state ) ' a <- b '
			( state_(state), start_= state_.GetCurrentPos(), compressed_start_= state_.GetCurrentCompressedPos() )
		{}

		fn destructor()
		{
			state_.FinalizePart( start_, compressed_start_ );
		}

		fn GetManglerState( this'x' ) : ManglerState &'x mut
		{
			return state_;
		}

	private:
		ManglerState &mut state_;
		size_type imut start_;
		size_type imut compressed_start_;
	}

private:
	fn GetCurrentPos( this ) : size_type;
	fn GetCurrentCompressedPos( this ) : size_type;
	fn FinalizePart( mut this, size_type start, size_type compressed_start );

private:
	type LenType= u16;
	struct Substitution
	{
		LenType start;
		LenType size;
	}

private:
	ust::vector</Substitution/> substitutions_;
	ust::string8 result_full_;
	ust::string8 result_compressed_;
}

fn ManglerState::Push( mut this, char8 c )
{
	result_full_.push_back( c );
	result_compressed_.push_back( c );
}

fn ManglerState::Push( mut this, ust::array_view_imut</char8/> name )
{
	result_full_+= name;
	result_compressed_+= name;
}

fn ManglerState::PushLengthPrefixed( mut this, ust::array_view_imut</char8/> name )
{
	PushDecimalNumber( u64(name.size()) );
	Push( name );
}

fn ManglerState::PushDecimalNumber( mut this, u64 n )
{
	// Small optimization for common cases. Needed because "ust::to_string8" allocates memory.
	auto zero_char= u64("0"c8);
	if( n < 10u64 )
	{
		Push( char8( zero_char + n ) );
	}
	else if( n < 100u64 )
	{
		Push( char8( zero_char + n / 10u64 ) );
		Push( char8( zero_char + n % 10u64 ) );
	}
	else if( n < 1000u64 )
	{
		Push( char8( zero_char + n / 100u64 ) );
		Push( char8( zero_char + n / 10u64 % 10u64 ) );
		Push( char8( zero_char + n % 10u64 ) );
	}
	else
	{
		Push( ust::to_string8( n ).range() );
	}
}

fn ManglerState::TakeResult( mut this ) : ust::string8
{
	// Take copy for result. This allows us to re-use internal buffer for mangling of next name.
	result_compressed_.push_back( "\0"c8 );
	var ust::string8 mut result= result_compressed_;

	substitutions_.clear();
	result_full_.clear();
	result_compressed_.clear();

	return move(result);
}

fn ManglerState::GetCurrentPos( this ) : size_type
{
	return result_full_.size();
}

fn ManglerState::GetCurrentCompressedPos( this ) : size_type
{
	return result_compressed_.size();
}

fn ManglerState::FinalizePart( mut this, size_type start, size_type compressed_start )
{
	auto size= result_full_.size() - start;

	// Search for replacement.
	for( auto mut i= 0s; i < substitutions_.size(); ++i )
	{
		var Substitution substitution= substitutions_[i];
		if(
			cast_imut(result_full_).range().subrange( start, start + size ) ==
			cast_imut(result_full_).range().subrange( size_type(substitution.start), size_type(substitution.start) + size_type( substitution.size) ) )
		{
			result_compressed_.resize( compressed_start, "\0"c8 );
			result_compressed_.push_back( "S"c8 );

			if( i > 0s )
			{
				auto n= i - 1s;
				if( n < 36s )
				{
					result_compressed_.push_back( Base36Digit( n ) );
				}
				else if( n < 36s * 36s )
				{
					result_compressed_.push_back( Base36Digit( n / 36s ) );
					result_compressed_.push_back( Base36Digit( n % 36s ) );
				}
				else if( n < 36s * 36s * 36s )
				{
					result_compressed_.push_back( Base36Digit( n / ( 36s * 36s ) ) );
					result_compressed_.push_back( Base36Digit( n / 36s % 36s ) );
					result_compressed_.push_back( Base36Digit( n % 36s ) );
				}
				else { halt; } // Too much substitutions.
			}
			result_compressed_.push_back( "_"c8 );
			return;
		}
	}

	// Not found replacement - add new substitution.
	var Substitution substitution{ .start= LenType(start), .size= LenType(size) };
	substitutions_.push_back( substitution );
}

fn Base36Digit( size_type mut value ) : char8
{
	value %= 36s;
	if( value < 10s )
	{
		return char8(size_type("0"c8) + value);
	}
	else
	{
		return char8(size_type("A"c8) + ( value - 10s ) );
	}
}

fn EncodeNestedName( ManglerState &mut mangler_state, ust::string8& name, NamesScope& parent_scope )
{
	ADD_NODE( mangler_state )
	{
		if( !parent_scope.GetParent().empty() )
		{
			mangler_state.Push( "N" );
			EncodeNamespacePrefix_r( mangler_state, parent_scope );
			mangler_state.PushLengthPrefixed( name.range() );
			mangler_state.Push( "E" );
		}
		else
		{
			mangler_state.PushLengthPrefixed( name.range() );
		}
	}
}

fn EncodeFundamentalTypeName( U_FundamentalType t ) : ust::array_view_imut</ char8 />
{
	if( t == U_FundamentalType::InvalidType ){ return ""; }
	if( t == U_FundamentalType::LastType	){ return ""; }
	if( t == U_FundamentalType::void_		){ return "v"; }
	if( t == U_FundamentalType::bool_		){ return "b"; }
	if( t == U_FundamentalType::i8_			){ return "a"; } // C++ signed char
	if( t == U_FundamentalType::u8_			){ return "h"; } // C++ unsigned char
	if( t == U_FundamentalType::i16_		){ return "s"; }
	if( t == U_FundamentalType::u16_		){ return "t"; }
	if( t == U_FundamentalType::i32_		){ return "i"; }
	if( t == U_FundamentalType::u32_		){ return "j"; }
	if( t == U_FundamentalType::i64_		){ return "x"; }
	if( t == U_FundamentalType::u64_		){ return "y"; }
	if( t == U_FundamentalType::i128_		){ return "n"; }
	if( t == U_FundamentalType::u128_		){ return "o"; }
	if( t == U_FundamentalType::f32_		){ return "f"; }
	if( t == U_FundamentalType::f64_		){ return "d"; }
	if( t == U_FundamentalType::char8_		){ return "c"; }
	if( t == U_FundamentalType::char16_		){ return "Ds"; }
	if( t == U_FundamentalType::char32_		){ return "Di"; }
	// Use vendor-extended types for "byte" types.
	if( t == U_FundamentalType::byte8_		){ return "u5byte8"  ; }
	if( t == U_FundamentalType::byte16_		){ return "u6byte16" ; }
	if( t == U_FundamentalType::byte32_		){ return "u6byte32" ; }
	if( t == U_FundamentalType::byte64_		){ return "u6byte64" ; }
	if( t == U_FundamentalType::byte128_	){ return "u7byte128"; }

	return "";
}

fn EncodeFunctionParam( ManglerState& mut mangler_state, FunctionType::Param& param )
{
	if( param.value_type == ValueType::Value )
	{
		EncodeTypeName( mangler_state, param.t );
	}
	else
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "R" );
			if( param.value_type == ValueType::ReferenceMut )
			{
				EncodeTypeName( mangler_state, param.t );
			}
			else
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( "K" );
					EncodeTypeName( mangler_state, param.t );
				}
			}
		}
	}
}

fn EncodeFunctionParams( ManglerState& mut mangler_state, ust::vector</FunctionType::Param/>& params )
{
	foreach( &param : params )
	{
		if( param.value_type == ValueType::Value &&
			!param.t.GetFundamentalType().empty() &&
			param.t.GetFundamentalType().try_deref().fundamental_type == U_FundamentalType::void_ )
		{
			// We need to distinguish between function with no params (with "v" for params) and function with single "void" param.
			// So, mark real "void: params with "const".
			// Normaly we do not use "konst" prefix for value params, so, "void" type is single exception.
			ADD_NODE( mangler_state )
			{
				mangler_state.Push( "K" );
				EncodeTypeName( mangler_state, param.t );
			}
		}
		else
		{
			EncodeFunctionParam( mangler_state, param );
		}
	}

	if( params.empty() )
	{
		mangler_state.Push( "v" );
	}
}

fn EncodeTemplateClassName( ManglerState &mut mangler_state, ClassType& class_type )
{
	auto& base_template= class_type.base_template.try_deref();
	ADD_NODE( mangler_state )
	{
		// Skip template parameters namespace.
		auto parent= class_type.members.lock_imut().deref().GetParent().try_lock_imut().deref().GetParent();
		if( !parent.try_lock_imut().deref().GetThisNamespaceName().empty() )
		{
			EncodeNamespacePrefix_r( mangler_state, parent.try_lock_imut().deref() );
		}

		auto& class_name= base_template.class_template.deref().syntax_element.deref().name;
		mangler_state.PushLengthPrefixed( class_name.range() );
	}

	EncodeTemplateArgs( mangler_state, base_template.signature_args );
}

fn EncodeTypeName( ManglerState& mut mangler_state, Type& t )
{
	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		mangler_state.Push( EncodeFundamentalTypeName( fundamental_type.fundamental_type ) );
		return;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "A" );
			mangler_state.PushDecimalNumber( array_type.element_count );
			mangler_state.Push( "_" );
			EncodeTypeName( mangler_state, array_type.element_type );
		}
		return;
	}
	if_var( &tuple_type : t.GetTupleType() )
	{
		ADD_NODE( mangler_state )
		{
			ADD_NODE( mangler_state )
			{
				mangler_state.PushLengthPrefixed( KeywordToString( Keyword::tup_ ) );
			}

			mangler_state.Push( "I" );
			foreach( &element_type : tuple_type.element_types )
			{
				EncodeTypeName( mangler_state, element_type );
			}
			mangler_state.Push( "E" );
		}
		return;
	}
	if_var( &class_type_ptr : t.GetClassType() )
	{
		auto class_lock= class_type_ptr.lock_imut();
		auto& class_type= class_lock.deref();
		auto class_members= class_type.members;
		auto class_members_lock= class_members.lock_imut();
		auto& class_members_ref= class_members_lock.deref();

		if( !class_type.typeinfo_src_type_.empty() )
		{
			ADD_NODE( mangler_state )
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.PushLengthPrefixed( class_type.members.lock_imut().deref().GetThisNamespaceName().range() );
				}
				ADD_NODE( mangler_state )
				{
					var TemplateArgsFinished mut typeinfo_args;
					typeinfo_args.push_back( class_type.typeinfo_src_type_.try_deref() );
					EncodeTemplateArgs( mangler_state, typeinfo_args );
				}
			}
		}
		else if( !class_type.base_template.empty() )
		{
			ADD_NODE( mangler_state )
			{
				auto t= class_type.base_template.try_deref().class_template;
				auto t_namespace= t.deref().parent_names_scope.lock();
				if( !t_namespace.empty() && !t_namespace.try_lock_imut().deref().GetParent().empty() )
				{
					mangler_state.Push( "N" );
					EncodeTemplateClassName( mangler_state, class_type );
					mangler_state.Push( "E" );
				}
				else
				{
					EncodeTemplateClassName( mangler_state, class_type );
				}
			}
		}
		else
		{
			EncodeNestedName( mangler_state, class_members_ref.GetThisNamespaceName(), class_members_ref.GetParent().try_lock_imut().deref() );
		}
		return;
	}
	if_var( &enum_type : t.GetEnumType() )
	{
		auto enum_members= enum_type.lock_imut().deref().names_scope;
		auto enum_members_lock= enum_members.lock_imut();
		auto& enum_members_ref= enum_members_lock.deref();

		EncodeNestedName( mangler_state, enum_members_ref.GetThisNamespaceName(), enum_members_ref.GetParent().try_lock_imut().deref() );
		return;
	}
	if_var( &raw_poiter_type : t.GetRawPointerType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "P" );
			EncodeTypeName( mangler_state, raw_poiter_type.element_type );
		}
		return;
	}
	if_var( &function_pointer_type : t.GetFunctionPointerType() )
	{
		ADD_NODE( mangler_state )
		{
			mangler_state.Push( "P" );
			EncodeTypeName( mangler_state, function_pointer_type.function_type );
		}
		return;
	}
	if_var( &function_type : t.GetFunctionType() )
	{
		ADD_NODE( mangler_state )
		{
			if( function_type.calling_convention == LLVMCallConv::C ) {}
			else if( function_type.calling_convention == LLVMCallConv::Cold )
			{
				mangler_state.Push( "U" );
				mangler_state.PushLengthPrefixed( "cold" );
			}
			else if( function_type.calling_convention == LLVMCallConv::Fast )
			{
				mangler_state.Push( "U" );
				mangler_state.PushLengthPrefixed( "fast" );
			}
			else if( function_type.calling_convention == LLVMCallConv::X86Stdcall )
			{
				mangler_state.Push( "U" );
				mangler_state.PushLengthPrefixed( "stdcall" );
			}

			mangler_state.Push( "F" );

			{
				var FunctionType::Param ret_param
				{
					.t( function_type.return_type ),
					.value_type= function_type.return_value_type,
				};

				EncodeFunctionParam( mangler_state, ret_param );
			}

			EncodeFunctionParams( mangler_state, function_type.params );

			if( !function_type.return_references.empty() )
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( "_RR" );

					halt if( function_type.return_references.size() >= 36s );
					mangler_state.Push( Base36Digit(function_type.return_references.size()) );

					foreach( &param_reference : function_type.return_references )
					{
						halt if( param_reference.param_index >= 36u8 );
						halt if( param_reference.reference_index >= 36u8 && param_reference.reference_index != FunctionType::c_param_reference_number );

						mangler_state.Push( Base36Digit( size_type(param_reference.param_index) ) );
						mangler_state.Push( select(
							param_reference.reference_index == FunctionType::c_param_reference_number
							? "_"c8
							: Base36Digit( size_type(param_reference.reference_index) ) ) );
					}
				}
			}
			if( !function_type.references_pollution.empty() )
			{
				ADD_NODE( mangler_state )
				{
					mangler_state.Push( "_RP" );

					halt if( function_type.references_pollution.size() >= 36s );
					mangler_state.Push( Base36Digit(function_type.references_pollution.size()) );

					foreach( &pollution : function_type.references_pollution )
					{
						halt if( pollution.dst.param_index >= 36u8 );
						halt if( pollution.dst.reference_index >= 36u8 && pollution.dst.reference_index != FunctionType::c_param_reference_number );
						halt if( pollution.src.param_index >= 36u8 );
						halt if( pollution.src.reference_index >= 36u8 && pollution.src.reference_index != FunctionType::c_param_reference_number );

						mangler_state.Push( Base36Digit( size_type(pollution.dst.param_index) ) );
						mangler_state.Push( select(
							pollution.dst.reference_index == FunctionType::c_param_reference_number
							? "_"c8
							: Base36Digit( size_type(pollution.dst.reference_index) ) ) );
						mangler_state.Push( Base36Digit( size_type(pollution.src.param_index) ) );
						mangler_state.Push( select(
							pollution.src.reference_index == FunctionType::c_param_reference_number
							? "_"c8
							: Base36Digit( size_type(pollution.src.reference_index) ) ) );
					}
				}
			}
			if( function_type.is_unsafe )
			{
				mangler_state.Push( "unsafe" );
			}

			mangler_state.Push( "E" );
		}
		return;
	}

	halt;
}

fn EncodeNamespacePrefix_r( ManglerState& mut mangler_state, NamesScope& names_scope )
{
	var ust::string8& name= names_scope.GetThisNamespaceName();

	// Process separately class templates.
	auto class_ptr= names_scope.GetClass();
	if( !class_ptr.empty() )
	{
		auto class_lock= class_ptr.try_lock_imut();
		auto& class_= class_lock.deref();
		if( !class_.base_template.empty() )
		{
			ADD_NODE( mangler_state )
			{
				EncodeTemplateClassName( mangler_state, class_ );
			}
			return;
		}
	}

	ADD_NODE( mangler_state )
	{
		auto parent= names_scope.GetParent();
		if( !parent.empty() )
		{
			auto parent_lock= parent.try_lock_imut();
			auto& parent_ref= parent_lock.deref();
			if( !parent_ref.GetThisNamespaceName().empty() )
			{
				EncodeNamespacePrefix_r( mangler_state, parent_ref );
			}
		}

		mangler_state.PushLengthPrefixed( name.range() );
	}
}

fn EncodeTemplateArgs( ManglerState &mut mangler_state, TemplateArgsFinished& template_args )
{
	mangler_state.Push( "I" );

	foreach( &arg : template_args )
	{
		if_var( &t : arg.get</Type/>() )
		{
			EncodeTypeName( mangler_state, t );
		}
		if_var( &v_ptr : arg.get</VariablePtr/>() )
		{
			auto lock= v_ptr.lock_imut();
			auto& v= lock.deref();

			mangler_state.Push( "L" );
			EncodeTypeName( mangler_state, v.t );

			auto mut is_signed= false;
			if_var( fundamental_type : v.t.GetFundamentalType() )
			{
				is_signed= IsSignedInteger( fundamental_type.fundamental_type );
			}
			if_var( enum_type : v.t.GetEnumType() )
			{
				is_signed= IsSignedInteger( enum_type.lock_imut().deref().underlaying_type.fundamental_type );
			}

			if( v.constexpr_value != LLVMValueRef::Null )
			{
				if( is_signed )
				{
					auto num= unsafe( LLVMConstIntGetSExtValue( v.constexpr_value ) );
					if( num >= 0i64 )
					{
						mangler_state.PushDecimalNumber( u64(num) );
					}
					else
					{
						mangler_state.Push( "n" );
						mangler_state.PushDecimalNumber( u64(-num) );
					}
				}
				else
				{
					mangler_state.PushDecimalNumber( unsafe( LLVMConstIntGetZExtValue( v.constexpr_value ) ) );
				}
			}

			mangler_state.Push( "E" );
		}
	}

	mangler_state.Push( "E" );
}

fn DecodeOperator( ust::string8& o ) : ust::array_view_imut</ char8 />
{
	if( o == "+" ){ return "pl"; }
	if( o == "-" ){ return "mi"; }
	if( o == "*" ){ return "ml"; }
	if( o == "/" ){ return "dv"; }
	if( o == "%" ){ return "rm"; }

	if( o == "==" ){ return "eq"; }
	if( o == "<=>" ){ return "ss"; } // C++ spaceship operator

	if( o == "&" ){ return "an"; }
	if( o == "|" ){ return "or"; }
	if( o == "^" ){ return "eo"; }

	if( o == "<<" ){ return "ls"; }
	if( o == ">>" ){ return "rs"; }

	if( o == "+=" ){ return "pL"; }
	if( o == "-=" ){ return "mI"; }
	if( o == "*=" ){ return "mL"; }
	if( o == "/=" ){ return "dV"; }
	if( o == "%=" ){ return "rM"; }

	if( o == "&=" ){ return "aN"; }
	if( o == "|=" ){ return "oR"; }
	if( o == "^=" ){ return "eO"; }

	if( o == "<<=" ){ return "lS"; }
	if( o == ">>=" ){ return "rS"; }

	if( o == "!" ){ return "nt"; }
	if( o == "~" ){ return "co"; }

	if( o == "=" ){ return "aS"; }
	if( o == "++" ){ return "pp"; }
	if( o == "--" ){ return "mm"; }

	if( o == "()" ){ return "cl"; }
	if( o == "[]" ){ return "ix"; }

	return "";
}

} // namespace U1
