import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Initializer& initializer )
{
	variant_visit( &i : initializer )
	{
		BuildInitializer( names_scope, function_context, variable, i );
	}
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::EmptyVariant& empty_initializer )
{
	halt;
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& expression_initializer )
{
	if( !variable.t.GetFundamentalType().empty() )
	{
		auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression_initializer );
		if( expr_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, Synt::GetFilePos(expression_initializer), variable.t, expr_result.t )
			return;
		}

		unsafe
		{
			auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr_result, function_context );
			LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, variable.llvm_value );
		}
		return;
	}
	if( !variable.t.GetArrayType().empty() )
	{
		REPORT_ERROR( NotImplemented, names_scope, Synt::GetFilePos(expression_initializer), ust::string8("expression initialization for arrays") )
		return;
	}
	if_var( &class_type : variable.t.GetClassType() )
	{
		auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression_initializer );
		if( expr_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, FilePos(), variable.t, expr_result.t )
			return;
		}
		TryCallCopyConstructor( names_scope, function_context, variable.llvm_value, expr_result.llvm_value, class_type, Synt::GetFilePos(expression_initializer) );
		return;
	}

	halt; // Unhandled type kind
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::SequenceInitializer& sequence_initializer )
{
	if_var( &array_type : variable.t.GetArrayType() )
	{
		if( sequence_initializer.elements_initializers.size() != array_type.element_count )
		{
			REPORT_ERROR( ArrayInitializersCountMismatch,
				names_scope,
				sequence_initializer.file_pos,
				array_type.element_count,
				sequence_initializer.elements_initializers.size() )
			return;
		}

		var NamesScopeVariable mut element_variable
		{
			.t= array_type.element_type.get_ref(),
		};

		auto mut i= 0s;
		foreach( &element_initializer : sequence_initializer.elements_initializers )
		{
			unsafe
			{
				var [ LLVMValueRef, 2 ] indexes
				[
					GetZeroGEPIndex(),
					LLVMConstInt( fundamental_llvm_types_.u32_, u64(i), LLVMBool::False )
				];

				element_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
			}

			BuildInitializer( names_scope, function_context, element_variable, element_initializer.get_ref() );
			++i;
		}

		return;
	}

	REPORT_ERROR( ArrayInitializerForNonArray, names_scope, sequence_initializer.file_pos )
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::StructNamedInitializer& struct_named_initializer )
{
	auto class_type_ref= variable.t.GetClassType();
	if( class_type_ref.empty() )
	{
		REPORT_ERROR( StructInitializerForNonStruct, names_scope, struct_named_initializer.file_pos )
		return;
	}
	var ClassTypePtr& class_type_ptr= class_type_ref.get_ref();
	auto class_type_lock= class_type_ptr.lock_imut();
	var ClassType& class_type= class_type_lock.get_ref();

	auto members_lock= class_type.members.lock_imut();
	var NamesScope& class_members= members_lock.get_ref();

	if( class_type.have_explicit_noncopy_constructors )
	{
		REPORT_ERROR( InitializerDisabledBecauseClassHaveExplicitNoncopyConstructors, names_scope, struct_named_initializer.file_pos )
	}

	foreach( &member_initializer : struct_named_initializer.members_initializers )
	{
		// TODO - use unordered_set
		foreach( &prev_initializer : struct_named_initializer.members_initializers )
		{
			if( ust::ref_to_int(prev_initializer) < ust::ref_to_int(member_initializer) &&
				member_initializer.name == prev_initializer.name )
			{
				REPORT_ERROR( DuplicatedStructMemberInitializer, names_scope, member_initializer.file_pos, member_initializer.name )
			}
		}

		auto member_ref= class_members.GetThisScopeValue( member_initializer.name );
		if( member_ref.empty() )
		{
			REPORT_ERROR( NameNotFound, names_scope, member_initializer.file_pos, member_initializer.name )
			return; // TODO - continue instead
		}
		auto field_ptr= member_ref.get_ref().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			REPORT_ERROR( InitializerForNonfieldStructMember, names_scope, member_initializer.file_pos, member_initializer.name )
			return; // TODO - continue instead
		}
		auto field_lock= field_ptr.lock_imut();
		var ClassField& class_field= field_lock.get_ref();

		var NamesScopeVariable mut member_variable
		{
			.t= class_field.t
		};

		auto op_name_nt= "." + member_initializer.name + "\0";
		unsafe
		{
			var [ LLVMValueRef, 2 ] indexes
			[
				GetZeroGEPIndex(),
				LLVMConstInt( fundamental_llvm_types_.u32_, u64(class_field.index), LLVMBool::False )
			];

			member_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, op_name_nt.front() );
		}
		BuildInitializer( names_scope, function_context, member_variable, member_initializer.initializer.get_ref() );
	}

	// Apply empty initializer for fileds, missing in struct named initializer.
	foreach( &class_member : class_members.GetInternalContainer() )
	{
		auto field_ptr= class_member.value().Get</ ClassField />();
		if( !field_ptr.empty() )
		{
			auto mut found= false;
			foreach( &member_initializer : struct_named_initializer.members_initializers )
			{
				if( member_initializer.name == class_member.key() )
				{
					found= true;
					break;
				}
			}

			if( !found )
			{
				auto field_lock= field_ptr.lock_imut();
				var ClassField & field= field_lock.get_ref();

				var NamesScopeVariable mut member_variable
				{
					.t= field.t
				};

				auto op_name_nt= "." + field.syntax_element.get_ref().name + "\0";
				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes
					[
						GetZeroGEPIndex(),
						LLVMConstInt( fundamental_llvm_types_.u32_, u64(field.index), LLVMBool::False )
					];

					member_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, op_name_nt.front() );
				}

				BuildEmptyInitializer( names_scope, function_context, member_variable, class_member.key(), struct_named_initializer.file_pos );
			}
		}
	}
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ConstructorInitializer& constructor_initializer )
{
	BuildConstructorInitializer( names_scope, function_context, variable, constructor_initializer.args, constructor_initializer.file_pos );
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ZeroInitializer& zero_initializer )
{
	if_var( &fundamental_type : variable.t.GetFundamentalType() )
	{
		var LLVMValueRef mut zero_value= zero_init;
		if( fundamental_type.fundamental_type == U_FundamentalType::bool_ ||
			IsInteger( fundamental_type.fundamental_type ) ||
			IsChar( fundamental_type.fundamental_type ) )
		{
			unsafe{  zero_value= LLVMConstInt( fundamental_type.llvm_type, 0u64, LLVMBool::False );  }
		}
		else
		{
			unsafe{  zero_value= LLVMConstReal( fundamental_type.llvm_type, 0.0 );  }
		}

		unsafe{  LLVMBuildStore( function_context.llvm_ir_builder, zero_value, variable.llvm_value );  }
		return;
	}
	if_var( &array_type : variable.t.GetArrayType() )
	{
		var NamesScopeVariable mut element_variable
		{
			.t= array_type.element_type.get_ref()
		};

		auto mut i= 0u64;
		while( i < array_type.element_count )
		{
			unsafe
			{
				var [ LLVMValueRef, 2 ] indexes
				[
					GetZeroGEPIndex(),
					LLVMConstInt( fundamental_llvm_types_.u32_, u64(i), LLVMBool::False )
				];

				element_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
			}

			BuildInitializer( names_scope, function_context, element_variable, zero_initializer );
			++i;
		}
		return;
	}
	if_var( &class_type_ptr : variable.t.GetClassType() )
	{
		auto class_type_lock= class_type_ptr.lock_imut();
		var ClassType& class_type= class_type_lock.get_ref();
		auto members_lock= class_type.members.lock_imut();
		var NamesScope& class_members= members_lock.get_ref();

		foreach( &class_member : class_members.GetInternalContainer() )
		{
			auto field_ptr= class_member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				auto field_lock= field_ptr.lock_imut();
				var ClassField& field= field_lock.get_ref();

				var NamesScopeVariable mut member_variable
				{
					.t= field.t
				};

				auto op_name_nt= "." + field.syntax_element.get_ref().name + "\0";
				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes
					[
						GetZeroGEPIndex(),
						LLVMConstInt( fundamental_llvm_types_.u32_, u64(field.index), LLVMBool::False )
					];

					member_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, op_name_nt.front() );
				}

				BuildInitializer( names_scope, function_context, member_variable, zero_initializer );
			}
		}
		return;
	}

	halt;
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::UninitializedInitializer& uninitialized_initializer )
{
	// TODO - emit error if not in unsafe block
}

fn CodeBuilder::BuildEmptyInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::string8& variable_name, FilePos& file_pos )
{
	if( !variable.t.IsDefaultConstructible() )
	{
		REPORT_ERROR( ExpectedInitializer, names_scope, file_pos, variable_name )
		return;
	}

	if_var( &array_type : variable.t.GetArrayType() )
	{
		var NamesScopeVariable mut element_variable
		{
			.t= array_type.element_type.get_ref()
		};

		auto mut i= 0u64;
		while( i < array_type.element_count )
		{
			unsafe
			{
				var [ LLVMValueRef, 2 ] indexes
				[
					GetZeroGEPIndex(),
					LLVMConstInt( fundamental_llvm_types_.u32_, u64(i), LLVMBool::False )
				];

				element_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
			}

			BuildEmptyInitializer( names_scope, function_context, element_variable, variable_name, file_pos );
			++i;
		}
		return;
	}
	if_var( &class_type_ptr : variable.t.GetClassType() )
	{
		auto class_members= class_type_ptr.lock_imut().get_ref().members;
		auto members_lock= class_members.lock_imut();

		auto member= members_lock.get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) );
		if( member.empty() )
		{
			// May be in case of error
			return;
		}

		auto constructors_ptr= member.get_ref().Get</NamesScopeFunctionsSet/>();
		// Should be functions set 100%
		// Should be complete here.

		var Variable this_
		{
			.t= variable.t,
			.value_type= ValueType::ReferenceMut,
			.llvm_value= variable.llvm_value,
		};

		var ust::vector</ ust::shared_ptr_final</Synt::Expression/> /> empty_args_list;

		CallFunctionsSet(
			names_scope,
			function_context,
			ust::optional_ref</ Variable, false />( this_ ),
			constructors_ptr.lock_imut().get_ref().functions_set,
			empty_args_list,
			file_pos );

		return;
	}
}

fn CodeBuilder::BuildConstructorInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args, FilePos& file_pos )
{
	if_var( &dst_type : variable.t.GetFundamentalType() )
	{
		if( args.size() != 1s )
		{
			REPORT_ERROR( FundamentalTypesHaveConstructorsWithExactlyOneParameter, names_scope, file_pos )
			return;
		}

		var Variable src_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, args.front().get_ref() );
		auto src_type_ref= src_var.t.GetFundamentalType();

		if( src_type_ref.empty() )
		{
			REPORT_ERROR( TypesMismatch, names_scope, file_pos, variable.t, src_var.t )
			return;
		}
		var FundamentalType& src_type= src_type_ref.get_ref();

		auto mut llvm_value= CreateMoveToLLVMRegisterInstruction( src_var, function_context );
		unsafe
		{
			if( src_type.fundamental_type == dst_type.fundamental_type )
			{}
			else if( IsInteger( dst_type.fundamental_type ) && IsInteger( src_type.fundamental_type ) )
			{
				// int to int
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					// We lost here some values in conversions, such i16 => u32, if src_type is signed.
					if( IsUnsignedInteger( dst_type.fundamental_type ) )
					{
						llvm_value= LLVMBuildZExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
					else
					{
						llvm_value= LLVMBuildSExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else{} // Same size integers - do nothing
			}
			else if( IsFloatingPoint( dst_type.fundamental_type ) && IsFloatingPoint( src_type.fundamental_type ) )
			{
				// float to float
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					llvm_value= LLVMBuildFPExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildFPTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else{ halt; } // WTF?
			}
			else if( IsFloatingPoint( dst_type.fundamental_type ) && IsInteger( src_type.fundamental_type ) )
			{
				// int to float
				if( IsSignedInteger( src_type.fundamental_type ) )
				{
					llvm_value= LLVMBuildSIToFP( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else
				{
					llvm_value= LLVMBuildUIToFP( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
			}
			else if( IsInteger( dst_type.fundamental_type ) && IsFloatingPoint( src_type.fundamental_type ) )
			{
				// float to int
				if( IsSignedInteger( dst_type.fundamental_type ) )
				{
					llvm_value= LLVMBuildFPToSI( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else
				{
					llvm_value= LLVMBuildFPToUI( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
			}
			else if( IsChar( dst_type.fundamental_type ) && ( IsInteger( src_type.fundamental_type ) || IsChar( src_type.fundamental_type ) ) )
			{
				// int to char or char to char
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					llvm_value= LLVMBuildZExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
			}
			else if( IsInteger( dst_type.fundamental_type ) && IsChar( src_type.fundamental_type ) )
			{
				// char to int
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					// We lost here some values in conversions, such i16 => u32, if src_type is signed.
					if( IsUnsignedInteger( dst_type.fundamental_type ) )
					{
						llvm_value= LLVMBuildZExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
					else
					{
						llvm_value= LLVMBuildSExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else{} // Same size - do nothing
			}
			else
			{
				if( dst_type.fundamental_type == U_FundamentalType::bool_ )
				{
					// TODO - error, bool have no constructors from other types
				}
				REPORT_ERROR( TypesMismatch, names_scope, file_pos, variable.t, src_var.t )
				return;
			}

			LLVMBuildStore( function_context.llvm_ir_builder, llvm_value, variable.llvm_value );
		}

		return;
	}
	if_var( &class_type : variable.t.GetClassType() )
	{
		auto class_members= class_type.lock_imut().get_ref().members;
		auto members_lock= class_members.lock_imut();

		auto member= members_lock.get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) );
		if( member.empty() )
		{
			REPORT_ERROR( ClassHaveNoConstructors, names_scope, file_pos )
			return;
		}

		auto constructors_ptr= member.get_ref().Get</NamesScopeFunctionsSet/>();
		// Should be functions set 100%
		// Should be complete here.

		var Variable this_
		{
			.t= variable.t,
			.value_type= ValueType::ReferenceMut,
			.llvm_value= variable.llvm_value,
		};
		CallFunctionsSet(
			names_scope,
			function_context,
			ust::optional_ref</ Variable, false />( this_ ),
			constructors_ptr.lock_imut().get_ref().functions_set,
			args,
			file_pos );

		return;
	}

	REPORT_ERROR( ConstructorInitializerForUnsupportedType, names_scope, file_pos )
	return;
}

fn CodeBuilder::BuildConstructorInitialization(
	this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	Synt::StructNamedInitializer& constructor_initialization_list )
{
	// Function context should contain "this" with class type
	auto class_type= function_context.this_.get_ref().t.GetClassType().get_ref();
	auto class_members= class_type.lock_imut().get_ref().members;

	// Check for errors, build list of initialized fields.
	var ust::vector</ust::string8/> mut initialized_fields;
	auto mut have_fields_errors= false;
	foreach( &member_initializer : constructor_initialization_list.members_initializers )
	{
		auto class_members_lock= class_members.lock_imut();
		auto member= class_members_lock.get_ref().GetThisScopeValue( member_initializer.name );
		if( member.empty() )
		{
			have_fields_errors= true;
			REPORT_ERROR( NameNotFound, names_scope, member_initializer.file_pos, member_initializer.name )
		}
		else
		{
			auto class_field_ptr= member.get_ref().Get</ClassField/>();
			if( class_field_ptr.empty() )
			{
				have_fields_errors= true;
				REPORT_ERROR( InitializerForNonfieldStructMember, names_scope, member_initializer.file_pos, member_initializer.name )
			}
			else
			{
				auto mut found= false;
				foreach( &prev_field : initialized_fields )
				{
					if( member_initializer.name == prev_field )
					{
						found= true;
						break;
					}
				}

				if( found )
				{
					have_fields_errors= true;
					REPORT_ERROR( DuplicatedStructMemberInitializer, names_scope, member_initializer.file_pos, member_initializer.name )
				}
				else
				{
					initialized_fields.push_back( member_initializer.name );
					function_context.uninitialized_this_fields.push_back( member_initializer.name );
				}
			}
		}
	}

	var ust::vector</ust::string8/> mut uninitialized_fields;

	foreach( &class_member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= class_member.value().Get</ ClassField />();
		if( !field_ptr.empty() )
		{
			auto mut found= false;
			foreach( &prev_field : initialized_fields )
			{
				if( class_member.key() == prev_field )
				{
					found= true;
					break;
				}
			}
			if( !found )
			{
				uninitialized_fields.push_back( class_member.key() );
			}
		}
	}

	// Initialize fields, missing in initializer list.
	// TODO - use fiedls order.
	foreach( &field_name : uninitialized_fields )
	{
		auto field_ptr= class_members.lock_imut().get_ref().GetThisScopeValue( field_name ).get_ref().Get</ClassField/>();
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		var NamesScopeVariable mut field_variable
		{
			.t= class_field.t,
			.is_mutable= true,
		};

		auto op_name_nt= "." + field_name + "\0";
		unsafe
		{
			var [ LLVMValueRef, 2 ] indexes
			[
				GetZeroGEPIndex(),
				LLVMConstInt( fundamental_llvm_types_.u32_, u64(class_field.index), LLVMBool::False )
			];

			field_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, function_context.this_.get_ref().llvm_value, indexes[0], 2u, op_name_nt.front() );
		}

		BuildEmptyInitializer( names_scope, function_context, field_variable, field_name, constructor_initialization_list.file_pos );
	}

	if( have_fields_errors )
	{
		return;
	}

	// Apply explicit initializers.
	foreach( &member_initializer : constructor_initialization_list.members_initializers )
	{
		auto field_ptr= class_members.lock_imut().get_ref().GetThisScopeValue( member_initializer.name ).get_ref().Get</ClassField/>();
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		var NamesScopeVariable mut field_variable
		{
			.t= class_field.t,
			.is_mutable= true,
		};

		auto op_name_nt= "." + member_initializer.name + "\0";
		unsafe
		{
			var [ LLVMValueRef, 2 ] indexes
			[
				GetZeroGEPIndex(),
				LLVMConstInt( fundamental_llvm_types_.u32_, u64(class_field.index), LLVMBool::False )
			];

			field_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, function_context.this_.get_ref().llvm_value, indexes[0], 2u, op_name_nt.front() );
		}

		BuildInitializer( names_scope, function_context, field_variable, member_initializer.initializer.get_ref() );

		// Erase field from list of uninitialized fields.
		auto mut i= 0s;
		while( i < function_context.uninitialized_this_fields.size() )
		{
			if( member_initializer.name == function_context.uninitialized_this_fields[i] )
			{
				auto back_index= function_context.uninitialized_this_fields.size() - 1s;
				function_context.uninitialized_this_fields.swap( i, back_index );
				function_context.uninitialized_this_fields.drop_back();
				break;
			}
			++i;
		}
	}
}

} // namespace U
