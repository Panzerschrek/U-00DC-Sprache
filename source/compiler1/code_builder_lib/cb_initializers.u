import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Initializer& initializer ) : LLVMValueRef
{
	variant_visit( &i : initializer )
	{
		return BuildInitializer( names_scope, function_context, variable, i );
	}
	halt;
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::EmptyVariant& empty_initializer ) : LLVMValueRef
{
	halt;
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& expression_initializer ) : LLVMValueRef
{
	if( !variable.t.GetFundamentalType().empty() || !variable.t.GetEnumType().empty() )
	{
		auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression_initializer );
		if( expr_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, Synt::GetFilePos(expression_initializer), variable.t, expr_result.t )
			return LLVMValueRef::Null;
		}

		unsafe
		{
			auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr_result, function_context );
			LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, variable.llvm_value );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, Synt::GetFilePos(expression_initializer) );

		return expr_result.constexpr_value;
	}
	if( !variable.t.GetFunctionPointerType().empty() )
	{
		return InitializeFunctionPointer( names_scope, function_context, variable, expression_initializer );
	}
	if( !variable.t.GetArrayType().empty() )
	{
		REPORT_ERROR( NotImplemented, names_scope, Synt::GetFilePos(expression_initializer), ust::string8("expression initialization for arrays") )
		return LLVMValueRef::Null;
	}
	if( !variable.t.GetTupleType().empty() )
	{
		auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression_initializer );
		if( expr_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, Synt::GetFilePos(expression_initializer), variable.t, expr_result.t )
			return LLVMValueRef::Null;
		}

		if( expr_result.value_type == ValueType::Value )
		{
			// Move.
			if( expr_result.node_id != ReferencesGraph::c_empty_node_id )
			{
				function_context.references_graph.MoveNode( expr_result.node_id );
			}
			CopyBytes( variable.llvm_value, expr_result.llvm_value, variable.t, function_context );
		}
		else
		{
			// Copy.
			if( !variable.t.IsCopyConstructible() )
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, Synt::GetFilePos(expression_initializer), variable.t )
				return LLVMValueRef::Null;
			}

			BuildCopyConstructorPart( names_scope, function_context, variable.llvm_value, expr_result.llvm_value, variable.t, Synt::GetFilePos(expression_initializer) );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, Synt::GetFilePos(expression_initializer) );

		// Copy constructor for constexpr type is trivial, so, we can just take constexpr value of source.
		return expr_result.constexpr_value;
	}
	if_var( &class_type : variable.t.GetClassType() )
	{
		auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression_initializer );
		if( !expr_result.t.ReferenceIsConvertibleTo( variable.t ) )
		{
			REPORT_ERROR( TypesMismatch, names_scope, FilePos(), variable.t, expr_result.t )
			return LLVMValueRef::Null;
		}

		if( expr_result.value_type == ValueType::Value && expr_result.t == variable.t )
		{
			// Move.
			if( expr_result.node_id != ReferencesGraph::c_empty_node_id )
			{
				function_context.references_graph.MoveNode( expr_result.node_id );
			}
			CopyBytes( variable.llvm_value, expr_result.llvm_value, variable.t, function_context );
		}
		else
		{
			// Copy.
			auto mut value_for_copy= CreateReferenceCast( expr_result.llvm_value, expr_result.t, variable.t, function_context );
			TryCallCopyConstructor( names_scope, function_context, variable.llvm_value, value_for_copy, class_type, Synt::GetFilePos(expression_initializer) );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, Synt::GetFilePos(expression_initializer) );

		return LLVMValueRef::Null;
	}

	halt; // Unhandled type kind
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::SequenceInitializer& sequence_initializer ) : LLVMValueRef
{
	if_var( &array_type : variable.t.GetArrayType() )
	{
		if( sequence_initializer.elements_initializers.size() != size_type(array_type.element_count) )
		{
			REPORT_ERROR( ArrayInitializersCountMismatch,
				names_scope,
				sequence_initializer.file_pos,
				array_type.element_count,
				sequence_initializer.elements_initializers.size() )
			return LLVMValueRef::Null;
		}

		auto mut is_constant= variable.t.CanBeConstexpr();
		var ust::vector</ LLVMValueRef /> mut elements_constants;

		var NamesScopeVariable mut element_variable
		{
			.t= array_type.element_type,
		};

		auto mut i= 0s;
		foreach( &element_initializer : sequence_initializer.elements_initializers )
		{
			unsafe
			{
				var [ LLVMValueRef, 2 ] indexes
				[
					GetZeroGEPIndex(),
					LLVMConstInt( fundamental_llvm_types_.u32_, u64(i), LLVMBool::False )
				];

				element_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
			}

			auto element_constant= BuildInitializer( names_scope, function_context, element_variable, element_initializer.get_ref() );

			if( is_constant )
			{
				if( element_constant == LLVMValueRef::Null )
				{
					is_constant= false;
				}
				else
				{
					elements_constants.push_back( element_constant );
				}
			}

			++i;
		}

		if( is_constant )
		{
			halt if( elements_constants.size() != size_type(array_type.element_count) ); // TODO - replace with assert
			unsafe
			{
				return LLVMConstArray( element_variable.t.GetLLVMType(), cast_imut(elements_constants).front_unsafe(), u32(elements_constants.size()) );
			}
		}
		return LLVMValueRef::Null;
	}
	if_var( tuple_type : variable.t.GetTupleType() )
	{
		if( sequence_initializer.elements_initializers.size() != tuple_type.element_types.size() )
		{
			REPORT_ERROR( TupleInitializersCountMismatch,
				names_scope,
				sequence_initializer.file_pos,
				tuple_type.element_types.size(),
				sequence_initializer.elements_initializers.size() )
			return LLVMValueRef::Null;
		}

		auto mut is_constant= variable.t.CanBeConstexpr();
		var ust::vector</ LLVMValueRef /> mut elements_constants;

		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			var NamesScopeVariable element_variable
			{
				.t= tuple_type.element_types[i],
				.llvm_value= CreateTupleElementGEP( variable.llvm_value, i, function_context ),
			};

			auto element_constant= BuildInitializer( names_scope, function_context, element_variable, sequence_initializer.elements_initializers[i].get_ref() );

			if( is_constant )
			{
				if( element_constant == LLVMValueRef::Null )
				{
					is_constant= false;
				}
				else
				{
					elements_constants.push_back( element_constant );
				}
			}
		}

		if( is_constant )
		{
			halt if( elements_constants.size() != tuple_type.element_types.size() ); // TODO - replace with assert
			unsafe
			{
				return LLVMConstStructInContext( llvm_context_, cast_imut(elements_constants).front_unsafe(), u32(elements_constants.size()), LLVMBool::False );
			}
		}
		return LLVMValueRef::Null;
	}

	REPORT_ERROR( ArrayInitializerForNonArray, names_scope, sequence_initializer.file_pos )
	return LLVMValueRef::Null;
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::StructNamedInitializer& struct_named_initializer ) : LLVMValueRef
{
	auto class_type_ref= variable.t.GetClassType();
	if( class_type_ref.empty() )
	{
		REPORT_ERROR( StructInitializerForNonStruct, names_scope, struct_named_initializer.file_pos )
		return LLVMValueRef::Null;
	}
	var ClassTypePtr& class_type_ptr= class_type_ref.get_ref();
	auto class_type_lock= class_type_ptr.lock_imut();
	var ClassType& class_type= class_type_lock.get_ref();

	auto members_lock= class_type.members.lock_imut();
	var NamesScope& class_members= members_lock.get_ref();

	if( class_type.have_explicit_noncopy_constructors )
	{
		REPORT_ERROR( InitializerDisabledBecauseClassHaveExplicitNoncopyConstructors, names_scope, struct_named_initializer.file_pos )
	}
	if( class_type.kind != ClassType::Kind::Struct )
	{
		REPORT_ERROR( StructInitializerForNonStruct, names_scope, struct_named_initializer.file_pos )
	}

	var ust::vector</LLVMValueRef/> mut constant_initializers;
	auto mut is_constexpr= class_type.can_be_constexpr;
	if( is_constexpr )
	{
		unsafe
		{
			constant_initializers.resize(
				size_type( LLVMCountStructElementTypes( class_type.llvm_type ) ),
				LLVMValueRef::Null );
		}
	}

	foreach( &member_initializer : struct_named_initializer.members_initializers )
	{
		// TODO - use unordered_set
		foreach( &prev_initializer : struct_named_initializer.members_initializers )
		{
			if( ust::ref_to_int(prev_initializer) < ust::ref_to_int(member_initializer) &&
				member_initializer.name == prev_initializer.name )
			{
				REPORT_ERROR( DuplicatedStructMemberInitializer, names_scope, member_initializer.file_pos, member_initializer.name )
			}
		}

		auto member_ref= class_members.GetThisScopeValue( member_initializer.name );
		if( member_ref.empty() )
		{
			REPORT_ERROR( NameNotFound, names_scope, member_initializer.file_pos, member_initializer.name )
			return LLVMValueRef::Null;
		}
		auto field_ptr= member_ref.get_ref().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			REPORT_ERROR( InitializerForNonfieldStructMember, names_scope, member_initializer.file_pos, member_initializer.name )
			return LLVMValueRef::Null;
		}
		auto field_lock= field_ptr.lock_imut();
		var ClassField& class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ is_constexpr= false; continue; } // May be in case of error

		if( class_field.is_reference )
		{
			auto initializer= InitializeReferenceField( names_scope, function_context, variable, class_field, member_initializer.initializer.get_ref() );
			if( initializer == LLVMValueRef::Null )
			{
				is_constexpr= false;
			}
			if( is_constexpr )
			{
				constant_initializers[class_field.index]= initializer;
			}
		}
		else
		{
			var NamesScopeVariable member_variable
			{
				.t= class_field.t,
				.llvm_value= CreateFieldGEP( variable.llvm_value, class_field, function_context )
			};

			auto initializer= BuildInitializer( names_scope, function_context, member_variable, member_initializer.initializer.get_ref() );
			if( initializer == LLVMValueRef::Null )
			{
				is_constexpr= false;
			}
			if( is_constexpr )
			{
				constant_initializers[class_field.index]= initializer;
			}
		}
	}

	// Apply default initializer for fields, missing in struct named initializer.
	foreach( &field_name : class_type.fields_order )
	{
		auto field_ptr= class_members.GetThisScopeValue(field_name).get_ref().Get</ClassField/>();
		auto mut found= false;
		foreach( &member_initializer : struct_named_initializer.members_initializers )
		{
			if( member_initializer.name == field_name )
			{
				found= true;
				break;
			}
		}
		if( found )
		{
			continue;
		}

		auto field_lock= field_ptr.lock_imut();
		var ClassField & field= field_lock.get_ref();

		if( field.index == ~0s ){ continue; } // May be in case of error

		var NamesScopeVariable member_variable
		{
			.t= field.t,
			.llvm_value= CreateFieldGEP( variable.llvm_value, field, function_context )
		};

		auto mut constexpr_initializer= LLVMValueRef::Null;
		auto& initializer= field.syntax_element.get_ref().initializer;
		if( !initializer.get</Synt::EmptyVariant/>().empty() )
		{
			if( field.is_reference )
			{
				REPORT_ERROR( ExpectedInitializer, names_scope, struct_named_initializer.file_pos, field_name )
				continue;
			}

			BuildEmptyInitializer( names_scope, function_context, member_variable, field_name, struct_named_initializer.file_pos );
		}
		else
		{
			if( field.is_reference )
			{
				constexpr_initializer= InitializeReferenceField( class_type.members, function_context, variable, field, initializer );
			}
			else
			{
				constexpr_initializer= BuildInitializer( class_type.members, function_context, member_variable, initializer );
			}
		}

		if( constexpr_initializer == LLVMValueRef::Null )
		{
			is_constexpr= false;
		}
		if( is_constexpr )
		{
			constant_initializers[field.index]= constexpr_initializer;
		}
	}

	if( is_constexpr )
	{
		unsafe
		{
			return LLVMConstNamedStruct( class_type.llvm_type, cast_imut(constant_initializers).front_unsafe(), u32(constant_initializers.size()) );
		}
	}

	return LLVMValueRef::Null;
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ConstructorInitializer& constructor_initializer ) : LLVMValueRef
{
	return BuildConstructorInitializer( names_scope, function_context, variable, constructor_initializer.args, constructor_initializer.file_pos );
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ZeroInitializer& zero_initializer ) : LLVMValueRef
{
	if( !variable.t.GetFundamentalType().empty() || !variable.t.GetEnumType().empty() || !variable.t.GetFunctionPointerType().empty() )
	{
		// Currently, first element of enum have zero value.
		unsafe
		{
			auto zero_value= LLVMConstNull( variable.t.GetLLVMType() );
			LLVMBuildStore( function_context.llvm_ir_builder, zero_value, variable.llvm_value );
			return zero_value;
		}
	}
	if_var( &array_type : variable.t.GetArrayType() )
	{
		CB_GENERATE_LOOP(
			function_context,
			array_type.element_count,
			{
				var NamesScopeVariable mut element_variable
				{
					.t= array_type.element_type
				};

				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes[ GetZeroGEPIndex(), counter_value ];
					element_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
				}

				BuildInitializer( names_scope, function_context, element_variable, zero_initializer );
			}
		)

		if( variable.t.CanBeConstexpr() )
		{
			unsafe{  return LLVMConstNull( array_type.llvm_type );  }
		}
		return LLVMValueRef::Null;
	}
	if_var( &tuple_type : variable.t.GetTupleType() )
	{
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			var NamesScopeVariable element_variable
			{
				.t= tuple_type.element_types[i],
				.llvm_value= CreateTupleElementGEP( variable.llvm_value, i, function_context ),
			};

			BuildInitializer( names_scope, function_context, element_variable, zero_initializer );
		}

		if( variable.t.CanBeConstexpr() )
		{
			unsafe{  return LLVMConstNull( tuple_type.llvm_type );  }
		}
		return LLVMValueRef::Null;
	}
	if_var( &class_type_ptr : variable.t.GetClassType() )
	{
		// TODO - disable zero_init for some classes.
		auto class_type_lock= class_type_ptr.lock_imut();
		var ClassType& class_type= class_type_lock.get_ref();

		if( class_type.have_explicit_noncopy_constructors )
		{
			REPORT_ERROR( InitializerDisabledBecauseClassHaveExplicitNoncopyConstructors, names_scope, zero_initializer.file_pos )
		}
		if( class_type.kind != ClassType::Kind::Struct )
		{
			REPORT_ERROR( ZeroInitializerForClass, names_scope, zero_initializer.file_pos )
		}

		auto members_lock= class_type.members.lock_imut();
		var NamesScope& class_members= members_lock.get_ref();

		foreach( &field_name : class_type.fields_order )
		{
			auto field_ptr= class_members.GetThisScopeValue(field_name).get_ref().Get</ClassField/>();
			auto field_lock= field_ptr.lock_imut();
			var ClassField& field= field_lock.get_ref();

			if( field.index == ~0s ){ continue; } // May be in case of error

			if( field.is_reference )
			{
				REPORT_ERROR( UnsupportedInitializerForReference, names_scope, zero_initializer.file_pos )
				continue;
			}

			var NamesScopeVariable member_variable
			{
				.t= field.t,
				.llvm_value= CreateFieldGEP( variable.llvm_value, field, function_context ),
			};

			BuildInitializer( names_scope, function_context, member_variable, zero_initializer );
		}

		if( class_type.can_be_constexpr )
		{
			unsafe{  return LLVMConstNull( class_type.llvm_type );  }
		}
		return LLVMValueRef::Null;
	}

	halt;
}

fn CodeBuilder::BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::UninitializedInitializer& uninitialized_initializer ) : LLVMValueRef
{
	if( !function_context.is_in_unsafe_block )
	{
		REPORT_ERROR( UninitializedInitializerOutsideUnsafeBlock, names_scope, uninitialized_initializer.file_pos )
	}
	return LLVMValueRef::Null;
}

fn CodeBuilder::BuildEmptyInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::string8& variable_name, FilePos& file_pos )
{
	if( !variable.t.IsDefaultConstructible() )
	{
		REPORT_ERROR( ExpectedInitializer, names_scope, file_pos, variable_name )
		return;
	}

	if_var( &array_type : variable.t.GetArrayType() )
	{
		var NamesScopeVariable mut element_variable
		{
			.t= array_type.element_type
		};

		CB_GENERATE_LOOP(
			function_context,
			array_type.element_count,
			{
				unsafe
				{
					var [ LLVMValueRef, 2 ] indexes[ GetZeroGEPIndex(), counter_value ];
					element_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, "[]\0"[0] );
				}

				BuildEmptyInitializer( names_scope, function_context, element_variable, variable_name, file_pos );
			} )
		return;
	}
	if_var( &tuple_type : variable.t.GetTupleType() )
	{
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			var NamesScopeVariable element_variable
			{
				.t= tuple_type.element_types[i],
				.llvm_value= CreateTupleElementGEP( variable.llvm_value, i, function_context ),
			};

			BuildEmptyInitializer( names_scope, function_context, element_variable, variable_name, file_pos );
		}
		return;
	}
	if_var( &class_type_ptr : variable.t.GetClassType() )
	{
		auto class_members= class_type_ptr.lock_imut().get_ref().members;
		auto members_lock= class_members.lock_imut();

		auto member= members_lock.get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) );
		if( member.empty() )
		{
			// May be in case of error
			return;
		}

		auto constructors_ptr= member.get_ref().Get</NamesScopeFunctionsSet/>();
		// Should be functions set 100%
		// Should be complete here.

		var Variable this_
		{
			.t= variable.t,
			.value_type= ValueType::ReferenceMut,
			.llvm_value= variable.llvm_value,
		};

		CallFunctionsSet(
			names_scope,
			function_context,
			ust::optional_ref</ Variable, false />( this_ ),
			constructors_ptr.lock_imut().get_ref().functions_set,
			ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />(),
			file_pos );

		return;
	}
}

fn CodeBuilder::BuildConstructorInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args, FilePos& file_pos )  : LLVMValueRef
{
	if_var( &dst_type : variable.t.GetFundamentalType() )
	{
		if( args.size() != 1s )
		{
			REPORT_ERROR( FundamentalTypesHaveConstructorsWithExactlyOneParameter, names_scope, file_pos )
			return LLVMValueRef::Null;
		}

		var Variable src_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, args.front().get_ref() );

		var FundamentalType mut src_type;
		if_var( &fundamental_type : src_var.t.GetFundamentalType() )
		{
			src_type= fundamental_type;
		}
		if_var( &enum_type : src_var.t.GetEnumType() )
		{
			src_type= enum_type.lock_imut().get_ref().underlaying_type;
		}

		if( src_type.llvm_type == LLVMTypeRef::Null )
		{
			REPORT_ERROR( TypesMismatch, names_scope, file_pos, variable.t, src_var.t )
			return LLVMValueRef::Null;
		}

		auto mut llvm_value= CreateMoveToLLVMRegisterInstruction( src_var, function_context );
		unsafe
		{
			if( src_type.fundamental_type == dst_type.fundamental_type )
			{}
			else if( IsInteger( dst_type.fundamental_type ) && IsInteger( src_type.fundamental_type ) )
			{
				// int to int
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					// We lost here some values in conversions, such i16 => u32, if src_type is signed.
					if( IsUnsignedInteger( dst_type.fundamental_type ) )
					{
						llvm_value= LLVMBuildZExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
					else
					{
						llvm_value= LLVMBuildSExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else{} // Same size integers - do nothing
			}
			else if( IsFloatingPoint( dst_type.fundamental_type ) && IsFloatingPoint( src_type.fundamental_type ) )
			{
				// float to float
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					llvm_value= LLVMBuildFPExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildFPTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else{ halt; } // WTF?
			}
			else if( IsFloatingPoint( dst_type.fundamental_type ) && IsInteger( src_type.fundamental_type ) )
			{
				// int to float
				if( IsSignedInteger( src_type.fundamental_type ) )
				{
					llvm_value= LLVMBuildSIToFP( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else
				{
					llvm_value= LLVMBuildUIToFP( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
			}
			else if( IsInteger( dst_type.fundamental_type ) && IsFloatingPoint( src_type.fundamental_type ) )
			{
				// float to int
				if( IsSignedInteger( dst_type.fundamental_type ) )
				{
					llvm_value= LLVMBuildFPToSI( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else
				{
					llvm_value= LLVMBuildFPToUI( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
			}
			else if( IsChar( dst_type.fundamental_type ) && ( IsInteger( src_type.fundamental_type ) || IsChar( src_type.fundamental_type ) ) )
			{
				// int to char or char to char
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					llvm_value= LLVMBuildZExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
			}
			else if( IsInteger( dst_type.fundamental_type ) && IsChar( src_type.fundamental_type ) )
			{
				// char to int
				if( src_type.GetSize() < dst_type.GetSize() )
				{
					// We lost here some values in conversions, such i16 => u32, if src_type is signed.
					if( IsUnsignedInteger( dst_type.fundamental_type ) )
					{
						llvm_value= LLVMBuildZExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
					else
					{
						llvm_value= LLVMBuildSExt( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
					}
				}
				else if( src_type.GetSize() > dst_type.GetSize() )
				{
					llvm_value= LLVMBuildTrunc( function_context.llvm_ir_builder, llvm_value, dst_type.llvm_type, "\0"[0] );
				}
				else{} // Same size - do nothing
			}
			else
			{
				if( dst_type.fundamental_type == U_FundamentalType::bool_ )
				{
					// TODO - error, bool have no constructors from other types
				}
				REPORT_ERROR( TypesMismatch, names_scope, file_pos, variable.t, src_var.t )
				return LLVMValueRef::Null;
			}

			LLVMBuildStore( function_context.llvm_ir_builder, llvm_value, variable.llvm_value );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos );

		unsafe{  if( LLVMIsConstant( llvm_value ) == LLVMBool::True ){ return llvm_value; }  }

		return LLVMValueRef::Null;
	}
	if_var( tuple_type : variable.t.GetTupleType() )
	{
		if( args.size() != 1s )
		{
			REPORT_ERROR( ConstructorInitializerForUnsupportedType, names_scope, file_pos )
			return LLVMValueRef::Null;
		}

		auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, args.front().get_ref() );
		if( expr_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, file_pos, variable.t, expr_result.t )
			return LLVMValueRef::Null;
		}

		if( expr_result.value_type == ValueType::Value )
		{
			// Move.
			if( expr_result.node_id != ReferencesGraph::c_empty_node_id )
			{
				function_context.references_graph.MoveNode( expr_result.node_id );
			}
			CopyBytes( variable.llvm_value, expr_result.llvm_value, variable.t, function_context );
		}
		else
		{
			// Copy.
			if( !variable.t.IsCopyConstructible() )
			{
				REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, variable.t )
				return LLVMValueRef::Null;
			}

			BuildCopyConstructorPart( names_scope, function_context, variable.llvm_value, expr_result.llvm_value, variable.t, file_pos );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos );

		// Copy constructor for constexpr type is trivial, so, we can just take constexpr value of source.
		return expr_result.constexpr_value;
	}
	if_var( &enum_type : variable.t.GetEnumType() )
	{
		if( args.size() != 1s )
		{
			REPORT_ERROR( FundamentalTypesHaveConstructorsWithExactlyOneParameter, names_scope, file_pos )
			return LLVMValueRef::Null;
		}

		var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, args.front().get_ref() );
		if( expr.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, file_pos, variable.t, expr.t )
			return LLVMValueRef::Null;
		}

		unsafe
		{
			LLVMBuildStore( function_context.llvm_ir_builder, CreateMoveToLLVMRegisterInstruction( expr, function_context ), variable.llvm_value );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos );

		return expr.constexpr_value;
	}
	if( !variable.t.GetFunctionPointerType().empty() )
	{
		if( args.size() != 1s )
		{
			REPORT_ERROR( FundamentalTypesHaveConstructorsWithExactlyOneParameter, names_scope, file_pos )
			return LLVMValueRef::Null;
		}

		return InitializeFunctionPointer( names_scope, function_context, variable, args.front().get_ref() );
	}
	if_var( &class_type : variable.t.GetClassType() )
	{
		var bool mut needs_move_construct = false;
		if( args.size() == 1s )
		{
			var VariablesFrameHolder temp_variables_frame_hodler(function_context);
			auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();
			auto instructions_state= SaveInstructionsState( function_context );

			var Variable arg= BuildExpressionCodeEnsureVariable( names_scope, function_context, args.front().get_ref() );
			needs_move_construct= arg.t == variable.t && arg.value_type == ValueType::Value;

			RestoreInstructionsState( function_context, instructions_state );
		}

		if( needs_move_construct )
		{
			var Variable expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, args.front().get_ref() );

			if( expr_result.node_id != ReferencesGraph::c_empty_node_id )
			{
				function_context.references_graph.MoveNode( expr_result.node_id );
			}
			CopyBytes( variable.llvm_value, expr_result.llvm_value, variable.t, function_context );

			return expr_result.constexpr_value; // Move can preserve constexpr.
		}

		auto class_members= class_type.lock_imut().get_ref().members;
		auto members_lock= class_members.lock_imut();

		auto member= members_lock.get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) );
		if( member.empty() )
		{
			REPORT_ERROR( ClassHaveNoConstructors, names_scope, file_pos )
			return LLVMValueRef::Null;
		}

		auto constructors_ptr= member.get_ref().Get</NamesScopeFunctionsSet/>();
		// Should be functions set 100%
		// Should be complete here.

		var Variable this_
		{
			.t= variable.t,
			.value_type= ValueType::ReferenceMut,
			.llvm_value= variable.llvm_value,
		};
		CallFunctionsSet(
			names_scope,
			function_context,
			ust::optional_ref</ Variable, false />( this_ ),
			constructors_ptr.lock_imut().get_ref().functions_set,
			args.range(),
			file_pos );

		DestroyUnusedTemporaryVariables( names_scope, function_context, file_pos );

		return LLVMValueRef::Null;
	}

	REPORT_ERROR( ConstructorInitializerForUnsupportedType, names_scope, file_pos )
	return LLVMValueRef::Null;
}

fn CodeBuilder::InitializeFunctionPointer( mut this,  NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& initializer_expression ) : LLVMValueRef
{
	auto initializer_file_pos= Synt::GetFilePos( initializer_expression );
	auto initializer_value= BuildExpressionCode( names_scope, function_context, initializer_expression );

	if_var( &initializer_variable : initializer_value.get</Variable/>() )
	{
		// TODO - support function pointer conversion here.
		if( initializer_variable.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, initializer_file_pos, variable.t, initializer_variable.t )
			return LLVMValueRef::Null;
		}

		auto value_for_store= CreateMoveToLLVMRegisterInstruction( initializer_variable, function_context );
		unsafe
		{
			LLVMBuildStore( function_context.llvm_ir_builder, value_for_store, variable.llvm_value );
		}

		DestroyUnusedTemporaryVariables( names_scope, function_context, initializer_file_pos );

		return initializer_variable.constexpr_value;
	}

	var ust::optional_ref</FunctionsSet, false/> mut functions_set_opt;
	if_var( &functions_set : initializer_value.get</FunctionsSet/>() )
	{
		functions_set_opt.reset( functions_set );
	}
	if_var( &this_methods_set : initializer_value.get</ThisMethodsSet/>() )
	{
		functions_set_opt.reset( this_methods_set.functions_set );
	}

	if_var( &functions_set : functions_set_opt )
	{
		var FunctionType& function_type= variable.t.GetFunctionPointerType().get_ref().function_type;

		var ust::vector</ FunctionVariable /> mut exact_type_functions;
		var ust::vector</ FunctionVariable /> mut functions_with_conversion;
		foreach( &function_variable : functions_set.functions )
		{
			if( function_variable.t == function_type )
			{
				exact_type_functions.push_back( function_variable );
			}
			else if( function_variable.t.PointerCanBeConvertedTo( function_type ) )
			{
				functions_with_conversion.push_back( function_variable );
			}
		}

		foreach( &parametrized_function_template : functions_set.parametrized_function_templates )
		{
			if( parametrized_function_template.known_args.size() != parametrized_function_template.base_template.get_ref().params.size() )
			{
				continue;
			}

			if_var( &function_variable : FinishFunctionTemplateParametrization( parametrized_function_template, initializer_file_pos ) )
			{
				if( function_variable.t == function_type )
				{
					exact_type_functions.push_back( function_variable );
				}
				else if( function_variable.t.PointerCanBeConvertedTo( function_type ) )
				{
					functions_with_conversion.push_back( function_variable );
				}
			}
		}

		foreach( &function_template : functions_set.function_templates )
		{
			if( !function_template.get_ref().params.empty() )
			{
				continue;
			}

			var ParametrizedFunctionTemplate parametrized_function_template{ .base_template= function_template };
			if_var( &function_variable : FinishFunctionTemplateParametrization( parametrized_function_template, initializer_file_pos ) )
			{
				if( function_variable.t == function_type )
				{
					exact_type_functions.push_back( function_variable );
				}
				else if( function_variable.t.PointerCanBeConvertedTo( function_type ) )
				{
					functions_with_conversion.push_back( function_variable );
				}
			}
		}

		if( exact_type_functions.size() == 1s )
		{
			auto& function_variable= exact_type_functions.front();
			if( function_variable.is_deleted )
			{
				REPORT_ERROR( AccessingDeletedMethod, names_scope, initializer_file_pos )
				return LLVMValueRef::Null;
			}

			unsafe
			{
				LLVMBuildStore( function_context.llvm_ir_builder, function_variable.llvm_function, variable.llvm_value );
			}
			return function_variable.llvm_function;
		}
		else if( exact_type_functions.size() > 1s )
		{
			REPORT_ERROR( TooManySuitableOverloadedFunctions, names_scope, initializer_file_pos )
		}
		else if( functions_with_conversion.size() == 1s )
		{
			auto& function_variable= functions_with_conversion.front();
			if( function_variable.is_deleted )
			{
				REPORT_ERROR( AccessingDeletedMethod, names_scope, initializer_file_pos )
				return LLVMValueRef::Null;
			}

			// TODO - maybe disable conversion for expression initializer?
			unsafe
			{
				auto ptr_casted= LLVMBuildPointerCast( function_context.llvm_ir_builder, function_variable.llvm_function, variable.t.GetLLVMType(), "\0"[0] );
				LLVMBuildStore( function_context.llvm_ir_builder, ptr_casted, variable.llvm_value );
				return ptr_casted;
			}
		}
		else if( functions_with_conversion.empty() )
		{
			REPORT_ERROR( CouldNotSelectOverloadedFunction, names_scope, initializer_file_pos )
		}
		else
		{
			REPORT_ERROR( TooManySuitableOverloadedFunctions, names_scope, initializer_file_pos )
		}
		return LLVMValueRef::Null;
	}

	// TODO - generate separate error
	REPORT_ERROR( ExpectedVariable, names_scope, initializer_file_pos, GetValueKindName(initializer_value) )

	return LLVMValueRef::Null;
}

fn CodeBuilder::InitializeReferenceField( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ClassField& field, Synt::Initializer& initializer ) : LLVMValueRef
{
	auto initializer_file_pos=  Synt::GetFilePos( initializer );

	var ust::optional_ref</Synt::Expression, false/> mut initializer_expression;
	if_var( &expression_initializer : initializer.get</Synt::Expression/>() )
	{
		initializer_expression.reset(expression_initializer);
	}
	if_var( &constructor_initializer : initializer.get</Synt::ConstructorInitializer/>() )
	{
		if( constructor_initializer.args.size() != 1s )
		{
			REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope, initializer_file_pos )
			return LLVMValueRef::Null;
		}

		initializer_expression.reset( constructor_initializer.args.front().get_ref() );
	}

	if( initializer_expression.empty() )
	{
		REPORT_ERROR( UnsupportedInitializerForReference, names_scope, initializer_file_pos )
		return LLVMValueRef::Null;
	}

	var Variable initializer_variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, initializer_expression.get_ref() );
	auto initializer_expression_file_pos= Synt::GetFilePos( initializer_expression.get_ref() );
	if( initializer_variable.t != field.t && !initializer_variable.t.ReferenceIsConvertibleTo( field.t ) )
	{
		REPORT_ERROR( TypesMismatch, names_scope, initializer_expression_file_pos, field.t, initializer_variable.t )
		return LLVMValueRef::Null;
	}
	if( initializer_variable.value_type == ValueType::Value )
	{
		REPORT_ERROR( ExpectedReferenceValue, names_scope, initializer_expression_file_pos )
		return LLVMValueRef::Null;
	}
	if( field.is_mutable && initializer_variable.value_type == ValueType::ReferenceImut )
	{
		REPORT_ERROR( BindingConstReferenceToNonconstReference, names_scope, initializer_expression_file_pos )
		return LLVMValueRef::Null;
	}

	auto reference_converted= CreateReferenceCast( initializer_variable.llvm_value, initializer_variable.t, field.t, function_context );
	auto address_of_reference= CreateFieldGEP( variable.llvm_value, field, function_context );
	unsafe{  LLVMBuildStore( function_context.llvm_ir_builder, reference_converted, address_of_reference );  }

	DestroyUnusedTemporaryVariables( names_scope, function_context, initializer_expression_file_pos );

	if( initializer_variable.constexpr_value != LLVMValueRef::Null )
	{
		// Only global variables can have constant address, so, create it.
		// TODO - create only if needed.
		auto global_variable= AddGlobalConstantVariable( "_temp_const\0", initializer_variable.t.GetLLVMType(), initializer_variable.constexpr_value );
		return CreateReferenceCast( global_variable, initializer_variable.t, field.t, function_context );
	}

	return LLVMValueRef::Null;
}

fn CodeBuilder::BuildConstructorInitialization(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	Synt::StructNamedInitializer& constructor_initialization_list )
{
	// Function context should contain "this" with class type
	auto class_type= function_context.this_.get_ref().t.GetClassType().get_ref();
	auto class_members_ptr= class_type.lock_imut().get_ref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	var NamesScope& class_members= class_members_lock.get_ref();
	auto base_class= class_type.lock_imut().get_ref().base_class;

	// Check for errors, build list of initialized fields.
	var ust::unordered_map</ust::string8, i32/> mut initialized_fields; // TODO - use unordered_set
	auto mut have_fields_errors= false;
	auto mut base_initialized= false;
	foreach( &member_initializer : constructor_initialization_list.members_initializers )
	{
		if( member_initializer.name == KeywordToString( Keyword::base_ ) )
		{
			if( base_class.empty() )
			{
				have_fields_errors= true;
				REPORT_ERROR( BaseUnavailable, names_scope, constructor_initialization_list.file_pos )
				continue;
			}
			if( base_initialized )
			{
				have_fields_errors= true;
				REPORT_ERROR( DuplicatedStructMemberInitializer, names_scope, constructor_initialization_list.file_pos, member_initializer.name )
				continue;
			}
			base_initialized= true;
			function_context.uninitialized_this_fields.insert( KeywordToString( Keyword::base_ ), 0 );
			continue;
		}

		auto member= class_members.GetThisScopeValue( member_initializer.name );
		if( member.empty() )
		{
			have_fields_errors= true;
			REPORT_ERROR( NameNotFound, names_scope, member_initializer.file_pos, member_initializer.name )
			continue;
		}
		auto class_field_ptr= member.get_ref().Get</ClassField/>();
		if( class_field_ptr.empty() )
		{
			have_fields_errors= true;
			REPORT_ERROR( InitializerForNonfieldStructMember, names_scope, member_initializer.file_pos, member_initializer.name )
			continue;
		}

		if( !initialized_fields.find( member_initializer.name ).empty() )
		{
			have_fields_errors= true;
			REPORT_ERROR( DuplicatedStructMemberInitializer, names_scope, member_initializer.file_pos, member_initializer.name )
			continue;
		}

		initialized_fields.insert( member_initializer.name, 0 );
		function_context.uninitialized_this_fields.insert( member_initializer.name, 0 );
	}

	// Initialize fields, missing in initializer list.
	if( !base_class.empty() && !base_initialized )
	{
		var NamesScopeVariable base_variable
		{
			.t= ust::to_non_nullable(base_class),
			.is_mutable= true,
			.llvm_value= CreateBaseClassFieldGEP( function_context.this_.get_ref().llvm_value, function_context ),
		};

		BuildEmptyInitializer( names_scope, function_context, base_variable, KeywordToString( Keyword::base_ ), constructor_initialization_list.file_pos );
	}
	foreach( &field_name : class_type.lock_imut().get_ref().fields_order )
	{
		if( !initialized_fields.find( field_name ).empty() )
		{
			continue;
		}
		auto field_ptr= class_members.GetThisScopeValue(field_name).get_ref().Get</ClassField/>();
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error

		var NamesScopeVariable field_variable
		{
			.t= class_field.t,
			.is_mutable= true,
			.llvm_value= CreateFieldGEP( function_context.this_.get_ref().llvm_value, class_field, function_context ),
		};

		auto& initializer= class_field.syntax_element.get_ref().initializer;
		if( !initializer.get</Synt::EmptyVariant/>().empty() )
		{
			if( class_field.is_reference )
			{
				REPORT_ERROR( ExpectedInitializer, names_scope, constructor_initialization_list.file_pos, field_name )
				continue;
			}

			BuildEmptyInitializer( names_scope, function_context, field_variable, field_name, constructor_initialization_list.file_pos );
		}
		else
		{
			if( class_field.is_reference )
			{
				var NamesScopeVariable this_variable{ .t= class_type, .llvm_value= function_context.this_.get_ref().llvm_value };
				InitializeReferenceField( class_members_ptr, function_context, this_variable, class_field, initializer );
			}
			else
			{
				BuildInitializer( class_members_ptr, function_context, field_variable, initializer );
			}
		}
	}

	if( have_fields_errors )
	{
		return;
	}

	// Apply explicit initializers.
	foreach( &member_initializer : constructor_initialization_list.members_initializers )
	{
		if( member_initializer.name == KeywordToString( Keyword::base_ ) )
		{
			var NamesScopeVariable base_variable
			{
				.t= ust::to_non_nullable( base_class ),
				.is_mutable= true,
				.llvm_value= CreateBaseClassFieldGEP( function_context.this_.get_ref().llvm_value, function_context ),
			};

			BuildInitializer( names_scope, function_context, base_variable, member_initializer.initializer.get_ref() );

			function_context.uninitialized_this_fields.erase( KeywordToString( Keyword::base_ ) );
			continue;
		}

		auto field_ptr= class_members.GetThisScopeValue( member_initializer.name ).get_ref().Get</ClassField/>();
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error

		if( class_field.is_reference )
		{
			var NamesScopeVariable mut this_copy
			{
				.t= function_context.this_.get_ref().t,
			};
			this_copy.llvm_value= function_context.this_.get_ref().llvm_value;
			InitializeReferenceField( names_scope, function_context, this_copy, class_field, member_initializer.initializer.get_ref() );
		}
		else
		{
			var NamesScopeVariable field_variable
			{
				.t= class_field.t,
				.is_mutable= true,
				.llvm_value= CreateFieldGEP( function_context.this_.get_ref().llvm_value, class_field, function_context ),
			};

			BuildInitializer( names_scope, function_context, field_variable, member_initializer.initializer.get_ref() );
		}

		function_context.uninitialized_this_fields.erase( member_initializer.name );
	}
}

fn CodeBuilder::CheckClassFieldsInitializers( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().get_ref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	var NamesScope& class_members= class_members_lock.get_ref();

	auto mut global_function_context= CreateGlobalFunctionContext();
	var VariablesFrameHolder temp_variables_frame_hodler(global_function_context);
	auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

	var NamesScopeVariable mut this_variable{ .t= class_type };
	unsafe{  this_variable.llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, class_type.lock_imut().get_ref().llvm_type, "\0"[0] );  }

	foreach( &field_name : class_type.lock_imut().get_ref().fields_order )
	{
		auto field_ptr= class_members.GetThisScopeValue(field_name).get_ref().Get</ClassField/>();
		auto field_lock= field_ptr.lock_imut();
		var ClassField & class_field= field_lock.get_ref();

		if( class_field.index == ~0s ){ continue; } // May be in case of error

		auto& initializer= class_field.syntax_element.get_ref().initializer;
		if( !initializer.get</Synt::EmptyVariant/>().empty() )
		{
			continue; // Skip empty initializers.
		}

		if( class_field.is_reference )
		{
			InitializeReferenceField( class_members_ptr, function_context, this_variable, class_field, initializer );
		}
		else
		{
			var NamesScopeVariable field_variable
			{
				.t= class_field.t,
				.is_mutable= true,
				.llvm_value= CreateFieldGEP( this_variable.llvm_value, class_field, function_context ),
			};
			BuildInitializer( class_members_ptr, function_context, field_variable, initializer );
		}
	}
}

} // namespace U1
