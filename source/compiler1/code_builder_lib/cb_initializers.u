import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Initializer& initializer )
{
	variant_visit( &i : initializer )
	{
		BuildInitializer( names_scope, function_context, variable, i );
	}
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::EmptyVariant& empty_initializer )
{
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& expression_initializer )
{
	auto expr_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, expression_initializer );

	if( expr_result.t != variable.t )
	{
		REPORT_ERROR( TypesMismatch, names_scope, FilePos(), variable.t, expr_result.t )
		return;
	}

	unsafe
	{
		auto value_in_register= CreateMoveToLLVMRegisterInstruction( expr_result, function_context );
		LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, variable.llvm_value );
	}
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::SequenceInitializer& sequence_initializer )
{
	// TODO - do something
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::StructNamedInitializer& struct_named_initializer )
{
	auto class_type_ref= variable.t.GetClassType();
	if( class_type_ref.empty() )
	{
		REPORT_ERROR( StructInitializerForNonStruct, names_scope, struct_named_initializer.file_pos )
		return;
	}
	var ClassTypePtr& class_type_ptr= class_type_ref.get_ref();
	auto class_type_lock= class_type_ptr.lock_imut();
	var ClassType& class_type= class_type_lock.get_ref();

	auto members_lock= class_type.members.lock_imut();
	var NamesScope& class_members= members_lock.get_ref();

	foreach( &member_initializer : struct_named_initializer.members_initializers )
	{
		auto member_ref= class_members.GetThisScopeValue( member_initializer.name );
		if( member_ref.empty() )
		{
			REPORT_ERROR( NameNotFound, names_scope, member_initializer.file_pos, member_initializer.name )
			return; // TODO - continue instead
		}
		auto field_ptr= member_ref.get_ref().Get</ClassField/>();
		if( field_ptr.empty() )
		{
			REPORT_ERROR( InitializerForNonfieldStructMember, names_scope, member_initializer.file_pos, member_initializer.name )
			return; // TODO - continue instead
		}
		auto field_lock= field_ptr.lock_imut();
		var ClassField& class_field= field_lock.get_ref();

		var NamesScopeVariable mut member_variable
		{
			.t= class_field.t
		};

		auto op_name_nt= "." + member_initializer.name + "\0";
		unsafe
		{
			var [ LLVMValueRef, 2 ] indexes
			[
				GetZeroGEPIndex(),
				LLVMConstInt( fundamental_llvm_types_.u32_, u64(class_field.index), LLVMBool::False )
			];

			member_variable.llvm_value= LLVMBuildGEP( function_context.llvm_ir_builder, variable.llvm_value, indexes[0], 2u, op_name_nt.front() );
		}
		BuildInitializer( names_scope, function_context, member_variable, member_initializer.initializer.get_ref() );
	}
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ConstructorInitializer& constructor_initializer )
{
	if_var( &dst_type : variable.t.GetFundamentalType() )
	{
		if( constructor_initializer.args.size() != 1s )
		{
			REPORT_ERROR( FundamentalTypesHaveConstructorsWithExactlyOneParameter, names_scope, constructor_initializer.file_pos )
			return;
		}

		var Variable src_var= BuildExpressionCodeEnsureVariable( names_scope, function_context, constructor_initializer.args.front() );
		if( src_var.t != dst_type )
		{
			// TODO - allow cast
			REPORT_ERROR( TypesMismatch, names_scope, constructor_initializer.file_pos, variable.t, src_var.t )
			return;
		}

		unsafe
		{
			auto value_in_register= CreateMoveToLLVMRegisterInstruction( src_var, function_context );
			LLVMBuildStore( function_context.llvm_ir_builder, value_in_register, variable.llvm_value );
		}

		return;
	}

	// TODO - report not implemented
	return;
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ZeroInitializer& zero_initializer )
{
	// TODO - do something
}

fn CodeBuilder::BuildInitializer( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::UninitializedInitializer& uninitialized_initializer )
{
	// TODO - do something
}

} // namespace U
