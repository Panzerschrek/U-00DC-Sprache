import "/composite.u"

import "/keywords.uh"
import "tbaa_metadata_builder.uh"

namespace U1
{

fn TBAAMetadataBuilder::constructor( LLVMContextRef llvm_context, ust::box</IMangler/> mut mangler )
	( llvm_context_(llvm_context), mangler_(move(mangler)) )
{
	unsafe // Because of a lot of C functions calls.
	{
		auto tbaa_root= CreateMetadataNode( llvm_context_, ust::make_array( CreateMetadataString(llvm_context_, "__U_tbaa_root" ) ) );

		auto zero_offset_value= LLVMConstInt( LLVMInt64TypeInContext( llvm_context ), 0u64, LLVMBool::False );
		auto zero_offset_metadata= LLVMValueAsMetadata( zero_offset_value );

		type_descriptors_.byte8_  = MakeTBAATypeDescriptor( llvm_context_, tbaa_root, KeywordToString( Keyword::byte8_ ) );
		type_descriptors_.byte16_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_ , KeywordToString( Keyword::byte16_  ) );
		type_descriptors_.byte32_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte16_, KeywordToString( Keyword::byte32_  ) );
		type_descriptors_.byte64_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte32_, KeywordToString( Keyword::byte64_  ) );
		type_descriptors_.byte128_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte64_, KeywordToString( Keyword::byte128_ ) );
	}
}

fn TBAAMetadataBuilder::CreateAccessTag( mut this, Type& t ) : LLVMMetadataRef
{
	// TODO - implement this properly.
	return GetTypeDescriptor(t);
}

fn TBAAMetadataBuilder::GetTypeDescriptor( mut this, Type& t ) : LLVMMetadataRef
{
	if_var( &cached_descriptor : types_descriptors_cache_.find(t) )
	{
		return cached_descriptor;
	}

	auto descriptor= CreateTypeDescriptor(t);
	types_descriptors_cache_.insert( t, descriptor );
	return descriptor;
}

fn TBAAMetadataBuilder::CreateTypeDescriptor( mut this, Type& t ) : LLVMMetadataRef
{
	var ust::string8 mut name= mangler_.deref().MangleType(t);
	// Remove trailing null char. We do not need it here.
	if( !name.empty() && name.back() == char8(0) )
	{
		name.pop_back();
	}

	// TODO - use proper base type, process composite types.
	return unsafe( MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_, name.range() ) );
}

fn MakeTBAATypeDescriptor( LLVMContextRef llvm_context, LLVMMetadataRef base_descriptor, ust::array_view_imut</char8/>& name ) unsafe : LLVMMetadataRef
{
	unsafe
	{
		auto zero_offset_value= LLVMConstInt( LLVMInt64TypeInContext( llvm_context ), 0u64, LLVMBool::False );
		auto zero_offset_metadata= LLVMValueAsMetadata( zero_offset_value );

		return
			CreateMetadataNode(
				llvm_context,
					ust::make_array(
						CreateMetadataString( llvm_context, name ),
						base_descriptor,
						zero_offset_metadata ) );
	}
}

fn CreateMetadataString( LLVMContextRef llvm_context, ust::array_view_imut</char8/>& s ) unsafe : LLVMMetadataRef
{
	return unsafe( LLVMMDStringInContext2( llvm_context, s.data(), s.size() ) );
}

fn CreateMetadataNode( LLVMContextRef llvm_context, ust::array_view_imut</LLVMMetadataRef/>& elements ) unsafe : LLVMMetadataRef
{
	return unsafe( LLVMMDNodeInContext2( llvm_context, elements.data(), elements.size() ) );
}

} // namespace U1
