import "/composite.u"

import "/keywords.uh"
import "tbaa_metadata_builder.uh"

namespace U1
{

fn TBAAMetadataBuilder::constructor( LLVMContextRef llvm_context, LLVMTargetDataRef data_layout, ust::box</IMangler/> mut mangler )
	( llvm_context_(llvm_context), mangler_(move(mangler)) )
{
	unsafe // Because of a lot of C functions calls.
	{
		auto tbaa_root= CreateMetadataNode( llvm_context_, ust::make_array( CreateMetadataString(llvm_context_, "__U_tbaa_root" ) ) );

		auto zero_offset_value= LLVMConstInt( LLVMInt64TypeInContext( llvm_context ), 0u64, LLVMBool::False );
		auto zero_offset_metadata= LLVMValueAsMetadata( zero_offset_value );

		type_descriptors_.byte8_  = MakeTBAATypeDescriptor( llvm_context_, tbaa_root, KeywordToString( Keyword::byte8_ ) );
		type_descriptors_.byte16_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_ , KeywordToString( Keyword::byte16_  ) );
		type_descriptors_.byte32_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte16_, KeywordToString( Keyword::byte32_  ) );
		type_descriptors_.byte64_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte32_, KeywordToString( Keyword::byte64_  ) );
		type_descriptors_.byte128_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte64_, KeywordToString( Keyword::byte128_ ) );

		type_descriptors_.void_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_, KeywordToString( Keyword::void_ ) );
		type_descriptors_.bool_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_, KeywordToString( Keyword::bool_ ) );

		type_descriptors_.i8_  = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_  , KeywordToString( Keyword::i8_   ) );
		type_descriptors_.u8_  = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_  , KeywordToString( Keyword::u8_   ) );
		type_descriptors_.i16_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte16_ , KeywordToString( Keyword::i16_  ) );
		type_descriptors_.u16_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte16_ , KeywordToString( Keyword::u16_  ) );
		type_descriptors_.i32_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte32_ , KeywordToString( Keyword::i32_  ) );
		type_descriptors_.u32_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte32_ , KeywordToString( Keyword::u32_  ) );
		type_descriptors_.i64_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte64_ , KeywordToString( Keyword::i64_  ) );
		type_descriptors_.u64_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte64_ , KeywordToString( Keyword::u64_  ) );
		type_descriptors_.i128_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte128_, KeywordToString( Keyword::i128_ ) );
		type_descriptors_.u128_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte128_, KeywordToString( Keyword::u128_ ) );

		type_descriptors_.f32_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte32_, KeywordToString( Keyword::f32_ ) );
		type_descriptors_.f64_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte64_, KeywordToString( Keyword::f64_ ) );

		type_descriptors_.char8_ = MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_ , KeywordToString( Keyword::char8_  ) );
		type_descriptors_.char16_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte16_, KeywordToString( Keyword::char16_ ) );
		type_descriptors_.char32_= MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte32_, KeywordToString( Keyword::char32_ ) );

		auto ptr_base= select(
			unsafe( LLVMGetIntTypeWidth( LLVMIntPtrTypeInContext( llvm_context, data_layout ) ) ) == 32u
			? type_descriptors_.byte32_
			: type_descriptors_.byte64_ );

		type_descriptors_.ptr= MakeTBAATypeDescriptor( llvm_context_, ptr_base, "__U_any_pointer" );
	}
}

fn TBAAMetadataBuilder::CreateAccessTag( mut this, Type& t ) : LLVMMetadataRef
{
	auto type_descriptor= GetTypeDescriptor(t);

	return
		unsafe( CreateMetadataNode(
			llvm_context_,
				ust::make_array(
					type_descriptor,
					type_descriptor,
					CreateI64ZeroMetadata( llvm_context_ ) ) ) );
}

fn TBAAMetadataBuilder::CreateReferenceAccessTag( mut this, Type& t ) : LLVMMetadataRef
{
	// Create access tags for references as for pointers.
	var RawPointerType mut raw_pointer_type{ .element_type= t };
	return CreateAccessTag( move(raw_pointer_type) );
}

fn TBAAMetadataBuilder::GetTypeDescriptor( mut this, Type& t ) : LLVMMetadataRef
{
	if_var( &cached_descriptor : types_descriptors_cache_.find(t) )
	{
		return cached_descriptor;
	}

	auto descriptor= CreateTypeDescriptor(t);
	types_descriptors_cache_.insert( t, descriptor );
	return descriptor;
}

fn TBAAMetadataBuilder::CreateTypeDescriptor( mut this, Type& t ) : LLVMMetadataRef
{
	var ust::string8 mut name= mangler_.deref().MangleType(t);
	// Remove trailing null char. We do not need it here.
	if( !name.empty() && name.back() == char8(0) )
	{
		name.pop_back();
	}

	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		return GetTypeDescriptorForFundamentalType( fundamental_type.fundamental_type );
	}
	if_var( &enum_type : t.GetEnumType() )
	{
		return unsafe( MakeTBAATypeDescriptor( llvm_context_, GetEnumTypeBaseTypeDescriptor(enum_type), name.range() ) );
	}
	if_var( &raw_pointer_type : t.GetRawPointerType() )
	{
		return unsafe( MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.ptr, name.range() ) );
	}
	if_var( &function_pointer_type : t.GetFunctionPointerType() )
	{
		return unsafe( MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.ptr, name.range() ) );
	}

	// TODO - support other types.
	return unsafe( MakeTBAATypeDescriptor( llvm_context_, type_descriptors_.byte8_, name.range() ) );
}

fn TBAAMetadataBuilder::GetTypeDescriptorForFundamentalType( mut this, U_FundamentalType t ) : LLVMMetadataRef
{
	if( t == U_FundamentalType::InvalidType ) { return type_descriptors_.byte8_; }
	if( t == U_FundamentalType::void_ ) { return type_descriptors_.void_; }
	if( t == U_FundamentalType::bool_ ) { return type_descriptors_.bool_; }

	if( t == U_FundamentalType::i8_   ) { return type_descriptors_.i8_  ; }
	if( t == U_FundamentalType::u8_   ) { return type_descriptors_.u8_  ; }
	if( t == U_FundamentalType::i16_  ) { return type_descriptors_.i16_ ; }
	if( t == U_FundamentalType::u16_  ) { return type_descriptors_.u16_ ; }
	if( t == U_FundamentalType::i32_  ) { return type_descriptors_.i32_ ; }
	if( t == U_FundamentalType::u32_  ) { return type_descriptors_.u32_ ; }
	if( t == U_FundamentalType::i64_  ) { return type_descriptors_.i64_ ; }
	if( t == U_FundamentalType::u64_  ) { return type_descriptors_.u64_ ; }
	if( t == U_FundamentalType::i128_ ) { return type_descriptors_.i128_; }
	if( t == U_FundamentalType::u128_ ) { return type_descriptors_.u128_; }

	if( t == U_FundamentalType::f32_ ) { return type_descriptors_.f32_; }
	if( t == U_FundamentalType::f64_ ) { return type_descriptors_.f64_; }

	if( t == U_FundamentalType::char8_  ) { return type_descriptors_.char8_ ; }
	if( t == U_FundamentalType::char16_ ) { return type_descriptors_.char16_; }
	if( t == U_FundamentalType::char32_ ) { return type_descriptors_.char32_; }

	if( t == U_FundamentalType::byte8_   ) { return type_descriptors_.byte8_  ; }
	if( t == U_FundamentalType::byte16_  ) { return type_descriptors_.byte16_ ; }
	if( t == U_FundamentalType::byte32_  ) { return type_descriptors_.byte32_ ; }
	if( t == U_FundamentalType::byte64_  ) { return type_descriptors_.byte64_ ; }
	if( t == U_FundamentalType::byte128_ ) { return type_descriptors_.byte128_; }

	halt;
}

fn TBAAMetadataBuilder::GetEnumTypeBaseTypeDescriptor( mut this, EnumTypePtr& enum_type ) : LLVMMetadataRef
{
	auto t= enum_type.lock_imut().deref().underlaying_type.fundamental_type;
	if( t == U_FundamentalType::i8_   ) { return type_descriptors_.byte8_  ; }
	if( t == U_FundamentalType::u8_   ) { return type_descriptors_.byte8_  ; }
	if( t == U_FundamentalType::i16_  ) { return type_descriptors_.byte16_ ; }
	if( t == U_FundamentalType::u16_  ) { return type_descriptors_.byte16_ ; }
	if( t == U_FundamentalType::i32_  ) { return type_descriptors_.byte32_ ; }
	if( t == U_FundamentalType::u32_  ) { return type_descriptors_.byte32_ ; }
	if( t == U_FundamentalType::i64_  ) { return type_descriptors_.byte64_ ; }
	if( t == U_FundamentalType::u64_  ) { return type_descriptors_.byte64_ ; }
	if( t == U_FundamentalType::i128_ ) { return type_descriptors_.byte128_; }
	if( t == U_FundamentalType::u128_ ) { return type_descriptors_.byte128_; }

	halt; // Wrong underlaying type.
}

fn MakeTBAATypeDescriptor( LLVMContextRef llvm_context, LLVMMetadataRef base_descriptor, ust::array_view_imut</char8/>& name ) unsafe : LLVMMetadataRef
{
	unsafe
	{
		auto zero_offset_metadata= CreateI64ZeroMetadata( llvm_context );

		return
			CreateMetadataNode(
				llvm_context,
					ust::make_array(
						CreateMetadataString( llvm_context, name ),
						base_descriptor,
						zero_offset_metadata ) );
	}
}

fn CreateI64ZeroMetadata( LLVMContextRef llvm_context ) unsafe : LLVMMetadataRef
{
	return unsafe( LLVMValueAsMetadata( LLVMConstInt( LLVMInt64TypeInContext( llvm_context ), 0u64, LLVMBool::False ) ) );
}

fn CreateMetadataString( LLVMContextRef llvm_context, ust::array_view_imut</char8/>& s ) unsafe : LLVMMetadataRef
{
	return unsafe( LLVMMDStringInContext2( llvm_context, s.data(), s.size() ) );
}

fn CreateMetadataNode( LLVMContextRef llvm_context, ust::array_view_imut</LLVMMetadataRef/>& elements ) unsafe : LLVMMetadataRef
{
	return unsafe( LLVMMDNodeInContext2( llvm_context, elements.data(), elements.size() ) );
}

} // namespace U1
