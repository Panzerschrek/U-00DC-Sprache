import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::constructor( LLVMContextRef llvm_context )
	(
		llvm_context_(llvm_context)
	)
{
	unsafe
	{
		fundamental_llvm_types_.i8_ = LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u8_ = LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i32_= LLVMInt32TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u32_= LLVMInt32TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i64_= LLVMInt64TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u64_= LLVMInt64TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i128_= LLVMInt128TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u128_= LLVMInt128TypeInContext( llvm_context_ );

		fundamental_llvm_types_.f32_= LLVMFloatTypeInContext( llvm_context_ );
		fundamental_llvm_types_.f64_= LLVMDoubleTypeInContext( llvm_context_ );

		fundamental_llvm_types_.char8_ = LLVMInt8TypeInContext ( llvm_context_ );
		fundamental_llvm_types_.char16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.char32_= LLVMInt32TypeInContext( llvm_context_ );

		fundamental_llvm_types_.invalid_type_= LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.void_= LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.void_for_ret_= LLVMVoidTypeInContext( llvm_context_ );
		fundamental_llvm_types_.bool_= LLVMInt1TypeInContext( llvm_context_ );

		fundamental_llvm_types_.int_ptr= LLVMInt64TypeInContext( llvm_context_ ); // TODO - use data layout to obtaint int_ptr type
	}
}

fn CodeBuilder::BuildProgram( mut this, Synt::SyntaxAnalysisResult& ast ) : BuildResult
{
	unsafe{ module_ = LLVMModuleCreateWithName( "some_module\0"[0] ); }

	var ErrorsContainerPtr errors_container( ErrorsContainer() );

	var ust::shared_ptr_mut</NamesScope/> global_names_scope( NamesScope( "", ust::shared_ptr_nullable_imut</NamesScope/>() ) );

	{
		auto mut l= global_names_scope.lock_mut();
		auto &mut n= l.get_ref();

		n.SetErrors( errors_container );
		FillGlobalNamesScope( n );
	}

	NamesScopeFill( global_names_scope, ast.program_elements );
	NamesScopeBuild( global_names_scope );

	var BuildResult mut res
	{
		.llvm_module= module_,
		.errors= errors_container.lock_imut().get_ref(),
	 };

	return move(res);
}

fn CodeBuilder::NamesScopeValueToValue( this, NamesScopeValue& names_scope_value ) : Value
{
	{
		auto t= names_scope_value.Get</Type/>();
		if( !t.empty() )
		{
			return Value( t.lock_imut().get_ref() );
		}
	}
	{
		auto f= names_scope_value.Get</FunctionsSet/>();
		// TODO - build functions set.
	}
	{
		auto var_ptr= names_scope_value.Get</NamesScopeVariable/>();
		if( !var_ptr.empty() )
		{
			auto lock= var_ptr.lock_imut();
			auto& v= lock.get_ref();

			var Variable mut res;
			res.t= v.t;
			res.llvm_value= v.llvm_value;
			res.location= Variable::Location::Pointer;
			return Value( move(res) );
		}
	}

	return Value( ErrorValue() );
}

fn CodeBuilder::ResolveValue( this, NamesScope& names_scope, Synt::ComplexName& complex_name ) : Value
{
	if_var( names_scope_value : names_scope.GetThisScopeValue( complex_name.name ) )
	{
		return NamesScopeValueToValue( names_scope_value );
	}

	var ust::shared_ptr_nullable_imut</NamesScope/> mut current_scope= names_scope.GetParent();
	while( !current_scope.empty() )
	{
		if_var( names_scope_value : current_scope.lock_imut().get_ref().GetThisScopeValue( complex_name.name ) )
		{
			return NamesScopeValueToValue( names_scope_value );
		}

		current_scope= names_scope.GetParent();
	}

	REPORT_ERROR( names_scope, NameNotFound, complex_name.file_pos )
	return Value( ErrorValue() );
}

fn CodeBuilder::FillGlobalNamesScope( this, NamesScope &mut names_scope )
{
	names_scope.AddName( KeywordToString(Keyword::void_), Type( FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::bool_), Type( FundamentalType( U_FundamentalType::bool_, fundamental_llvm_types_.bool_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::i8_  ), Type( FundamentalType( U_FundamentalType::i8_  , fundamental_llvm_types_.i8_   ) ) );
	names_scope.AddName( KeywordToString(Keyword::u8_  ), Type( FundamentalType( U_FundamentalType::u8_  , fundamental_llvm_types_.u8_   ) ) );
	names_scope.AddName( KeywordToString(Keyword::i16_ ), Type( FundamentalType( U_FundamentalType::i16_ , fundamental_llvm_types_.i16_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::u16_ ), Type( FundamentalType( U_FundamentalType::u16_ , fundamental_llvm_types_.u16_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::i32_ ), Type( FundamentalType( U_FundamentalType::i32_ , fundamental_llvm_types_.i32_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::u32_ ), Type( FundamentalType( U_FundamentalType::u32_ , fundamental_llvm_types_.u32_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::i64_ ), Type( FundamentalType( U_FundamentalType::i64_ , fundamental_llvm_types_.i64_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::u64_ ), Type( FundamentalType( U_FundamentalType::u64_ , fundamental_llvm_types_.u64_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::i128_), Type( FundamentalType( U_FundamentalType::i128_, fundamental_llvm_types_.i128_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::u128_), Type( FundamentalType( U_FundamentalType::u128_, fundamental_llvm_types_.u128_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::f32_ ), Type( FundamentalType( U_FundamentalType::f32_ , fundamental_llvm_types_.f32_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::f64_ ), Type( FundamentalType( U_FundamentalType::f64_ , fundamental_llvm_types_.f64_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::char8_ ), Type( FundamentalType( U_FundamentalType::char8_ , fundamental_llvm_types_.char8_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::char16_), Type( FundamentalType( U_FundamentalType::char16_, fundamental_llvm_types_.char16_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::char32_), Type( FundamentalType( U_FundamentalType::char32_, fundamental_llvm_types_.char32_ ) ) );
}

fn CodeBuilder::NamesScopeFill( NamesScopePtr& names_scope_ptr, Synt::ProgramElements& program_elements )
{
	foreach( & program_element : program_elements )
	{
		if_var( & function : program_element.get</ ust::shared_ptr_final</Synt::Function/> />() )
		{
			NamesScopeFill( names_scope_ptr, function );
		}
	}
}

fn CodeBuilder::NamesScopeFill( NamesScopePtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function )
{
	auto mut names_scope_lock= names_scope_ptr.lock_mut();
	auto& mut names_scope= names_scope_lock.get_ref();

	if( !names_scope.GetThisScopeValue( function.get_ref().name ).empty() )
	{
		REPORT_ERROR( names_scope, Redefinition, function.get_ref().file_pos )
		return;
	}

	// TODO - reuse existing functions set, report about redefinition.
	var FunctionsSet mut functions_set;

	functions_set.syntax_elements.push_back( function );

	names_scope.AddName( function.get_ref().name, NamesScopeValue( move(functions_set) ) );
}

fn CodeBuilder::NamesScopeBuild( this, NamesScopePtr& names_scope_ptr )
{
	auto lock= names_scope_ptr.lock_imut();
	auto& names_scope= lock.get_ref();

	foreach( &el : names_scope.GetInternalContainer() )
	{
		auto functions_set= el.value().Get</ FunctionsSet />();
		if( !functions_set.empty() )
		{
			NamesScopeBuildElement( names_scope_ptr, ust::to_non_nullable( functions_set ) );
		}
	}
}

fn CodeBuilder::NamesScopeBuildElement( this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/> functions_set )
{
	{ // First, lock as imut and check if complete.
		auto l= functions_set.lock_imut();
		var FunctionsSet& functions_set= l.get_ref();
		if( functions_set.syntax_elements.empty() ) // Already complete
		{
			return;
		}
	}

	auto mut l= functions_set.lock_mut();
	var FunctionsSet &mut functions_set= l.get_ref();

	while( !functions_set.syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.syntax_elements.back();
		PrepareFunction( syntax_element_ptr, names_scope_ptr, functions_set );
		functions_set.syntax_elements.drop_back();
	}
}

fn CodeBuilder::PrepareFunction(
	this,
	ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
	NamesScopePtr& names_scope_ptr,
	FunctionsSet &mut functions_set ) : bool
{
	auto& function_declaration= function_declaration_ptr.get_ref();

	var FunctionVariable mut function_variable{ .syntax_element= function_declaration_ptr };

	function_variable.t= PrepareType( names_scope_ptr.lock_imut().get_ref(), function_declaration.function_type );

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction( function_declaration.name, function_variable.t.GetFunctionType().get_ref() ).front(),
				function_variable.t.GetLLVMType() );
	}

	functions_set.functions.push_back( move(function_variable) );

	BuildFuncCode( names_scope_ptr, functions_set.functions.back() ); // TODO separate body build from prototype build.

	return true;
}

fn CodeBuilder::PrepareType( this, NamesScope& names_scope, Synt::TypeName& type_name ) : Type
{
	if_var( &named_type : type_name.get</Synt::ComplexName/>() )
	{
		return PrepareType( names_scope, named_type );
	}
	if_var( &function_type : type_name.get</ ust::box</ Synt::FunctionType/> />() )
	{
		return PrepareType( names_scope, function_type.get_ref() );
	}
	halt;
}

fn CodeBuilder::PrepareType( this, NamesScope& names_scope, Synt::ComplexName& named_type ) : Type
{
	var Value resolved_value= ResolveValue( names_scope, named_type );
	if_var( & t : resolved_value.get</Type/>() )
	{
		return t;
	}

	REPORT_ERROR( names_scope, NameIsNotTypeName, named_type.file_pos )
	return Type( FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ ) );
}

fn CodeBuilder::PrepareType( this, NamesScope& names_scope, Synt::FunctionType& function_type ) : Type
{
	var FunctionType mut res
	{
		.return_type(
			select(
				function_type.return_type.empty()
					? Type( FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_for_ret_ ) )
					: PrepareType( names_scope, function_type.return_type.get_ref() ) ) )
	};

	foreach( &arg : function_type.args )
	{
		var FunctionType::Arg mut out_arg{ .arg_type( PrepareType( names_scope, arg.arg_type ) ) };
		res.args.push_back( move(out_arg) );
	}

	var ust::vector</LLVMTypeRef/> mut llvm_arg_types;
	foreach( &arg : res.args )
	{
		llvm_arg_types.push_back( arg.arg_type.get_ref().GetLLVMType() );
	}

	unsafe
	{
		if( llvm_arg_types.empty() )
		{
			auto dummy= LLVMTypeRef::Null;
			res.llvm_type=
				LLVMFunctionType(
					res.return_type.get_ref().GetLLVMType(),
					dummy, 0u, LLVMBool::False );
		}
		else
		{
			auto s= u32(llvm_arg_types.size());
			res.llvm_type=
				LLVMFunctionType(
					res.return_type.get_ref().GetLLVMType(),
					llvm_arg_types.front(), s, LLVMBool::False );
		}
	}

	return Type(move(res));
}

fn CodeBuilder::BuildFuncCode( this, NamesScopePtr& names_scope_ptr, FunctionVariable &mut func_variable )
{
	var FunctionContext mut function_context( llvm_context_, func_variable.llvm_function );

	var NamesScopePtr args_names_scope_ptr( NamesScope( "", names_scope_ptr ) );

	{
		auto mut args_names_scope_lock= args_names_scope_ptr.lock_mut();
		auto &mut args_names_scope= args_names_scope_lock.get_ref();

		auto mut arg_n= 0u;
		foreach( &in_arg : func_variable.syntax_element.get_ref().function_type.args )
		{
			var NamesScopeVariable mut out_arg;
			out_arg.t= PrepareType( names_scope_ptr.lock_imut().get_ref(), in_arg.arg_type );

			auto arg_name= "_arg_" + in_arg.name;
			unsafe
			{
				out_arg.llvm_value= LLVMGetParam( func_variable.llvm_function, arg_n );
				LLVMSetValueName2( out_arg.llvm_value, arg_name.front(), arg_name.size() );
			}

			++arg_n;

			var bool insert_ok= !args_names_scope.AddName( in_arg.name, NamesScopeValue( move(out_arg) ) ).empty();
			if( !insert_ok )
			{
				REPORT_ERROR( args_names_scope, Redefinition, in_arg.file_pos )
			}
		}
	}

	BuildBlockElement( args_names_scope_ptr, function_context, func_variable.syntax_element.get_ref().block.get_ref() );

	// Finsih function - add remaining instructions
	unsafe{ LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block ); }
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope_ptr, FunctionContext &mut function_context, Synt::Block& block )
{
	var NamesScopePtr block_names_scope( NamesScope( "", names_scope_ptr ) );

	foreach( &el : block.elements )
	{
		if_var( &return_operator : el.get</Synt::ReturnOperator/>() )
		{
			BuildBlockElement( block_names_scope, function_context, return_operator );
		}
	}
}

fn CodeBuilder::BuildBlockElement( this, NamesScopePtr& names_scope_ptr, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator )
{
	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope_ptr.lock_imut().get_ref(), function_context, return_operator.expr );

	unsafe{ LLVMBuildRet( function_context.llvm_ir_builder, expr.llvm_value ); }
}

fn CodeBuilder::BuildExpressionCode( this, NamesScope& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value
{
	if_var( numeric_constant : expression.expr.get</Synt::NumericConstant/>() )
	{
		return BuildExpressionCode( names_scope, function_context, numeric_constant );
	}
	if_var( named_operand : expression.expr.get</Synt::ComplexName/>() )
	{
		return BuildExpressionCode( names_scope, function_context, named_operand );
	}
	halt;
}

fn CodeBuilder::BuildExpressionCodeEnsureVariable( this, NamesScope& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable
{
	var Value mut value= BuildExpressionCode( names_scope, function_context, expression );

	// TODO - fill dummy value if not variable.
	return value.get</Variable/>().get_ref();
}

fn CodeBuilder::BuildExpressionCode( this, NamesScope& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value
{
	var Variable mut res;
	res.t= Type( FundamentalType( U_FundamentalType::i32_ , fundamental_llvm_types_.i32_ ) );
	res.location= Variable::Location::LLVMRegister;

	unsafe{ res.llvm_value= LLVMConstInt( res.t.GetLLVMType(), u64(numeric_constant.num.value_double), LLVMBool::True ); }

	return Value( move(res) );
}

fn CodeBuilder::BuildExpressionCode( this, NamesScope& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value
{
	return ResolveValue( names_scope, named_operand );
}

} // amespace U
