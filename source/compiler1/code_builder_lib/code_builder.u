import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn AddAncestorsAccessRights_r( NamesScope &mut dst_class_members, ClassTypePtr& ancestor_class )
{
	dst_class_members.AddAccessRightsFor( ancestor_class, Synt::ClassVisibility::Protected );
	foreach( &parent : ancestor_class.lock_imut().get_ref().parents )
	{
		AddAncestorsAccessRights_r( dst_class_members, parent.class_ );
	}
}

fn CodeBuilder::constructor( LLVMContextRef llvm_context, LLVMTargetDataRef data_layout )
	(
		llvm_context_(llvm_context),
		data_layout_(data_layout),
	)
{
	unsafe
	{
		fundamental_llvm_types_.i8_ = LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u8_ = LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i32_= LLVMInt32TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u32_= LLVMInt32TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i64_= LLVMInt64TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u64_= LLVMInt64TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i128_= LLVMInt128TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u128_= LLVMInt128TypeInContext( llvm_context_ );

		fundamental_llvm_types_.f32_= LLVMFloatTypeInContext( llvm_context_ );
		fundamental_llvm_types_.f64_= LLVMDoubleTypeInContext( llvm_context_ );

		fundamental_llvm_types_.char8_ = LLVMInt8TypeInContext ( llvm_context_ );
		fundamental_llvm_types_.char16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.char32_= LLVMInt32TypeInContext( llvm_context_ );

		fundamental_llvm_types_.invalid_type_= LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.void_= LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.void_for_ret_= LLVMVoidTypeInContext( llvm_context_ );
		fundamental_llvm_types_.bool_= LLVMInt1TypeInContext( llvm_context_ );

		fundamental_llvm_types_.int_ptr= LLVMIntPtrTypeInContext( llvm_context_, data_layout_ );
	}

	invalid_type_= FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ );
	void_type_= FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_ );
	void_type_for_ret_= FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_for_ret_ );
	bool_type_= FundamentalType( U_FundamentalType::bool_, fundamental_llvm_types_.bool_ );

	unsafe
	{
		size_type_= select(
			LLVMGetIntTypeWidth( fundamental_llvm_types_.int_ptr ) == 32u
			? FundamentalType( U_FundamentalType::u32_, fundamental_llvm_types_.u32_ )
			: FundamentalType( U_FundamentalType::u64_, fundamental_llvm_types_.u64_ ) );
	}
}

fn CodeBuilder::BuildProgram( mut this, SourceGraph& source_graph ) : BuildResult
{
	unsafe // Create module.
	{
		module_ = LLVMModuleCreateWithNameInContext( "some_module\0"[0], llvm_context_ );
		LLVMSetModuleDataLayout( module_, data_layout_ );
	}

	unsafe // Prepare dummy function.
	{
		auto global_function_llvm_type= LLVMFunctionType( fundamental_llvm_types_.void_for_ret_, LLVMTypeRef::Null, 0u, LLVMBool::False );
		global_llvm_function_= LLVMAddFunction( module_, "\0"[0], global_function_llvm_type );
	}

	unsafe // Prepare halt function.
	{
		auto halt_function_llvm_type= LLVMFunctionType( fundamental_llvm_types_.void_for_ret_, LLVMTypeRef::Null, 0u, LLVMBool::False );
		halt_function_= LLVMAddFunction( module_, "__U_halt\0"[0], halt_function_llvm_type );

		{
			var ust::array_view_imut</ char8 /> attr_name= "noreturn";
			auto attr_kind= LLVMGetEnumAttributeKindForName( attr_name.front(), attr_name.size() );
			auto attr= LLVMCreateEnumAttribute( llvm_context_, attr_kind, 0u64 );
			LLVMAddAttributeAtIndex( halt_function_, LLVMAttributeFunctionIndex, attr );
		}
		{
			var ust::array_view_imut</ char8 /> attr_name= "nounwind";
			auto attr_kind= LLVMGetEnumAttributeKindForName( attr_name.front(), attr_name.size() );
			auto attr= LLVMCreateEnumAttribute( llvm_context_, attr_kind, 0u64 );
			LLVMAddAttributeAtIndex( halt_function_, LLVMAttributeFunctionIndex, attr );
		}
	}

	var ErrorsContainerPtr errors_container( ErrorsContainer() );

	compiled_sources_cache_.resize( source_graph.nodes.size() );
	BuildSourceGraphNode( errors_container, source_graph, 0s );

	unsafe{  LLVMDeleteFunction( global_llvm_function_ );  }
	global_llvm_function_= LLVMValueRef::Null;

	{ // Clear classes internals to break strong shared pointers loop and avoid memory leaks.
		var NamesScopeMutPtr dummy_class_names_scope( NamesScope( "", ust::shared_ptr_nullable_imut</NamesScope/>() ) );
		foreach( &mut node : compiled_sources_cache_ )
		{
			foreach( &mut class_table_entry : node.class_table )
			{
				auto mut lock= class_table_entry.key().lock_mut();
				auto &mut class_= lock.get_ref();
				class_.members= dummy_class_names_scope;
				class_.parents.clear();
				class_.virtual_table.clear();
			}
		}
	}

	compiled_sources_cache_.clear();

	var BuildResult mut res
	{
		.llvm_module= module_,
		.errors= errors_container.lock_imut().get_ref(),
	 };

	NormalizeErrors( res.errors );

	return move(res);
}

fn CodeBuilder::BuildSourceGraphNode( mut this, ErrorsContainerPtr& errors_container, SourceGraph& source_graph, size_type node_index )
{
	var NamesScopeMutPtr mut global_names_scope( NamesScope( "", ust::shared_ptr_nullable_imut</NamesScope/>() ) );

	{
		auto mut l= global_names_scope.lock_mut();
		auto &mut n= l.get_ref();

		n.SetErrors( errors_container );
		FillGlobalNamesScope( n );
	}

	var SourceGraph::Node& source_graph_node= source_graph.nodes[node_index];

	// Build dependent nodes.
	foreach( child_node_index : source_graph_node.children )
	{
		if( compiled_sources_cache_[child_node_index].names_scope.empty() )
		{
			BuildSourceGraphNode( errors_container, source_graph, child_node_index );
		}
	}
	// Prepare class table.
	{
		var ust::unordered_map</ ClassTypePtr, ClassType /> mut tmp_class_table;
		foreach( child_node_index : source_graph_node.children )
		{
			foreach( &class_table_entry : compiled_sources_cache_[child_node_index].class_table )
			{
				if( tmp_class_table.find( class_table_entry.key() ).empty() )
				{
					tmp_class_table.insert( class_table_entry.key(), class_table_entry.value() );
					continue;
				}

				var ClassType &mut prev_class_value= tmp_class_table.find( class_table_entry.key() ).get_ref();
				var ClassType& new_class_value= class_table_entry.value();

				if( !prev_class_value.syntax_element.empty() && !new_class_value.syntax_element.empty() &&
					prev_class_value.syntax_element != new_class_value.syntax_element )
				{
					REPORT_ERROR( ClassBodyDuplication, global_names_scope, new_class_value.syntax_element.get_ref().file_pos, new_class_value.syntax_element.get_ref().name )
				}
				if( !prev_class_value.forward_declaration_syntax_element.empty() && !new_class_value.forward_declaration_syntax_element.empty() &&
					prev_class_value.forward_declaration_syntax_element != new_class_value.forward_declaration_syntax_element )
				{
					// TODO - generate another error
					REPORT_ERROR( ClassBodyDuplication, global_names_scope, new_class_value.syntax_element.get_ref().file_pos, new_class_value.forward_declaration_syntax_element.get_ref().name )
				}

				// Select complete class.
				if( !prev_class_value.is_complete && new_class_value.is_complete )
				{
					prev_class_value= new_class_value;
				}
			}
		}

		foreach( &mut class_table_entry : tmp_class_table )
		{
			current_class_table_.push_back( class_table_entry.key() );

			auto mut lock= class_table_entry.key().lock_mut();
			lock.get_ref()= class_table_entry.value();
		}
	}
	// Merge namespaces. This must be done AFTER class table praparation.
	foreach( child_node_index : source_graph_node.children )
	{
		auto ptr= ust::to_non_nullable( compiled_sources_cache_[child_node_index].names_scope );
		NamesScopeMerge( global_names_scope, ptr.lock_imut().get_ref() );
	}

	auto& program_elements= source_graph_node.synt_result.program_elements;
	NamesScopeFill( global_names_scope, program_elements );
	NamesScopeFillOutOfLineElements( global_names_scope, program_elements );
	NamesScopeBuild( global_names_scope );

	// Finalize building template classes.
	// Save and update keys separately, because "generated_template_things_storage_" may change during iterations.
	{
		var ust::unordered_map</ ust::string8, i32 /> mut generated_template_things_keys;
		foreach( &el : generated_template_things_ )
		{
			generated_template_things_keys.insert( el.key(), 0 );
		}
		auto mut new_generated_template_things_keys= generated_template_things_keys;

		while( !new_generated_template_things_keys.empty() )
		{
			foreach( &el : new_generated_template_things_keys )
			{
				auto names_scope= generated_template_things_.find(el.key()).get_ref();
				NamesScopeBuild( names_scope );
			}

			new_generated_template_things_keys.clear();
			foreach( &el : generated_template_things_ )
			{
				if( generated_template_things_keys.find( el.key() ).empty() )
				{
					generated_template_things_keys.insert( el.key(), 0 );
					new_generated_template_things_keys.insert( el.key(), 0 );
				}
			}
		}
	}

	auto class_table= take(current_class_table_);

	var SourceGraphNodeBuildResult &mut out_node_build_result= compiled_sources_cache_[node_index];
	out_node_build_result.names_scope= move(global_names_scope);

	// Fill class table of current node.
	foreach( &class_type : class_table )
	{
		out_node_build_result.class_table.insert( class_type, class_type.lock_imut().get_ref() );
	}
}

fn CodeBuilder::NamesScopeValueToValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeValue& names_scope_value, FilePos& file_pos ) : Value
{
	auto t= names_scope_value.Get</Type/>();
	if( !t.empty() )
	{
		return t.lock_imut().get_ref();
	}

	auto f_ptr= names_scope_value.Get</NamesScopeFunctionsSet/>();
	if( !f_ptr.empty() )
	{
		// In case of access to functions set using function name, build only prototype, not full body.
		BuildFunctionsSet( names_scope, ust::to_non_nullable( f_ptr ), false );

		// Append "this" to functions set of this class.
		auto class_type= names_scope.lock_imut().get_ref().GetClass();
		if( !class_type.empty() &&
			!function_context.this_.empty() &&
			ust::to_non_nullable( class_type ) == function_context.this_.get_ref().t &&
			!function_context.whole_this_is_unavailable )
		{
			var ThisMethodsSet mut this_methods_set
			{
				.this_= function_context.this_.get_ref(),
				.functions_set= f_ptr.lock_imut().get_ref().functions_set,
			};
			return move(this_methods_set);
		}

		return f_ptr.lock_imut().get_ref().functions_set;
	}

	auto var_ptr= names_scope_value.Get</NamesScopeVariable/>();
	if( !var_ptr.empty() )
	{
		auto lock= var_ptr.lock_imut();
		auto& v= lock.get_ref();

		var Variable mut res
		{
			.t= v.t,
			.llvm_value= v.llvm_value,
			.constexpr_value= v.constexpr_value,
			.location= Variable::Location::Pointer,
			.value_type= select( v.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		};
		return move(res);
	}

	auto class_field_ptr= names_scope_value.Get</ClassField/>();
	if( !class_field_ptr.empty() )
	{
		auto field_lock= class_field_ptr.lock_imut();
		auto& field= field_lock.get_ref();
		auto& field_name= field.syntax_element.get_ref().name;

		if( function_context.this_.empty() )
		{
			REPORT_ERROR( ClassFiledAccessInStaticMethod, names_scope, file_pos, field_name )
			return ErrorValue();
		}

		auto field_class= names_scope.lock_imut().get_ref().GetClass();
		auto this_class= function_context.this_.get_ref().t.GetClassType().get_ref();
		var ust::shared_ptr_nullable_mut</ClassType/> mut current_class= this_class;
		auto mut this_value_corrected= function_context.this_.get_ref().llvm_value;
		while( !current_class.empty() && current_class != field_class )
		{
			var ust::shared_ptr_nullable_mut</ClassType/> next= cast_imut(current_class).lock_imut().get_ref().base_class;

			if( !next.empty() )
			{
				this_value_corrected= CreateBaseClassFieldGEP( this_value_corrected, function_context );
			}
			current_class= next;
		}

		if( current_class.empty() )
		{
			REPORT_ERROR( AccessOfNonThisClassField, names_scope, file_pos, field_name )
			return ErrorValue();
		}

		if( function_context.whole_this_is_unavailable )
		{
			if( !function_context.uninitialized_this_fields.find( field_name ).empty() ||
				( current_class != this_class && !function_context.uninitialized_this_fields.find( KeywordToString( Keyword::base_ ) ).empty() ) )
			{
				REPORT_ERROR( FieldIsNotInitializedYet, names_scope, file_pos, field_name )
			}
		}

		if( field.index == ~0s ){ return ErrorValue(); } // May be in case of error

		auto op_name_nt= "." + field_name + "\0";
		if( field.is_reference )
		{
			var Variable mut result
			{
				.t= field.t,
				.location= Variable::Location::Pointer,
				.value_type= select( field.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			};

			auto ptr_value= CreateFieldGEP( this_value_corrected, field, function_context );
			unsafe{  result.llvm_value= LLVMBuildLoad( function_context.llvm_ir_builder, ptr_value, op_name_nt.front() );  }

			return move(result);
		}
		else
		{
			var Variable mut result
			{
				.t= field.t,
				.location= Variable::Location::Pointer,
				.value_type= function_context.this_.get_ref().value_type,
				.llvm_value= CreateFieldGEP( this_value_corrected, field, function_context ),
			};

			if( !field.is_mutable )
			{
				result.value_type= ValueType::ReferenceImut;
			}

			return move(result);
		}
	}

	auto class_type_ptr= names_scope_value.Get</ClassType/>();
	if( !class_type_ptr.empty() )
	{
		auto ptr_non_null= ust::to_non_nullable(class_type_ptr);
		return Type( ptr_non_null );
	}

	auto enum_type_ptr= names_scope_value.Get</Enum/>();
	if( !enum_type_ptr.empty() )
	{
		auto ptr_non_null= ust::to_non_nullable(enum_type_ptr);
		BuildEnum( names_scope, ptr_non_null );
		return Type( ptr_non_null );
	}

	auto type_alias_ptr= names_scope_value.Get</TypeAlias/>();
	if( !type_alias_ptr.empty() )
	{
		auto mut lock= type_alias_ptr.lock_mut();
		auto &mut type_alias= lock.get_ref();
		BuildTypeAlias( names_scope, type_alias );

		if_var( &t : type_alias.t )
		{
			return t;
		}
	}

	auto global_variable_ptr= names_scope_value.Get</GlobalVariable/>();
	if( !global_variable_ptr.empty() )
	{
		auto mut lock= global_variable_ptr.lock_mut();
		auto &mut global_variable= lock.get_ref();
		BuildGlobalVariable( names_scope, global_variable );

		if_var( &v : global_variable.variable )
		{
			var Variable mut res
			{
				.t= v.t,
				.llvm_value= v.llvm_value,
				.constexpr_value= v.constexpr_value,
				.location= Variable::Location::Pointer,
				.value_type= select( v.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			};
			return move(res);
		}
	}

	auto global_auto_variable_ptr= names_scope_value.Get</GlobalAutoVariable/>();
	if( !global_auto_variable_ptr.empty() )
	{
		auto mut lock= global_auto_variable_ptr.lock_mut();
		auto &mut global_auto_variable= lock.get_ref();
		BuildGlobalAutoVariable( names_scope, global_auto_variable );

		if_var( &v : global_auto_variable.variable )
		{
			var Variable mut res
			{
				.t= v.t,
				.llvm_value= v.llvm_value,
				.constexpr_value= v.constexpr_value,
				.location= Variable::Location::Pointer,
				.value_type= select( v.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			};
			return move(res);
		}
	}

	auto template_arg_ptr= names_scope_value.Get</TemplateArg/>();
	if( !template_arg_ptr.empty() )
	{
		auto template_arg_lock= template_arg_ptr.lock_imut();
		auto& template_arg= template_arg_lock.get_ref();
		if_var( &t : template_arg.something.get</Type/>() )
		{
			return t;
		}
		if_var( &v : template_arg.something.get</NamesScopeVariable/>() )
		{
			var Variable mut res
			{
				.t= v.t,
				.llvm_value= v.llvm_value,
				.constexpr_value= v.constexpr_value,
				.location= Variable::Location::Pointer,
				.value_type= select( v.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			};
			return move(res);
		}
		REPORT_ERROR( TemplateArgumentIsNotDeducedYet, names_scope, FilePos(), ust::string8("TODO - name" ) )
	}

	auto type_templates_set_ptr= names_scope_value.Get</TypeTemplatesSet/>();
	if( !type_templates_set_ptr.empty() )
	{
		return ust::shared_ptr_imut</TypeTemplatesSet/>( ust::to_non_nullable( type_templates_set_ptr ) );
	}

	return ErrorValue();
}

fn CodeBuilder::ResolveValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : Value
{
	return ResolveValue( names_scope, function_context, complex_name, false );
}

fn CodeBuilder::ResolveValue(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	Synt::ComplexName& complex_name,
	bool skip_last_template_args ) : Value
{
	var ust::shared_ptr_nullable_imut</NamesScope/> mut current_scope(names_scope);

	var ust::optional</NamesScopeValue/> mut current_value;
	if( complex_name.name.empty() ) // ::
	{
		while( true )
		{
			auto parent= current_scope.lock_imut().get_ref().GetParent();
			if( parent.empty() )
			{
				break;
			}
			current_scope= parent;
		}

		if_var( mut names_scope_value : current_scope.lock_imut().get_ref().GetThisScopeValue( complex_name.tail.front().get</ust::string8/>().get_ref() ) )
		{
			current_value= move(names_scope_value);
		}
	}
	else
	{
		while( !current_scope.empty() )
		{
			if_var( mut names_scope_value : current_scope.lock_imut().get_ref().GetThisScopeValue( complex_name.name ) )
			{
				current_value= move(names_scope_value);
				break;
			}
			current_scope= current_scope.lock_imut().get_ref().GetParent();
		}

		if( complex_name.name == KeywordToString( Keyword::constructor_ ) ||
			complex_name.name == KeywordToString( Keyword::destructor_ ) )
		{
			if( !function_context.is_in_unsafe_block )
			{
				REPORT_ERROR( ExplicitAccessToThisMethodIsUnsafe, names_scope, complex_name.file_pos, complex_name.name )
			}
		}
	}

	if( current_value.empty() )
	{
		REPORT_ERROR( NameNotFound, names_scope, complex_name.file_pos, complex_name.name )
		return ErrorValue();
	}

	// TOOD - simplify this. After first component lookup do not use optional for "current_value" and nullable pointer for "current_scope"

	for( auto mut i= select( complex_name.name.empty() ? 1s : 0s ); i < complex_name.tail.size(); ++i )
	{
		auto& name_component= complex_name.tail[i];
		if_var( &name_component_name : name_component.get</ ust::string8 />() )
		{
			var ust::shared_ptr_nullable_imut</NamesScope/> mut namespace_= current_value.get_ref().Get</NamesScope/>();
			auto mut class_= current_value.get_ref().Get</ClassType/>();
			auto enum_= current_value.get_ref().Get</Enum/>();
			auto type_templates_set= current_value.get_ref().Get</TypeTemplatesSet/>();
			auto t= current_value.get_ref().Get</Type/>();
			auto type_alias= current_value.get_ref().Get</TypeAlias/>();

			if( !t.empty() )
			{
				auto lock= t.lock_imut();
				if_var( &class_type : lock.get_ref().GetClassType() )
				{
					class_= class_type;
				}
			}
			if( !type_alias.empty() )
			{
				{
					auto mut lock= type_alias.lock_mut();
					BuildTypeAlias( names_scope, lock.get_ref() );
				}
				auto lock= type_alias.lock_imut();
				if_var( &t : lock.get_ref().t )
				{
					if_var( &class_type : t.GetClassType() )
					{
						class_= class_type;
					}
				}
			}

			if( !class_.empty() )
			{
				// We need to build class here, because class internal namespace may be filled in build process in case of inheritance.
				// TODO - maybe not build it here if class have no parents?
				BuildClass( ust::to_non_nullable(current_scope), ust::to_non_nullable( class_ ) );

				auto class_lock= class_.lock_imut();
				auto& class_ref= class_lock.get_ref();
				namespace_= class_ref.members;

				if( u32( names_scope.lock_imut().get_ref().GetAccessFor( ust::to_non_nullable(class_) ) ) <
					u32( class_ref.GetMemberVisibility( name_component_name ) ) )
				{
					REPORT_ERROR( AccessingNonpublicClassMember, names_scope, complex_name.file_pos, name_component_name, Type(ust::to_non_nullable(class_)).ToString() )
				}
			}

			if( !namespace_.empty() )
			{
				auto namespace_lock= namespace_.lock_imut();
				auto new_value= namespace_lock.get_ref().GetThisScopeValue( name_component_name );
				if( new_value.empty() )
				{
					REPORT_ERROR( NameNotFound, names_scope, complex_name.file_pos, name_component_name )
					return ErrorValue();
				}

				current_value.get_ref()= new_value.get_ref();
				current_scope= namespace_;
			}
			else if( !enum_.empty() )
			{
				auto enum_non_null= ust::to_non_nullable(enum_);
				BuildEnum( ust::to_non_nullable(current_scope), enum_non_null );

				auto lock= enum_.lock_imut();

				auto element= lock.get_ref().elements.find( name_component_name );
				if( element.empty() )
				{
					REPORT_ERROR( NameNotFound, names_scope, complex_name.file_pos, name_component_name )
					return ErrorValue();
				}

				var NamesScopeVariable mut v
				{
					.t= enum_non_null,
					.is_mutable= false,
					.llvm_value= element.get_ref().llvm_value,
					.constexpr_value= element.get_ref().constexpr_value,
				};

				current_value= move(v);
			}
			else if( !type_templates_set.empty() )
			{
				REPORT_ERROR( TemplateInstantiationRequired, names_scope, complex_name.file_pos, name_component_name )
				return ErrorValue();
			}
			else
			{
				REPORT_ERROR( NameNotFound, names_scope, complex_name.file_pos, name_component_name ) // TODO -print more relevant error
				return ErrorValue();
			}

			if( name_component_name == KeywordToString( Keyword::constructor_ ) ||
				name_component_name == KeywordToString( Keyword::destructor_ ) )
			{
				if( !function_context.is_in_unsafe_block )
				{
					REPORT_ERROR( ExplicitAccessToThisMethodIsUnsafe, names_scope, complex_name.file_pos, name_component_name )
				}
			}
		}
		if_var( &template_args : name_component.get</ ust::box</Synt::TemplateArgs/> />() )
		{
			auto type_templates_set= current_value.get_ref().Get</TypeTemplatesSet/>();
			auto functions_set= current_value.get_ref().Get</NamesScopeFunctionsSet/>();
			if( !type_templates_set.empty() )
			{
				BuiltTypeTemplatesSet( ust::to_non_nullable(current_scope), ust::to_non_nullable(type_templates_set) );

				if( skip_last_template_args && i + 1s == complex_name.tail.size()  )
				{
					break;
				}

				auto generated_type= GenTemplateType(
					names_scope,
					function_context,
					ust::to_non_nullable(type_templates_set),
					template_args.get_ref(),
					complex_name.file_pos );
				if( !generated_type.empty() )
				{
					current_value.get_ref()= generated_type.get_ref();
					if_var( generated_class : generated_type.get_ref().GetClassType() )
					{
						current_value= NamesScopeValue( generated_class );
						current_scope= generated_class.lock_imut().get_ref().members;
					}
				}
				else
				{
					return ErrorValue();
				}
			}
			else if( !functions_set.empty() )
			{
				BuildFunctionsSet( ust::to_non_nullable(current_scope), ust::to_non_nullable( functions_set ), false );
				auto lock= functions_set.lock_imut();
				auto& f= lock.get_ref();

				if( f.functions_set.function_templates.empty() )
				{
					REPORT_ERROR( ValueIsNotTemplate, names_scope, complex_name.file_pos )
					return ErrorValue();
				}

				current_value=
					ParametrizeTemplateFunctions(
						names_scope,
						function_context,
						f.functions_set,
						template_args.get_ref(),
						complex_name.file_pos );
				if( current_value.empty() )
				{
					return ErrorValue();
				}
			}
			else
			{
				REPORT_ERROR( ValueIsNotTemplate, names_scope, complex_name.file_pos )
				return ErrorValue();
			}
		}
	}

	{
		auto template_arg_ptr= current_value.get_ref().Get</TemplateArg/>();
		if( !template_arg_ptr.empty() )
		{
			auto template_arg_lock= template_arg_ptr.lock_imut();
			auto& template_arg= template_arg_lock.get_ref();
			if( !template_arg.something.get</TemplateArg::NotKnownYet/>().empty() )
			{
				REPORT_ERROR( TemplateArgumentIsNotDeducedYet, names_scope, complex_name.file_pos, complex_name.name )
				return ErrorValue();
			}
		}
	}

	return NamesScopeValueToValue( ust::to_non_nullable(current_scope), function_context, current_value.get_ref(), complex_name.file_pos );
}

fn CodeBuilder::FillGlobalNamesScope( this, NamesScope &mut names_scope )
{
	var [ tup[ Keyword, U_FundamentalType ], 17 ] constexpr types_table
	[
		[ Keyword::void_, U_FundamentalType::void_ ],
		[ Keyword::bool_, U_FundamentalType::bool_ ],
		[ Keyword::i8_  , U_FundamentalType::i8_   ],
		[ Keyword::u8_  , U_FundamentalType::u8_   ],
		[ Keyword::i16_ , U_FundamentalType::i16_  ],
		[ Keyword::u16_ , U_FundamentalType::u16_  ],
		[ Keyword::i32_ , U_FundamentalType::i32_  ],
		[ Keyword::u32_ , U_FundamentalType::u32_  ],
		[ Keyword::i64_ , U_FundamentalType::i64_  ],
		[ Keyword::u64_ , U_FundamentalType::u64_  ],
		[ Keyword::i128_, U_FundamentalType::i128_ ],
		[ Keyword::u128_, U_FundamentalType::u128_ ],
		[ Keyword::f32_ , U_FundamentalType::f32_  ],
		[ Keyword::f64_ , U_FundamentalType::f64_  ],
		[ Keyword::char8_ , U_FundamentalType::char8_  ],
		[ Keyword::char16_, U_FundamentalType::char16_ ],
		[ Keyword::char32_, U_FundamentalType::char32_ ],
	];

	foreach( &el : types_table )
	{
		names_scope.AddName( KeywordToString( el[0] ), Type( FundamentalType( el[1], GetFundamentalLLVMType(el[1]) ) ) );
	}

	names_scope.AddName( KeywordToString(Keyword::size_type_), size_type_ );
}

fn CodeBuilder::BuildFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeFunctionsSet/> functions_set_ptr, bool build_body )
{
	if( !build_body )
	{
		{ // First, lock as imut and check if complete.
			auto l= functions_set_ptr.lock_imut();
			var NamesScopeFunctionsSet& functions_set= l.get_ref();
			if( functions_set.syntax_elements.empty() &&
				functions_set.out_of_line_syntax_elements.empty() &&
				functions_set.function_templates_syntax_elements.empty() ) // Already complete
			{
				return;
			}
		}
	}

	{ 	// Preapare functions set itself.
		auto mut l= functions_set_ptr.lock_mut();
		var NamesScopeFunctionsSet &mut functions_set= l.get_ref();

		while( !functions_set.syntax_elements.empty() )
		{
			auto syntax_element_ptr= functions_set.syntax_elements.back();
			auto class_type_ptr= functions_set.class_;
			PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set.functions_set, false );
			functions_set.syntax_elements.drop_back();
		}
		while( !functions_set.out_of_line_syntax_elements.empty() )
		{
			auto syntax_element_ptr= functions_set.out_of_line_syntax_elements.back();
			auto class_type_ptr= functions_set.class_;
			PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set.functions_set, true );
			functions_set.out_of_line_syntax_elements.drop_back();
		}
		while( !functions_set.function_templates_syntax_elements.empty() )
		{
			auto syntax_element_ptr= functions_set.function_templates_syntax_elements.back();
			auto function_template= PrepareFunctionTemplate( names_scope_ptr, syntax_element_ptr, functions_set.class_ );
			functions_set.functions_set.function_templates.push_back( function_template );
			functions_set.function_templates_syntax_elements.drop_back();
		}
	}

	if( build_body )
	{
		foreach( &func_variable : functions_set_ptr.lock_imut().get_ref().functions_set.functions )
		{
			BuildFuncCode( names_scope_ptr, func_variable );
		}
	}
}

fn CodeBuilder::BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type )
{
	{
		auto lock= class_type.lock_imut();
		auto& ref= lock.get_ref();
		if( ref.is_complete || ref.syntax_element.empty() )
		{
			return;
		}
	}

	auto syntax_element_ptr= class_type.lock_imut().get_ref().syntax_element;
	auto& syntax_element= syntax_element_ptr.get_ref();

	auto mut global_function_context= CreateGlobalFunctionContext();

	// Fill parents
	foreach( &parent_name : syntax_element.parents )
	{
		auto parent_type= PrepareType( names_scope_ptr, global_function_context, parent_name );
		if( parent_type.GetClassType().empty() )
		{
			REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.file_pos, parent_type )
			continue;
		}

		if( !EnsureTypeComplete( parent_type ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope_ptr, syntax_element.file_pos, parent_type )
			continue;
		}

		auto parent_class= parent_type.GetClassType().get_ref();

		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.get_ref();

		auto mut duplicated= false;
		foreach( &prev_parent : class_.parents )
		{
			duplicated|= prev_parent.class_ == parent_class;
		}
		if( duplicated )
		{
			REPORT_ERROR( DuplicatedParentClass, names_scope_ptr, syntax_element.file_pos, parent_type )
			continue;
		}

		auto parent_kind= parent_class.lock_imut().get_ref().kind;
		if( !( parent_kind == ClassType::Kind::Abstract || parent_kind == ClassType::Kind::Interface || parent_kind == ClassType::Kind::PolymorphNonFinal ) )
		{
			REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.file_pos, parent_type )
			continue;
		}

		if( parent_kind != ClassType::Kind::Interface ) // not interface=base
		{
			if( !class_.base_class.empty() )
			{
				REPORT_ERROR( DuplicatedBaseClass, names_scope_ptr, syntax_element.file_pos, parent_type )
				continue;
			}
			class_.base_class= parent_class;
		}

		{ // Give access from this class to protected members of all ancestor classes.
			auto mut members_lock= class_.members.lock_mut();
			AddAncestorsAccessRights_r( members_lock.get_ref(), parent_class );
		}

		var ClassType::Parent mut parent{ .class_= parent_class };
		class_.parents.push_back( move(parent) );
	}

	{ // Pre-mark class as polymorph, because it's needed for functions checks. Exact kind of class we will known later.
		auto mut lock= class_type.lock_mut();
		auto &mut class_= lock.get_ref();

		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
			!syntax_element.parents.empty() )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else
		{
			class_.kind= ClassType::Kind::NonPolymorph;
		}
	}

	// Allocate virtual table pointer, if class have no parents.
	// If class have at least one parent, reuse it's virtual table pointer.
	auto allocate_virtual_table_pointer= syntax_element.parents.empty() && (
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface );

	var ust::vector</ LLVMTypeRef /> mut fields_llvm_types;

	if( allocate_virtual_table_pointer )
	{
		unsafe{  fields_llvm_types.push_back( LLVMPointerType( fundamental_llvm_types_.int_ptr, 0u ) );  } // set exact type later.
	}

	{
		// Make base class first field. Add parent classes fields.

		auto mut lock= class_type.lock_mut();
		auto &mut class_= lock.get_ref();

		auto base_class= class_.base_class;
		if( !base_class.empty() )
		{
			fields_llvm_types.push_back( base_class.lock_imut().get_ref().llvm_type );
		}
		foreach( &mut parent : class_.parents )
		{
			if( parent.class_ != base_class )
			{
				parent.field_number= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( parent.class_.lock_imut().get_ref().llvm_type );
			}
			else
			{
				parent.field_number= 0u;
			}
		}
	}

	auto class_members= class_type.lock_imut().get_ref().members;
	auto mut field_count= 0u;
	foreach( &member : class_members.lock_imut().get_ref().GetInternalContainer() )
	{
		auto field_ptr= member.value().Get</ ClassField />();
		if( !field_ptr.empty() )
		{
			++field_count;

			auto mut field_lock= field_ptr.lock_mut();
			var ClassField &mut field= field_lock.get_ref();

			field.t= PrepareType( class_members, global_function_context, field.syntax_element.get_ref().t );

			if( !EnsureTypeComplete( field.t ) )
			{
				REPORT_ERROR( UsingIncompleteType, class_members, field.syntax_element.get_ref().file_pos, field.t )
				continue;
			}
			if( !field.is_reference && field.t.IsAbstract() )
			{
				REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope_ptr, field.syntax_element.get_ref().file_pos, field.t )
				continue;
			}

			field.index= fields_llvm_types.size();

			auto mut llvm_type= field.t.GetLLVMType();
			if( field.is_reference ) { unsafe{  llvm_type= LLVMPointerType( llvm_type, 0u );  } }

			fields_llvm_types.push_back( llvm_type );
		}

		auto functions_set_ptr= member.value().Get</ NamesScopeFunctionsSet />();
		if( !functions_set_ptr.empty() )
		{
			BuildFunctionsSet( class_members, ust::to_non_nullable( functions_set_ptr ), false );
		}

		// Type aliases required for class completeness.
		auto type_alias_ptr= member.value().Get</ TypeAlias />();
		if( !type_alias_ptr.empty() )
		{
			auto mut lock= type_alias_ptr.lock_mut();
			auto &mut type_alias= lock.get_ref();
			BuildTypeAlias( names_scope_ptr, type_alias );
		}
		// TODO - maybe build here also inner classes, enums, global variables?
	}

	// Generate destructor prototype before perparing virtual table to mark it as virtual and setup virtual table index.
	TryGenerateDestructorPrototype( class_type );

	if( !syntax_element.parents.empty() ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
	{
		PrepareClassVirtualTable( class_type );
		PrepareClassVirtualTableType( class_type );
		if( allocate_virtual_table_pointer )
		{
			unsafe
			{
				fields_llvm_types.front()= LLVMPointerType( class_type.lock_imut().get_ref().virtual_table_llvm_type, 0u );
			}
		}
	}

	{
		auto mut class_lock= class_type.lock_mut();
		var ClassType &mut class_= class_lock.get_ref();

		unsafe
		{
			// Check opaque before set body for cases of errors (class body duplication).
			if( LLVMIsOpaqueStruct( class_.llvm_type ) == LLVMBool::True )
			{
				if( fields_llvm_types.empty() )
				{
					var LLVMTypeRef dummy= zero_init;
					LLVMStructSetBody( class_.llvm_type, dummy, 0u, LLVMBool::False );
				}
				else
				{
					LLVMStructSetBody( class_.llvm_type, cast_imut(fields_llvm_types).front(), u32(fields_llvm_types.size()), LLVMBool::False );
				}
			}
		}
	}

	// Setup class kind.
	{
		auto mut lock= class_type.lock_mut();
		auto &mut class_= lock.get_ref();

		auto mut class_contains_pure_virtual_functions= false;
		foreach( &virtual_table_entry : class_.virtual_table )
		{
			class_contains_pure_virtual_functions|= virtual_table_entry.is_pure;
		}

		auto have_parents= class_.parents.empty();
		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Class )
		{
			class_.kind= select( have_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphNonFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.file_pos, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Final )
		{
			class_.kind= select( have_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.file_pos, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.file_pos, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface )
		{
			if( !class_.base_class.empty() )
			{
				REPORT_ERROR( BaseClassForInterface, names_scope_ptr, syntax_element.file_pos )
			}
			if( field_count != 0u )
			{
				REPORT_ERROR( FieldsForInterfacesNotAllowed, names_scope_ptr, syntax_element.file_pos )
			}

			{
				// Constructors value should always exists and should always be NamesScopeFunctionsSet.
				auto constructors_ptr= class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).get_ref().Get</NamesScopeFunctionsSet/>();
				auto constructors_lock= constructors_ptr.lock_imut();
				auto& constructors= constructors_lock.get_ref();
				if( !constructors.functions_set.functions.empty() || !constructors.functions_set.function_templates.empty() )
				{
					REPORT_ERROR( ConstructorForInterface, names_scope_ptr, syntax_element.file_pos )
				}
			}
			foreach( &virtual_table_entry : class_.virtual_table )
			{
				if( !virtual_table_entry.is_pure && virtual_table_entry.name != KeywordToString( Keyword::destructor_ ) )
				{
					// TODO - report using function file_pos for each function.
					REPORT_ERROR( NonPureVirtualFunctionInInterface, names_scope_ptr, syntax_element.file_pos, syntax_element.name )
					break;
				}
			}

			class_.kind= ClassType::Kind::Interface;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
		{
			class_.kind= ClassType::Kind::Abstract;
		}
		else{ halt; }
	}

	BuildClassVirtualTable( class_type );

	TryGenerateDefaultConstructor( class_type );
	TryGenerateCopyConstructor( class_type );
	TryGenerateCopyAssignmentOperator( class_type );
	TryGenerateDestructor( class_type );

	{
		auto mut class_lock= class_type.lock_mut();
		var ClassType &mut class_= class_lock.get_ref();

		// Search for explicit noncopy constructors.
		if_var( constructors : class_members.lock_imut().get_ref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ) )
		{
			auto functions_set_ptr= constructors.Get</NamesScopeFunctionsSet/>();
			// Should be functions set 100%
			foreach( &function_variable : functions_set_ptr.lock_imut().get_ref().functions_set.functions )
			{
				if( function_variable.is_generated )
				{
					continue;
				}

				if( IsDefaultConstructor( function_variable, class_type ) )
				{
					class_.have_explicit_noncopy_constructors= true;
				}
				else if( IsCopyConstructor( function_variable, class_type ) ) {}
				else
				{
					class_.have_explicit_noncopy_constructors= true;
				}
			}
		}
	}

	// Merge namespaces of parents.
	foreach( &parent : class_type.lock_imut().get_ref().parents )
	{
		auto parent_members= parent.class_.lock_imut().get_ref().members;
		foreach( &member_value : parent_members.lock_imut().get_ref().GetInternalContainer() )
		{
			auto mut dst_members_lock= class_members.lock_mut();
			auto &mut dst_members_= dst_members_lock.get_ref();

			if( !member_value.value().Get</ClassType/>().empty() ||
				!member_value.value().Get</Enum/>().empty() ||
				!member_value.value().Get</TypeAlias/>().empty() ||
				!member_value.value().Get</GlobalVariable/>().empty() ||
				!member_value.value().Get</GlobalAutoVariable/>().empty() )
			{
				dst_members_.AddName( member_value.key(), member_value.value() );
			}

			auto src_functions_set_ptr= member_value.value().Get</NamesScopeFunctionsSet/>();
			if( !src_functions_set_ptr.empty() )
			{
				// SPARCHE_TODO - maybe also skip additive-assignment operators?
				if( member_value.key() == KeywordToString( Keyword::constructor_ ) ||
					member_value.key() == KeywordToString( Keyword::destructor_ ) ||
					member_value.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) )
				{
					continue; // Did not inherit constructors, destructors, assignment operators.
				}

				if( dst_members_.GetThisScopeValue( member_value.key() ).empty() )
				{
					// Just add new functions set.
					dst_members_.AddName( cast_imut(member_value).key(), cast_imut(member_value).value() );
					continue;
				}

				auto result_class_value= dst_members_.GetThisScopeValue( member_value.key() );
				auto result_functions_set_ptr= result_class_value.get_ref().Get</NamesScopeFunctionsSet/>();
				if( result_functions_set_ptr.empty() )
				{
					continue; // Name in new class shadows name with different kind in parent class.
				}
				// Merge functions sets.

				auto src_functions_set_lock= src_functions_set_ptr.lock_imut();
				auto& src_functions_set= src_functions_set_lock.get_ref();

				auto mut result_functions_set_lock= result_functions_set_ptr.lock_mut();
				auto &mut result_functions_set= result_functions_set_lock.get_ref();

				foreach( &src_function : src_functions_set.functions_set.functions )
				{
					if( !GetFunctionWithSameType( result_functions_set.functions_set, src_function.t ).empty() )
					{
						continue; // New class function shadows function with same type in source class, so, skip it.
					}
					ApplyOverloadedFunction( result_functions_set.functions_set, src_function, class_members, syntax_element.file_pos );
				}

				// TODO - merge function templates smarter.
				foreach( &function_template : src_functions_set.functions_set.function_templates )
				{
					result_functions_set.functions_set.function_templates.push_back( function_template );
				}
			} // if function set
		} // for parent members
	} // for parents

	// Finally, make class complete.
	{
		auto mut class_lock= class_type.lock_mut();
		class_lock.get_ref().is_complete= true;
	}
}

fn CodeBuilder::BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type )
{
	if( enum_type.lock_imut().get_ref().underlaying_type.llvm_type != LLVMTypeRef::Null )
	{
		return;
	}

	auto mut lock= enum_type.lock_mut();
	var Enum &mut enum_= lock.get_ref();

	auto enum_declaration_ptr= enum_.syntax_element;
	auto& enum_declaration= enum_declaration_ptr.get_ref();

	// Default underlaying type is 32bit. TODO - maybe do it platform-dependent?
	enum_.underlaying_type= FundamentalType( U_FundamentalType::u32_, fundamental_llvm_types_.u32_ );
	if( !enum_declaration.underlaying_type.name.empty() )
	{
		var FunctionContext mut function_context= CreateGlobalFunctionContext();
		auto t= PrepareType( names_scope_ptr, function_context, enum_declaration.underlaying_type );

		auto fundamental_type= t.GetFundamentalType();
		if( fundamental_type.empty() || !IsInteger( fundamental_type.get_ref().fundamental_type ) )
		{
			// SPRACHE_TODO - maybe allow inheritance of enums?
			REPORT_ERROR( TypesMismatch, names_scope_ptr, enum_declaration.file_pos, ust::string8("any integer type"), t )
		}
		else
		{
			enum_.underlaying_type= fundamental_type.get_ref();
		}
	}

	foreach( &element : enum_declaration.elements )
	{
		if( IsKeyword( element.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, element.file_pos )
		}

		if( !enum_.elements.find( element.name ).empty() )
		{
			REPORT_ERROR( Redefinition,  names_scope_ptr, element.file_pos, element.name )
		}

		var Enum::Element mut out_element;

		auto name_mangled= MangleGlobalVariable( enum_.names_scope.lock_imut().get_ref(), element.name );
		unsafe
		{
			out_element.constexpr_value= LLVMConstInt( enum_.underlaying_type.llvm_type, u64(enum_.elements.size()), LLVMBool::False );
			out_element.llvm_value= LLVMAddGlobal( module_, enum_.underlaying_type.llvm_type, name_mangled.front() );
			LLVMSetLinkage( out_element.llvm_value, LLVMLinkage::Internal );
			LLVMSetGlobalConstant( out_element.llvm_value, LLVMBool::True );
			LLVMSetInitializer( out_element.llvm_value, out_element.constexpr_value );
		}

		enum_.elements.insert( element.name, move(out_element) );
	}

	var u64 bit_width(enum_.underlaying_type.GetSize() * 8s);
	if( bit_width < 32u64 ) // Assume that 64 bits are enough for all enums.
	{
		auto max_value_plus_one=
			1u64 << ( bit_width - select( IsSignedInteger( enum_.underlaying_type.fundamental_type ) ? 1u64 : 0u64 ) );
		auto max_value= max_value_plus_one - 1u64;

		if( u64(enum_.elements.size()) > max_value )
		{
			REPORT_ERROR( UnderlayingTypeForEnumIsTooSmall, names_scope_ptr, enum_declaration.file_pos, enum_.elements.size() - 1s, max_value )
		}
	}
}

fn CodeBuilder::BuildTypeAlias( mut this, NamesScopePtr& names_scope, TypeAlias& mut type_alias )
{
	if( !type_alias.t.empty() )
	{
		return;
	}

	auto syntax_element_ptr= type_alias.syntax_element;

	var FunctionContext mut function_context= CreateGlobalFunctionContext();
	type_alias.t.reset( PrepareType( names_scope, function_context, syntax_element_ptr.get_ref().type_name ) );
}

fn CodeBuilder::BuildGlobalVariable( mut this, NamesScopePtr& names_scope, GlobalVariable& mut global_variable )
{
	if( !global_variable.variable.empty() )
	{
		return;
	}

	auto variables_declaration_ptr= global_variable.syntax_element;
	auto& variables_declaration= variables_declaration_ptr.get_ref();
	auto& variable_declaration= variables_declaration.variables[ global_variable.variable_index ];

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	global_variable.variable.reset( NamesScopeVariable() );
	var NamesScopeVariable &mut variable= global_variable.variable.get_ref();

	variable.t= PrepareType( names_scope, function_context, variables_declaration.t );
	if( !EnsureTypeComplete( variable.t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, variables_declaration.file_pos, variable.t )
		return;
	}
	if( !variable.t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope, variable_declaration.file_pos )
		return;
	}
	if( variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable )
	{
		REPORT_ERROR( GlobalVariableMustBeConstexpr, names_scope, variable_declaration.file_pos, variable_declaration.name )
		return;
	}

	if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= MangleGlobalVariable( names_scope.lock_imut().get_ref(), variable_declaration.name );
		unsafe
		{
			variable.llvm_value= LLVMAddGlobal( module_, variable.t.GetLLVMType(), name_mangled.front() );
			LLVMSetLinkage( variable.llvm_value, LLVMLinkage::Internal );
			LLVMSetGlobalConstant( variable.llvm_value, LLVMBool::True );
		}

		if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
		{
			BuildEmptyInitializer( names_scope, function_context, variable, variable_declaration.name, variable_declaration.file_pos );
		}
		else
		{
			variable.constexpr_value= BuildInitializer( names_scope, function_context, variable, variable_declaration.initializer );
		}

		unsafe{  LLVMSetInitializer( variable.llvm_value, variable.constexpr_value );  }
	}
	else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( !variable_declaration.initializer.get</Synt::EmptyVariant/>().empty() )
		{
			REPORT_ERROR( ExpectedInitializer, names_scope, variable_declaration.file_pos, variable_declaration.name )
			return;
		}

		var ust::optional_ref</Synt::Expression, false/> mut initializer_expression;
		if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
		{
			initializer_expression.reset(expression_initializer);
		}
		if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
		{
			if( constructor_initializer.args.size() != 1s )
			{
				REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope, constructor_initializer.file_pos )
				return;
			}

			initializer_expression.reset( constructor_initializer.args.front().get_ref() );
		}

		if( initializer_expression.empty() )
		{
			REPORT_ERROR( UnsupportedInitializerForReference, names_scope, variable_declaration.file_pos )
			return;
		}

		auto expression_result= BuildExpressionCodeEnsureVariable( names_scope, function_context, initializer_expression.get_ref() );
		// TODO - allow reference conversion
		if( expression_result.t != variable.t )
		{
			REPORT_ERROR( TypesMismatch, names_scope, variable_declaration.file_pos, variable.t, expression_result.t )
			return;
		}

		variable.llvm_value= expression_result.llvm_value;
		variable.constexpr_value= expression_result.constexpr_value;
	}
	else{ halt; }

	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, variable_declaration.file_pos )
	}

	// TODO - maybe clear here dummy global function?
}

fn CodeBuilder::BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope, GlobalAutoVariable& mut global_auto_variable )
{
	if( !global_auto_variable.variable.empty() )
	{
		return;
	}

	auto auto_variable_declaration_ptr= global_auto_variable.syntax_element;
	auto& auto_variable_declaration= auto_variable_declaration_ptr.get_ref();

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	global_auto_variable.variable.reset( NamesScopeVariable() );
	var NamesScopeVariable &mut variable= global_auto_variable.variable.get_ref();

	var Variable expr= BuildExpressionCodeEnsureVariable( names_scope, function_context, auto_variable_declaration.initializer_expression );
	variable.t= expr.t;
	if( variable.t == invalid_type_ )
	{
		REPORT_ERROR( InvalidTypeForAutoVariable, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
		return;
	}
	if( !variable.t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope, auto_variable_declaration.file_pos )
		return;
	}
	if( auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable )
	{
		REPORT_ERROR( GlobalVariableMustBeConstexpr, names_scope, auto_variable_declaration.file_pos, auto_variable_declaration.name )
		return;
	}

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue,  names_scope, auto_variable_declaration.file_pos )
			return;
		}

		variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= MangleGlobalVariable( names_scope.lock_imut().get_ref(), auto_variable_declaration.name );
		unsafe
		{
			variable.llvm_value= LLVMAddGlobal( module_, variable.t.GetLLVMType(), name_mangled.front() );
			LLVMSetLinkage( variable.llvm_value, LLVMLinkage::Internal );
			LLVMSetGlobalConstant( variable.llvm_value, LLVMBool::True );
			LLVMSetInitializer( variable.llvm_value, expr.constexpr_value );
		}

		if( !expr.t.IsCopyConstructible() )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, auto_variable_declaration.file_pos, variable.t )
		}

		BuildCopyConstructorPart( names_scope, function_context, variable.llvm_value, expr.llvm_value, variable.t, auto_variable_declaration.file_pos );
	}
	else { halt; }

	variable.constexpr_value= expr.constexpr_value;
	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope, auto_variable_declaration.file_pos )
	}
}

fn CodeBuilder::PrepareFunction(
	mut this,
	ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
	NamesScopePtr& names_scope_ptr,
	ust::shared_ptr_nullable_mut</ClassType/>& class_type,
	FunctionsSet &mut functions_set,
	bool is_out_of_line_function ) : bool
{
	auto& function_declaration= function_declaration_ptr.get_ref();
	auto& func_name= function_declaration.name.back();

	if( !function_declaration.constructor_initializer_list.empty() && func_name != KeywordToString( Keyword::constructor_ ) )
	{
		REPORT_ERROR( InitializationListInNonconstructor, names_scope_ptr, function_declaration.constructor_initializer_list.get_ref().file_pos )
	}

	auto mut global_function_context= CreateGlobalFunctionContext();

	var FunctionVariable mut function_variable
	{
		.t= PrepareFunctionType( names_scope_ptr, global_function_context, function_declaration.function_type, class_type )
	};
	if( function_declaration.block.empty() )
	{
		function_variable.prototype_syntax_element= function_declaration_ptr;
	}
	else
	{
		function_variable.body_syntax_element= function_declaration_ptr;
	}

	function_variable.is_this_call=
		!function_declaration.function_type.args.empty() &&
		function_declaration.function_type.args.front().name == KeywordToString( Keyword::this_ );

	auto is_constructor= func_name == KeywordToString( Keyword::constructor_ );
	auto is_destructor = func_name == KeywordToString( Keyword::destructor_  );
	{
		auto& function_type= function_variable.t;
		if( ( is_constructor || is_destructor ) &&
			!(function_type.return_type == void_type_ && !function_type.return_value_is_reference ) )
		{
			REPORT_ERROR( ConstructorAndDestructorMustReturnVoid, names_scope_ptr, function_declaration.file_pos )
		}
		if( func_name == KeywordToString( Keyword::destructor_ ) && function_type.args.size() > 1s )
		{
			REPORT_ERROR( ExplicitArgumentsInDestructor, names_scope_ptr, function_declaration.file_pos )
		}

		CheckOverloadedOperator( class_type, function_type, function_declaration.operator, names_scope_ptr, function_declaration.file_pos );
	}

	if( function_declaration.virtual_kind != Synt::Function::VirtualKind::None )
	{
		if( class_type.empty() )
		{
			REPORT_ERROR( VirtualForNonclassFunction, names_scope_ptr, function_declaration.file_pos, func_name )
		}
		if( !function_variable.is_this_call )
		{
			REPORT_ERROR( VirtualForNonThisCallFunction, names_scope_ptr, function_declaration.file_pos, func_name )
		}
		if( is_constructor )
		{
			REPORT_ERROR( FunctionCanNotBeVirtual, names_scope_ptr, function_declaration.file_pos, func_name )
		}
		if( !class_type.empty() )
		{
			auto class_lock= class_type.lock_imut();
			auto& class_ref= class_lock.get_ref();
			if( class_ref.kind == ClassType::Kind::Struct || class_ref.kind == ClassType::Kind::NonPolymorph )
			{
				REPORT_ERROR( VirtualForNonpolymorphClass, names_scope_ptr, function_declaration.file_pos, func_name )
			}
		}
		if( is_out_of_line_function )
		{
			REPORT_ERROR( VirtualForFunctionImplementation, names_scope_ptr, function_declaration.file_pos, func_name )
		}
	}

	// Check "=default" / "=delete".
	if( function_declaration.body_kind != Synt::Function::BodyKind::Regular )
	{
		var bool mut invalid_func= false;

		if( class_type.empty() ){ invalid_func= true; }
		else
		{
			auto class_type_non_null= ust::to_non_nullable( class_type );
			if( is_constructor && ( IsDefaultConstructor( function_variable, class_type_non_null ) || IsCopyConstructor( function_variable, class_type_non_null ) ) )
			{}
			else if( function_declaration.operator == OverloadedOperator::Assign && IsCopyAssignmentOperator( function_variable, class_type_non_null ) )
			{}
			else{ invalid_func= true; }
		}

		if( invalid_func )
		{
			REPORT_ERROR( InvalidMethodForBodyGeneration, names_scope_ptr, function_declaration.file_pos )
		}
		else
		{
			select( function_declaration.body_kind == Synt::Function::BodyKind::BodyGenerationRequired ? function_variable.is_generated : function_variable.is_deleted )= true;
		}
	}

	if_var( &mut prev_function : GetFunctionWithSameType( functions_set, function_variable.t ) )
	{
		if( prev_function.prototype_syntax_element.empty() )
		{
			prev_function.prototype_syntax_element= function_variable.prototype_syntax_element;
		}
		else if( !function_variable.prototype_syntax_element.empty() )
		{
			REPORT_ERROR(
				FunctionPrototypeDuplication,
				names_scope_ptr,
				ust::max( function_declaration.file_pos, prev_function.prototype_syntax_element.get_ref().file_pos ),
				func_name )
			return false;
		}

		if( prev_function.body_syntax_element.empty() )
		{
			prev_function.body_syntax_element= function_variable.body_syntax_element;
		}
		else if( !function_variable.body_syntax_element.empty() )
		{
			REPORT_ERROR(
				FunctionBodyDuplication,
				names_scope_ptr,
				ust::max( function_declaration.file_pos, prev_function.body_syntax_element.get_ref().file_pos ),
				func_name )
			return false;
		}

		if( prev_function.is_this_call != function_variable.is_this_call )
		{
			REPORT_ERROR( ThiscallMismatch, names_scope_ptr, function_declaration.file_pos, func_name )
			return false;
		}

		if( !is_out_of_line_function &&
			!prev_function.body_syntax_element.empty() && !prev_function.prototype_syntax_element.empty() &&
			prev_function.body_syntax_element.get_ref().virtual_kind != prev_function.prototype_syntax_element.get_ref().virtual_kind )
		{
			REPORT_ERROR( VirtualMismatch, names_scope_ptr, prev_function.body_syntax_element.get_ref().file_pos, func_name )
			return false;
		}
		if( !prev_function.body_syntax_element.empty() && !prev_function.prototype_syntax_element.empty() &&
			prev_function.prototype_syntax_element.get_ref().virtual_kind == Synt::Function::VirtualKind::VirtualPure )
		{
			REPORT_ERROR( BodyForPureVirtualFunction, names_scope_ptr, prev_function.body_syntax_element.get_ref().file_pos, func_name )
			return false;
		}

		if( prev_function.is_deleted != function_variable.is_deleted )
		{
			REPORT_ERROR( BodyForDeletedFunction, names_scope_ptr, prev_function.prototype_syntax_element.get_ref().file_pos, func_name )
			return false;
		}
		if( prev_function.is_generated != function_variable.is_generated )
		{
			REPORT_ERROR( BodyForGeneratedFunction, names_scope_ptr, prev_function.prototype_syntax_element.get_ref().file_pos, func_name )
			return false;
		}

		return true;
	}

	if( is_out_of_line_function )
	{
		REPORT_ERROR( FunctionDeclarationOutsideItsScope, names_scope_ptr, function_declaration.file_pos )
		return false;
	}

	unsafe
	{
		function_variable.llvm_function=
			LLVMAddFunction(
				module_,
				MangleFunction(
					names_scope_ptr.lock_imut().get_ref(),
					func_name,
					function_variable.t ).front(),
				function_variable.t.llvm_type );
	}

	return ApplyOverloadedFunction( functions_set, move(function_variable), names_scope_ptr, function_declaration.file_pos );
}

fn CodeBuilder::CheckOverloadedOperator(
	this,
	ust::shared_ptr_nullable_mut</ClassType/>& class_type,
	FunctionType& func_type,
	OverloadedOperator operator,
	NamesScopePtr& names_scope,
	FilePos& file_pos )
{
	if( operator == OverloadedOperator::None ) { return; } // Non-operator

	if( class_type.empty() )
	{
		REPORT_ERROR( OperatorDeclarationOutsideClass, names_scope, file_pos )
		return;
	}

	auto class_type_non_null= ust::to_non_nullable( class_type );

	auto mut is_this_class= false;
	foreach( & arg : func_type.args )
	{
		if( arg.arg_type == class_type_non_null )
		{
			is_this_class= true;
			break;
		}
	}

	if( !is_this_class )
	{
		REPORT_ERROR( OperatorDoesNotHaveParentClassArguments, names_scope, file_pos )
	}

	auto ret_is_void=
		( func_type.return_type == void_type_ || func_type.return_type == void_type_for_ret_ ) &&
		!func_type.return_value_is_reference;

	if( operator == OverloadedOperator::Add ||
		operator == OverloadedOperator::Sub )
	{
		if( !( func_type.args.size() == 1s || func_type.args.size() == 2s ) )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
	}
	else
	if( operator == OverloadedOperator::Mul ||
		operator == OverloadedOperator::Div ||
		operator == OverloadedOperator::Rem ||
		operator == OverloadedOperator::And ||
		operator == OverloadedOperator::Or  ||
		operator == OverloadedOperator::Xor ||
		operator == OverloadedOperator::ShiftLeft  ||
		operator == OverloadedOperator::ShiftRight )
	{
		if( func_type.args.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
	}
	else
	if( operator == OverloadedOperator::AssignAdd ||
		operator == OverloadedOperator::AssignSub ||
		operator == OverloadedOperator::AssignMul ||
		operator == OverloadedOperator::AssignDiv ||
		operator == OverloadedOperator::AssignRem ||
		operator == OverloadedOperator::AssignAnd ||
		operator == OverloadedOperator::AssignOr  ||
		operator == OverloadedOperator::AssignXor ||
		operator == OverloadedOperator::AssignShiftLeft  ||
		operator == OverloadedOperator::AssignShiftRight ||
		operator == OverloadedOperator::Assign )
	{
		if( func_type.args.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
		if( !ret_is_void )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, file_pos, void_type_ )
		}
	}
	else
	if( operator == OverloadedOperator::Equal     ||
		operator == OverloadedOperator::NotEqual  ||
		operator == OverloadedOperator::Less      ||
		operator == OverloadedOperator::LessEqual ||
		operator == OverloadedOperator::Greater   ||
		operator == OverloadedOperator::GreaterEqual )
	{
		if( func_type.args.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
		if( !( func_type.return_type == bool_type_ && !func_type.return_value_is_reference ) )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, file_pos, void_type_ )
		}
	}
	else
	if( operator == OverloadedOperator::LogicalNot ||
		operator == OverloadedOperator::BitwiseNot )
	{
		if( func_type.args.size() != 1s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
	}
	else
	if( operator == OverloadedOperator::Increment ||
		operator == OverloadedOperator::Decrement )
	{
		if( func_type.args.size() != 1s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
		if( !ret_is_void )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, file_pos, void_type_ )
		}
	}
	else if( operator == OverloadedOperator::Indexing )
	{
		if( func_type.args.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
		// Indexing operator must have first argument of parent class.
		if( !func_type.args.empty() && func_type.args.front().arg_type != class_type_non_null )
		{
			REPORT_ERROR( OperatorDoesNotHaveParentClassArguments, names_scope, file_pos )
		}
		// TODO - maybe also disable non-this-call indexing operator?
	}
	else if( operator == OverloadedOperator::Call )
	{
		if( func_type.args.empty() )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, file_pos )
		}
		// Call operator must have first argument of parent class.
		if( !func_type.args.empty() && func_type.args.front().arg_type != class_type_non_null )
		{
			REPORT_ERROR( OperatorDoesNotHaveParentClassArguments, names_scope, file_pos )
		}
		// TODO - maybe also disable non-this-call call operator?
	}
}

fn CodeBuilder::BuildFuncCode( mut this, NamesScopePtr& names_scope, FunctionVariable& func_variable )
{
	if( func_variable.body_syntax_element.empty() )
	{
		return;
	}
	unsafe
	{
		if( LLVMCountBasicBlocks( func_variable.llvm_function ) != 0u )
		{
			return; // Body already exists
		}
	}

	auto& function_type= func_variable.t;

	var FunctionContext mut function_context_value(
		llvm_context_,
		func_variable.llvm_function,
		function_type.return_type,
		function_type.return_value_is_reference,
		function_type.return_value_is_mutable );

	var NamesScopeMutPtr args_names_scope_ptr( NamesScope( "", names_scope ) );

	var VariablesFrameHolder args_variables_frame_hodler(function_context_value);
	auto& mut function_context= args_variables_frame_hodler.GetFunctionContext();

	// TODO - maybe forbid incomplete types even for references?
	if( !function_type.return_value_is_reference && !EnsureTypeComplete( function_type.return_type ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, func_variable.body_syntax_element.get_ref().file_pos, function_type.return_type )
	}

	{
		auto mut args_names_scope_lock= args_names_scope_ptr.lock_mut();
		auto &mut args_names_scope= args_names_scope_lock.get_ref();

		auto is_s_ret= !function_type.return_value_is_reference && !function_type.return_type.GetClassType().empty();
		if( is_s_ret )
		{
			unsafe
			{
				var ust::array_view_imut</ char8 /> attr_name= "sret";
				auto attr_kind= LLVMGetEnumAttributeKindForName( attr_name.front(), attr_name.size() );
				auto attr= LLVMCreateEnumAttribute( llvm_context_, attr_kind, 0u64 );

				LLVMAddAttributeAtIndex( func_variable.llvm_function, LLVMAttributeFirstParamIndex, attr );

				function_context.s_ret= LLVMGetParam( func_variable.llvm_function, 0u );
				var ust::array_view_imut</ char8 /> param_name= "_return_value";
				LLVMSetValueName2( function_context.s_ret, param_name.front(), param_name.size() );
			}
		}

		auto mut arg_n= 0u;
		auto first_llvm_arg= select( is_s_ret ? 1u : 0u );
		foreach( &in_arg : func_variable.body_syntax_element.get_ref().function_type.args )
		{
			var NamesScopeVariable mut out_arg
			{
				.t= function_type.args[arg_n].arg_type,
				.is_mutable= function_type.args[arg_n].is_mutable,
			};

			// Ensure type completness even for reference args because of reference checking.
			if( !EnsureTypeComplete( out_arg.t ) )
			{
				REPORT_ERROR( UsingIncompleteType, names_scope, in_arg.file_pos, out_arg.t )
				return;
			}

			if( function_type.args[arg_n].is_reference )
			{
				unsafe
				{
					auto arg_value= LLVMGetParam( func_variable.llvm_function, first_llvm_arg + arg_n );
					LLVMSetValueName2( arg_value, in_arg.name.front(), in_arg.name.size() );
					out_arg.llvm_value= arg_value;
				}
			}
			else
			{
				if( !out_arg.t.GetClassType().empty() )
				{
					// Non-fundamentals are passed by reference.
					unsafe
					{
						auto arg_value= LLVMGetParam( func_variable.llvm_function, first_llvm_arg + arg_n );
						LLVMSetValueName2( arg_value, in_arg.name.front(), in_arg.name.size() );
						out_arg.llvm_value= arg_value;
					}
				}
				else
				{
					auto arg_name= "_arg_" + in_arg.name;
					unsafe
					{
						auto arg_value= LLVMGetParam( func_variable.llvm_function, first_llvm_arg + arg_n );
						LLVMSetValueName2( arg_value, arg_name.front(), arg_name.size() );

						out_arg.llvm_value= LLVMBuildAlloca( function_context.alloca_ir_builder, out_arg.t.GetLLVMType(), (in_arg.name + "\0").front() );

						LLVMBuildStore( function_context.llvm_ir_builder, arg_value, out_arg.llvm_value );
					}
				}

				function_context.variables_frames.back().push_back( out_arg ); // Register arg for destruction
			}

			++arg_n;

			if( in_arg.name == KeywordToString( Keyword::this_ ) && func_variable.is_this_call && !out_arg.t.GetClassType().empty() )
			{
				var Variable mut this_variable
				{
					.t= take(out_arg.t),
					.value_type= select( out_arg.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
					.llvm_value= out_arg.llvm_value,
				};
				function_context.this_= move(this_variable);
				move(out_arg);
			}
			else
			{
				var bool insert_ok= !args_names_scope.AddName( in_arg.name, NamesScopeValue( move(out_arg) ) ).empty();
				if( !insert_ok )
				{
					REPORT_ERROR( Redefinition, names_scope, in_arg.file_pos, in_arg.name )
				}
			}
		}
	}

	auto& block= func_variable.body_syntax_element.get_ref().block.get_ref();

	auto& func_name= func_variable.body_syntax_element.get_ref().name.back();
	auto is_constructor= func_name == KeywordToString( Keyword::constructor_ );
	auto is_destructor = func_name == KeywordToString( Keyword::destructor_  );
	if( is_constructor )
	{
		function_context.whole_this_is_unavailable= true;

		if( !func_variable.body_syntax_element.get_ref().constructor_initializer_list.empty() )
		{
			BuildConstructorInitialization(
				args_names_scope_ptr,
				function_context,
				func_variable.body_syntax_element.get_ref().constructor_initializer_list.get_ref() );
		}
		else
		{
			var Synt::StructNamedInitializer dummy_initializer{ .file_pos= block.file_pos };
			BuildConstructorInitialization(
				args_names_scope_ptr,
				function_context,
				dummy_initializer );
		}

		function_context.whole_this_is_unavailable= false;
	}
	if( is_destructor )
	{
		unsafe{  function_context.destructor_end_block= LLVMCreateBasicBlockInContext( llvm_context_, "destructor_end\0"[0] );  }
	}

	if( is_constructor || is_destructor )
	{
		// Setup virtual table pointers before main body of constructor/destructor and after constructor initialization list.
		auto this_llvm_value= function_context.this_.get_ref().llvm_value;
		auto class_type_ptr= function_context.this_.get_ref().t.GetClassType().get_ref();
		SetupVirtualTablePointers( this_llvm_value, class_type_ptr, function_context );
	}

	if( ( is_constructor || is_destructor ) && !function_context.this_.get_ref().t.GetClassType().empty() )
	{
		auto class_type= function_context.this_.get_ref().t.GetClassType().get_ref();
		auto class_kind= class_type.lock_imut().get_ref().kind;
		if( class_kind == ClassType::Kind::Interface || class_kind == ClassType::Kind::Abstract )
		{
			function_context.whole_this_is_unavailable= true;
		}
	}

	auto block_build_info= BuildBlockElement( args_names_scope_ptr, function_context, block );
	if( !block_build_info.have_terminal_instruction_inside )
	{
		if( function_type.return_type == void_type_ )
		{
			// Manually generate "return" for void-return functions.
			CallDestructorsForAllVariablesFrames( args_names_scope_ptr, function_context, block.end_file_pos );
			unsafe
			{
				if( function_context.destructor_end_block != LLVMBasicBlockRef::Null )
				{
					LLVMBuildBr( function_context.llvm_ir_builder, function_context.destructor_end_block );
				}
				else
				{
					LLVMBuildRetVoid( function_context.llvm_ir_builder );
				}
			}
		}
		else
		{
			REPORT_ERROR( NoReturnInFunctionReturningNonVoid, args_names_scope_ptr, block.end_file_pos )
			return;
		}
	}

	// Finsih function - add remaining instructions
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );

		if( function_context.destructor_end_block != LLVMBasicBlockRef::Null && ! function_context.this_.empty() )
		{
			LLVMAppendExistingBasicBlock( function_context.llvm_function, function_context.destructor_end_block );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, function_context.destructor_end_block );

			auto this_copy= function_context.this_.get_ref();
			if_var( &class_type : this_copy.t.GetClassType() )
			{
				BuildMembersDestructors( function_context, this_copy.llvm_value, class_type );
			}
			LLVMBuildRetVoid( function_context.llvm_ir_builder );
		}
	}
}

fn CodeBuilder::TryCallCopyConstructor(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	LLVMValueRef dst, LLVMValueRef src,
	ClassTypePtr& class_type,
	FilePos& file_pos )
{
	// TODO - maybe combine this with "BuildCopyConstructorPart" method?
	if( !class_type.lock_imut().get_ref().is_copy_constructible )
	{
		REPORT_ERROR( OperationNotSupportedForThisType, names_scope, file_pos, Type(class_type) )
		return;
	}

	// TODO - what if copy constructor is unsafe?

	BuildCopyConstructorPart( names_scope, function_context, dst, src, class_type, file_pos );
}

fn CodeBuilder::CallDestructorsForVariablesFrame( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variables_frame_index, FilePos& file_pos )
{
	// Call destructors in reverse order.
	for( auto mut i= function_context.variables_frames[variables_frame_index].size(); i > 0s; --i )
	{
		auto variable= function_context.variables_frames[variables_frame_index][i - 1s];
		BuildDestructorPart( names_scope, function_context, variable.llvm_value, variable.t, file_pos );
	}
}

fn CodeBuilder::CallDestructorsForTopVariablesFrame( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, FilePos& file_pos )
{
	auto variables_frame_index= function_context.variables_frames.size() - 1s;
	CallDestructorsForVariablesFrame( names_scope, function_context, variables_frame_index, file_pos );
}

fn CodeBuilder::CallDestructorsForAllVariablesFrames( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, FilePos& file_pos )
{
	for( auto mut i= function_context.variables_frames.size(); i > 0s; --i )
	{
		CallDestructorsForVariablesFrame( names_scope, function_context, i - 1s, file_pos );
	}
}

fn CodeBuilder::CallDestructorsForLoopInnerVariables( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, FilePos& file_pos )
{
	for( var size_type mut i= function_context.variables_frames.size(), i_end= function_context.loops_stack.back().variable_frames_stack_size; i > i_end; --i )
	{
		CallDestructorsForVariablesFrame( names_scope, function_context, i - 1s, file_pos );
	}
}

fn CodeBuilder::EnsureTypeComplete( mut this, Type& t ) : bool
{
	if_var( &class_type_ptr : t.GetClassType() )
	{
		// TODO - maybe names scope is not needed here?
		auto class_parent_scope= ust::to_non_nullable( class_type_ptr.lock_imut().get_ref().members.lock_imut().get_ref().GetParent() );

		BuildClass( class_parent_scope, class_type_ptr );
		return class_type_ptr.lock_imut().get_ref().is_complete;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		return EnsureTypeComplete( array_type.element_type );
	}

	return true;
}

fn CodeBuilder::GetFunctionWithSameType( FunctionsSet &'x mut functions_set, Type& function_type ) : ust::optional_ref</ FunctionVariable, true />'x'
{
	foreach( &mut function : functions_set.functions )
	{
		if( function.t == function_type )
		{
			return ust::optional_ref</ FunctionVariable, true />( function );
		}
	}

	return ust::optional_ref</ FunctionVariable, true />();
}

fn CodeBuilder::IsDefaultConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( !function_variable.is_this_call ){ return false; }
	if( function_variable.t.args.size() != 1s ){ return false; }

	auto& arg= function_variable.t.args.front();
	return arg.arg_type == class_type && arg.is_mutable && arg.is_reference;
}

fn CodeBuilder::IsCopyConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( !function_variable.is_this_call ){ return false; }
	if( function_variable.t.args.size() != 2s ){ return false; }

	auto& arg_dst= function_variable.t.args.front();
	auto& arg_src= function_variable.t.args.back();
	return
		arg_dst.arg_type == class_type &&  arg_dst.is_mutable && arg_dst.is_reference &&
		arg_src.arg_type == class_type && !arg_src.is_mutable && arg_src.is_reference;
}

fn CodeBuilder::IsCopyAssignmentOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( function_variable.t.args.size() != 2s ){ return false; }

	auto& arg_dst= function_variable.t.args.front();
	auto& arg_src= function_variable.t.args.back();
	return
		arg_dst.arg_type == class_type &&  arg_dst.is_mutable && arg_dst.is_reference &&
		arg_src.arg_type == class_type && !arg_src.is_mutable && arg_src.is_reference;
}

fn CodeBuilder::GetFundamentalLLVMType( this, U_FundamentalType t ) : LLVMTypeRef
{
	if( t == U_FundamentalType::InvalidType	) { return fundamental_llvm_types_.invalid_type_; }
	if( t == U_FundamentalType::void_		) { return fundamental_llvm_types_.void_; }
	if( t == U_FundamentalType::bool_		) { return fundamental_llvm_types_.bool_; }
	if( t == U_FundamentalType::i8_			) { return fundamental_llvm_types_.i8_	; }
	if( t == U_FundamentalType::u8_			) { return fundamental_llvm_types_.u8_	; }
	if( t == U_FundamentalType::i16_		) { return fundamental_llvm_types_.i16_	; }
	if( t == U_FundamentalType::u16_		) { return fundamental_llvm_types_.u16_	; }
	if( t == U_FundamentalType::i32_		) { return fundamental_llvm_types_.i32_	; }
	if( t == U_FundamentalType::u32_		) { return fundamental_llvm_types_.u32_	; }
	if( t == U_FundamentalType::i64_		) { return fundamental_llvm_types_.i64_	; }
	if( t == U_FundamentalType::u64_		) { return fundamental_llvm_types_.u64_	; }
	if( t == U_FundamentalType::i128_		) { return fundamental_llvm_types_.i128_; }
	if( t == U_FundamentalType::u128_		) { return fundamental_llvm_types_.u128_; }
	if( t == U_FundamentalType::f32_		) { return fundamental_llvm_types_.f32_	; }
	if( t == U_FundamentalType::f64_		) { return fundamental_llvm_types_.f64_	; }
	if( t == U_FundamentalType::char8_		) { return fundamental_llvm_types_.char8_ ; }
	if( t == U_FundamentalType::char16_		) { return fundamental_llvm_types_.char16_; }
	if( t == U_FundamentalType::char32_		) { return fundamental_llvm_types_.char32_; }

	halt;
}

fn CodeBuilder::GetZeroGEPIndex( this ) : LLVMValueRef
{
	unsafe{  return LLVMConstNull( fundamental_llvm_types_.i32_ );  }
}

fn CodeBuilder::CreateMoveToLLVMRegisterInstruction( Variable& variable, FunctionContext& function_context ) : LLVMValueRef
{
	if( variable.constexpr_value != LLVMValueRef::Null )
	{
		return variable.constexpr_value;
	}
	if( variable.location == Variable::Location::Pointer )
	{
		unsafe{  return LLVMBuildLoad( function_context.llvm_ir_builder, variable.llvm_value, "\0"[0] );  }
	}
	if( variable.location == Variable::Location::LLVMRegister )
	{
		return variable.llvm_value;
	}

	halt;
}

fn CodeBuilder::CreateReferenceCast( this, LLVMValueRef ref, Type& src_type, Type& dst_type, FunctionContext& function_context ) : LLVMValueRef
{
	if( src_type == dst_type )
	{
		return ref;
	}
	if( dst_type == void_type_ )
	{
		unsafe
		{
			auto dst_pointer_type= LLVMPointerType( dst_type.GetLLVMType(), 0u );
			return LLVMBuildPointerCast( function_context.llvm_ir_builder, ref, dst_pointer_type, "\0"[0] );
		}
	}

	auto src_class_type= src_type.GetClassType().get_ref();
	foreach( &parent : src_class_type.lock_imut().get_ref().parents )
	{
		auto mut sub_ref= LLVMValueRef::Null;
		unsafe
		{
			var [ LLVMValueRef, 2 ] indexes
			[
				GetZeroGEPIndex(),
				LLVMConstInt( fundamental_llvm_types_.u32_, u64(parent.field_number), LLVMBool::False )
			];

			sub_ref= LLVMBuildGEP( function_context.llvm_ir_builder, ref, indexes[0], 2u, "\0"[0] );
		}

		if( parent.class_ == dst_type )
		{
			return sub_ref;
		}
		else if( Type(parent.class_).ReferenceIsConvertibleTo( dst_type ) )
		{
			return CreateReferenceCast( sub_ref, parent.class_, dst_type, function_context );
		}
	}

	halt;
}

fn CodeBuilder::CreateFieldGEP( this, LLVMValueRef value, ClassField& field, FunctionContext& function_context ) : LLVMValueRef
{
	auto op_name_nt= "." + field.syntax_element.get_ref().name + "\0";
	unsafe
	{
		var [ LLVMValueRef, 2 ] indexes
		[
			GetZeroGEPIndex(),
			LLVMConstInt( fundamental_llvm_types_.u32_, u64(field.index), LLVMBool::False )
		];

		return LLVMBuildGEP( function_context.llvm_ir_builder, value, indexes[0], 2u, op_name_nt.front() );
	}
}

fn CodeBuilder::CreateParentFieldGEP( this, LLVMValueRef value, ClassType::Parent& parent, FunctionContext& function_context ) : LLVMValueRef
{
	unsafe
	{
		var [ LLVMValueRef, 2 ] indexes
		[
			GetZeroGEPIndex(),
			LLVMConstInt( fundamental_llvm_types_.u32_, u64(parent.field_number), LLVMBool::False )
		];

		return LLVMBuildGEP( function_context.llvm_ir_builder, value, indexes[0], 2u, "\0"[0] );
	}
}

fn CodeBuilder::CreateBaseClassFieldGEP( this, LLVMValueRef value, FunctionContext& function_context ) : LLVMValueRef
{
	var [ LLVMValueRef, 2 ] indexes
	[
		GetZeroGEPIndex(),
		GetZeroGEPIndex(), // Base class is always zero field.
	];

	unsafe{  return LLVMBuildGEP( function_context.llvm_ir_builder, value, indexes[0], 2u, ".base\0"[0] );  }
}

fn CodeBuilder::SaveInstructionsState( FunctionContext& function_context ) : InstructionsState
{
	unsafe
	{
		var InstructionsState mut instructions_state
		{
			.current_block_last_instruction= LLVMGetLastInstruction( LLVMGetInsertBlock( function_context.llvm_ir_builder ) ),
			.alloca_block_last_instruction= LLVMGetLastInstruction( LLVMGetInsertBlock( function_context.alloca_ir_builder ) ),
			.current_block= LLVMGetInsertBlock( function_context.llvm_ir_builder ),
		};
		return move(instructions_state);
	}
}

fn CodeBuilder::RestoreInstructionsState( FunctionContext &mut function_context, InstructionsState& state )
{
	unsafe
	{
		while( LLVMGetLastBasicBlock( function_context.llvm_function ) != state.current_block )
		{
			auto bb= LLVMGetLastBasicBlock( function_context.llvm_function );
			U1_DropAllBasicBlockUsersReferences( bb );
			LLVMDeleteBasicBlock( bb );
		}

		while( LLVMGetLastInstruction( state.current_block ) != state.current_block_last_instruction )
		{
			LLVMInstructionEraseFromParent( LLVMGetLastInstruction( state.current_block ) );
		}

		while( LLVMGetLastInstruction( function_context.alloca_basic_block ) != state.alloca_block_last_instruction )
		{
			LLVMInstructionEraseFromParent( LLVMGetLastInstruction( function_context.alloca_basic_block ) );
		}

		LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, state.current_block );
		LLVMPositionBuilderAtEnd( function_context.alloca_ir_builder, function_context.alloca_basic_block );
	}
}

fn CodeBuilder::CreateGlobalFunctionContext( this ) : FunctionContext
{
	var FunctionContext mut function_context(
		llvm_context_,
		global_llvm_function_,
		void_type_for_ret_,
		false,
		false );

	function_context.variables_frames.push_back( FunctionContext::VariablesFrame() );
	return move(function_context);
}

} // namespace U
