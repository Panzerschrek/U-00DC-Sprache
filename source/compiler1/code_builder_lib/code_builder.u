import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::constructor( LLVMContextRef llvm_context )
	(
		llvm_context_(llvm_context)
	)
{
	unsafe
	{
		fundamental_llvm_types_.i8_ = LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u8_ = LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i32_= LLVMInt32TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u32_= LLVMInt32TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i64_= LLVMInt64TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u64_= LLVMInt64TypeInContext( llvm_context_ );
		fundamental_llvm_types_.i128_= LLVMInt128TypeInContext( llvm_context_ );
		fundamental_llvm_types_.u128_= LLVMInt128TypeInContext( llvm_context_ );

		fundamental_llvm_types_.f32_= LLVMFloatTypeInContext( llvm_context_ );
		fundamental_llvm_types_.f64_= LLVMDoubleTypeInContext( llvm_context_ );

		fundamental_llvm_types_.char8_ = LLVMInt8TypeInContext ( llvm_context_ );
		fundamental_llvm_types_.char16_= LLVMInt16TypeInContext( llvm_context_ );
		fundamental_llvm_types_.char32_= LLVMInt32TypeInContext( llvm_context_ );

		fundamental_llvm_types_.invalid_type_= LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.void_= LLVMInt8TypeInContext( llvm_context_ );
		fundamental_llvm_types_.void_for_ret_= LLVMVoidTypeInContext( llvm_context_ );
		fundamental_llvm_types_.bool_= LLVMInt1TypeInContext( llvm_context_ );

		fundamental_llvm_types_.int_ptr= LLVMInt64TypeInContext( llvm_context_ ); // TODO - use data layout to obtaint int_ptr type
	}
}

fn CodeBuilder::BuildProgram( mut this, Synt::SyntaxAnalysisResult& ast ) : BuildResult
{
	var BuildResult mut res{ .llvm_module= LLVMModuleRef::Null };

	unsafe{ res.llvm_module= LLVMModuleCreateWithName( "some_module\0"[0] ); }

	var NamesScope mut global_names_scope( "" );

	FillGlobalNamesScope( global_names_scope );
	NamesScopeFill( global_names_scope, ast.program_elements );

	return move(res);
}

fn CodeBuilder::FillGlobalNamesScope( this, NamesScope &mut names_scope )
{
	names_scope.AddName( KeywordToString(Keyword::void_), Type( FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::bool_), Type( FundamentalType( U_FundamentalType::bool_, fundamental_llvm_types_.bool_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::i8_  ), Type( FundamentalType( U_FundamentalType::i8_  , fundamental_llvm_types_.i8_   ) ) );
	names_scope.AddName( KeywordToString(Keyword::u8_  ), Type( FundamentalType( U_FundamentalType::u8_  , fundamental_llvm_types_.u8_   ) ) );
	names_scope.AddName( KeywordToString(Keyword::i16_ ), Type( FundamentalType( U_FundamentalType::i16_ , fundamental_llvm_types_.i16_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::u16_ ), Type( FundamentalType( U_FundamentalType::u16_ , fundamental_llvm_types_.u16_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::i32_ ), Type( FundamentalType( U_FundamentalType::i32_ , fundamental_llvm_types_.i32_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::u32_ ), Type( FundamentalType( U_FundamentalType::u32_ , fundamental_llvm_types_.u32_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::i64_ ), Type( FundamentalType( U_FundamentalType::i64_ , fundamental_llvm_types_.i64_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::u64_ ), Type( FundamentalType( U_FundamentalType::u64_ , fundamental_llvm_types_.u64_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::i128_), Type( FundamentalType( U_FundamentalType::i128_, fundamental_llvm_types_.i128_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::u128_), Type( FundamentalType( U_FundamentalType::u128_, fundamental_llvm_types_.u128_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::f32_ ), Type( FundamentalType( U_FundamentalType::f32_ , fundamental_llvm_types_.f32_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::f64_ ), Type( FundamentalType( U_FundamentalType::f64_ , fundamental_llvm_types_.f64_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::char8_ ), Type( FundamentalType( U_FundamentalType::char8_ , fundamental_llvm_types_.char8_  ) ) );
	names_scope.AddName( KeywordToString(Keyword::char16_), Type( FundamentalType( U_FundamentalType::char16_, fundamental_llvm_types_.char16_ ) ) );
	names_scope.AddName( KeywordToString(Keyword::char32_), Type( FundamentalType( U_FundamentalType::char32_, fundamental_llvm_types_.char32_ ) ) );
}

fn CodeBuilder::NamesScopeFill( NamesScope &mut names_scope, Synt::ProgramElements& program_elements )
{
	foreach( & program_element : program_elements )
	{
		if_var( & function : program_element.get</ ust::shared_ptr_final</Synt::Function/> />() )
		{
			NamesScopeFill( names_scope, function );
		}
	}
}

fn CodeBuilder::NamesScopeFill( NamesScope &mut names_scope, ust::shared_ptr_final</Synt::Function/>& function )
{
	if( !names_scope.GetThisScopeValue( function.get_ref().name ).empty() )
	{
		REPORT_ERROR( names_scope, Redefinition, function.get_ref().file_pos )
		return;
	}

	// TODO - reuse existing functions set, report about redefinition.
	var FunctionsSet mut functions_set;

	functions_set.syntax_elements.push_back( function );

	names_scope.AddName( function.get_ref().name, NamesScopeValue( move(functions_set) ) );
}

fn CodeBuilder::NamesScopeBuild( NamesScope& names_scope )
{
	foreach( &el : names_scope.GetInternalContainer() )
	{
		auto functions_set= el.value().Get</ FunctionsSet />();
		if( !functions_set.empty() )
		{
			NamesScopeBuildElement( names_scope, ust::to_non_nullable( functions_set ) );
		}
	}
}

fn CodeBuilder::NamesScopeBuildElement( NamesScope& names_scope, ust::shared_ptr_mut</FunctionsSet/> functions_set )
{
	{ // First, lock as imut and check if complete.
		auto l= functions_set.lock_imut();
		var FunctionsSet& functions_set= l.get_ref();
		if( functions_set.syntax_elements.empty() ) // Already complete
		{
			return;
		}
	}

	auto mut l= functions_set.lock_mut();
	var FunctionsSet &mut functions_set= l.get_ref();

	while( !functions_set.syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.syntax_elements.back();
		PrepareFunction( syntax_element_ptr.get_ref(), names_scope, functions_set );
		functions_set.syntax_elements.drop_back();
	}
}

fn CodeBuilder::PrepareFunction(
	Synt::Function& function_declaration,
	NamesScope& names_scope,
	FunctionsSet &mut functions_set ) : bool
{
	var FunctionVariable mut function_variable;

	functions_set.functions.push_back( move(function_variable) );

	return true;
}

} // amespace U
