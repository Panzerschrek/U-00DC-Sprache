import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::NamesScopeFillClass( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type )
{
	auto mut current_visibility= Synt::ClassVisibility::Public;
	var bool is_struct= class_type.lock_imut().deref().syntax_element.try_deref().kind_attribute == Synt::Class::KindAttribute::Struct;
	var u32 mut field_index= 0u;
	foreach( & class_element : class_elements )
	{
		variant_visit( & el : class_element )
		{
			type ElementT= typeof(el);
			static_if( ust::is_same_type</ ElementT, Synt::ClassVisibilityLabel />() )
			{
				if( is_struct )
				{
					REPORT_ERROR( VisibilityForStruct, names_scope_ptr, el.src_loc, Type(class_type).ToString() )
				}
				else
				{
					current_visibility= el.visibility;
				}
			}
			else static_if( ust::is_same_type</ ElementT, ust::shared_ptr_final</Synt::ClassField/> />() )
			{
				NamesScopeFill( names_scope_ptr, el, class_type, current_visibility, field_index );
				++field_index;
			}
			else
			{
				NamesScopeFill( names_scope_ptr, el, class_type, current_visibility );
			}
		}
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements )
{
	foreach( & namespace_element : namespace_elements )
	{
		variant_visit( & el : namespace_element )
		{
			NamesScopeFill( names_scope_ptr, el );
		}
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function )
{
	NamesScopeFill( names_scope_ptr, function, ust::shared_ptr_nullable_mut</ClassType/>(), Synt::ClassVisibility::Public );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	if( function.deref().name.size() != 1s )
	{
		return; // Process out of line functions later.
	}

	auto& func_name= function.deref().name.back();

	if( func_name == KeywordToString( Keyword::constructor_ ) || func_name == KeywordToString( Keyword::destructor_ ) )
	{
		if( class_type.empty() )
		{
			REPORT_ERROR( ConstructorOrDestructorOutsideClass, names_scope_ptr, function.deref().src_loc )
			return;
		}
	}
	else if( IsKeyword( func_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, function.deref().src_loc )
		return;
	}

	if( visibility != Synt::ClassVisibility::Public )
	{
		if( func_name ==  KeywordToString( Keyword::constructor_ ) ||
			func_name == KeywordToString( Keyword::destructor_ ) ||
			func_name == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
			func_name == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) ||
			func_name == OverloadedOperatorToString( OverloadedOperator::CompareOrder ) )
		{
			REPORT_ERROR( ThisMethodMustBePublic, names_scope_ptr, function.deref().src_loc, func_name )
		}
	}

	if( function.deref().name.size() > 1s )
	{
		return; // Out of line function - fill it later.
	}

	auto mut names_scope_lock= names_scope_ptr.lock_mut();
	auto& mut names_scope= names_scope_lock.deref();

	if_var( &prev_name : names_scope.GetThisScopeValue( func_name) )
	{
		auto prev_functions_set_ptr= prev_name.Get</ NamesScopeFunctionsSet />();
		if( prev_functions_set_ptr.empty() )
		{
			auto errors_container= names_scope.GetErrors();
			auto mut errors_container_lock= errors_container.try_lock_mut();
			errors_container_lock.deref().push_back( ReportError( CodeBuilderErrorCode::Redefinition, function.deref().src_loc ) );
			return;
		}

		if( !class_type.empty() && class_type.try_lock_imut().deref().GetMemberVisibility( func_name ) != visibility )
		{
			auto errors_container= names_scope.GetErrors();
			auto mut errors_container_lock= errors_container.try_lock_mut();
			errors_container_lock.deref().push_back( ReportError( CodeBuilderErrorCode::FunctionsVisibilityMismatch, function.deref().src_loc, func_name ) );
			return;
		}

		auto mut lock= prev_functions_set_ptr.try_lock_mut();
		lock.deref().syntax_elements.push_back( function );
		return;
	}

	var NamesScopeFunctionsSet mut functions_set;

	functions_set.class_= class_type;
	functions_set.syntax_elements.push_back( function );

	names_scope.AddName( func_name, NamesScopeValue( move(functions_set) ) );

	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( func_name, visibility );
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template )
{
	NamesScopeFill( names_scope_ptr, function_template, ust::shared_ptr_nullable_mut</ClassType/>(), Synt::ClassVisibility::Public );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	auto& func_name= function_template.deref().name;

	if( func_name == KeywordToString( Keyword::constructor_ ) || func_name == KeywordToString( Keyword::destructor_ ) )
	{
		if( class_type.empty() )
		{
			REPORT_ERROR( ConstructorOrDestructorOutsideClass, names_scope_ptr, function_template.deref().src_loc )
			return;
		}
	}
	else if( IsKeyword( func_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, function_template.deref().src_loc )
		return;
	}

	if( function_template.deref().function.deref().name.size() > 1s )
	{
		// Only simple names allowed for function templates.
		REPORT_ERROR( FunctionDeclarationOutsideItsScope, names_scope_ptr, function_template.deref().src_loc )
		return;
	}

	auto mut names_scope_lock= names_scope_ptr.lock_mut();
	auto& mut names_scope= names_scope_lock.deref();

	if_var( &prev_name : names_scope.GetThisScopeValue( func_name ) )
	{
		auto prev_functions_set_ptr= prev_name.Get</ NamesScopeFunctionsSet />();
		if( prev_functions_set_ptr.empty() )
		{
			auto errors_container= names_scope.GetErrors();
			auto mut errors_container_lock= errors_container.try_lock_mut();
			errors_container_lock.deref().push_back( ReportError( CodeBuilderErrorCode::Redefinition, function_template.deref().src_loc ) );
			return;
		}

		if( !class_type.empty() && class_type.try_lock_imut().deref().GetMemberVisibility( func_name ) != visibility )
		{
			auto errors_container= names_scope.GetErrors();
			auto mut errors_container_lock= errors_container.try_lock_mut();
			errors_container_lock.deref().push_back( ReportError( CodeBuilderErrorCode::FunctionsVisibilityMismatch, function_template.deref().src_loc, func_name ) );
			return;
		}

		auto mut lock= prev_functions_set_ptr.try_lock_mut();
		lock.deref().function_templates_syntax_elements.push_back( function_template );
		return;
	}

	var NamesScopeFunctionsSet mut functions_set;

	functions_set.class_= class_type;
	functions_set.function_templates_syntax_elements.push_back( function_template );

	names_scope.AddName( func_name, NamesScopeValue( move(functions_set) ) );

	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( func_name, visibility );
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ )
{
	NamesScopeAddClass( names_scope_ptr, class_ );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( class_.deref().name, visibility );
	}
	NamesScopeFill( names_scope_ptr, class_ );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_ )
{
	auto& name= enum_.deref().name;
	if( IsKeyword( name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, enum_.deref().src_loc )
		return;
	}

	var Enum mut result_enum
	{
		.syntax_element= enum_,
		.names_scope( NamesScope( name, names_scope_ptr ) )
	};

	var bool mut insert_not_ok= false;
	with( mut lock : names_scope_ptr.lock_mut() )
	{
		insert_not_ok= lock.deref().AddName( name, move(result_enum) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, enum_.deref().src_loc, name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( enum_.deref().name, visibility );
	}
	NamesScopeFill( names_scope_ptr, enum_ );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias )
{
	auto& name= type_alias.deref().name;
	if( IsKeyword( name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, type_alias.deref().src_loc )
		return;
	}

	var TypeAlias mut result_type_alias{ .syntax_element= type_alias };

	var bool mut insert_not_ok= false;
	with( mut lock : names_scope_ptr.lock_mut() )
	{
		insert_not_ok= lock.deref().AddName( name, move(result_type_alias) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, type_alias.deref().src_loc, name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( type_alias.deref().name, visibility );
	}
	NamesScopeFill( names_scope_ptr, type_alias );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template )
{
	NamesScopeFill( names_scope_ptr, type_template, ust::shared_ptr_nullable_mut</ClassType/>(), Synt::ClassVisibility::Public );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	auto mut names_scope_lock= names_scope_ptr.lock_mut();
	auto &mut names_scope= names_scope_lock.deref();

	auto& template_name= type_template.deref().name;
	if_var( &prev_name : names_scope.GetThisScopeValue(template_name) )
	{
		auto prev_type_templates_set_ptr= prev_name.Get</ TypeTemplatesSet />();
		if( prev_type_templates_set_ptr.empty() )
		{
			auto errors_container= names_scope.GetErrors();
			auto mut errors_container_lock= errors_container.try_lock_mut();
			errors_container_lock.deref().push_back( ReportError( CodeBuilderErrorCode::Redefinition, type_template.deref().src_loc ) );
			return;
		}

		if( !class_type.empty() && class_type.try_lock_imut().deref().GetMemberVisibility( template_name ) != visibility )
		{
			auto errors_container= names_scope.GetErrors();
			auto mut errors_container_lock= errors_container.try_lock_mut();
			errors_container_lock.deref().push_back( ReportError( CodeBuilderErrorCode::TypeTemplatesVisibilityMismatch, type_template.deref().src_loc, template_name ) );
			return;
		}

		auto mut lock= prev_type_templates_set_ptr.try_lock_mut();
		lock.deref().syntax_elements.push_back( type_template );
		return;
	}

	var TypeTemplatesSet mut type_templates_set;
	type_templates_set.syntax_elements.push_back( type_template );

	names_scope.AddName( template_name, move(type_templates_set) );

	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( template_name, visibility );
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration )
{
	for( auto mut i= 0s; i < variables_declaration.deref().variables.size(); ++i )
	{
		auto& variable_declaration= variables_declaration.deref().variables[i];

		if( IsKeyword( variable_declaration.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, variable_declaration.src_loc )
			continue;
		}

		var GlobalVariable mut global_variable
		{
			.syntax_element= variables_declaration,
			.variable_index= u32(i),
		};

		var bool mut insert_not_ok= false;
		with( mut lock : names_scope_ptr.lock_mut() )
		{
			insert_not_ok= lock.deref().AddName( variable_declaration.name, move(global_variable) ).empty();
		}

		if( insert_not_ok )
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, variable_declaration.src_loc, variable_declaration.name )
		}
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		foreach( &variable_declaration : variables_declaration.deref().variables )
		{
			class_lock.deref().SetMemberVisibility( variable_declaration.name, visibility );
		}
	}
	NamesScopeFill( names_scope_ptr, variables_declaration );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration )
{
	if( IsKeyword( auto_variable_declaration.deref().name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, auto_variable_declaration.deref().src_loc )
		return;
	}

	var GlobalAutoVariable mut global_auto_variable{ .syntax_element= auto_variable_declaration };

	var bool mut insert_not_ok= false;
	with( mut lock : names_scope_ptr.lock_mut() )
	{
		insert_not_ok= lock.deref().AddName( auto_variable_declaration.deref().name, move(global_auto_variable) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, auto_variable_declaration.deref().src_loc, auto_variable_declaration.deref().name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	if( !class_type.empty() )
	{
		auto mut class_lock= class_type.try_lock_mut();
		class_lock.deref().SetMemberVisibility( auto_variable_declaration.deref().name, visibility );
	}
	NamesScopeFill( names_scope_ptr, auto_variable_declaration );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert )
{
	// Store all static asserts in symobl table, using keyword "static_assert" as key.

	var ust::string8 key= KeywordToString(Keyword::static_assert_);
	if_var( prev_name : names_scope_ptr.lock_imut().deref().GetThisScopeValue(key) )
	{
		auto prev_static_asserts= prev_name.Get</GlobalStaticAssertsSet/>();
		if( !prev_static_asserts.empty() )
		{
			auto mut lock= prev_static_asserts.try_lock_mut();
			lock.deref().push_back(static_asert);
		}
		else
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, static_asert.deref().src_loc, key )
		}
		return;
	}

	var GlobalStaticAssertsSet mut static_asserts_set;
	static_asserts_set.push_back( static_asert );

	auto mut lock= names_scope_ptr.lock_mut();
	lock.deref().AddName( key, move(static_asserts_set) );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility )
{
	NamesScopeFill( names_scope_ptr, static_asert );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Namespace/>& namespace_ )
{
	var ust::string8 name= namespace_.deref().name;
	if_var( prev_name : names_scope_ptr.lock_imut().deref().GetThisScopeValue( name ) )
	{
		auto prev_namespace= prev_name.Get</NamesScope/>();
		if( !prev_namespace.empty() )
		{
			// Ok - extend previous namespace
			NamesScopeFill( prev_namespace.try_to_non_nullable(), namespace_.deref().elements );
		}
		else
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, namespace_.deref().src_loc, name )
		}
		return;
	}

	if( IsKeyword( name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, namespace_.deref().src_loc, name )
	}

	var NamesScopeValue mut names_scope_value( NamesScope( name, names_scope_ptr ) );
	NamesScopeFill( names_scope_value.Get</NamesScope/>().try_to_non_nullable(), namespace_.deref().elements );

	auto mut lock= names_scope_ptr.lock_mut();
	lock.deref().AddName( name, move(names_scope_value) );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility, u32 field_index )
{
	var ClassTypePtr class_type_non_null = class_type.try_to_non_nullable();

	auto& field_name= class_field.deref().name;
	if( IsKeyword( field_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, class_field.deref().src_loc )
		return;
	}

	var ClassField mut field
	{
		.syntax_element= class_field,
		.is_reference= class_field.deref().reference_modifier == Synt::ReferenceModifier::Reference,
		.is_mutable= true,
		.original_index= field_index,
		.source_class= class_type_non_null,
	};

	if( field.is_reference )
	{
		field.is_mutable= class_field.deref().mutability_modifier == Synt::MutabilityModifier::Mutable;
	}
	else
	{
		field.is_mutable=
			class_field.deref().mutability_modifier == Synt::MutabilityModifier::None ||
			class_field.deref().mutability_modifier == Synt::MutabilityModifier::Mutable;
	}

	var bool mut insert_not_ok= false;
	with( mut lock : names_scope_ptr.lock_mut() )
	{
		insert_not_ok= lock.deref().AddName( field_name, move(field) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_field.deref().src_loc, field_name )
	}

	auto mut class_lock= class_type_non_null.lock_mut();
	class_lock.deref().SetMemberVisibility( field_name, visibility );
}

fn CodeBuilder::NamesScopeFillOutOfLineElements( this, NamesScopePtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements )
{
	foreach( & namespace_element : namespace_elements )
	{
		if_var( & function_declaration_ptr : namespace_element.get</ ust::shared_ptr_final</Synt::Function/> />() )
		{
			auto& function_declaration= function_declaration_ptr.deref();
			auto& name_components = function_declaration.name;
			if( name_components.size() <= 1s )
			{
				continue;
			}

			var ust::optional</NamesScopeValue/> mut current_value;

			auto mut start_component_index= 0s;
			if( name_components.front().empty() )
			{
				// Global name - search in root namespace.
				if_var( mut names_scope_value : GetRootNamespace( names_scope_ptr ).lock_imut().deref().GetThisScopeValue( name_components[1s] ) )
				{
					current_value= move(names_scope_value);
				}

				start_component_index= 2s;
			}
			else
			{
				var ust::shared_ptr_imut</NamesScope/> mut current_scope(names_scope_ptr);

				loop
				{
					if_var( mut names_scope_value : current_scope.lock_imut().deref().GetThisScopeValue( name_components.front() ) )
					{
						current_value= move(names_scope_value);
						break;
					}
					auto next_scope= current_scope.lock_imut().deref().GetParent();
					if( next_scope.empty() )
					{
						break;
					}
					current_scope= next_scope.try_to_non_nullable();
				}
				start_component_index= 1s;
			}
			if( current_value.empty() )
			{
				REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.src_loc, name_components.front() )
				continue;
			}
			for( auto mut i= start_component_index; i < name_components.size(); ++i )
			{
				auto& name_component= name_components[i];

				auto namespace_= current_value.try_deref().Get</NamesScope/>();
				auto class_= current_value.try_deref().Get</ClassType/>();
				if( !namespace_.empty() )
				{
					auto namespace_lock= namespace_.try_lock_imut();
					auto new_value= namespace_lock.deref().GetThisScopeValue( name_component );
					if( new_value.empty() )
					{
						REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.src_loc, name_component )
						current_value.reset();
						break;
					}

					current_value.try_deref()= new_value.try_deref();
				}
				else if( !class_.empty() )
				{
					auto class_lock= class_.try_lock_imut();
					auto namespace_lock= class_lock.deref().members.lock_imut();
					auto new_value= namespace_lock.deref().GetThisScopeValue( name_component );
					if( new_value.empty() )
					{
						REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.src_loc, name_component )
						current_value.reset();
						break;
					}

					current_value.try_deref()= new_value.try_deref();
				}
				else
				{
					REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.src_loc, name_components.front() ) // TODO -print more relevant error
					current_value.reset();
					break;
				}
			}

			if( !current_value.empty() )
			{
				auto functions_set= current_value.try_deref().Get</NamesScopeFunctionsSet/>();
				if( !functions_set.empty() )
				{
					auto mut lock= functions_set.try_lock_mut();
					lock.deref().out_of_line_syntax_elements.push_back( function_declaration_ptr );
				}
				else
				{
					REPORT_ERROR( FunctionDeclarationOutsideItsScope, names_scope_ptr, function_declaration.src_loc )
				}
			}
		}

		if_var( &namespace_ : namespace_element.get</ ust::shared_ptr_final</Synt::Namespace/> />() )
		{
			if_var( & inner_namespace_value : names_scope_ptr.lock_imut().deref().GetThisScopeValue( namespace_.deref().name ) )
			{
				auto inner_namespace= inner_namespace_value.Get</NamesScope/>();
				if( !inner_namespace.empty() )
				{
					NamesScopeFillOutOfLineElements( inner_namespace.try_to_non_nullable(), namespace_.deref().elements );
				}
			}
		}
	}
}

fn CodeBuilder::NamesScopeAddClass( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ ) : ust::shared_ptr_nullable_mut</ClassType/>
{
	auto& class_name= class_.deref().name;
	if( IsKeyword( class_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, class_.deref().src_loc )
		return ust::shared_ptr_nullable_mut</ClassType/>();
	}

	if( !names_scope_ptr.lock_imut().deref().GetThisScopeValue( class_name ).empty() )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_.deref().src_loc, class_name )
		return ust::shared_ptr_nullable_mut</ClassType/>();
	}

	var NamesScopeMutPtr class_members( NamesScope( class_name, names_scope_ptr ) );
	var ClassType mut class_type{ .members= class_members, .members_initial= class_members, .syntax_element= class_ };

	var NamesScopeValue mut names_scope_value( move(class_type) );
	auto class_type_ptr= names_scope_value.Get</ClassType/>().try_to_non_nullable();

	class_table_.push_back( class_type_ptr );

	with( mut lock : class_members.lock_mut() )
	{
		// Create functions set for constructors/destructors/assignment operators. It's needed for later methods generation.
		// TODO - what about user-specified non-public constructors and assignment operators?
		var NamesScopeFunctionsSet functions_set{ .class_= class_type_ptr };
		lock.deref().AddName( KeywordToString( Keyword::constructor_ ), functions_set );
		lock.deref().AddName( KeywordToString( Keyword::destructor_  ), functions_set );
		lock.deref().AddName( OverloadedOperatorToString( OverloadedOperator::Assign ), functions_set );

		// Add special member to names scope to identify it as class names scope
		lock.deref().SetClass( class_type_ptr );

		// Allow accessing private members of class for all it's inner namespaces.
		lock.deref().AddAccessRightsFor( class_type_ptr, Synt::ClassVisibility::Private );
	}

	{
		auto name_mangled= mangler_.deref().MangleType( class_type_ptr );
		auto mut lock= class_type_ptr.lock_mut();
		lock.deref().llvm_type= unsafe( LLVMStructCreateNamed( llvm_context_, name_mangled.front() ) );
	}


	NamesScopeFillClass( class_members, class_.deref().class_elements, class_type_ptr );

	var bool mut insert_not_ok= false;
	with( mut lock : names_scope_ptr.lock_mut() )
	{
		insert_not_ok= lock.deref().AddName( class_name, move(names_scope_value) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_.deref().src_loc, class_name )
		return ust::shared_ptr_nullable_mut</ClassType/>();
	}

	return class_type_ptr;
}

} // namespace U1
