import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "mangling.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements )
{
	foreach( & namespace_element : namespace_elements )
	{
		variant_visit( & el : namespace_element )
		{
			NamesScopeFill( names_scope_ptr, el );
		}
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type )
{
	foreach( & class_element : class_elements )
	{
		variant_visit( & el : class_element )
		{
			NamesScopeFill( names_scope_ptr, el, class_type );
		}
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function )
{
	NamesScopeFill( names_scope_ptr, function, ust::shared_ptr_nullable_mut</ClassType/>() );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	auto& func_name= function.get_ref().name.back();

	if( func_name == KeywordToString( Keyword::constructor_ ) || func_name == KeywordToString( Keyword::destructor_ ) )
	{
		if( class_type.empty() )
		{
			REPORT_ERROR( ConstructorOrDestructorOutsideClass, names_scope_ptr, function.get_ref().file_pos )
			return;
		}
	}
	else if( IsKeyword( func_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, function.get_ref().file_pos )
		return;
	}

	if( function.get_ref().name.size() > 1s )
	{
		return; // Out of line function - fill it later.
	}

	auto mut names_scope_lock= names_scope_ptr.lock_mut();
	auto& mut names_scope= names_scope_lock.get_ref();

	if_var( &prev_name : names_scope.GetThisScopeValue( func_name) )
	{
		auto prev_functions_set_ptr= prev_name.Get</ NamesScopeFunctionsSet />();
		if( prev_functions_set_ptr.empty() )
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, function.get_ref().file_pos )
			return;
		}

		auto mut lock= prev_functions_set_ptr.lock_mut();
		lock.get_ref().syntax_elements.push_back( function );
		return;
	}

	var NamesScopeFunctionsSet mut functions_set;

	functions_set.class_= class_type;
	functions_set.syntax_elements.push_back( function );

	names_scope.AddName( func_name, NamesScopeValue( move(functions_set) ) );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ )
{
	auto& class_name= class_.get_ref().name;
	if( IsKeyword( class_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, class_.get_ref().file_pos )
		return;
	}

	var NamesScopeMutPtr class_members( NamesScope( class_name, names_scope_ptr ) );
	var ClassType mut class_type
	{
		.members= class_members,
		.syntax_element= class_,
	};

	var NamesScopeValue mut names_scope_value( move(class_type) );
	auto class_type_ptr= ust::to_non_nullable( names_scope_value.Get</ClassType/>() );
	unsafe
	{
		auto name_mangled= MangleType( class_type_ptr );
		auto mut lock= class_type_ptr.lock_mut();
		lock.get_ref().llvm_type= LLVMStructCreateNamed( llvm_context_, name_mangled.front() );
	}

	class_table_.push_back( class_type_ptr );

	// Create functions set for constructors/destructors. It's needed for later constructors/destructor generation.
	{
		auto mut lock= class_members.lock_mut();

		var NamesScopeFunctionsSet functions_set{ .class_= class_type_ptr };
		lock.get_ref().AddName( KeywordToString( Keyword::constructor_ ), functions_set );
		lock.get_ref().AddName( KeywordToString( Keyword::destructor_  ), functions_set );
	}

	NamesScopeFill( class_members, class_.get_ref().class_elements, class_type_ptr );

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( class_name, move(names_scope_value) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_.get_ref().file_pos, class_name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	// Ignore parent class
	NamesScopeFill( names_scope_ptr, class_ );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_ )
{
	auto& name= enum_.get_ref().name;
	if( IsKeyword( name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, enum_.get_ref().file_pos )
		return;
	}

	var Enum mut result_enum
	{
		.syntax_element= enum_,
		.names_scope( NamesScope( name, names_scope_ptr ) )
	};

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( name, move(result_enum) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, enum_.get_ref().file_pos, name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	NamesScopeFill( names_scope_ptr, enum_ );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias )
{
	auto& name= type_alias.get_ref().name;
	if( IsKeyword( name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, type_alias.get_ref().file_pos )
		return;
	}

	var TypeAlias mut result_type_alias{ .syntax_element= type_alias };

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( name, move(result_type_alias) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, type_alias.get_ref().file_pos, name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	NamesScopeFill( names_scope_ptr, type_alias );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration )
{
	auto mut i= 0s;
	while( i < variables_declaration.get_ref().variables.size() )
	{
		auto& variable_declaration= variables_declaration.get_ref().variables[i];

		if( IsKeyword( variable_declaration.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, variable_declaration.file_pos )
			return;
		}

		var GlobalVariable mut global_variable
		{
			.syntax_element= variables_declaration,
			.variable_index= i,
		};

		var bool mut insert_not_ok= false;
		{
			auto mut lock= names_scope_ptr.lock_mut();
			insert_not_ok= lock.get_ref().AddName( variable_declaration.name, move(global_variable) ).empty();
		}

		if( insert_not_ok )
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, variable_declaration.file_pos, variable_declaration.name )
		}

		++i;
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	NamesScopeFill( names_scope_ptr, variables_declaration );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration )
{
	if( IsKeyword( auto_variable_declaration.get_ref().name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, auto_variable_declaration.get_ref().file_pos )
		return;
	}

	var GlobalAutoVariable mut global_auto_variable{ .syntax_element= auto_variable_declaration };

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( auto_variable_declaration.get_ref().name, move(global_auto_variable) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, auto_variable_declaration.get_ref().file_pos, auto_variable_declaration.get_ref().name )
	}
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	NamesScopeFill( names_scope_ptr, auto_variable_declaration );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert )
{
	// Store all static asserts in symobl table, using keyword "static_assert" as key.

	var ust::string8 key= KeywordToString(Keyword::static_assert_);
	if_var( prev_name : names_scope_ptr.lock_imut().get_ref().GetThisScopeValue(key) )
	{
		auto prev_static_asserts= prev_name.Get</GlobalStaticAssertsSet/>();
		if( !prev_static_asserts.empty() )
		{
			auto mut lock= prev_static_asserts.lock_mut();
			lock.get_ref().push_back(static_asert);
		}
		else
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, static_asert.get_ref().file_pos, key )
		}
		return;
	}

	var GlobalStaticAssertsSet mut static_asserts_set;
	static_asserts_set.push_back( static_asert );

	auto mut lock= names_scope_ptr.lock_mut();
	lock.get_ref().AddName( key, move(static_asserts_set) );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	NamesScopeFill( names_scope_ptr, static_asert );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Namespace/>& namespace_ )
{
	if_var( prev_name : names_scope_ptr.lock_imut().get_ref().GetThisScopeValue( namespace_.get_ref().name ) )
	{
		auto prev_namespace= prev_name.Get</NamesScope/>();
		if( !prev_namespace.empty() )
		{
			// Ok - extend previous namespace
			NamesScopeFill( ust::to_non_nullable( prev_namespace ), namespace_.get_ref().elements );
		}
		else
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, namespace_.get_ref().file_pos, namespace_.get_ref().name )
		}
		return;
	}

	var NamesScopeValue mut names_scope_value( NamesScope( namespace_.get_ref().name, names_scope_ptr ) );
	NamesScopeFill( ust::to_non_nullable( names_scope_value.Get</NamesScope/>() ), namespace_.get_ref().elements );

	auto mut lock= names_scope_ptr.lock_mut();
	lock.get_ref().AddName( namespace_.get_ref().name, move(names_scope_value) );
}

fn CodeBuilder::NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	auto& field_name= class_field.get_ref().name;
	if( IsKeyword( field_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, class_field.get_ref().file_pos )
		return;
	}

	var ClassField mut field
	{
		.syntax_element= class_field,
		.is_reference= class_field.get_ref().reference_modifier == Synt::ReferenceModifier::Reference,
		.is_mutable= true,
	};

	if( field.is_reference )
	{
		field.is_mutable= class_field.get_ref().mutability_modifier == Synt::MutabilityModifier::Mutable;
	}
	// TODO - support immutable value fields

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( field_name, move(field) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_field.get_ref().file_pos, field_name )
	}
}

fn CodeBuilder::NamesScopeFillOutOfLineElements( this, NamesScopePtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements )
{
	foreach( & namespace_element : namespace_elements )
	{
		if_var( & function_declaration_ptr : namespace_element.get</ ust::shared_ptr_final</Synt::Function/> />() )
		{
			auto& function_declaration= function_declaration_ptr.get_ref();
			auto& name_components = function_declaration.name;
			if( name_components.size() <= 1s )
			{
				continue;
			}
			var ust::shared_ptr_nullable_imut</NamesScope/> mut current_scope(names_scope_ptr);
			var ust::optional</NamesScopeValue/> mut current_value;
			while( !current_scope.empty() )
			{
				if_var( mut names_scope_value : current_scope.lock_imut().get_ref().GetThisScopeValue( name_components.front() ) )
				{
					current_value= move(names_scope_value);
					break;
				}
				current_scope= current_scope.lock_imut().get_ref().GetParent();
			}
			if( current_scope.empty() )
			{
				REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.file_pos, name_components.front() )
				continue;
			}
			auto mut i= 1s;
			while( i < name_components.size() )
			{
				auto& name_component= name_components[i];

				auto namespace_= current_value.get_ref().Get</NamesScope/>();
				auto class_= current_value.get_ref().Get</ClassType/>();
				if( !namespace_.empty() )
				{
					auto namespace_lock= namespace_.lock_imut();
					auto new_value= namespace_lock.get_ref().GetThisScopeValue( name_component );
					if( new_value.empty() )
					{
						REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.file_pos, name_component )
						current_value.reset();
						break;
					}

					current_value.get_ref()= new_value.get_ref();
					current_scope= namespace_;
				}
				else if( !class_.empty() )
				{
					auto class_lock= class_.lock_imut();
					auto namespace_lock= class_lock.get_ref().members.lock_imut();
					auto new_value= namespace_lock.get_ref().GetThisScopeValue( name_component );
					if( new_value.empty() )
					{
						REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.file_pos, name_component )
						current_value.reset();
						break;
					}

					current_value.get_ref()= new_value.get_ref();
					current_scope= class_lock.get_ref().members;
				}
				else
				{
					REPORT_ERROR( NameNotFound, names_scope_ptr, function_declaration.file_pos, name_components.front() ) // TODO -print more relevant error
					current_value.reset();
					break;
				}

				++i;
			}

			if( !current_value.empty() )
			{
				auto functions_set= current_value.get_ref().Get</NamesScopeFunctionsSet/>();
				if( !functions_set.empty() )
				{
					auto mut lock= functions_set.lock_mut();
					lock.get_ref().out_of_line_syntax_elements.push_back( function_declaration_ptr );
				}
				else
				{
					REPORT_ERROR( FunctionDeclarationOutsideItsScope, names_scope_ptr, function_declaration.file_pos )
				}
			}
		}

		if_var( &namespace_ : namespace_element.get</ ust::shared_ptr_final</Synt::Namespace/> />() )
		{
			if_var( & inner_namespace_value : names_scope_ptr.lock_imut().get_ref().GetThisScopeValue( namespace_.get_ref().name ) )
			{
				auto inner_namespace_value= inner_namespace_value.Get</NamesScope/>();
				if( !inner_namespace_value.empty() )
				{
					NamesScopeFillOutOfLineElements( ust::to_non_nullable( inner_namespace_value ), namespace_.get_ref().elements );
				}
			}
		}
	}
}

} // namespace U
