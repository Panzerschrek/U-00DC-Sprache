import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::NamesScopeFill( this, NamesScopeMutPtr& names_scope_ptr, Synt::ProgramElements& program_elements )
{
	foreach( & program_element : program_elements )
	{
		variant_visit( & el : program_element )
		{
			NamesScopeFill( names_scope_ptr, el );
		}
	}
}

fn CodeBuilder::NamesScopeFill( this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type )
{
	foreach( & class_element : class_elements )
	{
		variant_visit( & el : class_element )
		{
			NamesScopeFill( names_scope_ptr, el, class_type );
		}
	}
}

fn CodeBuilder::NamesScopeFill( this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function )
{
	NamesScopeFill( names_scope_ptr, function, ust::shared_ptr_nullable_mut</ClassType/>() );
}

fn CodeBuilder::NamesScopeFill( this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	auto& func_name= function.get_ref().name;
	if( IsKeyword( func_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, function.get_ref().file_pos )
		return;
	}

	auto mut names_scope_lock= names_scope_ptr.lock_mut();
	auto& mut names_scope= names_scope_lock.get_ref();

	if_var( &prev_name : names_scope.GetThisScopeValue( func_name) )
	{
		auto prev_functions_set_ptr= prev_name.Get</ NamesScopeFunctionsSet />();
		if( prev_functions_set_ptr.empty() )
		{
			REPORT_ERROR( Redefinition, names_scope_ptr, function.get_ref().file_pos )
			return;
		}

		auto mut lock= prev_functions_set_ptr.lock_mut();
		lock.get_ref().syntax_elements.push_back( function );
		return;
	}

	var NamesScopeFunctionsSet mut functions_set;

	functions_set.class_= class_type;
	functions_set.syntax_elements.push_back( function );

	names_scope.AddName( func_name, NamesScopeValue( move(functions_set) ) );
}

fn CodeBuilder::NamesScopeFill( this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ )
{
	auto& class_name= class_.get_ref().name;
	if( IsKeyword( class_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, class_.get_ref().file_pos )
		return;
	}

	var NamesScopeMutPtr class_members( NamesScope( class_name, names_scope_ptr ) );
	var ClassType mut class_type
	{
		.members= class_members,
		.syntax_element= class_,
	};

	unsafe
	{
		class_type.llvm_type= LLVMStructCreateNamed( llvm_context_, (class_.get_ref().name + "\0").front() ); // TODO - mangle type
	}

	var NamesScopeValue mut names_scope_value( move(class_type) );

	NamesScopeFill( class_members, class_.get_ref().class_elements, ust::to_non_nullable( names_scope_value.Get</ClassType/>() ) );

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( class_name, move(names_scope_value) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_.get_ref().file_pos, class_name )
	}
}

fn CodeBuilder::NamesScopeFill( this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type )
{
	auto& field_name= class_field.get_ref().name;
	if( IsKeyword( field_name ) )
	{
		REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, class_field.get_ref().file_pos )
		return;
	}

	var ClassField mut field
	{
		.syntax_element= class_field
	};

	var bool mut insert_not_ok= false;
	{
		auto mut lock= names_scope_ptr.lock_mut();
		insert_not_ok= lock.get_ref().AddName( field_name, move(field) ).empty();
	}

	if( insert_not_ok )
	{
		REPORT_ERROR( Redefinition, names_scope_ptr, class_field.get_ref().file_pos, field_name )
	}
}

} // namespace U
