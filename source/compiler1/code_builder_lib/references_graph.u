import "references_graph.uh"

fn nomangle U1_ReferencesGraphGetNextUniqueId() : u32;

namespace U1
{

op ReferencesGraph::Link::==(Link& l, Link& r ) : bool
{
	return l.src == r.src && l.dst == r.dst;
}

fn ReferencesGraph::AddNode( mut this, NodeKind kind, ust::string8 mut name ) : NodeId
{
	// Use unique identifiers for bugs prevention.
	// Use function implemented on C++ because we needs global mutable variable for it.
	var NodeId node_id= U1_ReferencesGraphGetNextUniqueId();

	var Node mut node{ .kind= kind, .name= move(name), .inner_reference_node= c_empty_node_id, .moved= false };
	nodes_.insert( node_id, move(node) );

	return node_id;
}

fn ReferencesGraph::RemoveNode( mut this, NodeId node_id )
{
	if( nodes_.find( node_id ).empty() )
	{
		return;
	}

	var NodeId inner_reference_node_id= nodes_[node_id].inner_reference_node;
	RemoveNode( inner_reference_node_id );

	// Collect in/out nodes.
	var ust::vector</NodeId/> mut in_nodes, mut out_nodes;
	foreach( &link : links_ )
	{
		if( link.src == link.dst ){ continue; } // Self-loop link.

		if( link.src == node_id ) { out_nodes.push_back( link.dst ); }
		if( link.dst == node_id ) {  in_nodes.push_back( link.src ); }
	}

	// Remove links.
	for( auto mut i= 0s; i < links_.size(); )
	{
		if( links_[i].src == node_id || links_[i].dst == node_id )
		{
			auto back= links_.size() - 1s;
			links_.swap( i, back );
			links_.pop_back();
		}
		else
		{
			++i;
		}
	}

	// Erase node.
	nodes_.erase( node_id );

	// Create new links.
	foreach( from : in_nodes )
	{
		foreach( to : out_nodes )
		{
			AddLink( from, to );
		}
	}
}

fn ReferencesGraph::AddLink( mut this, NodeId from, NodeId to )
{
	if( from == to )
	{
		return;
	}

	var Link link{ .src= from, .dst= to };

	foreach( &prev_link : links_ )
	{
		if( link == prev_link )
		{
			return;
		}
	}
	links_.push_back( link );
}

fn ReferencesGraph::CreateNodeInnerReference( mut this, NodeId node_id, NodeKind kind ) : NodeId
{
	halt if( kind == NodeKind::Variable );

	var ust::string8 mut node_name= nodes_[node_id].name + " inner reference";
	var NodeId inner_node_id= AddNode( kind, move(node_name) );

	var Node &mut dst_node= nodes_[node_id];
	halt if( dst_node.inner_reference_node != c_empty_node_id );
	dst_node.inner_reference_node= inner_node_id;

	return inner_node_id;
}

fn ReferencesGraph::MoveNode( mut this, NodeId node_id )
{
	{
		var Node &mut node= nodes_[node_id];
		halt if(node.moved);
		node.moved= true;
	}

	for( auto mut i= 0s; i < links_.size(); )
	{
		if( links_[i].src == node_id || links_[i].dst == node_id )
		{
			auto back= links_.size() - 1s;
			links_.swap( i, back );
			links_.pop_back();
		}
		else
		{
			++i;
		}
	}
}

fn ReferencesGraph::NodeIsMoved( this, NodeId node_id ) : bool
{
	return nodes_[node_id].moved;
}

fn ReferencesGraph::HaveOutgoingLinks( this, NodeId from ) : bool
{
	foreach( &link : links_ )
	{
		if( link.src == from )
		{
			return true;
		}
	}
	return false;
}

fn ReferencesGraph::HaveOutgoingMutableNodes( this, NodeId from ) : bool
{
	foreach( &link : links_ )
	{
		if( link.src == from )
		{
			if_var( &node : nodes_.find( link.dst ) )
			{
				if( node.kind == NodeKind::ReferenceMut )
				{
					return true;
				}
			}
		}
	}
	return false;
}

fn ReferencesGraph::GetNodeKind( this, NodeId node_id ) : NodeKind
{
	return nodes_[node_id].kind;
}

fn ReferencesGraph::GetNodeName( this, NodeId node_id ) : ust::string8&
{
	return nodes_[node_id].name;
}

fn ReferencesGraph::GetNodeInnerReference( this, NodeId node_id ) : NodeId
{
	return nodes_[node_id].inner_reference_node;
}

fn ReferencesGraph::GetAllAccessibleVariableNodes( this, NodeId node_id ) : NodesSet
{
	var NodesSet mut nodes_set;
	GetAllAccessibleVariableNodes_r( node_id, nodes_set );
	return move(nodes_set);
}

fn ReferencesGraph::GetAllAccessibleVariableInnerNodes( this, NodeId node_id ) : NodesSet
{
	var NodesSet mut nodes_set;
	GetAllAccessibleVariableInnerNodes_r( node_id, nodes_set );
	return move(nodes_set);
}

fn ReferencesGraph::GetAllAccessibleVariableNodes_r( this, NodeId node_id, NodesSet &mut out_nodes )
{
	if( nodes_[node_id].kind == NodeKind::Variable )
	{
		out_nodes.insert( node_id, 0 );
	}

	foreach( &link : links_ )
	{
		if( link.dst == node_id )
		{
			GetAllAccessibleVariableNodes_r( link.src, out_nodes );
		}
	}
}

fn ReferencesGraph::GetAllAccessibleVariableInnerNodes_r( this, NodeId node_id, NodesSet &mut out_nodes )
{
	auto inner_node= nodes_[node_id].inner_reference_node;
	if( inner_node != c_empty_node_id )
	{
		out_nodes.insert( inner_node, 0 );
	}

	foreach( &link : links_ )
	{
		if( link.dst == node_id )
		{
			GetAllAccessibleVariableInnerNodes_r( link.src, out_nodes );
		}
	}
}

} // namespace U1
