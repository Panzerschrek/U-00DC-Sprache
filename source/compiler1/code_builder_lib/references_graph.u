import "/assert.u"
import "error_reporting.uh"
import "references_graph.uh"

namespace U1
{

struct NodeReplacement
{
	VariablePtr first;
	VariablePtr second;
}

fn ReferencesGraph::AddNode( mut this, VariablePtr& node )
{
	debug_assert( nodes_.find( node ).empty(), "Node is already registered!" );

	var NodeState mut node_state{ .moved= false };
	nodes_.insert( node, move(node_state) );
}

fn ReferencesGraph::AddNodeIfNotExists( mut this, VariablePtr& node )
{
	var NodeState mut node_state{ .moved= false };
	nodes_.insert( node, move(node_state) );
}

fn ReferencesGraph::RemoveNode( mut this, VariablePtr& node )
{
	if( nodes_.find( node ).empty() )
	{
		return;
	}

	var VariableNullablePtr inner_reference_node= nodes_[node].inner_reference_node;
	if( !inner_reference_node.empty() )
	{
		RemoveNode( inner_reference_node.try_to_non_nullable() );
	}

	foreach( &child : node.lock_imut().deref().children )
	{
		if( !child.empty() )
		{
			RemoveNode( child.try_to_non_nullable() );
		}
	}

	RemoveNodeLinks( node );

	// Erase node.
	nodes_.erase( node );
}

fn ReferencesGraph::AddLink( mut this, VariablePtr& from, VariablePtr& to )
{
	debug_assert( !nodes_.find( from ).empty(), "Node is not registered!" );
	debug_assert( !nodes_.find( to ).empty(), "Node is not registered!" );

	if( from == to )
	{
		return;
	}

	var Link link{ .src= from, .dst= to };

	foreach( &prev_link : links_ )
	{
		if( link == prev_link )
		{
			return;
		}
	}
	links_.push_back( link );
}

fn ReferencesGraph::TryAddLink( mut this, VariablePtr& from, VariablePtr& to, NamesScopePtr& names_scope, SrcLoc& src_loc )
{
	if( ( to.lock_imut().deref().value_type == ValueType::ReferenceMut && HaveOutgoingLinks( from ) ) ||
		HaveOutgoingMutableNodes( from ) )
	{
		REPORT_ERROR( ReferenceProtectionError, names_scope, src_loc, from.lock_imut().deref().name )
		return;
	}

	AddLink( from, to );
}

fn ReferencesGraph::CreateNodeInnerReference( mut this, VariablePtr& node, ValueType value_type ) : VariablePtr
{
	halt if( value_type == ValueType::Value );

	var Variable mut node_src{ .value_type= value_type, .location= Variable::Location::Pointer, .name= node.lock_imut().deref().name + " inner reference" };
	var VariablePtr inner_node( move(node_src) );

	AddNode( inner_node );

	var NodeState &mut dst_node= nodes_[node];
	halt if( !dst_node.inner_reference_node.empty() );
	dst_node.inner_reference_node= inner_node;

	return inner_node;
}

fn ReferencesGraph::MoveNode( mut this, VariablePtr& node )
{
	debug_assert( !nodes_.find( node ).empty(), "Node is not registered!" );

	var VariableNullablePtr mut inner_reference_node;
	{
		var NodeState &mut node= nodes_[node];
		halt if(node.moved);
		node.moved= true;

		inner_reference_node= node.inner_reference_node;
		node.inner_reference_node.reset();
	}

	if( !inner_reference_node.empty() )
	{
		RemoveNode( inner_reference_node.try_to_non_nullable() );
	}

	// Move child nodes first in order to replace links from children with links from parent.
	foreach( &child : node.lock_imut().deref().children )
	{
		if( !child.empty() )
		{
			var VariablePtr child_non_null= child.try_to_non_nullable();
			if( !nodes_.find(child_non_null).empty() ) // Children nodes are lazily-added.
			{
				MoveNode( child_non_null );
			}
		}
	}

	RemoveNodeLinks( node );
}

fn ReferencesGraph::NodeIsMoved( this, VariablePtr& node ) : bool
{
	debug_assert( !nodes_.find( node ).empty(), "Node is not registered!" );

	return nodes_[node].moved;
}

fn ReferencesGraph::HaveOutgoingLinks( this, VariablePtr& from ) : bool
{
	debug_assert( !nodes_.find( from ).empty(), "Node is not registered!" );

	// Check if any parent have links and any child (including children of children) have links.
	// Doesn't count sibling nodes and other indirect relatives.

	if( HaveOutgoingLinksIncludingChildrenLinks_r( from ) )
	{
		return true;
	}

	var VariableNullablePtr mut parent= from.lock_imut().deref().parent.lock();
	while( !parent.empty() )
	{
		var VariablePtr parent_non_null= parent.try_to_non_nullable();
		if( HaveDirectOutgoingLinks( parent_non_null ) )
		{
			return true;
		}
		parent= parent_non_null.lock_imut().deref().parent.lock();
	}

	return false;
}

fn ReferencesGraph::HaveOutgoingMutableNodes( this, VariablePtr& from ) : bool
{
	debug_assert( !nodes_.find( from ).empty(), "Node is not registered!" );

	// Check if any parent have mutable links and any child (including children of children) have mutable links.
	// Doesn't count sibling nodes and other indirect relatives.

	if( HaveOutgoingMutableNodesIncludingChildrenNodes_r( from ) )
	{
		return true;
	}

	var VariableNullablePtr mut parent= from.lock_imut().deref().parent.lock();
	while( !parent.empty() )
	{
		var VariablePtr parent_non_null= parent.try_to_non_nullable();
		if( HaveDirectOutgoingMutableNodes( parent_non_null ) )
		{
			return true;
		}
		parent= parent_non_null.lock_imut().deref().parent.lock();
	}

	return false;
}

fn ReferencesGraph::EnsureHaveNoOutgoingLinks( this, VariablePtr& from, NamesScopePtr& names_scope, SrcLoc& src_loc )
{
	if( HaveOutgoingLinks( from ) )
	{
		REPORT_ERROR( ReferenceProtectionError, names_scope, src_loc, from.lock_imut().deref().name )
	}
}

fn ReferencesGraph::EnsureHaveNoOutgoingMutableNodes( this, VariablePtr& from, NamesScopePtr& names_scope, SrcLoc& src_loc )
{
	if( HaveOutgoingMutableNodes( from ) )
	{
		REPORT_ERROR( ReferenceProtectionError, names_scope, src_loc, from.lock_imut().deref().name )
	}
}

fn ReferencesGraph::GetNodeInnerReference( this, VariablePtr& node ) : VariableNullablePtr
{
	debug_assert( !nodes_.find( node ).empty(), "Node is not registered!" );
	return nodes_[node].inner_reference_node;
}

fn ReferencesGraph::GetAllAccessibleVariableNodes( this, VariablePtr& node ) : NodesSet
{
	debug_assert( !nodes_.find( node ).empty(), "Node is not registered!" );

	var NodesSet mut nodes_set;
	GetAllAccessibleVariableNodes_r( node, nodes_set );
	return move(nodes_set);
}

fn ReferencesGraph::GetAccessibleVariableNodesInnerReferences( this, VariablePtr& node ) : NodesSet
{
	debug_assert( !nodes_.find( node ).empty(), "Node is not registered!" );

	var NodesSet mut nodes_set;
	GetAccessibleVariableNodesInnerReferences_r( node, nodes_set );
	return move(nodes_set);
}

fn ReferencesGraph::GetNodeInputLinks( this, VariablePtr& node ) : NodesSet
{
	debug_assert( !nodes_.find( node ).empty(), "Node is not registered!" );

	var NodesSet mut result;

	var VariablePtr mut current_node= node;
	loop
	{
		foreach( &link : links_ )
		{
			if( link.dst == current_node )
			{
				result.insert( link.src );
			}
		}

		var VariableNullablePtr parent= current_node.lock_imut().deref().parent.lock();
		if( parent.empty() )
		{
			break;
		}
		current_node= parent.try_to_non_nullable();
	}

	return result;
}

fn ReferencesGraph::MergeReferencesGraphsAfterConditionalBranches( ust::array_view_imut</ReferencesGraph/> branches,  ErrorsContainer &mut errors, SrcLoc& src_loc ) : ReferencesGraph
{
	var ReferencesGraph mut result;

	var ust::vector</NodeReplacement/> mut replaced_nodes;
	foreach( &branch_state : branches )
	{
		foreach( &node_pair : branch_state.nodes_ )
		{
			var VariablePtr& node= node_pair.key();
			var NodeState& src_node= node_pair.value();

			if( result.nodes_.find( node ).empty() )
			{
				result.nodes_.insert( node, src_node );
			}

			var NodeState &mut dst_node= result.nodes_[ node ];
			if( src_node.moved != dst_node.moved )
			{
				errors.push_back( ReportError( CodeBuilderErrorCode::ConditionalMove, src_loc, node.lock_imut().deref().name ) );
			}

			if( src_node.inner_reference_node == dst_node.inner_reference_node )
			{} // ok - same nodes.
			else if( dst_node.inner_reference_node.empty() )
			{  // ok - dst have no node, take node from src.
				dst_node.inner_reference_node= src_node.inner_reference_node;
			}
			else if( src_node.inner_reference_node.empty() )
			{} // ok - src have no node.
			else
			{
				// Node created in both branches.
				// Take mutable node and replace it with immutable node.
				if( src_node.inner_reference_node.try_lock_imut().deref().value_type == ValueType::ReferenceMut )
				{
					var NodeReplacement mut replacement{ .first= dst_node.inner_reference_node.try_to_non_nullable(), .second= src_node.inner_reference_node.try_to_non_nullable() };
					dst_node.inner_reference_node= src_node.inner_reference_node;
					replaced_nodes.push_back( move(replacement) );
				}
				else
				{
					var NodeReplacement mut replacement{ .first= src_node.inner_reference_node.try_to_non_nullable(), .second= dst_node.inner_reference_node.try_to_non_nullable() };
					replaced_nodes.push_back( move(replacement) );
				}
			}
		}

		foreach( &src_link : branch_state.links_ )
		{
			var bool mut found= false;
			foreach( &dst_link : result.links_ )
			{
				if( src_link == dst_link )
				{
					found= true;
					break;
				}
			}

			if( !found )
			{
				result.links_.push_back( src_link );
			}
		}
	}

	if( !replaced_nodes.empty() )
	{
		var ust::vector</Link/> mut links_corrected;
		foreach( mut link : result.links_ )
		{
			foreach( &replacement : replaced_nodes )
			{
				if( link.src == replacement.first )
				{
					link.src = replacement.second;
				}
				if( link.dst == replacement.first )
				{
					link.dst= replacement.second;
				}
			}

			var bool mut found= false;
			foreach( &prev_link : links_corrected )
			{
				if( link == prev_link )
				{
					found= true;
					break;
				}
			}

			if( !found )
			{
				links_corrected.push_back( link );
			}
		}

		result.links_= move(links_corrected);
	}

	foreach( &replacement : replaced_nodes )
	{
		if( !result.nodes_.find( replacement.first ).empty() )
		{
			result.nodes_.erase( replacement.first );
		}
	}

	// See the comment in same code in Compiler0.

	return move(result);
}

fn ReferencesGraph::CheckReferencesGraphAfterLoop( ReferencesGraph& state_before, ReferencesGraph& state_after, ErrorsContainer &mut errors, SrcLoc& src_loc )
{
	foreach( &node_before_pair : state_before.nodes_ )
	{
		var NodeState& node_before= node_before_pair.value();
		var NodeState& node_after= state_after.nodes_[node_before_pair.key()];

		if( !node_before.moved && node_after.moved )
		{
			errors.push_back( ReportError( CodeBuilderErrorCode::OuterVariableMoveInsideLoop, src_loc, node_before_pair.key().lock_imut().deref().name ) );
		}

		if( node_before.inner_reference_node.empty() && node_after.inner_reference_node.empty() )
		{
			continue;
		}

		// TODO - what if inner variable node changed? What if links removed?
		if( !node_after.inner_reference_node.empty() )
		{
			var NodesSet mut new_accessible_variables= state_after.GetAllAccessibleVariableNodes( node_after.inner_reference_node.try_to_non_nullable() );
			if( !node_before.inner_reference_node.empty() )
			{
				foreach( &variable_node : state_before.GetAllAccessibleVariableNodes( node_before.inner_reference_node.try_to_non_nullable() ) )
				{
					if( new_accessible_variables.exists(variable_node) )
					{
						new_accessible_variables.drop( variable_node );
					}
				}
			}

			foreach( &added_node : new_accessible_variables )
			{
				errors.push_back(
					ReportError(
						CodeBuilderErrorCode::ReferencePollutionOfOuterLoopVariable,
						src_loc,
						node_before_pair.key().lock_imut().deref().name,
						added_node.lock_imut().deref().name ) );
			}
		}
	}
}

fn ReferencesGraph::GetAllAccessibleVariableNodes_r( this, VariablePtr& node, NodesSet &mut out_nodes )
{
	if( node.lock_imut().deref().value_type == ValueType::Value )
	{
		out_nodes.insert( node );
	}

	foreach( &link : links_ )
	{
		if( link.dst == node )
		{
			GetAllAccessibleVariableNodes_r( link.src, out_nodes );
		}
	}

	var VariableNullablePtr parent= node.lock_imut().deref().parent.lock();
	if( !parent.empty() )
	{
		GetAllAccessibleVariableNodes_r( parent.try_to_non_nullable(), out_nodes );
	}
	// Children nodes can't have input links. So, ignore them.
}

fn ReferencesGraph::GetAccessibleVariableNodesInnerReferences_r( this, VariablePtr& node, NodesSet &mut out_nodes )
{
	var VariableNullablePtr inner_node= nodes_[node].inner_reference_node;
	if( !inner_node.empty() )
	{
		out_nodes.insert( inner_node.try_to_non_nullable() );
		return;
	}

	foreach( &link : links_ )
	{
		if( link.dst == node )
		{
			GetAccessibleVariableNodesInnerReferences_r( link.src, out_nodes );
		}
	}

	var VariableNullablePtr parent= node.lock_imut().deref().parent.lock();
	if( !parent.empty() )
	{
		GetAccessibleVariableNodesInnerReferences_r( parent.try_to_non_nullable(), out_nodes );
	}
}

fn ReferencesGraph::HaveDirectOutgoingLinks( this, VariablePtr& from ) : bool
{
	foreach( &link : links_ )
	{
		if( link.src == from )
		{
			return true;
		}
	}

	return false;
}

fn ReferencesGraph::HaveOutgoingLinksIncludingChildrenLinks_r( this, VariablePtr& from ) : bool
{
	if( HaveDirectOutgoingLinks( from ) )
	{
		return true;
	}

	foreach( &child : from.lock_imut().deref().children )
	{
		if( !child.empty() )
		{
			var VariablePtr child_non_null= child.try_to_non_nullable();
			if( !nodes_.find( child_non_null ).empty() && // Children nodes are lazily-added.
				HaveOutgoingLinksIncludingChildrenLinks_r( child_non_null ) )
			{
				return true;
			}
		}
	}

	return false;
}

fn ReferencesGraph::HaveDirectOutgoingMutableNodes( this, VariablePtr& from ) : bool
{
	foreach( &link : links_ )
	{
		if( link.src == from && link.dst.lock_imut().deref().value_type == ValueType::ReferenceMut )
		{
			return true;
		}
	}

	return false;
}

fn ReferencesGraph::HaveOutgoingMutableNodesIncludingChildrenNodes_r( this, VariablePtr& from ) : bool
{
	if( HaveDirectOutgoingMutableNodes( from ) )
	{
		return true;
	}

	foreach( &child : from.lock_imut().deref().children )
	{
		if( !child.empty() )
		{
			var VariablePtr child_non_null= child.try_to_non_nullable();
			if( !nodes_.find( child_non_null ).empty() && // Children nodes are lazily-added.
				HaveOutgoingMutableNodesIncludingChildrenNodes_r( child_non_null ) )
			{
				return true;
			}
		}
	}

	return false;
}

fn ReferencesGraph::RemoveNodeLinks( mut this, VariablePtr& node )
{
	// Collect in/out nodes.
	var NodesSet mut in_nodes, mut out_nodes;
	foreach( &link : links_ )
	{
		if( link.src == link.dst ){ continue; } // Self-loop link.

		if( link.src == node ) { out_nodes.insert( link.dst ); }
		if( link.dst == node ) {  in_nodes.insert( link.src ); }
	}

	// Remove links.
	for( auto mut i= 0s; i < links_.size(); )
	{
		if( links_[i].src == node || links_[i].dst == node )
		{
			auto back= links_.size() - 1s;
			links_.swap( i, back );
			links_.pop_back();
		}
		else
		{
			++i;
		}
	}

	// Create new links.
	foreach( &from : in_nodes )
	{
		foreach( &to : out_nodes )
		{
			AddLink( from, to );
		}
	}

	// If this is a child node, replace links from it with links from parent.
	var VariableNullablePtr parent= node.lock_imut().deref().parent.lock();
	if( !parent.empty() )
	{
		debug_assert( in_nodes.empty(), "Non-empty input nodes list for node with parent!" );

		var VariablePtr parent_non_null= parent.try_to_non_nullable();
		foreach( &to : out_nodes )
		{
			AddLink( parent_non_null, to );
		}
	}
}

} // namespace U1
