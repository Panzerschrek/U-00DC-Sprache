import "/helpers.u"
import "/string_conversions.u"
import "/keywords.uh"
import "structs_combined.uh"

namespace U1
{

// Sizes for 8-bit pointers.
static_assert( typeinfo</Type/>.size_of <= 24s, "size of Type is too big" ); // 1 pointer for variant, 2 pointers for variant contents
static_assert( typeinfo</Value/>.size_of <= 40s, "size of Value is too big" );
static_assert( typeinfo</NamesScopeValue/>.size_of <= 24s, "size of NamesScopeValue is too big" ); // 1 pointer for variant and 2 pointers for contents.

//
// Type
//

namespace ToStringHelper
{

template</type T/>
fn ToString( ust::shared_ptr_final_base</T, false/>& b ) : ust::string8
{
	return ToStringHelper::ToString( b.deref() );
}

fn ToString( FundamentalType& fundamental_type ) : ust::string8
{
	return ust::string8( GetFundamentalTypeName( fundamental_type.fundamental_type ) );
}

fn ToString( ArrayType& array_type ) : ust::string8
{
	var ust::string8 mut result;
	result+= "[ ";
	result+= array_type.element_type.ToString();
	result+= ", ";
	result+= ust::to_string8(array_type.element_count);
	result+= " ]";
	return move(result);
}

fn ToString( TupleType& tuple_type ) : ust::string8
{
	var ust::string8 mut result;
	result+= KeywordToString( Keyword::tup_ );

	if( tuple_type.element_types.empty() )
	{
		result+= "[]";
		return move(result);
	}

	result+= "[ ";

	foreach( &element_type : tuple_type.element_types )
	{
		result+= element_type.ToString();
		if( ust::ref_cmp_ne( element_type, tuple_type.element_types.back() ) )
		{
			result+= ", ";
		}
	}

	result+= " ]";
	return move(result);
}

fn ToString( RawPointerType& raw_pointer_type ) : ust::string8
{
	var ust::string8 mut result;
	result+= "$";
	result+= "(";
	result+= raw_pointer_type.element_type.ToString();
	result+= ")";

	return move(result);
}

fn ToString( FunctionType& function_type ) : ust::string8
{
	// TODO - add references pollution/return references

	var ust::string8 mut result;

	result+= KeywordToString( Keyword::fn_ );

	if( function_type.params.empty() )
	{
		result+= "()";
	}
	else
	{
		result+= "( ";
		result+= FunctionParamsToString( function_type.params.range() );
		result+= " )";
	}

	if( function_type.is_unsafe )
	{
		result+= " ";
		result+= KeywordToString( Keyword::unsafe_ );
	}

	if( function_type.calling_convention != LLVMCallConv::C )
	{
		result+= KeywordToString( Keyword::call_conv_ );
		result+= " (\"";

		if( function_type.calling_convention == LLVMCallConv::Fast )
		{
			result+= "fast";
		}
		if( function_type.calling_convention == LLVMCallConv::Cold )
		{
			result+= "cold";
		}
		if( function_type.calling_convention == LLVMCallConv::X86Stdcall )
		{
			result+= "system";
		}

		result+= "\")";
	}

	result+= " : ";

	result+= function_type.return_type.ToString();

	if( function_type.return_value_type == ValueType::ReferenceMut )
	{
		result+= " &mut";
	}
	if( function_type.return_value_type == ValueType::ReferenceImut )
	{
		result+= " &imut";
	}

	return move(result);
}

fn ToString( FunctionPointerType& function_pointer_type ) : ust::string8
{
	return ToString( function_pointer_type.function_type );
}

fn ToString( ClassTypePtr& class_type ) : ust::string8
{
	return class_type.lock_imut().deref().members.lock_imut().deref().ToString();
}

fn ToString( EnumTypePtr& enum_type ) : ust::string8
{
	return enum_type.lock_imut().deref().names_scope.lock_imut().deref().ToString();
}

} // namespace ToStringHelper

fn FundamentalType::constructor( U_FundamentalType in_fundamental_type, LLVMTypeRef in_llvm_type )
	( fundamental_type= in_fundamental_type, llvm_type= in_llvm_type )
{}

fn FundamentalType::GetSize(this) : u32
{
	switch(fundamental_type)
	{
		U_FundamentalType::InvalidType -> { return 0u; },
		U_FundamentalType::void_ -> { return 0u; },
		U_FundamentalType::bool_ -> { return 1u; },
		U_FundamentalType::i8_  , U_FundamentalType::u8_  , U_FundamentalType::byte8_   -> { return  1u; },
		U_FundamentalType::i16_ , U_FundamentalType::u16_ , U_FundamentalType::byte16_  -> { return  2u; },
		U_FundamentalType::i32_ , U_FundamentalType::u32_ , U_FundamentalType::byte32_  -> { return  4u; },
		U_FundamentalType::i64_ , U_FundamentalType::u64_ , U_FundamentalType::byte64_  -> { return  8u; },
		U_FundamentalType::i128_, U_FundamentalType::u128_, U_FundamentalType::byte128_ -> { return 16u; },
		U_FundamentalType::f32_ -> { return 4u; },
		U_FundamentalType::f64_ -> { return 8u; },
		U_FundamentalType::char8_  -> { return 1u; },
		U_FundamentalType::char16_ -> { return 2u; },
		U_FundamentalType::char32_ -> { return 4u; },
	}
}

op FundamentalType::==( FundamentalType& l, FundamentalType& r ) : bool
{
	return l.fundamental_type == r.fundamental_type;
}

op ArrayType::==( ArrayType& l, ArrayType& r ) : bool
{
	return l.element_type == r.element_type && l.element_count == r.element_count;
}

op TupleType::==( TupleType& l, TupleType& r ) : bool
{
	return l.element_types == r.element_types;
}

op RawPointerType::==( RawPointerType& l, RawPointerType& r ) : bool
{
	return l.element_type == r.element_type;
}

op FunctionType::ParamReference::<=>(ParamReference& l, ParamReference& r) : i32
{
	if( l.param_index != r.param_index )
	{
		return l.param_index <=> r.param_index;
	}
	return l.reference_index <=> r.reference_index;
}

op FunctionType::ReferencePollution::<=>(ReferencePollution& l, ReferencePollution& r) : i32
{
	if( l.dst != r.dst )
	{
		return l.dst <=> r.dst;
	}
	return l.src <=> r.src;
}

fn FunctionType::PointerCanBeConvertedTo( this, FunctionType& dst ) : bool
{
	if(
		this.return_type != dst.return_type ||
		( this.return_value_type == ValueType::Value ) != ( dst.return_value_type == ValueType::Value ) ||
		( this.return_value_type == ValueType::ReferenceImut && dst.return_value_type == ValueType::ReferenceMut ) || // Allow mutability conversions, except mut->imut
		( this.is_unsafe && !dst.is_unsafe ) || // Disable unsafe function to safe function conversion
		this.calling_convention != dst.calling_convention ||
		this.params.size() != dst.params.size() )
	{
		return false;
	}

	// Can convert pointer to function returning less references to pointer to function, returning more references.
	foreach( &src_param_reference : this.return_references )
	{
		var bool mut found= false;
		foreach( &dst_param_reference : dst.return_references )
		{
			if( src_param_reference == dst_param_reference )
			{
				found= true;
				break;
			}
		}
		if( !found )
		{
			return false;
		}
	}

	// Can convert function, linkink less references to function, linking more references.
	foreach( &src_pollution : this.references_pollution )
	{
		var bool mut found= false;
		foreach( &dst_pollution : dst.references_pollution )
		{
			if( src_pollution == dst_pollution )
			{
				found= true;
				break;
			}
		}
		if( !found )
		{
			return false;
		}
	}

	for( auto mut i= 0s; i < params.size(); ++i )
	{
		auto& this_param= this.params[i];
		auto& dst_param= dst.params[i];
		if( this_param.t != dst_param.t ||
			( this_param.value_type == ValueType::Value ) != ( dst_param.value_type == ValueType::Value ) ||
			this_param.value_type == ValueType::ReferenceMut && dst_param.value_type == ValueType::ReferenceImut ) // Allow mutability conversions, except mut->imut
		{
			return false;
		}
	}

	return true;
}

fn FunctionType::ReturnsCompositeValue( this ) : bool
{
	return
		return_value_type == ValueType::Value &&
		( !return_type.GetClassType().empty() || !return_type.GetArrayType().empty() || !return_type.GetTupleType().empty() );
}

fn FunctionParamsToString( ust::array_view_imut</FunctionType::Param/> params ) : ust::string8
{
	var ust::string8 mut result;

	foreach( &param : params )
	{
		result+= param.t.ToString();
		result+= " ";

		if( param.value_type == ValueType::ReferenceMut )
		{
			result+= "&mut ";
		}
		if( param.value_type == ValueType::ReferenceImut )
		{
			result+= "&imut ";
		}

		result+= "_"; // use some dummy for param name.

		if( ust::ref_cmp_ne( param, params.back() ) )
		{
			result+= ", ";
		}
	}

	return move(result);
}

op FunctionPointerType::==( FunctionPointerType& l, FunctionPointerType& r ) : bool
{
	return l.function_type == r.function_type;
}

fn Type::conversion_constructor( FundamentalType mut fundamental_type )
	( something_( move(fundamental_type) ) )
{}

fn Type::conversion_constructor( ArrayType mut array_type )
	( something_( ust::make_shared_ptr_final(move(array_type)) ) )
{}

fn Type::conversion_constructor( TupleType mut tuple_type )
	( something_( ust::make_shared_ptr_final(move(tuple_type)) ) )
{}

fn Type::conversion_constructor( RawPointerType mut raw_pointer_type )
	( something_( ust::make_shared_ptr_final(move(raw_pointer_type)) ) )
{}

fn Type::conversion_constructor( FunctionPointerType mut function_pointer_type )
	( something_( ust::make_shared_ptr_final(move(function_pointer_type)) ) )
{}

fn Type::conversion_constructor( ClassTypePtr mut class_type )
	( something_( move(class_type) ) )
{}

fn Type::conversion_constructor( EnumTypePtr mut enum_type )
	( something_( move(enum_type) ) )
{}

fn Type::GetFundamentalType( imut this ) : ust::optional_ref_imut</FundamentalType />'this'
{
	return something_.get</FundamentalType/>();
}

fn Type::GetArrayType( imut this ) : ust::optional_ref_imut</ArrayType />'this'
{
	if_var( &b : something_.get</ust::shared_ptr_final</ArrayType/>/>() )
	{
		return ust::optional_ref_imut</ArrayType/>( b.deref() );
	}

	return ust::null_optional_ref;
}

fn Type::GetTupleType( imut this ) : ust::optional_ref_imut</TupleType />'this'
{
	if_var( &b : something_.get</ust::shared_ptr_final</TupleType/>/>() )
	{
		return ust::optional_ref_imut</TupleType/>( b.deref() );
	}

	return ust::null_optional_ref;
}

fn Type::GetRawPointerType( imut this ) : ust::optional_ref_imut</RawPointerType />'this'
{
	if_var( &b : something_.get</ust::shared_ptr_final</RawPointerType/>/>() )
	{
		return ust::optional_ref_imut</RawPointerType/>( b.deref() );
	}

	return ust::null_optional_ref;
}

fn Type::GetFunctionPointerType( imut this ) : ust::optional_ref_imut</FunctionPointerType />'this'
{
	if_var( &b : something_.get</ust::shared_ptr_final</FunctionPointerType/>/>() )
	{
		return ust::optional_ref_imut</FunctionPointerType/>( b.deref() );
	}

	return ust::null_optional_ref;
}

fn Type::GetClassType( imut this ) : ust::optional_ref_imut</ClassTypePtr />'this'
{
	return something_.get</ClassTypePtr/>();
}

fn Type::GetEnumType( imut this ) : ust::optional_ref_imut</EnumTypePtr />'this'
{
	return something_.get</EnumTypePtr/>();
}

fn Type::GetLLVMType( this ) : LLVMTypeRef
{
	if_var( &fundamental_type : GetFundamentalType() )
	{
		return fundamental_type.llvm_type;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.llvm_type;
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.llvm_type;
	}
	if_var( &raw_pointer_type : GetRawPointerType() )
	{
		return raw_pointer_type.llvm_type;
	}
	if_var( &function_pointer_type : GetFunctionPointerType() )
	{
		return function_pointer_type.llvm_type;
	}
	if_var( &class_type_ptr : GetClassType() )
	{
		return class_type_ptr.lock_imut().deref().llvm_type;
	}
	if_var( &enum_type_ptr : GetEnumType() )
	{
		return enum_type_ptr.lock_imut().deref().underlaying_type.llvm_type;
	}

	halt;
}

fn Type::IsDefaultConstructible( this ) : bool
{
	if_var( &fundamental_type : GetFundamentalType() )
	{
		return fundamental_type.fundamental_type == U_FundamentalType::void_;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count == 0u64 || array_type.element_type.IsDefaultConstructible();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( !element_type.IsDefaultConstructible() )
			{
				return false;
			}
		}
		return true;
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_default_constructible;
	}
	return false;
}

fn Type::IsCopyConstructible( this ) : bool
{
	if( !GetFundamentalType().empty() |
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		return true;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count == 0u64 || array_type.element_type.IsCopyConstructible();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( !element_type.IsCopyConstructible() )
			{
				return false;
			}
		}
		return true;
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_copy_constructible;
	}
	return false;
}

fn Type::IsCopyAssignable( this ) : bool
{
	if( !GetFundamentalType().empty() |
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		return true;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count == 0u64 || array_type.element_type.IsCopyAssignable();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( !element_type.IsCopyAssignable() )
			{
				return false;
			}
		}
		return true;
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_copy_assignable;
	}
	return false;
}

fn Type::IsEqualityComparable( this ) : bool
{
	if( !GetFundamentalType().empty() |
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		return true;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.IsEqualityComparable();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( !element_type.IsEqualityComparable() )
			{
				return false;
			}
		}
		return true;
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_equality_comparable;
	}
	return false;
}

fn Type::HaveDestructor( this ) : bool
{
	if_var( &class_type_ptr : GetClassType() )
	{
		// Assume all classes except typeinfo have destructors.
		return class_type_ptr.lock_imut().deref().generated_class_data.get</ TypeinfoClassDescription />().empty();
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.HaveDestructor();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( element_type.HaveDestructor() )
			{
				return true;
			}
		}
		return false;
	}

	return false;
}

fn Type::CanBeConstexpr( this ) : bool
{
	if( !GetFundamentalType().empty() || !GetEnumType().empty() || !GetFunctionPointerType().empty() )
	{
		return true;
	}

	// Raw pointer type is not constexpr, because pointer dereference and pointer arithmetic can break functional purity of constexpr functions.

	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.CanBeConstexpr();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( !element_type.CanBeConstexpr() )
			{
				return false;
			}
		}
		return true;
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().can_be_constexpr;
	}

	return false;
}

fn Type::IsAbstract( this ) : bool
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count > 0u64 && array_type.element_type.IsAbstract();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		foreach( &element_type : tuple_type.element_types )
		{
			if( element_type.IsAbstract() )
			{
				return true;
			}
		}
		return false;
	}
	if_var( &class_type : GetClassType() )
	{
		auto kind= class_type.lock_imut().deref().kind;
		return kind == ClassType::Kind::Abstract || kind == ClassType::Kind::Interface;
	}

	return false;
}

fn Type::GetInnerReferenceKind( this ) : InnerReferenceKind
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.GetInnerReferenceKind();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		var InnerReferenceKind mut inner_reference_type= InnerReferenceKind::None;
		foreach( &element_type : tuple_type.element_types )
		{
			var InnerReferenceKind element_inner_reference_type= element_type.GetInnerReferenceKind();
			if( u32(element_inner_reference_type) > u32(inner_reference_type) )
			{
				inner_reference_type= element_inner_reference_type;
			}
		}
		return inner_reference_type;
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().inner_reference_kind;
	}

	return InnerReferenceKind::None;
}

fn Type::ReferenceIsConvertibleTo( this, Type& dst ) : bool
{
	if( this == dst )
	{
		return true;
	}

	if_var( &src_class_type : this.GetClassType() )
	{
		if_var( &dst_class_type : dst.GetClassType() )
		{
			foreach( &parent : src_class_type.lock_imut().deref().parents )
			{
				if( dst_class_type == parent.class_ || Type(parent.class_).ReferenceIsConvertibleTo(dst) )
				{
					return true;
				}
			}
		}
	}
	return false;
}

fn Type::ToString( this ) : ust::string8
{
	variant_visit( &t : something_ )
	{
		return ToStringHelper::ToString(t);
	}
	halt;
}

op Type::==( Type& l, Type& r ) : bool
{
	if( l.something_.index() != r.something_.index() )
	{
		return false;
	}

	variant_visit( &l_t : l.something_ )
	{
		type LeftT= typeof(l_t);
		static_if(
			same_type</ LeftT, ust::shared_ptr_final</ArrayType/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</TupleType/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</RawPointerType/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</FunctionPointerType/> /> )
		{
			return l_t.deref() == r.something_.get</ LeftT />().try_deref().deref();
		}
		else
		{
			return l_t == r.something_.get</ LeftT />().try_deref();
		}
	}

	halt;
}

//
// TypeHasher
//

fn TypeHasher::hash( Type& t ) : size_type
{
	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		return hash_combine( 0s, hash(fundamental_type) );
	}
	if_var( &array_type : t.GetArrayType() )
	{
		return hash_combine( 1s, hash(array_type) );
	}
	if_var( &tuple_type : t.GetTupleType() )
	{
		return hash_combine( 2s, hash(tuple_type) );
	}
	if_var( &raw_pointer_type : t.GetRawPointerType() )
	{
		return hash_combine( 3s, hash(raw_pointer_type) );
	}
	if_var( &function_pointer_type : t.GetFunctionPointerType() )
	{
		return hash_combine( 4s, hash(function_pointer_type) );
	}
	if_var( &class_type : t.GetClassType() )
	{
		return hash_combine( 5s, hash(class_type) );
	}
	if_var( &enum_type : t.GetEnumType() )
	{
		return hash_combine( 6s, hash(enum_type) );
	}

	// Unhandled type kind.
	halt;
}

fn TypeHasher::hash( FundamentalType& t ) : size_type
{
	return size_type(t.fundamental_type);
}

fn TypeHasher::hash( ArrayType& t ) : size_type
{
	return hash_combine( size_type(t.element_count), hash(t.element_type) );
}

fn TypeHasher::hash( TupleType& t ) : size_type
{
	auto mut res= 0s;
	foreach( &element_type : t.element_types )
	{
		res= hash_combine( res, hash(element_type) );
	}

	return res;
}

fn TypeHasher::hash( RawPointerType& t ) : size_type
{
	return hash(t.element_type);
}

fn TypeHasher::hash( FunctionType& t ) : size_type
{
	auto mut res= 0s;
	foreach( &param : t.params )
	{
		res= hash_combine( res, hash(param.t) );
		res= hash_combine( res, size_type(param.value_type) );
	}

	res= hash_combine( res, hash(t.return_type) );
	res= hash_combine( res, size_type(t.return_value_type) );

	res= hash_combine( res, size_type(t.calling_convention) );
	res= hash_combine( res, select( t.is_unsafe ? 1s : 0s ) );

	foreach( &return_reference : t.return_references )
	{
		res= hash_combine( res, size_type(return_reference.param_index) );
		res= hash_combine( res, size_type(return_reference.reference_index) );
	}
	foreach( &reference_pollution : t.references_pollution )
	{
		res= hash_combine( res, size_type(reference_pollution.dst.param_index) );
		res= hash_combine( res, size_type(reference_pollution.dst.reference_index) );
		res= hash_combine( res, size_type(reference_pollution.src.param_index) );
		res= hash_combine( res, size_type(reference_pollution.src.reference_index) );
	}

	return res;
}

fn TypeHasher::hash( FunctionPointerType& t ) : size_type
{
	return hash(t.function_type);
}

fn TypeHasher::hash( ClassTypePtr& t ) : size_type
{
	// Use hash of pointer.
	return ust::default_hasher::hash(t);
}

fn TypeHasher::hash( EnumTypePtr& t ) : size_type
{
	// Use hash of pointer.
	return ust::default_hasher::hash(t);
}

fn TypeHasher::hash_combine( size_type x, size_type y ) : size_type
{
	auto shift= 7s;
	auto hash_bits= typeinfo</size_type/>.size_of * 8s;

	// Use simple XOR and rotate.
	return x ^ ( (y << shift) | (y >> hash_bits - shift) );
}

//
// CoroutineTypeDescription
//

fn CoroutineTypeDescriptionHasher::hash(CoroutineTypeDescription& d) : size_type
{
	auto mut hash= size_type(d.kind);
	hash= TypeHasher::hash_combine( hash, TypeHasher::hash(d.return_type) );
	hash= TypeHasher::hash_combine( hash, size_type(d.return_value_type) );
	hash= TypeHasher::hash_combine( hash, size_type(d.inner_reference_kind) );
	hash= TypeHasher::hash_combine( hash, select(d.non_sync_ ? 1s : 0s) );
	return hash;
}

//
// ClassType
//

fn ClassType::GetMemberVisibility( this, ust::string8& member_name ) : Synt::ClassVisibility
{
	if_var( v : members_visibility.find(member_name) )
	{
		return v;
	}

	return Synt::ClassVisibility::Public;
}

fn ClassType::SetMemberVisibility( mut this, ust::string8& member_name, Synt::ClassVisibility visibility )
{
	if( visibility == Synt::ClassVisibility::Public )
	{
		if( !members_visibility.find( member_name ).empty() )
		{
			members_visibility.drop( member_name );
		}
	}
	else
	{
		members_visibility.insert( member_name, visibility );
	}
}

fn ClassType::HasAncestor( this, ClassTypePtr& possible_ancestor ) : bool
{
	foreach( &parent : parents )
	{
		if( parent.class_ == possible_ancestor || parent.class_.lock_imut().deref().HasAncestor( possible_ancestor ) )
		{
			return true;
		}
	}

	return false;
}

//
// Value
//

fn ConstantVariableToString( Type& t, LLVMValueRef constant_value ) : ust::string8
{
	if( constant_value == LLVMValueRef::Null )
	{
		return "";
	}

	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		if( fundamental_type.fundamental_type == U_FundamentalType::bool_ )
		{
			return select( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) == 0u64 ? ust::string8("false") : ust::string8("true") );
		}
		else if( IsSignedInteger( fundamental_type.fundamental_type ) )
		{
			var ust::string8 mut suffix;
			if( fundamental_type.fundamental_type == U_FundamentalType::i32_ )
			{  suffix= "";  }
			else
			{  suffix= GetFundamentalTypeName( fundamental_type.fundamental_type );  }

			return ust::to_string8( unsafe( LLVMConstIntGetSExtValue( constant_value ) ) ) + suffix;
		}
		else if( IsUnsignedInteger( fundamental_type.fundamental_type ) )
		{
			var ust::string8 mut suffix;
			if( fundamental_type.fundamental_type == U_FundamentalType::u32_ )
			{  suffix= "u";  }
			else
			{  suffix= GetFundamentalTypeName( fundamental_type.fundamental_type );  }

			return ust::to_string8( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) )  + suffix;
		}
		else if( IsChar( fundamental_type.fundamental_type ) )
		{
			var ust::string8 mut suffix;
			switch( fundamental_type.fundamental_type )
			{
				U_FundamentalType::char8_  -> {  suffix= "c8" ;  },
				U_FundamentalType::char16_ -> {  suffix= "c16";  },
				U_FundamentalType::char32_ -> {  suffix= "c32";  },
				default -> { halt; },
			}
			return ust::to_string8( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) ) + suffix;
		}
		else if( IsByte( fundamental_type.fundamental_type ) )
		{
			var ust::string8 mut res;
			res+= GetFundamentalTypeName( fundamental_type.fundamental_type );
			res+= "( ";

			res+= ust::to_string8( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) );
			switch( fundamental_type.fundamental_type )
			{
				U_FundamentalType::byte8_   -> { res+= GetFundamentalTypeName( U_FundamentalType::u8_   ); },
				U_FundamentalType::byte16_  -> { res+= GetFundamentalTypeName( U_FundamentalType::u16_  ); },
				U_FundamentalType::byte32_  -> { res+= GetFundamentalTypeName( U_FundamentalType::u32_  ); },
				U_FundamentalType::byte64_  -> { res+= GetFundamentalTypeName( U_FundamentalType::u64_  ); },
				U_FundamentalType::byte128_ -> { res+= GetFundamentalTypeName( U_FundamentalType::u128_ ); },
				default -> { halt; },
			}

			res+= " )";
			return move(res);
		}
	}
	if_var( &enum_type : t.GetEnumType() )
	{
		foreach( &element : enum_type.lock_imut().deref().elements )
		{
			if( unsafe( LLVMConstIntGetZExtValue( constant_value ) == LLVMConstIntGetZExtValue( element.value().constexpr_value ) ) )
			{
				var ust::string8 mut res;
				res+= t.ToString();
				res+= "::";
				res+= element.key();
				return res;
			}
		}
	}

	return "";
}

fn FunctionVariable::VirtuallyEquals( this, FunctionVariable& other ) : bool
{
	halt if( !( this.is_this_call && other.is_this_call ) );

	auto& tl= this.t;
	auto& tr= other.t;

	if( !(
		tl.return_type == tr.return_type &&
		tl.return_value_type == tr.return_value_type &&
		tl.is_unsafe == tr.is_unsafe &&
		tl.calling_convention == tr.calling_convention &&
		tl.params.size() == tr.params.size() &&
		tl.params.size() > 0s &&
		tl.params.front().value_type == tr.params.front().value_type &&
		tl.return_references == tr.return_references &&
		tl.references_pollution == tr.references_pollution
		) )
	{
		return false;
	}

	for( auto mut i= 1s; i < tl.params.size(); ++i )
	{
		auto& param_l= tl.params[i];
		auto& param_r= tr.params[i];
		if( param_l != param_r )
		{
			return false;
		}
	}

	return true;
}

namespace ValueKindHelper
{

fn GetValueKind( VariablePtr& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "variable";
}

fn GetValueKind( Type& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "type";
}

fn GetValueKind( FunctionsSetPtr& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "functions set";
}

fn GetValueKind( ThisMethodsSet& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "this + methods set";
}

fn GetValueKind( ust::shared_ptr_imut</TypeTemplatesSet/>& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "type templates set";
}

fn GetValueKind( ErrorValue& v ) : ust::string_view8
{
	ust::ignore_unused( v );
	return "error value";
}

} // namespace ValueKindHelper

fn GetValueKindName( Value& v ) : ust::string_view8
{
	variant_visit( &el : v )
	{
		return ValueKindHelper::GetValueKind( el );
	}

	halt;
}

//
// Templates
//

fn TemplateSignatureParam::conversion_constructor( TemplateParam mut template_param )
	( something_( move(template_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( TypeParam mut type_param )
	( something_( move(type_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( VariableParam mut variable_param )
	( something_( move(variable_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( ArrayTypeParam mut array_type_param )
	( something_( ust::make_shared_ptr_final( move(array_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( TupleTypeParam mut tuple_type_param )
	( something_( ust::make_shared_ptr_final( move(tuple_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( RawPointerTypeParam mut raw_pointer_type_param )
	( something_( ust::make_shared_ptr_final( move(raw_pointer_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( FunctionTypeParam mut function_type_param )
	( something_( ust::make_shared_ptr_final( move(function_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( CoroutineTypeParam mut coroutine_type_param )
	( something_( ust::make_shared_ptr_final( move(coroutine_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( SpecializedTemplateParam mut specialized_template_param )
	( something_( ust::make_shared_ptr_final( move(specialized_template_param) ) ) )
{}

fn TemplateSignatureParam::GetTemplateParam(this) : ust::optional_ref_imut</ TemplateParam />'this'
{
	return something_.get</TemplateParam/>();
}

fn TemplateSignatureParam::GetTypeParam(this) : ust::optional_ref_imut</ TypeParam />'this'
{
	return something_.get</TypeParam/>();
}

fn TemplateSignatureParam::GetVariableParam(this) : ust::optional_ref_imut</ VariableParam />'this'
{
	return something_.get</VariableParam/>();
}

fn TemplateSignatureParam::GetArrayTypeParam(this) : ust::optional_ref_imut</ ArrayTypeParam />'this'
{
	if_var( &array_type_param : something_.get</ ust::shared_ptr_final</ArrayTypeParam/> />() )
	{
		return ust::optional_ref_imut</ ArrayTypeParam />(array_type_param.deref());
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetTupleTypeParam(this) : ust::optional_ref_imut</ TupleTypeParam />'this'
{
	if_var( &tuple_type_param : something_.get</ ust::shared_ptr_final</TupleTypeParam/> />() )
	{
		return ust::optional_ref_imut</ TupleTypeParam />(tuple_type_param.deref());
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetRawPointerTypeParam(this) : ust::optional_ref_imut</ RawPointerTypeParam />'this'
{
	if_var( &raw_pointer_type_param : something_.get</ ust::shared_ptr_final</RawPointerTypeParam/> />() )
	{
		return ust::optional_ref_imut</ RawPointerTypeParam />(raw_pointer_type_param.deref());
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetFunctionTypeParam(this) : ust::optional_ref_imut</ FunctionTypeParam />'this'
{
	if_var( &function_type_param : something_.get</ ust::shared_ptr_final</FunctionTypeParam/> />() )
	{
		return ust::optional_ref_imut</ FunctionTypeParam />(function_type_param.deref());
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetCoroutineTypeParam(this) : ust::optional_ref_imut</ CoroutineTypeParam />'this'
{
	if_var( &coroutine_type_param : something_.get</ ust::shared_ptr_final</CoroutineTypeParam/> />() )
	{
		return ust::optional_ref_imut</ CoroutineTypeParam />(coroutine_type_param.deref());
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetSpecializedTemplateParam(this) : ust::optional_ref_imut</ SpecializedTemplateParam />'this'
{
	if_var( &specialized_template_param : something_.get</ ust::shared_ptr_final</SpecializedTemplateParam/> />() )
	{
		return ust::optional_ref_imut</ SpecializedTemplateParam />(specialized_template_param.deref());
	}

	return ust::null_optional_ref;
}

op TemplateSignatureParam::VariableParam::==(VariableParam& l, VariableParam& r) : bool
{
	return l.t == r.t && unsafe( LLVMConstIntGetZExtValue(l.constexpr_value) == LLVMConstIntGetZExtValue(r.constexpr_value) );
}

op TemplateSignatureParam::==(TemplateSignatureParam& l, TemplateSignatureParam& r) : bool
{
	if( l.something_.index() != r.something_.index() )
	{
		return false;
	}

	variant_visit( &l_t : l.something_ )
	{
		type LeftT= typeof(l_t);
		static_if(
			same_type</ LeftT, ust::shared_ptr_final</ArrayTypeParam/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</TupleTypeParam/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</RawPointerTypeParam/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</FunctionTypeParam/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</CoroutineTypeParam/> /> ||
			same_type</ LeftT, ust::shared_ptr_final</SpecializedTemplateParam/> /> )
		{
			return l_t.deref() == r.something_.get</ LeftT />().try_deref().deref();
		}
		else
		{
			return l_t == r.something_.get</ LeftT />().try_deref();
		}
	}

	halt;
}

//
// NamesScope
//

fn NamesScope::constructor(
	ust::string8 mut name,
	ust::shared_ptr_nullable_imut</NamesScope/>& parent )
	(
		name_= move(name),
		parent_(parent)
	)
{
}

fn NamesScope::GetThisScopeValue( this, ust::string8& name ) : ust::optional_ref_imut</ NamesScopeValue />'this'
{
	return names_map_.find( name );
}

fn NamesScope::IsInsideTemplate( this ) : bool
{
	if( name_ == c_template_args_namespace_name )
	{
		return true;
	}
	auto parent= GetParent();
	if( !parent.empty() )
	{
		return parent.try_lock_imut().deref().IsInsideTemplate();
	}

	return false;
}

fn NamesScope::AddName( mut this, ust::string8 mut name, NamesScopeValue mut value ) : ust::optional_ref_mut</ NamesScopeValue />'this'
{
	if( !names_map_.find(name).empty() )
	{
		return ust::null_optional_ref;
	}

	return ust::optional_ref_mut</ NamesScopeValue />( names_map_.insert(move(name), move(value) ) );
}

fn NamesScope::GetParent( this ) : ust::shared_ptr_nullable_imut</NamesScope/>
{
	return parent_.lock();
}

fn NamesScope::SetErrors( mut this, ErrorsContainerPtr errors_container )
{
	errors_container_= errors_container;
}

fn NamesScope::GetErrors( this ) : ErrorsContainerPtr
{
	if( errors_container_.empty() )
	{
		return parent_.lock().try_lock_imut().deref().GetErrors();
	}

	return errors_container_;
}

fn NamesScope::range( this ) : ust::unordered_map</ust::string8, NamesScopeValue/>::unordered_map_range</false/>'this'
{
	return names_map_.range();
}

fn NamesScope::GetThisNamespaceName( this ) : ust::string8&
{
	return name_;
}

fn NamesScope::ToString( this ) : ust::string8
{
	if( !class_.empty() )
	{
		auto class_lock= class_.try_lock_imut();
		auto& class_type= class_lock.deref();
		if_var( &base_template : class_type.generated_class_data.get</ ClassType::BaseTemplate />() )
		{
			// This is class template. So, parent namespace is arguments names scope.
			with( &type_template : base_template.class_template.lock_imut().deref() )
			{
				auto parent= type_template.parent_names_scope.lock();
				if( !parent.empty() )
				{
					var ust::string8 mut res;

					auto parent_lock= parent.try_lock_imut();
					if( !parent_lock.deref().GetParent().empty() )
					{
						res+= parent.try_lock_imut().deref().ToString();
						res+= "::";
					}
					res+= type_template.syntax_element.deref().name;

					res+= "</";
					foreach( &arg : base_template.signature_args )
					{
						if_var( &t : arg.get</Type/>() )
						{
							res+= t.ToString();
						}
						else if_var( &v_ptr : arg.get</VariablePtr/>() )
						{
							auto lock= v_ptr.lock_imut();
							auto& v= lock.deref();
							res+= ConstantVariableToString( v.t, v.constexpr_value );
						}

						if( ust::ref_cmp_ne( arg, base_template.signature_args.back() ) )
						{
							res+= ", ";
						}
					}
					res+= "/>";

					return move(res);
				}
			}
		}
		if_var( &typeinfo_class_description : class_type.generated_class_data.get</ TypeinfoClassDescription />() )
		{
			var ust::string8 mut res;
			res= KeywordToString(Keyword::typeof_);
			res+= "(";
			res+= KeywordToString(Keyword::typeinfo_);
			res+= "</";
			res+= typeinfo_class_description.source_type.ToString();
			res+= "/>";
			res+=")";
			return move(res);
		}
		if_var( &coroutine_type_description : class_type.generated_class_data.get</ CoroutineTypeDescription />() )
		{
			var ust::string8 mut res;
			if( coroutine_type_description.kind == CoroutineKind::Generator )
			{
				res+= KeywordToString( Keyword::generator_ );
			}
			else { halt; }

			if( coroutine_type_description.inner_reference_kind == InnerReferenceKind::None )
			{}
			else if( coroutine_type_description.inner_reference_kind == InnerReferenceKind::Imut )
			{
				res+= "'";
				res+= KeywordToString( Keyword::imut_ );
				res+= "'";
			}
			else if( coroutine_type_description.inner_reference_kind == InnerReferenceKind::Mut )
			{
				res+= "'";
				res+= KeywordToString( Keyword::mut_ );
			}
			else { halt; }

			res+= " ";

			if( coroutine_type_description.non_sync_ )
			{
				res+= KeywordToString( Keyword::non_sync_ );
			}

			res+= ": ";

			res+= coroutine_type_description.return_type.ToString();

			if( coroutine_type_description.return_value_type == ValueType::Value )
			{}
			else if( coroutine_type_description.return_value_type == ValueType::ReferenceImut )
			{
				res+= " &";
				res+= KeywordToString( Keyword::imut_ );
			}
			else if( coroutine_type_description.return_value_type == ValueType::ReferenceMut )
			{
				res+= " &";
				res+= KeywordToString( Keyword::mut_ );
			}
			else { halt; }

			return move(res);
		}
	}

	var ust::string8 mut res;

	auto mut parent= parent_.lock();
	if( !parent.empty() )
	{
		auto parent_lock= parent.try_lock_imut();
		if( !parent_lock.deref().GetParent().empty() )
		{
			res+= parent_lock.deref().ToString();
			res+= "::";
		}
	}

	res+= name_;
	return move(res);
}

fn NamesScope::SetClass( mut this, ust::shared_ptr_nullable_mut</ClassType/> in_class_ )
{
	class_= in_class_;
}

fn NamesScope::GetClass( this ) : ust::shared_ptr_nullable_mut</ClassType/>
{
	return class_;
}

fn NamesScope::AddAccessRightsFor( mut this, ClassTypePtr& class_type, Synt::ClassVisibility visibility )
{
	access_rights_.insert( class_type, visibility );
}

fn NamesScope::GetAccessFor( this, ClassTypePtr& class_type ) : Synt::ClassVisibility
{
	auto mut this_namespace_visibility= Synt::ClassVisibility::Public;
	if_var( visibility : access_rights_.find( class_type ) )
	{
		this_namespace_visibility= visibility;
	}

	auto mut parent_namespace_visibility= Synt::ClassVisibility::Public;
	auto parent= GetParent();
	if( !parent.empty() )
	{
		parent_namespace_visibility= parent.try_lock_imut().deref().GetAccessFor( class_type );
	}

	// TODO - maybe add to language possibility to order compare enum values?
	return select( u32(this_namespace_visibility) > u32(parent_namespace_visibility) ? this_namespace_visibility : parent_namespace_visibility );
}

fn NamesScope::CopyAccessRightsFrom( mut this, NamesScope& src )
{
	access_rights_= src.access_rights_;
}

fn GetRootNamespace( NamesScopePtr& names_scope ) : NamesScopePtr
{
	var NamesScopePtr mut root_names_scope= names_scope;
	loop
	{
		auto parent= root_names_scope.lock_imut().deref().GetParent();
		if( parent.empty() )
		{
			break;
		}
		root_names_scope= parent.try_to_non_nullable();
	}

	return move(root_names_scope);
}

} // namespace U1
