import "../lex_synt_lib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U
{

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name ) : Type
{
	variant_visit( &t : type_name )
	{
		return PrepareType( names_scope, function_context, t );
	}

	halt;
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_type ) : Type
{
	var Value resolved_value= ResolveValue( names_scope, named_type );
	if_var( & t : resolved_value.get</Type/>() )
	{
		return t;
	}

	REPORT_ERROR( NameIsNotTypeName, names_scope, named_type.file_pos, named_type.name )
	return Type( FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ ) );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Type
{
	var ArrayType mut out_array_type
	{
		.element_type( PrepareType( names_scope, function_context, array_type.get_ref().element_type ) )
	};

	var Variable mut index_variable;
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		auto instructions_state= SaveInstructionsState( function_context );
		index_variable= BuildExpressionCodeEnsureVariable( names_scope, function_context, array_type.get_ref().element_count );
		RestoreInstructionsState( function_context, instructions_state );
	}

	if( index_variable.constexpr_value != LLVMValueRef::Null )
	{
		if( !index_variable.t.GetFundamentalType().empty() && IsInteger( index_variable.t.GetFundamentalType().get_ref().fundamental_type ) )
		{
			unsafe{  out_array_type.element_count= LLVMConstIntGetZExtValue( index_variable.constexpr_value );  }
			if( IsSignedInteger( index_variable.t.GetFundamentalType().get_ref().fundamental_type ) && i64(out_array_type.element_count) < 0i64 )
			{
				out_array_type.element_count= 0u64;
			}
		}
		else
		{
			REPORT_ERROR( ArraySizeIsNotInteger, names_scope, array_type.get_ref().file_pos )
		}
	}
	else
	{
		REPORT_ERROR( ExpectedConstantExpression, names_scope, array_type.get_ref().file_pos )
	}

	unsafe{ out_array_type.llvm_type= LLVMArrayType( out_array_type.element_type.get_ref().GetLLVMType(), u32(out_array_type.element_count) ); }

	return Type( move(out_array_type) );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type_ptr ) : Type
{
	return PrepareType( names_scope, function_context, function_type_ptr.get_ref() );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Type
{
	return PrepareFunctionType( names_scope, function_context, function_type, ust::shared_ptr_nullable_mut</ClassType/>() );
}

fn CodeBuilder::PrepareFunctionType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type, ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : Type
{
	var FunctionType mut res
	{
		.return_type(
			select(
				function_type.return_type.empty()
					? Type( FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_for_ret_ ) )
					: PrepareType( names_scope, function_context, function_type.return_type.get_ref() ) ) )
		.return_value_is_reference= function_type.return_value_reference_modifier == Synt::ReferenceModifier::Reference,
		.return_value_is_mutable= function_type.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable,
	};

	foreach( &arg : function_type.args )
	{
		var FunctionType::Arg mut out_arg
		{
			.arg_type( invalid_type_ ),
			.is_reference= arg.reference_modifier == Synt::ReferenceModifier::Reference,
			.is_mutable= arg.mutability_modifier == Synt::MutabilityModifier::Mutable,
		};

		if( arg.name == KeywordToString( Keyword::this_ ) )
		{
			if( class_type.empty() )
			{
				REPORT_ERROR( ThisInNonclassFunction, names_scope, arg.file_pos, ust::string8("TODO - func name") )
			}
			else if( ust::ref_to_int(arg) != ust::ref_to_int(function_type.args.front() ) )
			{
				REPORT_ERROR( UsingKeywordAsName, names_scope, arg.file_pos )
			}
			else
			{
				out_arg.is_reference= true;
				out_arg.arg_type.get_ref()= ust::to_non_nullable( class_type );
			}
		}
		else
		{
			if( IsKeyword( arg.name ) )
			{
				REPORT_ERROR( UsingKeywordAsName, names_scope, arg.file_pos )
			}

			out_arg.arg_type.get_ref()= PrepareType( names_scope, function_context, arg.arg_type );
		}

		res.args.push_back( move(out_arg) );
	}

	var ust::vector</LLVMTypeRef/> mut llvm_arg_types;

	// s_ret
	auto is_s_ret= !res.return_value_is_reference && !res.return_type.get_ref().GetClassType().empty();
	if( is_s_ret )
	{
		unsafe{  llvm_arg_types.push_back( LLVMPointerType( res.return_type.get_ref().GetLLVMType(), 0u ) );  }
	}

	foreach( &arg : res.args )
	{
		auto mut llvm_type= arg.arg_type.get_ref().GetLLVMType();
		if( arg.is_reference )
		{
			unsafe{  llvm_type= LLVMPointerType( llvm_type, 0u );  }
		}
		else
		{
			// Pass non-fundamental types by-reference
			if( !arg.arg_type.get_ref().GetClassType().empty() )
			{
				unsafe{  llvm_type= LLVMPointerType( llvm_type, 0u );  }
			}
		}
		llvm_arg_types.push_back( llvm_type );
	}

	unsafe
	{
		auto mut ret_llvm_type= res.return_type.get_ref().GetLLVMType();
		if( res.return_value_is_reference )
		{
			ret_llvm_type= LLVMPointerType( ret_llvm_type, 0u );
		}
		else if( is_s_ret )
		{
			ret_llvm_type= fundamental_llvm_types_.void_for_ret_;
		}

		if( llvm_arg_types.empty() )
		{
			auto dummy= LLVMTypeRef::Null;
			res.llvm_type= LLVMFunctionType( ret_llvm_type, dummy, 0u, LLVMBool::False );
		}
		else
		{
			res.llvm_type= LLVMFunctionType( ret_llvm_type, cast_imut(llvm_arg_types).front(), u32(llvm_arg_types.size()), LLVMBool::False );
		}
	}

	return Type(move(res));
}

} // namespace U
