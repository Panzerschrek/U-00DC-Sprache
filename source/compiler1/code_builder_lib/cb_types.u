import "/sort.u"
import "/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name ) : Type
{
	variant_visit( &t : type_name )
	{
		return PrepareType( names_scope, function_context, t );
	}

	halt;
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_type ) : Type
{
	var Value resolved_value= ResolveValue( names_scope, function_context, named_type );
	if_var( & t : resolved_value.get</Type/>() )
	{
		return t;
	}

	REPORT_ERROR( NameIsNotTypeName, names_scope, Synt::GetSrcLoc(named_type), named_type )
	return Type( FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ ) );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Type
{
	return PrepareType( names_scope, function_context, array_type.deref() );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ArrayType& array_type ) : Type
{
	var Type mut element_type= PrepareType( names_scope, function_context, array_type.element_type );

	var u64 mut element_count(0);
	{
		var VariablesFrameHolder temp_variables_frame_hodler(function_context);
		auto& mut function_context= temp_variables_frame_hodler.GetFunctionContext();

		var bool prev_is_functionless_context= function_context.is_functionless_context;
		function_context.is_functionless_context= true;

		auto state= SaveFunctionContextState( function_context );
		with( &index_variable: BuildExpressionCodeEnsureVariable( names_scope, function_context, array_type.element_count ).lock_imut().deref() )
		{
			if( index_variable.constexpr_value != LLVMValueRef::Null )
			{
				{
					if_var( &fundamental_type : index_variable.t.GetFundamentalType() )
					{
						if( IsInteger( fundamental_type.fundamental_type ) )
						{
							if( IsSignedInteger( fundamental_type.fundamental_type ) )
							{
								auto s= unsafe( LLVMConstIntGetSExtValue( index_variable.constexpr_value ) );
								if( s >= 0i64 )
								{
									element_count= u64(s);
								}
								else
								{
									element_count= 0u64;
									REPORT_ERROR( ArraySizeIsNegative, names_scope, array_type.src_loc  )
								}
							}
							else
							{
								element_count= unsafe( LLVMConstIntGetZExtValue( index_variable.constexpr_value ) );
							}
							break label integer_check;
						}
					}
					REPORT_ERROR( ArraySizeIsNotInteger, names_scope, array_type.src_loc )

				} label integer_check
			}
			else
			{
				REPORT_ERROR( ExpectedConstantExpression, names_scope, array_type.src_loc )
			}
		}

		RestoreFunctionContextState( function_context, state );

		function_context.is_functionless_context= prev_is_functionless_context;
	}

	var ArrayType mut out_array_type
	{
		.llvm_type= unsafe( LLVMArrayType( element_type.GetLLVMType(), u32(element_count) ) ),
		.element_type= move(element_type),
		.element_count= element_count,
	};

	return Type( move(out_array_type) );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Type
{
	return PrepareType( names_scope, function_context, tuple_type.deref() );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TupleType& tuple_type ) : Type
{
	var TupleType mut out_tuple_type;

	var ust::vector</ LLVMTypeRef /> mut element_llvm_types;
	foreach( & element : tuple_type.elements )
	{
		var Type mut t= PrepareType( names_scope, function_context, element );
		element_llvm_types.push_back( t.GetLLVMType() );
		out_tuple_type.element_types.push_back( move(t) );
	}

	out_tuple_type.llvm_type= unsafe( LLVMStructTypeInContext( llvm_context_, element_llvm_types.data(), u32(element_llvm_types.size()), LLVMBool::False ) );

	return move(out_tuple_type);
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::RawPointerType/>& raw_pointer_type ) : Type
{
	return PrepareType( names_scope, function_context, raw_pointer_type.deref() );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerType& raw_pointer_type ) : Type
{
	var RawPointerType mut out_type{ .element_type = PrepareType( names_scope, function_context, raw_pointer_type.element_type ) };
	out_type.llvm_type= unsafe( LLVMPointerType( out_type.element_type.GetLLVMType(), 0u ) );

	return move(out_type);
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type_ptr ) : Type
{
	return PrepareType( names_scope, function_context, function_type_ptr.deref() );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Type
{
	var FunctionType mut res= PrepareFunctionType( names_scope, function_context, function_type, ust::shared_ptr_nullable_mut</ClassType/>() );
	return FunctionTypeToPointer( move(res) );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::GeneratorType/>& generator_type_ptr ) : Type
{
	return PrepareType( names_scope, function_context, generator_type_ptr.deref() );
}

fn CodeBuilder::PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::GeneratorType& generator_type ) : Type
{
	var CoroutineTypeDescription mut coroutine_type_description
	{
		.kind= CoroutineKind::Generator,
		.return_type= PrepareType( names_scope, function_context, generator_type.return_type ),
		.return_value_type= select(
			generator_type.return_value_reference_modifier == Synt::ReferenceModifier::Reference
				? select(
					generator_type.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable
						? ValueType::ReferenceMut
						: ValueType::ReferenceImut )
				: ValueType::Value ),
		.non_sync_= ImmediateEvaluateNonSyncTag( names_scope, function_context, generator_type.non_sync_tag ),
	};

	if( !coroutine_type_description.non_sync_ && GetTypeNonSync( coroutine_type_description.return_type, names_scope, generator_type.src_loc  ) )
	{
		REPORT_ERROR( GeneratorNonSyncRequired, names_scope, generator_type.src_loc )
	}

	if( !generator_type.inner_reference_tag.empty() )
	{
		coroutine_type_description.inner_reference_kind=
			select( generator_type.inner_reference_tag.try_deref().mutability_modifier == Synt::MutabilityModifier::Mutable
				? InnerReferenceKind::Mut
				: InnerReferenceKind::Imut );
	}

	if( !generator_type.return_value_reference_tag.empty() )
	{
		var bool mut found= false;
		if( !generator_type.inner_reference_tag.empty() && generator_type.inner_reference_tag.try_deref().name == generator_type.return_value_reference_tag )
		{
			found= true;
		}

		if( !found )
		{
			REPORT_ERROR( NameNotFound, names_scope, generator_type.src_loc, generator_type.return_value_reference_tag )
		}
	}
	foreach( &inner_return_reference_tag : generator_type.return_value_inner_reference_tags )
	{
	var bool mut found= false;
		if( !generator_type.inner_reference_tag.empty() && generator_type.inner_reference_tag.try_deref().name == inner_return_reference_tag )
		{
			found= true;
		}

		if( !found )
		{
			REPORT_ERROR( NameNotFound, names_scope, generator_type.src_loc, inner_return_reference_tag )
		}
	}

	// For now there is no reason to process reference tag.
	// Assume, that if generator returns a reference, it points to single possible reference tag - inner reference tag.
	return GetCoroutineType( GetRootNamespace( names_scope ), coroutine_type_description );
}

fn CodeBuilder::PrepareFunctionType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type, ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionType
{
	var FunctionType mut res
	{
		.return_type(
			select(
				function_type.return_type.empty()
					? Type( void_type_ )
					: PrepareType( names_scope, function_context, function_type.return_type.try_deref() ) ) ),
		.return_value_type= ValueType::Value,
		.is_unsafe= function_type.is_unsafe,
		.calling_convention= GetLLVMCallingConvention( function_type.calling_convention, names_scope, function_type.src_loc ),
	};

	if( function_type.return_value_reference_modifier == Synt::ReferenceModifier::Reference )
	{
		res.return_value_type= select( function_type.return_value_mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );
	}

	foreach( &param : function_type.params )
	{
		var FunctionType::Param mut out_param
		{
			.t( invalid_type_ ),
			.value_type= ValueType::Value,
		};

		if( param.reference_modifier == Synt::ReferenceModifier::Reference )
		{
			out_param.value_type= select( param.mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut );
		}

		if( param.name == KeywordToString( Keyword::this_ ) )
		{
			if( class_type.empty() )
			{
				REPORT_ERROR( ThisInNonclassFunction, names_scope, param.src_loc, ust::string8("TODO - func name") )
			}
			else if( ust::ref_cmp_ne( param, function_type.params.front() ) )
			{
				REPORT_ERROR( UsingKeywordAsName, names_scope, param.src_loc )
			}
			else
			{
				auto mut param_ok= false;
				if_var( &param_type_complex_name : param.t.get</Synt::ComplexName/>() )
				{
					if_var( &name_lookup : param_type_complex_name.get</Synt::NameLookup/>() )
					{
						param_ok= name_lookup.name.empty();
					}
				}
				if( !param_ok )
				{
					REPORT_ERROR( UsingKeywordAsName, names_scope, param.src_loc )
				}

				out_param.t= class_type.try_to_non_nullable();
			}
		}
		else
		{
			if( IsKeyword( param.name ) )
			{
				REPORT_ERROR( UsingKeywordAsName, names_scope, param.src_loc )
			}

			out_param.t= PrepareType( names_scope, function_context, param.t );
		}

		res.params.push_back( move(out_param) );
	}

	// Setup return references mapping.
	if( !function_type.return_value_reference_tag.empty() )
	{
		for( auto mut param_n= 0s; param_n < res.params.size(); ++param_n )
		{
			auto& param= function_type.params[param_n];
			if( function_type.return_value_reference_tag == param.reference_tag )
			{
				var FunctionType::ParamReference mut param_reference{ .param_index= u8(param_n), .reference_index= FunctionType::c_param_reference_number };
				res.return_references.push_back( move(param_reference) );
			}
			for( auto mut tag_n= 0s; tag_n < param.inner_reference_tags.size(); ++tag_n )
			{
				if( function_type.return_value_reference_tag == param.inner_reference_tags[tag_n] )
				{
					var FunctionType::ParamReference mut param_reference{ .param_index= u8(param_n), .reference_index= u8(tag_n) };
					res.return_references.push_back( move(param_reference) );
				}
			}
		}

		if( res.return_references.empty() )
		{
			REPORT_ERROR( NameNotFound, names_scope, function_type.src_loc, function_type.return_value_reference_tag )
		}
	}
	else if( res.return_value_type != ValueType::Value ) // Auto-generate return reference mapping if return tag is empty, but only for returning references and not for returning values.
	{
		// If there is no tag for return reference, assume, that it may refer to any reference param, but not inner reference of any param.
		for( auto mut i= 0s; i < res.params.size(); ++i )
		{
			if( res.params[i].value_type != ValueType::Value )
			{
				// TODO - what if param is immutable reference and return reference is mutable?
				var FunctionType::ParamReference mut param_reference{ .param_index= u8(i), .reference_index= FunctionType::c_param_reference_number };
				res.return_references.push_back( move(param_reference) );
			}
		}
	}

	res.return_inner_references.resize( function_type.return_value_inner_reference_tags.size() );
	for( auto mut return_inner_tag_n= 0s; return_inner_tag_n < function_type.return_value_inner_reference_tags.size(); ++return_inner_tag_n )
	{
		var ust::string8& return_inner_tag= function_type.return_value_inner_reference_tags[return_inner_tag_n];
		auto &mut out_return_references= res.return_inner_references[return_inner_tag_n];

		for( auto mut param_n= 0s; param_n < res.params.size(); ++param_n )
		{
			auto& param= function_type.params[param_n];
			if( return_inner_tag == param.reference_tag )
			{
				var FunctionType::ParamReference mut param_reference{ .param_index= u8(param_n), .reference_index= FunctionType::c_param_reference_number };
				out_return_references.push_back( move(param_reference) );
			}
			for( auto mut tag_n= 0s; tag_n < param.inner_reference_tags.size(); ++tag_n )
			{
				if( return_inner_tag == param.inner_reference_tags[tag_n] )
				{
					var FunctionType::ParamReference mut param_reference{ .param_index= u8(param_n), .reference_index= u8(tag_n) };
					out_return_references.push_back( move(param_reference) );
				}
			}
		}

		if( out_return_references.empty() )
		{
			REPORT_ERROR( NameNotFound, names_scope, function_type.src_loc, return_inner_tag )
		}
	}

	if_var( &references_pollution_expression : function_type.references_pollution_expression )
	{
		res.references_pollution= EvaluateFunctionReferencePollution( names_scope, references_pollution_expression );
	}

	return move(res);
}

fn CodeBuilder::GetLLVMFunctionType( mut this, FunctionType& function_type ) : LLVMTypeRef
{
	var ust::vector</LLVMTypeRef/> mut llvm_param_types;

	if( function_type.ReturnsCompositeValue() )
	{
		EnsureTypeComplete( function_type.return_type );
	}

	var bool is_s_ret= FunctionTypeIsSRet( function_type );
	if( is_s_ret )
	{
		llvm_param_types.push_back( unsafe( LLVMPointerType( function_type.return_type.GetLLVMType(), 0u ) ) );
	}

	var LLVMTypeRef mut ret_llvm_type= function_type.return_type.GetLLVMType();
	if( function_type.return_value_type == ValueType::Value )
	{
		if( function_type.return_type == void_type_ )
		{
			ret_llvm_type= fundamental_llvm_types_.void_for_ret_;
		}
		else if( function_type.ReturnsCompositeValue() )
		{
			var LLVMTypeRef single_scalar_type= GetSingleScalarType( ret_llvm_type );
			if( single_scalar_type != LLVMTypeRef::Null )
			{
				ret_llvm_type= single_scalar_type;
			}
			else
			{
				ret_llvm_type= fundamental_llvm_types_.void_for_ret_;
			}
		}
	}
	else
	{
		ret_llvm_type= unsafe( LLVMPointerType( ret_llvm_type, 0u ) );
	}

	foreach( &param : function_type.params )
	{
		var LLVMTypeRef mut llvm_type= param.t.GetLLVMType();
		if( param.value_type == ValueType::Value )
		{
			if( EnsureTypeComplete( param.t ) )
			{
				if( !param.t.GetClassType().empty() || !param.t.GetArrayType().empty() || !param.t.GetTupleType().empty() )
				{
					var LLVMTypeRef single_scalar_type= GetSingleScalarType( param.t.GetLLVMType() );
					if( single_scalar_type != LLVMTypeRef::Null )
					{
						// Pass composite types with single scalar inside in register, using type of this scalar.
						llvm_type= single_scalar_type;
					}
					else
					{
						// Pass aggregate types by-reference.
						llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) );
					}
				}
			}
		}
		else
		{
			llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) );
		}

		llvm_param_types.push_back( llvm_type );
	}

	return unsafe( LLVMFunctionType( ret_llvm_type, llvm_param_types.data(), u32(llvm_param_types.size()), LLVMBool::False ) );
}

fn CodeBuilder::FunctionTypeToPointer( mut this, FunctionType mut function_type ) : FunctionPointerType
{
	var FunctionPointerType mut result
	{
		.function_type= move(function_type),
		.llvm_type= unsafe( LLVMPointerTypeInContext( llvm_context_, 0u ) )
	};
	return move(result);
}

fn CodeBuilder::GetLLVMCallingConvention(
	this,
	ust::optional</ust::string8/>& calling_convention_name,
	NamesScopePtr& names_scope,
	SrcLoc& src_loc ) : LLVMCallConvID
{
	if( calling_convention_name.empty() )
	{
		return LLVMCallConv::C;
	}

	var ust::string8& cc= calling_convention_name.try_deref();

	if( cc == "C" ||
		cc == "default" ||
		cc == "Ãœ" )
	{
		return LLVMCallConv::C;
	}

	if( cc == "fast" )
	{
		return LLVMCallConv::Fast;
	}

	if( cc == "cold" )
	{
		return LLVMCallConv::Cold;
	}

	if( cc == "system" )
	{
		if( target_triple_str_ == "i686-pc-windows-gnu\0" ||
			target_triple_str_ == "i686-pc-windows-msvc\0" )
		{
			return LLVMCallConv::X86Stdcall;
		}

		return LLVMCallConv::C;
	}

	REPORT_ERROR( UnknownCallingConvention, names_scope, src_loc, cc )
	return LLVMCallConv::C;
}

fn CodeBuilder::FunctionTypeIsSRet( FunctionType& function_type ) : bool
{
	return
		function_type.ReturnsCompositeValue() &&
		GetSingleScalarType( function_type.return_type.GetLLVMType() ) == LLVMTypeRef::Null;
}

fn CodeBuilder::GetSingleScalarType( LLVMTypeRef mut t ) : LLVMTypeRef
{
	loop
	{
		var LLVMTypeKind t_kind= unsafe( LLVMGetTypeKind( t ) );
		if( t_kind == LLVMTypeKind::Struct && unsafe( LLVMCountStructElementTypes( t ) ) == 1u )
		{
			t= unsafe( LLVMStructGetTypeAtIndex( t, 0u ) );
			continue;
		}
		if( t_kind == LLVMTypeKind::Array && unsafe( LLVMGetArrayLength( t ) ) == 1u )
		{
			t= unsafe( LLVMGetElementType( t ) );
			continue;
		}

		break; // Not a composite.
	}

	var LLVMTypeKind t_kind= unsafe( LLVMGetTypeKind( t ) );
	if( t_kind == LLVMTypeKind::Half ||
		t_kind == LLVMTypeKind::Float ||
		t_kind == LLVMTypeKind::Double ||
		t_kind == LLVMTypeKind::X86_FP80 ||
		t_kind == LLVMTypeKind::P128 ||
		t_kind == LLVMTypeKind::PPC_FP128 ||
		t_kind == LLVMTypeKind::Integer ||
		t_kind == LLVMTypeKind::Pointer )
	{
		return t;
	}

	return LLVMTypeRef::Null;
}

} // namespace U1
