import "error_reporting.uh"

namespace U1
{

op CodeBuilderError::==(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	return
		l.code == r.code &&
		l.file_pos == r.file_pos &&
		l.text == r.text &&
		l.errors_context == r.errors_context;
}

op CodeBuilderError::!=(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	return !(l == r);
}

op CodeBuilderError::<(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	// Sort by position in file, then, by code, then, by text.
	if( l.file_pos != r.file_pos )
	{
		return l.file_pos < r.file_pos;
	}
	return u32(l.code) < u32(r.code);
	// TODO - compare also texts.
	//return l.text < r.text;
}

fn ReportError( CodeBuilderErrorCode code, FilePos file_pos, ust::vector</ust::string8/>& format_args ) : CodeBuilderError
{
	var ust::string8 mut result_error_text;

	auto mut pattern= GetErrorMessagePattern(code);
	{
		while( !pattern.empty() )
		{
			if( pattern.size() >= 3s && pattern[0s] == "{"c8 && ( pattern[1s] >= "0"c8 && pattern[1s] <= "9"c8 ) && pattern[2s] == "}"c8 )
			{
				auto arg_index= size_type(pattern[1s]) - size_type("0"c8);
				result_error_text+= format_args[ arg_index ]; // Will halt if arg index out of range

				pattern.drop_front();
				pattern.drop_front();
				pattern.drop_front();
			}
			else
			{
				result_error_text.push_back(pattern.front());
				pattern.drop_front();
			}
		}
	}

	var CodeBuilderError mut err
	{
		.code= code,
		.text= move(result_error_text),
		.file_pos= file_pos,
	};

	return move(err);
}

fn ComplexNameToString( Synt::ComplexName& complex_name ) : ust::string8
{
	var ust::string8 mut result;
	if_var( &empty_start : complex_name.start.get</Synt::EmptyVariant/>() )
	{}
	if_var( &name : complex_name.start.get</ust::string8/>() )
	{
		result+= name;
	}

	foreach( &tail_component : complex_name.tail )
	{
		if_var( &name : tail_component.get</ust::string8/>() )
		{
			result+= "::";
			result+= name;
		}

		if_var( &template_args : tail_component.get</ ust::box</Synt::TemplateArgs/> />() )
		{
			result+= "</";
			result+= "..."; // TODO - print real args
			result+= "/>";
		}
	}

	return move(result);
}


fn NormalizeErrors( ErrorsContainer &mut errors, Synt::MacroExpansionContexts& macro_expansion_contexts )
{
	errors= NormalizeErrors_impl( ExpandErrorsInMacros( errors,  macro_expansion_contexts ) );
}

fn ExpandErrorsInMacros( ErrorsContainer& in_errors, Synt::MacroExpansionContexts& macro_expansion_contexts ) : ErrorsContainer
{
	var ErrorsContainer mut macro_contexts_errors;
	var ust::vector</ ust::shared_ptr_mut</ErrorsContainer/> /> mut macro_contexts_errors_internals;

	foreach( &macro_expansion_context : macro_expansion_contexts )
	{
		var ust::shared_ptr_mut</ErrorsContainer/> internal_errors( ErrorsContainer() );

		var TemplateErrorsContext mut template_errors_context
		{
			.context_name= macro_expansion_context.macro_name,
			.context_declaration_file_pos= macro_expansion_context.macro_declaration_file_pos,
			.errors= internal_errors,
		};

		var CodeBuilderError mut macro_expansion_context_error
		{
			.text = "in expansion of macro \"" + macro_expansion_context.macro_name + "\"",
			.file_pos= macro_expansion_context.file_pos,
			.code= CodeBuilderErrorCode::MacroExpansionContext,
			.errors_context( move(template_errors_context) ),
		};

		macro_contexts_errors.push_back( move(macro_expansion_context_error) );
		macro_contexts_errors_internals.push_back( internal_errors );
	}

	var ErrorsContainer mut out_errors;
	foreach( &in_error : in_errors )
	{
		var CodeBuilderError mut error= in_error;
		if( !error.errors_context.empty() )
		{
			var TemplateErrorsContext mut new_context= error.errors_context.lock_imut().get_ref(); // take copy
			new_context.errors= ust::shared_ptr_mut</ErrorsContainer/>( ExpandErrorsInMacros( new_context.errors.lock_imut().get_ref(), macro_expansion_contexts ) );
			error.errors_context= ust::shared_ptr_nullable_mut</TemplateErrorsContext/>( move(new_context) );
		}

		auto macro_expansion_index= size_type(error.file_pos.GetMacroExpansionIndex());
		if( macro_expansion_index < macro_contexts_errors_internals.size() )
		{
			auto mut lock= macro_contexts_errors_internals[ macro_expansion_index ].lock_mut();
			lock.get_ref().push_back( move(error) );
		}
		else
		{
			out_errors.push_back( move(error) );
		}
	}

	foreach( &macro_context_error : macro_contexts_errors )
	{
		auto macro_expansion_index= size_type(macro_context_error.file_pos.GetMacroExpansionIndex());
		if( macro_expansion_index < macro_contexts_errors_internals.size() )
		{
			auto mut lock= macro_contexts_errors_internals[ macro_expansion_index ].lock_mut();
			lock.get_ref().push_back( macro_context_error );
		}
		else
		{
			out_errors.push_back( macro_context_error );
		}
	}

	return out_errors;
}

fn NormalizeErrors_impl( ErrorsContainer mut errors ) : ErrorsContainer
{
	// Use simple bubble sorting. TODO - use REAL sorting.
	{

		for( auto mut i= 0s; i < errors.size(); ++i )
		{
			for( auto mut j= i + 1s; j < errors.size(); ++j )
			{
				if( cast_imut(errors)[j] < cast_imut(errors)[i] )
				{
					errors.swap( i, j );
				}
			}
		}
	}

	// Leave only unique errors.
	var ust::vector</CodeBuilderError/> mut res;
	foreach( &err : errors )
	{
		if( res.empty() || err != res.back() )
		{
			auto mut err_copy= err;
			if( !err_copy.errors_context.empty() )
			{
				auto sub_errors_ptr= err_copy.errors_context.lock_imut().get_ref().errors;
				auto mut sub_errors_lock= sub_errors_ptr.lock_mut();
				auto &mut sub_errors= sub_errors_lock.get_ref();
				sub_errors= NormalizeErrors_impl( sub_errors );
				if( sub_errors.empty() )
				{
					continue;
				}
			}

			res.push_back(move(err_copy));
		}
	}

	return move(res);
}

} // namespace U1
