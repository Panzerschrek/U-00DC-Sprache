import "error_reporting.uh"

namespace U1
{

op CodeBuilderError::==(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	return
		l.code == r.code &&
		l.file_pos == r.file_pos &&
		l.text == r.text &&
		l.errors_context == r.errors_context;
}

op CodeBuilderError::!=(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	return !(l == r);
}

op CodeBuilderError::<(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	// Sort by position in file, then, by code, then, by text.
	if( l.file_pos != r.file_pos )
	{
		return l.file_pos < r.file_pos;
	}
	return u32(l.code) < u32(r.code);
	// TODO - compare also texts.
	//return l.text < r.text;
}

fn ReportError( CodeBuilderErrorCode code, FilePos file_pos, ust::vector</ust::string8/>& format_args ) : CodeBuilderError
{
	var ust::string8 mut result_error_text;

	auto mut pattern= GetErrorMessagePattern(code);
	{
		while( !pattern.empty() )
		{
			if( pattern.size() >= 3s && pattern[0s] == "{"c8 && ( pattern[1s] >= "0"c8 && pattern[1s] <= "9"c8 ) && pattern[2s] == "}"c8 )
			{
				auto arg_index= size_type(pattern[1s]) - size_type("0"c8);
				result_error_text+= format_args[ arg_index ]; // Will halt if arg index out of range

				pattern.drop_front();
				pattern.drop_front();
				pattern.drop_front();
			}
			else
			{
				result_error_text.push_back(pattern.front());
				pattern.drop_front();
			}
		}
	}

	var CodeBuilderError mut err
	{
		.code= code,
		.text= move(result_error_text),
		.file_pos= file_pos,
	};

	return move(err);
}

fn ComplexNameToString( Synt::ComplexName& complex_name ) : ust::string8
{
	var ust::string8 mut result;
	if_var( &empty_start : complex_name.start.get</Synt::EmptyVariant/>() )
	{}
	if_var( &name : complex_name.start.get</ust::string8/>() )
	{
		result+= name;
	}

	foreach( &tail_component : complex_name.tail )
	{
		if_var( &name : tail_component.get</ust::string8/>() )
		{
			result+= "::";
			result+= name;
		}

		if_var( &template_args : tail_component.get</ ust::box</Synt::TemplateArgs/> />() )
		{
			result+= "</";
			result+= "..."; // TODO - print real args
			result+= "/>";
		}
	}

	return move(result);
}

fn NormalizeErrors( ust::vector</CodeBuilderError/> &mut errors )
{
	// Use simple bubble sorting. TODO - use REAL sorting.
	{

		for( auto mut i= 0s; i < errors.size(); ++i )
		{
			for( auto mut j= i + 1s; j < errors.size(); ++j )
			{
				if( cast_imut(errors)[j] < cast_imut(errors)[i] )
				{
					errors.swap( i, j );
				}
			}
		}
	}

	// Leave only unique errors.
	// TODO - do not use temporary container.
	var ust::vector</CodeBuilderError/> mut res;
	foreach( &err : errors )
	{
		if( res.empty() || err != res.back() )
		{
			auto mut err_copy= err;
			if( !err_copy.errors_context.empty() )
			{
				auto sub_errors_ptr= err_copy.errors_context.lock_imut().get_ref().errors;
				auto mut sub_errors_lock= sub_errors_ptr.lock_mut();
				auto &mut sub_errors= sub_errors_lock.get_ref();
				NormalizeErrors( sub_errors );
				if( sub_errors.empty() )
				{
					continue;
				}
			}

			res.push_back(move(err_copy));
		}
	}

	errors= move(res);
}

} // namespace U1
