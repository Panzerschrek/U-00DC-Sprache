import "error_reporting.uh"

namespace U1
{

op CodeBuilderError::==(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	return
		l.code == r.code &&
		l.file_pos == r.file_pos &&
		l.text == r.text;
}

op CodeBuilderError::!=(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	return !(l == r);
}

op CodeBuilderError::<(CodeBuilderError& l, CodeBuilderError& r) : bool
{
	// Sort by position in file, then, by code, then, by text.
	if( l.file_pos != r.file_pos )
	{
		return l.file_pos < r.file_pos;
	}
	return u32(l.code) < u32(r.code);
	// TODO - compare also texts.
	//return l.text < r.text;
}

fn ReportError( CodeBuilderErrorCode code, FilePos file_pos, ust::vector</ust::string8/>& format_args ) : CodeBuilderError
{
	var ust::string8 mut result_error_text;

	auto mut pattern= GetErrorMessagePattern(code);
	{
		while( !pattern.empty() )
		{
			if( pattern.size() >= 3s && pattern[0s] == "{"c8 && ( pattern[1s] >= "0"c8 && pattern[1s] <= "9"c8 ) && pattern[2s] == "}"c8 )
			{
				auto arg_index= size_type(pattern[1s]) - size_type("0"c8);
				result_error_text+= format_args[ arg_index ]; // Will halt if arg index out of range

				pattern.drop_front();
				pattern.drop_front();
				pattern.drop_front();
			}
			else
			{
				result_error_text.push_back(pattern.front());
				pattern.drop_front();
			}
		}
	}

	var CodeBuilderError mut err
	{
		.code= code,
		.text= move(result_error_text),
		.file_pos= file_pos,
	};

	return move(err);
}

fn NormalizeErrors( ust::vector</CodeBuilderError/> &mut errors )
{
	// Use simple bubble sorting. TODO - use REAL sorting.
	{

		for( auto mut i= 0s; i < errors.size(); ++i )
		{
			for( auto mut j= i + 1s; j < errors.size(); ++j )
			{
				if( cast_imut(errors)[j] < cast_imut(errors)[i] )
				{
					errors.swap( i, j );
				}
			}
		}
	}

	// Leave only unique errors.
	// TODO - do not use temporary container.
	if( !errors.empty() )
	{
		var ust::vector</CodeBuilderError/> mut res;
		res.push_back( errors.front() );
		foreach( &err : errors )
		{
			if( err != res.back() )
			{
				res.push_back(err);
			}
		}

		errors= move(res);
	}
}

} // namespace U1
