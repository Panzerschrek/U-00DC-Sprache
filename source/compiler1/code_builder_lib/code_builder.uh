import "../lex_synt_lib/syntax_analyzer.uh"
import "/code_builder_errors.uh"
import "function_context.uh"
import "names_scope.uh"
import "value.uh"

namespace U
{

class CodeBuilder
{
public:
	fn constructor( LLVMContextRef llvm_context );

	struct BuildResult
	{
		ust::vector</CodeBuilderError/> errors;
		LLVMModuleRef llvm_module;
	}

	fn BuildProgram( mut this, Synt::SyntaxAnalysisResult& ast ) : BuildResult;

private:
	fn FillGlobalNamesScope( this, NamesScope &mut names_scope );

	fn NamesScopeFill( NamesScope &mut names_scope, Synt::ProgramElements& program_elements );
	fn NamesScopeFill( NamesScope &mut names_scope, ust::shared_ptr_final</Synt::Function/>& function );

	fn NamesScopeBuild( this, NamesScope& names_scope );
	fn NamesScopeBuildElement( this, NamesScope& names_scope, ust::shared_ptr_mut</FunctionsSet/> functions_set );

	// Returns "true" if ok.
	fn PrepareFunction(
		this,
		ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
		NamesScope& names_scope,
		FunctionsSet &mut functions_set ) : bool;

	fn PrepareType( this, NamesScope& names_scope, Synt::TypeName& type_name ) : Type;
	fn PrepareType( this, NamesScope& names_scope, Synt::ComplexName& named_type ) : Type;
	fn PrepareType( this, NamesScope& names_scope, Synt::FunctionType& function_type) : Type;

	fn BuildFuncCode( this, FunctionVariable &mut func_variable );

	fn BuildBlockElement( this, FunctionContext &mut function_context, Synt::Block& block );
	fn BuildBlockElement( this, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator );

	fn BuildExpressionCodeEnsureVariable( this, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable;
	fn BuildExpressionCode( this, FunctionContext &mut function_context, Synt::Expression& expression ) : Value;
	fn BuildExpressionCode( this, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value;

private:
	LLVMContextRef llvm_context_;

	struct FundamentalLLVMTypes
	{
		LLVMTypeRef  i8_;
		LLVMTypeRef  u8_;
		LLVMTypeRef i16_;
		LLVMTypeRef u16_;
		LLVMTypeRef i32_;
		LLVMTypeRef u32_;
		LLVMTypeRef i64_;
		LLVMTypeRef u64_;
		LLVMTypeRef i128_;
		LLVMTypeRef u128_;

		LLVMTypeRef f32_;
		LLVMTypeRef f64_;

		LLVMTypeRef char8_ ;
		LLVMTypeRef char16_;
		LLVMTypeRef char32_;

		LLVMTypeRef void_;
		LLVMTypeRef void_for_ret_;
		LLVMTypeRef invalid_type_;
		LLVMTypeRef bool_;

		LLVMTypeRef int_ptr; // Type with width of pointer.
	}
	FundamentalLLVMTypes fundamental_llvm_types_= zero_init;

	LLVMModuleRef module_= LLVMModuleRef::Null;
}

} // namespace U
