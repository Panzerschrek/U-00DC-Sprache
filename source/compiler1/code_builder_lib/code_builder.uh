import "../lex_synt_lib/syntax_analyzer.uh"
import "/code_builder_errors.uh"
import "llvm.uh"
import "names_scope.uh"

namespace U
{

class CodeBuilder
{
public:
	fn constructor( LLVMContextRef llvm_context );

	struct BuildResult
	{
		ust::vector</CodeBuilderError/> errors;
		LLVMModuleRef llvm_module;
	}

	fn BuildProgram( mut this, Synt::SyntaxAnalysisResult& ast ) : BuildResult;

private:
	fn FillGlobalNamesScope( this, NamesScope &mut names_scope );

	fn NamesScopeFill( NamesScope &mut names_scope, Synt::ProgramElements& program_elements );
	fn NamesScopeFill( NamesScope &mut names_scope, ust::shared_ptr_final</Synt::Function/>& function );

	fn NamesScopeBuild( this, NamesScope& names_scope );
	fn NamesScopeBuildElement( this, NamesScope& names_scope, ust::shared_ptr_mut</FunctionsSet/> functions_set );

	// Returns "true" if ok.
	fn PrepareFunction(
		this,
		Synt::Function& function_declaration,
		NamesScope& names_scope,
		FunctionsSet &mut functions_set ) : bool;

	fn PrepareType( this, NamesScope& names_scope, Synt::TypeName& type_name ) : Type;
	fn PrepareType( this, NamesScope& names_scope, Synt::ComplexName& named_type ) : Type;
	fn PrepareType( this, NamesScope& names_scope, Synt::FunctionType& function_type) : Type;

private:
	LLVMContextRef llvm_context_;

	struct FundamentalLLVMTypes
	{
		LLVMTypeRef  i8_;
		LLVMTypeRef  u8_;
		LLVMTypeRef i16_;
		LLVMTypeRef u16_;
		LLVMTypeRef i32_;
		LLVMTypeRef u32_;
		LLVMTypeRef i64_;
		LLVMTypeRef u64_;
		LLVMTypeRef i128_;
		LLVMTypeRef u128_;

		LLVMTypeRef f32_;
		LLVMTypeRef f64_;

		LLVMTypeRef char8_ ;
		LLVMTypeRef char16_;
		LLVMTypeRef char32_;

		LLVMTypeRef void_;
		LLVMTypeRef void_for_ret_;
		LLVMTypeRef invalid_type_;
		LLVMTypeRef bool_;

		LLVMTypeRef int_ptr; // Type with width of pointer.
	}
	FundamentalLLVMTypes fundamental_llvm_types_= zero_init;

}

} // namespace U
