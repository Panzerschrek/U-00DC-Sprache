import "../lex_synt_lib/source_graph.uh"
import "/code_builder_errors.uh"
import "constexpr_function_evaluator.uh"
import "debug_info_builder.uh"
import "function_context.uh"
import "mangling.uh"
import "references_graph.uh"
import "tbaa_metadata_builder.uh"

namespace U1
{

type GlobalThingsStack= ust::vector</NamesScopeValue/>;
type GlobalThingsStackPtr= ust::shared_ptr_mut</GlobalThingsStack/>;

// This enum must match same enum in Compiler0 code!
enum ManglingScheme
{
	ItaniumABI,
	MSVC, // Auto-select 32-bit or 64-bit scheme.
	MSVC32,
	MSVC64,
}

struct CodeBuilderOptions
{
	bool build_debug_info= false;
	bool create_lifetimes= true;
	bool generate_lifetime_start_end_debug_calls= false;
	bool generate_tbaa_metadata= false;
	bool report_about_unused_names= true;
	ManglingScheme mangling_scheme= ManglingScheme::ItaniumABI;
}

class CodeBuilder
{
public:
	// llvm context, data layout should live longer, than this class.
	fn constructor(
		LLVMContextRef llvm_context,
		LLVMTargetDataRef data_layout,
		ust::string8 target_triple_str, // should be null-terminated
		CodeBuilderOptions& options,
		IVfsSharedPtr vfs );

	struct BuildResult
	{
		ust::vector</CodeBuilderError/> errors;
		LLVMModuleRef llvm_module;
		ust::vector</ust::string8/> embedded_files;
	}

	fn BuildProgram( mut this, SourceGraph& source_graph ) @( ust::reference_notation::pollution::param0_param_1_reference ) : BuildResult;

private:
	template</type Func/>
	fn GenerateLoop( mut this, FunctionContext &mut function_context, u64 iteration_count, Func mut func )
	{
		if( function_context.is_functionless_context )
		{
			auto counter_value= unsafe( LLVMConstNull( fundamental_llvm_types_.size_type_ ) );
			move(func)( this, function_context, counter_value );
		}
		else if( iteration_count != 0u64 )
		{
			unsafe
			{
				auto zero_value= LLVMConstNull( fundamental_llvm_types_.size_type_ );
				auto one_value= LLVMConstInt( fundamental_llvm_types_.size_type_, 1u64, LLVMBool::False );
				auto loop_count_value= LLVMConstInt( fundamental_llvm_types_.size_type_, iteration_count, LLVMBool::False );

				auto block_before_loop= LLVMGetInsertBlock( function_context.llvm_ir_builder ) ;
				auto loop_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );
				auto block_after_loop= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

				LLVMBuildBr( function_context.llvm_ir_builder, loop_block );

				LLVMAppendExistingBasicBlock( function_context.llvm_function, loop_block );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, loop_block );

				auto counter_value= LLVMBuildPhi( function_context.llvm_ir_builder, fundamental_llvm_types_.size_type_, g_null_string );
				auto counter_value_plus_one= LLVMBuildAdd( function_context.llvm_ir_builder, counter_value, one_value, g_null_string );

				safe( move(func)( this, function_context, counter_value ) );

				auto counter_test= LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::ULT, counter_value_plus_one, loop_count_value, g_null_string );
				LLVMBuildCondBr( function_context.llvm_ir_builder, counter_test, loop_block, block_after_loop );

				var [ LLVMValueRef, 2 ] mut incoming_values[ zero_value, counter_value_plus_one ];
				var [ LLVMBasicBlockRef, 2 ] mut incoming_blocks[ block_before_loop, LLVMGetInsertBlock( function_context.llvm_ir_builder ) ];
				LLVMAddIncoming( counter_value, $<(incoming_values[0]), $<(incoming_blocks[0]), 2u );

				LLVMAppendExistingBasicBlock( function_context.llvm_function, block_after_loop );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, block_after_loop );
			}
		}
		else
		{
			move(func);
		}
	}

	template</type Func/>
	fn WithVariablesFrame( mut this, FunctionContext &mut function_context, Func mut func ) : auto
	{
		function_context.variables_frames.push_back( FunctionContext::VariablesFrame() );

		auto result= move(func)( this, function_context );

		foreach( &variable : function_context.variables_frames.back() )
		{
			function_context.references_graph.RemoveNode( variable );
		}
		function_context.variables_frames.drop_back();

		return result;
	}

private:
	fn BuildSourceGraphNode( mut this, SourceGraph& source_graph, size_type node_index );

	// Returns true if this is definition in the main file and not in an imported file.
	fn IsSrcLocFromMainFile( this, SrcLoc& src_loc ) : bool;

	//
	// Resolving
	//

	fn NamesScopeValueToValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeValue& names_scope_value, SrcLoc& src_loc ) : Value;
	fn ResolveValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : Value;

	fn ResolveValueInternal( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : ust::optional</NamesScopeValue/>;

	template</type T/>
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</T/>& t ) : ust::optional</NamesScopeValue/>
	{
		return this.ResolveValueImpl( names_scope, function_context, t.deref() );
	}

	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NameLookup& name_lookup ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RootNamespaceNameLookup& root_namespace_name_lookup ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NamesScopeNameFetch& names_scope_fetch ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TemplateParameterization& template_parameterization ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeof& typeof_ ) : ust::optional</NamesScopeValue/>;

	fn BuildGlobalThingDuringResolveIfNecessary( mut this, NamesScopePtr& names_scope, NamesScopeValue& value );

	// Value with scope where it was found.
	type NameLookupResult= ust::optional</tup[NamesScopePtr, NamesScopeValue]/>;

	fn LookupName( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::string8& name, SrcLoc& src_loc ) : NameLookupResult;

	// Returns value itself, visibility label, namespace of class where this value was found (class itself or one of parents).
	fn ResolveClassValue(
		mut this,
		ClassTypePtr& class_type,
		ust::string8& name ) : ust::optional</ tup[ NamesScopeValue, Synt::ClassVisibility, NamesScopePtr ] />;
	fn ResolveClassValueImpl(
		mut this,
		ClassTypePtr& class_type,
		ust::string8& name,
		bool recursive_call ) : ust::optional</ tup[ NamesScopeValue, Synt::ClassVisibility, NamesScopePtr ] />;

	//
	// NamesScope-related functions
	//

	fn FillGlobalNamesScope( this, NamesScope &mut names_scope );

	fn NamesScopeMerge(
		NamesScopeMutPtr& dst_ptr,
		NamesScope& src,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table );

	fn DeepCopyNamesScopeValue(
		NamesScopeValue& value,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue(
		ClassTypePtr& class_type,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue(
		NamesScopeMutPtr& namespace_,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Type/>& t ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Variable/>& variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</FunctionsSet/>& functions_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</ClassField/>& class_field ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( EnumTypePtr& enum_type ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeAlias/>& type_alias ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TemplateArg/>& template_arg ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalVariable/>& global_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Mixins/>& mixins ) : NamesScopeValue;

	fn NamesScopeMergeValues(
		NamesScopeValue& dst,
		NamesScopeValue& src,
		ust::string8& name,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table );

	fn GetValueSrcLoc( NamesScopeValue& value ) : SrcLoc; // Get src_loc or empty value

	fn NamesScopeFillClass( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type, Synt::ClassVisibility start_visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Mixin/>& mixin_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Mixin/>& mixin_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility  );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Namespace/>& namespace_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility, u32 field_index );
	fn NamesScopeFillOutOfLineElements( this, NamesScopePtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeAddClass( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::optional</ ClassType::BaseTemplate /> base_template ) : ust::shared_ptr_nullable_mut</ClassType/>;

	fn NamesScopeBuild( mut this, NamesScopePtr& names_scope_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScope/>& namespace_ );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Type/>& t );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Variable/>& variable );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassType/>& class_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassField/>& class_field );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Enum/>& enum_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TemplateArg/>& template_arg );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts_set_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Mixins/>& mixins_ );

	// Mixins
	fn ProcessMixins( mut this, NamesScopeMutPtr& names_scope_ptr );
	// Returns total number of mixins.
	fn EvaluateMixinsExpressions_r( mut this, NamesScopePtr& names_scope_ptr ) : u32;
	fn ExpandNamespaceMixins_r( mut this, NamesScopeMutPtr& names_scope_ptr );
	fn ProcessClassMixins( mut this, ClassTypePtr& class_type );
	fn ExpandClassMixins_r( mut this, ClassTypePtr& class_type );
	fn ExpandNamespaceMixin( mut this, NamesScopeMutPtr& names_scope_ptr, Mixin &mut mixin_ );
	fn ExpandClassMixin( mut this, ClassTypePtr& class_type, Mixin &mut mixin_ );
	fn ExpandBlockMixin( mut this, NamesScopePtr& names_scope_ptr, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::Mixin/>& mixin_ ) : ust::shared_ptr_final_nullable</ Synt::BlockElements />;
	fn ExpandTypeNameMixin( mut this, NamesScopePtr& names_scope_ptr, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::Mixin/>& mixin_ ) : ust::shared_ptr_final_nullable</ Synt::TypeName />;
	fn ExpandExpressionMixin( mut this, NamesScopePtr& names_scope_ptr, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::Mixin/>& mixin_ ) : ust::shared_ptr_final_nullable</ Synt::Expression />;
	fn EvaluateMixinExpressionInGlobalContext( mut this, NamesScopePtr& names_scope_ptr, Mixin &mut mixin_ );
	fn EvaluateMixinExpression( mut this, NamesScopePtr& names_scope_ptr, FunctionContext &mut function_context, Mixin &mut mixin_ );
	fn PrepareMixinLexems( mut this, NamesScopePtr& names_scope_ptr, SrcLoc& src_loc, ust::string_view8 mixin_text ) : ust::optional</Lexems/>;

	// Global things build.

	fn DetectGlobalsLoop( this, NamesScopeValue& global_thing ) : bool;

	fn PrepareFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set_ptr );
	fn BuildFunctionsSetBodies( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set_ptr );
	fn PrepareFunctionsSetAndBuildConstexprBodies( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set_ptr );
	fn PrepareClassParentsList( mut this, ClassTypePtr& class_type );
	fn BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type );
	fn BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type );
	fn BuildTypeAlias( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr );
	fn BuildGlobalVariable( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );

	// Returns "true" if ok.
	fn PrepareFunction(
		mut this,
		ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
		NamesScopePtr& names_scope_ptr,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionsSet &mut functions_set,
		bool is_out_of_line_function ) : bool;

	fn CheckOverloadedOperator(
		this,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionType& func_type,
		OverloadedOperator operator,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc );

	template</type T/>
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</T/>& t ) : Type
	{
		return this.PrepareType( names_scope, function_context, t.deref() );
	}

	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ArrayType& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TupleType& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerType& raw_pointer_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CoroutineType& coroutine_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::Mixin/>& mixin_ ) : Type;
	fn PrepareFunctionType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type, ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionType;
	fn GetLLVMFunctionType( mut this, FunctionType& function_type ) : LLVMTypeRef;

	fn FunctionTypeToPointer( mut this, FunctionType function_type ) : FunctionPointerType;

	fn GetLLVMCallingConvention(
		this,
		ust::optional</ust::string8/>& calling_convention_name,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc ) : LLVMCallConvID;

	// Requires return type to be complete.
	fn FunctionTypeIsSRet( FunctionType& function_type ) : bool;

	// Returns scalar type, if this is a scalar type of a composite type, containing (recursively) such type.
	// Returns null otherwise.
	// Requires type to be complete.
	fn GetSingleScalarType( LLVMTypeRef t ) : LLVMTypeRef;

	// Returns constant value if initializer is contant
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::Initializer& initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::EmptyVariant& empty_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::Expression& expression_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::SequenceInitializer& sequence_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::StructNamedInitializer& struct_named_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::ConstructorInitializer& constructor_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::ZeroInitializer& zero_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptre, Synt::UninitializedInitializer& uninitialized_initializer ) : LLVMValueRef;
	fn BuildEmptyInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, ust::string8& variable_name, SrcLoc& src_loc ) : LLVMValueRef;
	fn BuildConstructorInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> /> args, SrcLoc& src_loc )  : LLVMValueRef;

	fn InitializeFunctionPointer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::Expression& initializer_expression ) : LLVMValueRef;

	fn InitializeReferenceField( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, ClassField& field, Synt::Initializer& initializer ) : LLVMValueRef;

	fn BuildConstructorInitialization(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Synt::StructNamedInitializer& constructor_initialization_list );

	fn CheckClassFieldsInitializers( mut this, ClassTypePtr& class_type );

	fn BuildFuncCode(
		mut this,
		NamesScopePtr& names_scope_ptr,
		FunctionVariable &mut func_variable,
		ust::shared_ptr_nullable_mut</ ReturnTypeDeductionContext /> return_type_deduction_context,
		ust::shared_ptr_nullable_mut</ ReferenceNotationDeductionContext /> reference_notation_deduction_context,
		ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext /> lambda_preprocessing_context );

	struct BlockElementBuildInfo
	{
		bool has_terminal_instruction_inside= false;
	}

	fn BuildBlockElements( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, ust::array_view_imut</Synt::BlockElement/>& elements ) : BlockElementBuildInfo;
	fn BuildBlock( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;
	fn BuildBlockImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;

	fn BuildIfAlternative( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfAlternative& if_alternative ) : BlockElementBuildInfo;

	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ScopeBlock/>& scope_block_ptr ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo;
	fn BuildVariableDeclarationImpl( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration::VariableEntry& variable_declaration, Type& t );
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration ) : BlockElementBuildInfo;
	fn BuildAutoVariableDeclarationImpl( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration );
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo;
	fn BuildReturnOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator );
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::YieldOperator& yield_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo;
	fn BuildAssignmentOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator );
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo;
	fn BuildAdditiveAssignmentOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator );
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticIfOperator& static_if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfCoroAdvanceOperator& if_coro_advance_operator ) : BlockElementBuildInfo;
	fn BuildIfCoroAdvanceOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfCoroAdvanceOperator& if_coro_advance_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SwitchOperator& switch_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LoopOperator& loop_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RangeForOperator& range_for_operator ) : BlockElementBuildInfo;
	fn BuildRangeForOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RangeForOperator& range_for_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CStyleForOperator& c_style_for_operator ) : BlockElementBuildInfo;
	fn BuildCStyleForOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CStyleForOperator& c_style_for_operator );
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WithOperator& with_operator ) : BlockElementBuildInfo;
	fn BuildWithOperatorImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WithOperator& with_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias_ptr ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::Mixin/>& mixin_ ) : BlockElementBuildInfo;

	fn BuildEmptyReturn( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );

	fn AddLoopFrame(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMBasicBlockRef break_block,
		LLVMBasicBlockRef continue_block,
		ust::optional</Synt::Label/>& label_ );

	// Returns index or ~0 if not found.
	fn FetchLoopFrame(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::optional</Synt::Label/>& label_ ) : size_type;

	fn BuildDeltaOneOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc, i32 delta );

	fn BuildExpressionCodeEnsureVariable( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : VariablePtr;

	// May move local variables.
	fn BuildExpressionCodeForValueReturn( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : VariablePtr;

	template</type T/>
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</T/>& expression ) : Value
	{
		return this.BuildExpressionCode( names_scope, function_context, expression.deref() );
	}

	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StringLiteral& string_literal ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeinfo& typeinfo_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SameType& same_type_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NonSyncExpression& non_sync_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRef& cast_ref_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRefUnsafe& cast_ref_unsafe_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastImut& cast_imut_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastMut& cast_mut_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Embed& embed_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SafeExpression& safe_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnsafeExpression& unsafe_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MoveOperator& move_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TakeOperator& take_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Lambda& lambda_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TernaryOperator& ternary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReferenceToRawPointerOperator& reference_to_raw_pointer_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerToReferenceOperator& raw_pointer_to_reference_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MemberAccessOperator& member_access_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::VariableInitialization& variable_initialization ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AwaitOperator& await_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ArrayType& array_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TupleType& tuple_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerType& raw_pointer_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CoroutineType& coroutine_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::Mixin/>& mixin_ ) : Value;

	fn DoReferenceCast( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name, Synt::Expression& expression, SrcLoc& src_loc, bool allow_unsafe ) : Value;

	fn AccessClassBase( mut this, FunctionContext& mut function_context, VariablePtr& variable_ptr ) : VariablePtr;
	fn AccessClassField(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& variable_ptr,
		ClassField& field,
		ust::string8& field_name,
		SrcLoc& src_loc ) : Value;

	fn AccessDirectClassField(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& variable_ptr,
		ClassField& field,
		ust::string8& field_name,
		SrcLoc& src_loc ) : VariablePtr;

	fn BuildBinaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariableLite& l_var,
		VariableLite& r_var,
		BinaryOperatorType operator,
		SrcLoc& src_loc ) : Value;
	fn BuildLazyBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;

	fn TryCallOverloadedBinaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		ArgsEvaluationOrder args_evaluation_order,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn CallBinaryOperatorForArrayOrTuple(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		SrcLoc& src_loc ) : Value;

	fn ConcatenateCharArrays(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		SrcLoc& src_loc ) : Value;

	fn TryCallOverloadedUnaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		VariablePtr& variable_ptr,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn TryCallOverloadedPostfixOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		VariablePtr& variable,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& synt_args,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn CallFunctionsSet(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariableNullablePtr this_,
		FunctionsSetPtr& functions_set,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariableNullablePtr& this_,
		FunctionType& function_type,
		LLVMValueRef function,
		bool is_constexpr,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;

	enum ArgsEvaluationOrder{ Direct, Reversed }

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		FunctionType& function_type,
		LLVMValueRef function,
		bool is_constexpr,
		ust::array_view_imut</ VariablePtr />& preevaluated_args,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		ArgsEvaluationOrder args_evaluation_order,
		SrcLoc& src_loc ) : Value;

	fn BuildTempVariableConstruction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Type& t,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> /> args,
		SrcLoc& src_loc ) : Value;

	fn ConvertVariable(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& src,
		Type& dst_type,
		FunctionVariable& conversion_constructor_,
		SrcLoc& src_loc ) : VariablePtr;

	fn EvaluateBoolConstantExpression( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : bool;

	// NonSync stuff

	fn GetTypeNonSync( mut this, Type& t, NamesScopePtr& names_scope, SrcLoc& src_loc ) : bool;
	fn GetTypeNonSyncImpl( mut this, ust::vector</Type/> &mut prev_types_stack, Type& t, NamesScopePtr& names_scope, SrcLoc& src_loc ) : bool;
	fn ImmediateEvaluateNonSyncTag( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NonSyncTag& non_sync_tag ) : bool;
	fn CheckClassNonSyncTagExpression( mut this, ClassTypePtr& class_type );
	fn CheckClassNonSyncTagInheritance( mut this, ClassTypePtr& class_type );

	// Templates
	fn PrepareTypeTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::TypeTemplate/>& type_template_syntax_element,
		TypeTemplatesSet &mut out_templates_set );

	fn PrepareFunctionTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template_syntax_element,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionTemplatePtr;

	fn PrepareTemplateParams(
		mut this,
		NamesScopePtr& names_scope,
		ust::array_view_imut</Synt::TemplateParam/> in_params ) : ust::vector</ TemplateBase::Param />;

	fn FillVariableTemplateParamsTypes(
		mut this,
		NamesScopePtr& names_scope,
		ust::array_view_imut</Synt::TemplateParam/> in_params,
		ust::array_view_mut</TemplateBase::Param/> template_params,
		ust::array_view_mut</bool/> template_params_usage_flags );

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::Expression& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::ComplexName& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::TypeName& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::ArrayType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::TupleType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::RawPointerType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::FunctionType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::CoroutineType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam( mut this, NamesScopePtr& names_scope, Value& value, SrcLoc& src_loc ) : TemplateSignatureParam;

	fn GenTemplateType(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
		Synt::TemplateArgs& template_args,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>;

	struct TemplateTypeArgsEvaluationResult
	{
		TypeTemplatePtr type_template;
		NamesScopeMutPtr args_names_scope; // Where we place template arguments
		TemplateArgsFinished signature_args;
	}

	fn EvaluateTemplateTypeArgs(
		mut this,
		TypeTemplatePtr& type_template_ptr,
		ust::array_view_imut</TemplateArgFinished/> template_args ) : ust::optional</TemplateTypeArgsEvaluationResult/>;

	fn FinishTypeTemplateGeneration(
		mut this,
		TemplateTypeArgsEvaluationResult& template_args_evaluation_result,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>;

	struct TemplateFunctionPreparationResult
	{
		FunctionTemplatePtr function_template;
		NamesScopeMutPtr args_names_scope; // Where we place template arguments
	}

	fn PrepareTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		ust::array_view_imut</TemplateArgFinished/> known_template_args,
		ust::array_view_imut</VariableTypeExtended/> args,
		bool first_arg_is_this,
		SrcLoc& src_loc ) : ust::optional</TemplateFunctionPreparationResult/>;

	fn FinishFunctionTemplateParameterization(
		mut this,
		ParameterizedFunctionTemplate& parameterized_function_template,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn FinishTemplateFunctionGeneration(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		NamesScopeMutPtr& result_names_scope,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Returns nullptr on error.
	fn ParameterizeTemplateFunctions(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		FunctionsSetPtr& functions_set,
		Synt::TemplateArgs& template_args,
		SrcLoc& src_loc ) : ust::shared_ptr_nullable_mut</FunctionsSet/>;

	// Returns true if ok
	fn MatchTemplateArgument(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam& param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TemplateParam& template_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TypeParam& type_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::VariableParam& variable_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::ArrayTypeParam& array_type_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TupleTypeParam& tuple_type_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::RawPointerTypeParam& raw_pointer_type_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::FunctionTypeParam& function_type_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::CoroutineTypeParam& coroutine_type_param,
		TemplateArgFinished& given_arg ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::SpecializedTemplateParam& specialized_template_param,
		TemplateArgFinished& given_arg ) : bool;

	// Returns vector with wrong size in case of error.
	fn EvaluateTemplateArgs(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		Synt::TemplateArgs& template_args,
		SrcLoc& src_loc ) : TemplateArgsFinished;

	fn ValueToTemplateArg( NamesScopePtr& names_scope, SrcLoc& src_loc, Value& value ) : ust::optional</TemplateArgFinished/>;

	fn FillKnownFunctionTemplateArgsIntoNamespace(
		mut this,
		FunctionTemplate& function_template,
		ust::array_view_imut</TemplateArgFinished/> known_template_args,
		NamesScopeMutPtr& target_namespace );

	fn AddNewTemplateThing( mut this, TemplateKey key, NamesScopePtr thing );

	// Typeinfo
	fn BuildTypeinfo( mut this, Type& t, NamesScopePtr& root_namespace ) : VariablePtr;
	fn GetTypeinfoPrototype( mut this, Type& t, NamesScopePtr& root_namespace ) : VariablePtr;
	fn BuildFullTypeinfo( mut this, Type& t ) : VariablePtr;

	fn CreateTypeinfoClass( mut this, NamesScopePtr& root_namespace, Type& src_type, ust::string8 name, bool is_main_class ) : ClassTypePtr;
	fn CreateTypeinfoHelperClass( mut this, NamesScopePtr& root_namespace, Type& src_type, ust::string8 name ) : ClassTypePtr;
	fn FinishTypeinfoClass( mut this, ClassTypePtr& typeinfo_class, ust::array_view_imut</LLVMTypeRef/> fields_llvm_types );
	fn TryFetchTypeinfoClassLazyField( mut this, Type& typeinfo_type, ust::string_view8 name ) : VariableNullablePtr;

	fn BuildTypeinfoTupleElementsList( mut this, NamesScopePtr& root_namespace, TupleType& tuple_type ) : VariablePtr;
	fn BuildTypeinfoFunctionParamsList( mut this, NamesScopePtr& root_namespace, FunctionType& function_type ) : VariablePtr;
	fn BuildTypeinfoClassFieldsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr;
	fn BuildTypeinfoClassFunctionsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr;
	fn BuildTypeinfoClassTypesList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr;
	fn BuildTypeinfoClassParentsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariablePtr;
	fn BuildTypeinfoEnumElementsList( mut this, NamesScopePtr& root_namespace, EnumTypePtr& enum_type ) : VariablePtr;
	fn FinishTypeinfoList( mut this, ust::vector</Type/> mut element_types, ust::array_view_imut</LLVMValueRef/> initializers ) : VariablePtr;

	// Virtual stuff

	fn PrepareClassVirtualTable( this, ClassTypePtr& class_type_ptr );
	fn PrepareClassVirtualTableType( mut this, ClassTypePtr& class_type_ptr );

	fn BuildClassPolymorphTypeId( mut this, ClassTypePtr& class_type_ptr );
	fn BuildClassVirtualTable_r( mut this, ClassType& ancestor_class, ClassType& dst_class, u64 offset ) : LLVMValueRef;
	fn BuildClassVirtualTable( mut this, ClassTypePtr& class_type_ptr );

	fn SetupVirtualTablePointers_r(
		mut this,
		LLVMValueRef this_,
		LLVMValueRef ptr_to_vtable_ptr,
		ClassType& class_type,
		FunctionContext &mut function_context );

	fn SetupVirtualTablePointers(
		mut this,
		LLVMValueRef this_,
		ClassTypePtr& class_type_ptr,
		FunctionContext &mut function_context );

	fn TryFetchVirtualFunction(
		mut this,
		VariablePtr& this_ptr,
		FunctionVariable& function,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		SrcLoc& src_loc ) : tup[ VariablePtr, LLVMValueRef ];

	// Overloading

	fn GetFunctionWithSameType( FunctionsSet & mut functions_set, FunctionType& function_type ) : ust::optional_ref_mut</ FunctionVariable /> @(ust::reference_notation::return_inner_references::param0);

	fn ApplyOverloadedFunction(
		FunctionsSet &mut functions_set,
		FunctionVariable mut function,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc ) : bool;

	type OverloadingResolutionItem= ust::variant</ tup[ FunctionVariable, TemplateFunctionPreparationResult ] />;

	fn OverloadingResolutionItemGetParamExtendedType( mut this, OverloadingResolutionItem& item, size_type param_index ) : VariableTypeExtended;
	fn OverloadingResolutionItemGetTemplateSignatureParam( mut this, OverloadingResolutionItem& item, size_type param_index ) : TemplateSignatureParam;
	fn OverloadingResolutionItemIsThisCall( mut this, OverloadingResolutionItem& item ) : bool;
	fn OverloadingResolutionItemIsConversionConstructor( mut this, OverloadingResolutionItem& item ) : bool;

	// This call may trigger template function building.
	fn FinalizeSelectedFunction(
		mut this,
		OverloadingResolutionItem& item,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Fetch all functions (including instantiations of function template), that match given args.
	// Adds functions into output container (but does not clear it).
	fn FetchMatchedOverloadedFunctions(
		mut this,
		FunctionsSet& functions_set,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc,
		bool allow_type_conversions,
		ust::vector</OverloadingResolutionItem/> &mut out_matched_functions );

	// Select single (best) matched overloaded function.
	// Returns index of function in input array or invalid index in case of error.
	fn SelectOverloadedFunction(
		mut this,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc,
		ust::array_view_imut</OverloadingResolutionItem/> matched_functions ) : size_type;

	// Fetch and select overloaded function.
	fn GetOverloadedFunction(
		mut this,
		FunctionsSet& functions_set,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Fetch and select overloaded operator.
	fn GetOverloadedOperator(
		mut this,
		ust::array_view_imut</VariableTypeExtended/> args,
		OverloadedOperator operator,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Fetch and select overloaded conversion constructor.
	fn GetConversionConstructor( mut this, NamesScopePtr& names_scope, Type& dst, Type& src, SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Check existance of conversion constuctor, but do not trigger its building.
	fn HasConversionConstructor( mut this, NamesScopePtr& names_scope, Type& dst, Type& src, SrcLoc& src_loc ) : bool;

	// Returns index of more specialized or ~0s
	fn SelectMoreSpecializedTemplate(
		mut this,
		ust::array_view_imut</TypeTemplatePtr/> type_templates,
		size_type signature_args_to_check ) : size_type;

	// Reference notation.

	fn EvaluateReferenceFieldTag( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : ust::optional</u8/>;
	fn EvaluateReferenceFieldInnerTags( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : ust::optional</ust::vector</u8/>/>;
	fn EvaluateFunctionReferencePollution( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, size_type num_params ) : FunctionType::ReferencesPollution;
	fn EvaluateFunctionReturnReferences( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, size_type num_params ) : FunctionType::ParamReferences;
	fn EvaluateFunctionReturnInnerReferences( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, size_type num_params ) : FunctionType::ReturnInnerReferences;
	fn EvaluateReferenceNotationExpression( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : VariableLite;
	fn NormalizeParamReferencesList( FunctionType::ParamReferences &mut param_references );
	fn NormalizeReferencesPollution( FunctionType::ReferencesPollution &mut references_pollution );

	type ReferenceNotationConstant= tup[ Type, LLVMValueRef ]; // Second - llvm constant
	fn GetReturnReferencesConstant( this, FunctionType::ParamReferences& return_references ) : ReferenceNotationConstant;
	fn GetReturnInnerReferencesConstant( this, FunctionType::ReturnInnerReferences& return_inner_references ) : ReferenceNotationConstant;
	fn GetReferencesPollutionConstant( this, FunctionType::ReferencesPollution& references_pollution ) : ReferenceNotationConstant;
	fn GetParamReferenceConstant( this, FunctionType::ParamReference& param_reference ) : LLVMValueRef; // Type is reference_notation_param_reference_description_type_

	// Coroutines

	// Call this before transforming function type.
	fn PerformCoroutineFunctionReferenceNotationChecks( mut this, FunctionType& function_type, NamesScopePtr& names_scope, SrcLoc& src_loc );

	// Make return type - coroutine type and prepare it properly. Modifies given function type.
	fn TransformCoroutineFunctionType( mut this, NamesScopePtr& root_namespace, FunctionType &mut coroutine_function_type, FunctionVariable::Kind kind, bool non_sync_ );

	fn GetCoroutineType( mut this, NamesScopePtr& root_namespace, CoroutineTypeDescription& coroutine_type_description ) : ClassTypePtr;

	// This function should be called for coroutine function just after aruments preparation.
	fn PrepareCoroutineBlocks( this, FunctionContext &mut function_context );
	fn CoroutineYield( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc );
	fn AsyncReturn( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc );
	fn BuildAwait( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc ) : Value;
	fn CoroutineSuspend( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CoroutineFinalSuspend( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );

	// Lambdas

	fn BuildLambda( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Lambda& lambda_ ) : Value;

	// Returns pair of address and constexpr value
	fn InitializeLambdaField(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ClassField& field,
		VariablePtr& variable,
		VariablePtr& result,
		SrcLoc& src_loc ) : tup[ LLVMValueRef, LLVMValueRef ];

	fn PrepareLambdaClass( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Lambda& lambda_ ) : ClassTypePtr;
	fn GetLambdaPreprocessingDummyClass( mut this, NamesScopePtr& names_scope ) : ClassTypePtr;
	fn GetLambdaBaseName( this, Synt::Lambda& lambda_, ust::array_view_imut</u32/> tuple_for_indices ) : ust::string8;
	fn CollectCurrentFunctionVariables( FunctionContext &mut function_context ) : ust::unordered_set</VariablePtr/>;
	fn LambdaPreprocessingCheckVariableUsage( NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable, ust::string8& name, SrcLoc& src_loc );
	fn LambdaPreprocessingAccessExternalVariable( mut this, FunctionContext &mut function_context, VariablePtr& variable, ust::string8& name ) : VariablePtr;
	fn LambdaPreprocessingEnsureCapturedVariableRegistered( FunctionContext &mut function_context, LambdaPreprocessingContext::CapturedVariableData& captured_variable );
	fn LambdaPreprocessingHandleCapturedVariableMove( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable, ust::string8& name, SrcLoc& src_loc ) : Value;

	// Methods generation

	fn TryGenerateDefaultConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyAssignmentOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateEqualityCompareOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructorPrototype( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructor( mut this, ClassTypePtr& class_type );

	// Sets "constexpr" flag for method and checks for errors.
	fn ProcessGeneratedMethodConstexprFlag( ClassTypePtr& class_type, FunctionContext& function_context_after_body_generation, FunctionVariable &mut method );

	fn BuildCopyConstructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc );
	fn BuildCopyAssignmentOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc );
	fn BuildEqualityCompareOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef l_address, LLVMValueRef r_address, Type& t, LLVMBasicBlockRef false_basic_block, SrcLoc& src_loc );
	fn BuildDestructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef value, Type& t, SrcLoc& src_loc );
	fn BuildMembersDestructors( mut this, FunctionContext &mut function_context, LLVMValueRef value, ClassTypePtr& class_type );

	fn TryCallCopyConstructor(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef dst, LLVMValueRef src,
		ClassTypePtr& class_type,
		SrcLoc& src_loc );

	// Unused name error generation stuff.
	fn CheckForUnusedGlobalNames( this, NamesScopePtr& names_scope );
	fn CheckForUnusedGlobalNamesImpl( this, NamesScopePtr& names_scope );
	fn CheckForUnusedLocalNames( this, NamesScopePtr& names_scope );
	fn VariableExistanceMayHaveSideEffects( Type& variable_type ) : bool;

	fn CallDestructorsForVariablesFrame( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variables_frame_index, SrcLoc& src_loc );
	fn CallDestructorsForTopVariablesFrame( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CallDestructorsForAllVariablesFrames( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CallDestructorsForLoopInnerVariables( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variable_frames_stack_size, SrcLoc& src_loc );

	fn DestroyUnusedTemporaryVariables( mut this, NamesScopePtr& names_scope, FunctionContext& mut function_context, SrcLoc& src_loc );

	fn RegisterTemporaryVariable( FunctionContext& mut function_context, VariablePtr variable );
	fn RegisterTopFrameVariable( FunctionContext& mut function_context, VariablePtr variable );
	fn RegisterFrameVariable( FunctionContext& mut function_context, VariablePtr variable, size_type frame_index_from_top );

	// Reference checking.

	// Call this only when types of params and return value are complete.
	fn CheckCompleteFunctionReferenceNotation( FunctionType& function_type, NamesScopePtr& names_scope, SrcLoc& src_loc );

	fn CheckFunctionReferencesNotationInnerReferences( FunctionType& function_type, NamesScopePtr& names_scope, SrcLoc& src_loc );
	fn CheckFunctionReferencesNotationParamReference( FunctionType& function_type, FunctionType::ParamReference& param_reference, NamesScopePtr& names_scope, SrcLoc& src_loc );

	fn CheckFunctionReferencesNotationMutabilityCorrectness( FunctionType& function_type, NamesScopePtr& names_scope, SrcLoc& src_loc );
	fn CheckReferenceNotationMutabilityViolationForReturnReferences( FunctionType& function_type, FunctionType::ParamReferences& return_references, NamesScopePtr& names_scope, SrcLoc& src_loc );
	fn CheckReferenceNotationMutabilityViolationForMutableReference( FunctionType& function_type, FunctionType::ParamReference& param_reference, NamesScopePtr& names_scope, SrcLoc& src_loc );

	fn CheckReturnedReferenceIsAllowed( this, NamesScopePtr& names, FunctionContext& function_context, VariablePtr& return_reference_node, SrcLoc& src_loc );
	fn IsReferenceAllowedForReturn( this, FunctionContext& function_context, VariablePtr& variable_node ) : bool;

	fn CheckReturnedInnerReferenceIsAllowed( this, NamesScopePtr& names, FunctionContext& function_context, VariablePtr& return_reference_node, SrcLoc& src_loc );
	fn IsReferenceAllowedForInnerReturn( this, FunctionContext& function_context, VariablePtr& variable_node, size_type index ) : bool;

	fn CheckAsyncReturnReferenceIsAllowed(
		NamesScopePtr& names,
		FunctionContext& function_context,
		CoroutineTypeDescription& coroutine_type_description,
		VariablePtr& node,
		SrcLoc& src_loc );

	fn CheckAsyncReturnInnerReferencesAreAllowed(
		NamesScopePtr& names,
		FunctionContext& function_context,
		CoroutineTypeDescription& coroutine_type_description,
		VariablePtr& node,
		SrcLoc& src_loc );

	fn GetCoroutineInnerReferenceForParamNode( FunctionContext& function_context, VariablePtr& node ) : ust::optional</FunctionType::ParamReference/>;

	fn CheckReferencesPollutionBeforeReturn( this, NamesScopePtr& names_scope, FunctionContext& function_context, SrcLoc& src_loc );

	fn CollectReturnReferences( FunctionContext &mut function_context, VariablePtr& return_node );
	fn CollectReturnInnerReferences( FunctionContext &mut function_context, VariablePtr& return_node );
	fn CollectReferencePollution( FunctionContext &mut function_context );

	fn MergeReferencesGraphsAfterConditionalBranches( ust::array_view_imut</ReferencesGraph/> branches, NamesScopePtr names_scope, SrcLoc& src_loc ) : ReferencesGraph; // TODO - rename
	fn CheckReferencesGraphAfterLoop( ReferencesGraph& state_before, ReferencesGraph& state_after, NamesScopePtr names_scope, SrcLoc& src_loc );

	fn SetupReferencesInCopyOrMove(
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& dst_node,
		VariablePtr& src_node,
		SrcLoc& src_loc );

	// Returns "false" if not complete.
	fn IsTypeComplete( this, Type& t ) : bool;
	fn EnsureTypeComplete( mut this, Type& t ) : bool;

	fn IsDefaultConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyAssignmentOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsEqualityCompareOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;

	fn AddGlobalConstantVariable( this, ust::string_view8 name_null_terminated, LLVMTypeRef llvm_type, LLVMValueRef initializer ) : LLVMValueRef;
	fn AddGlobalMutableVariable( this, ust::string_view8 name_null_terminated, LLVMTypeRef llvm_type, bool externally_available ) : LLVMValueRef;

	fn GetAttributeKindByName( ust::string_view8 attr_name ) : u32;
	fn AddFunctionAttribute( this, LLVMValueRef llvm_function, u32 index, ust::string_view8 attr_name );
	fn AddFunctionTypeAttribute( this, LLVMValueRef llvm_function, u32 index, ust::string_view8 attr_name, LLVMTypeRef t );

	// Creates LLVM function and its LLVM type lazily. This call may trigger types competion.
	fn EnsureLLVMFunctionCreated( mut this, FunctionVariable& function_variable ) : LLVMValueRef;

	fn SetupFunctionParamsAndRetAttributes( mut this, FunctionVariable& mut function_variable );
	// Requires complete types
	fn SetupDereferenceableFunctionParamsAndRetAttributes( this, FunctionVariable& mut function_variable );

	fn SetupDereferenceableFunctionParamsAndRetAttributes_r( this, NamesScope& names_scope );

	fn IsGlobalVariable( VariablePtr& variable ) : bool;

	fn SetGlobalMetadata( this, LLVMValueRef global_value, ust::string_view8 name, LLVMMetadataRef metadata );
	fn EraseGlobalMetadata( this, LLVMValueRef global_value, ust::string_view8 name );
	fn MarkInstructionWithTBAAMetadata( this, LLVMValueRef instruction, LLVMMetadataRef metadata );
	fn MarkLoadInstructionWithNonNullMetadata( this, LLVMValueRef load_instruction );
	fn MarkInstructionWithEmptyMetadata( this, LLVMValueRef instruction, ust::string_view8 name );

	fn CreateTypedLoad( mut this, FunctionContext& function_context, Type& t, LLVMValueRef address ) : LLVMValueRef;
	fn CreateTypedReferenceLoad( mut this, FunctionContext& function_context, Type& t, LLVMValueRef address ) : LLVMValueRef;
	fn CreateTypedStore( mut this, FunctionContext& function_context, Type& t, LLVMValueRef value_to_store, LLVMValueRef address );
	fn CreateTypedReferenceStore( mut this, FunctionContext& function_context, Type& t, LLVMValueRef value_to_store, LLVMValueRef address );

	fn GetFundamentalLLVMType( this, U_FundamentalType t ) : LLVMTypeRef;
	fn GetFundamentalTypeSize( this, U_FundamentalType t ) : u32;
	fn GetZeroGEPIndex( this ) : LLVMValueRef;
	fn CreateMoveToLLVMRegisterInstruction( mut this, VariableLite& variable, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateReferenceCast( this, LLVMValueRef ref, Type& src_type, Type& dst_type, FunctionContext& function_context ) : LLVMValueRef;

	fn CreateClassFieldGEP( this, FunctionContext& function_context, VariableLite& class_variable, ClassField& field ) : LLVMValueRef;
	fn CreateClassFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value, ClassField& field ) : LLVMValueRef;
	fn CreateClassParentFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value, ClassType::Parent& parent ) : LLVMValueRef;
	fn CreateBaseClassFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value ) : LLVMValueRef;
	fn CreateTupleElementGEP( this, FunctionContext& function_context, VariableLite& tuple_variable, u32 element_index ) : LLVMValueRef;
	fn CreateTupleElementGEP( this, FunctionContext& function_context, TupleType& t, LLVMValueRef value, u32 element_index ) : LLVMValueRef;
	fn CreateArrayElementGEP( this, FunctionContext& function_context, ArrayType& t, LLVMValueRef value, u32 index ) : LLVMValueRef;
	fn CreateArrayElementGEP( this, FunctionContext& function_context, ArrayType& t, LLVMValueRef value, LLVMValueRef index ) : LLVMValueRef;
	fn CreateIndexValue( this, u32 index ) : LLVMValueRef;

	// Create GEP instruction even in functionless context.
	fn ForceCreateConstantIndexGEP( this, FunctionContext& function_context, LLVMTypeRef t, LLVMValueRef value, u32 index ) : LLVMValueRef;

	fn WrapRawScalarConstant( LLVMValueRef constant, LLVMTypeRef dst_type ) : LLVMValueRef;
	fn UnwrapRawScalarConstant( LLVMValueRef constant ) : LLVMValueRef;

	fn MoveConstantToMemory( this, LLVMValueRef ptr, LLVMValueRef constant, FunctionContext& function_context );

	fn CopyBytes( mut this, LLVMValueRef dst, LLVMValueRef src, Type& t, FunctionContext &mut function_context );

	fn ConstexprCompareEqual(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef l,
		LLVMValueRef r,
		Type& t,
		SrcLoc& src_loc ) : LLVMValueRef;

	fn CreateLifetimeStart( this, FunctionContext &mut function_context, LLVMValueRef llvm_value );
	fn CreateLifetimeEnd( this, FunctionContext &mut function_context, LLVMValueRef llvm_value );

	fn GetIntrinsic( this, ust::string_view8 name, ust::array_view_imut</LLVMTypeRef/> types ) : LLVMValueRef;

	struct FunctionContextState
	{
		LLVMBasicBlockRef current_block;
		ReferencesGraph references_graph;
	}

	fn SaveFunctionContextState( FunctionContext& function_context ) : FunctionContextState;
	fn RestoreFunctionContextState( FunctionContext &mut function_context, FunctionContextState& state );

	// Dummy function context for places outside actual function.
	fn CreateGlobalFunctionContext( this ) : FunctionContext;

private:
	LLVMContextRef imut llvm_context_;
	LLVMTargetDataRef imut data_layout_;
	ust::string8 imut target_triple_str_; // null-terminated
	ConstexprFunctionEvaluator constexpr_function_evaluator_;
	bool imut generate_tbaa_metadata_;
	bool imut report_about_unused_names_;
	TBAAMetadataBuilder tbaa_metadata_builder_;
	ust::box</IMangler/> mangler_;
	IVfsSharedPtr imut vfs_;

	struct FundamentalLLVMTypes
	{
		LLVMTypeRef invalid_type_;

		LLVMTypeRef void_;
		LLVMTypeRef bool_;

		LLVMTypeRef  i8_;
		LLVMTypeRef  u8_;
		LLVMTypeRef i16_;
		LLVMTypeRef u16_;
		LLVMTypeRef i32_;
		LLVMTypeRef u32_;
		LLVMTypeRef i64_;
		LLVMTypeRef u64_;
		LLVMTypeRef i128_;
		LLVMTypeRef u128_;

		// Types with width of pointer.
		LLVMTypeRef ssize_type_;
		LLVMTypeRef size_type_ ;

		LLVMTypeRef f32_;
		LLVMTypeRef f64_;

		LLVMTypeRef char8_ ;
		LLVMTypeRef char16_;
		LLVMTypeRef char32_;

		LLVMTypeRef byte8_  ;
		LLVMTypeRef byte16_ ;
		LLVMTypeRef byte32_ ;
		LLVMTypeRef byte64_ ;
		LLVMTypeRef byte128_;

		LLVMTypeRef void_for_ret_;

	}
	FundamentalLLVMTypes imut fundamental_llvm_types_;

	Type imut invalid_type_;
	Type imut void_type_;
	Type imut bool_type_;
	Type imut ssize_type_;
	Type imut size_type_ ;
	Type imut reference_notation_param_reference_description_type_;
	Type imut reference_notation_pollution_element_type_;
	LLVMTypeRef imut virtual_function_pointer_type_; // Use common type for all function pointers in virtual table - for simplicity.
	LLVMTypeRef imut polymorph_type_id_table_element_type_;

	LLVMModuleRef module_= LLVMModuleRef::Null;

	LLVMValueRef global_llvm_function_= LLVMValueRef::Null; // For global function context

	ErrorsContainerPtr root_errors_container_;

	ust::optional_ref_imut</SourceGraph/> source_graph_; // Current source graph.

	type ClassesMembersNamespacesTable= ust::unordered_map</ ClassTypePtr, ust::shared_ptr_imut</ NamesScope /> />;
	struct SourceGraphNodeBuildResult
	{
		ust::shared_ptr_nullable_imut</NamesScope/> names_scope;
		ClassesMembersNamespacesTable classes_members_namespaces_table;
	}
	ust::vector</ SourceGraphNodeBuildResult /> source_graph_nodes_build_results_;

	ust::shared_ptr_nullable_imut</ Synt::MacroExpansionContexts /> macro_expansion_contexts_; // Macro expansion contexts of currently compiled source graph.

	// Class table of current source graph node.
	ust::vector</ ClassTypePtr /> class_table_;

	// Store template things in global container to use same things for same template arguments.
	ust::unordered_map</ TemplateKey, NamesScopePtr /> generated_template_things_;
	// Template things for current source graph node added sequentialy into this vector too.
	ust::vector</ TemplateKey /> generated_template_things_sequence_;

	ust::unordered_map</ ParameterizedFunctionTemplateKey, FunctionsSetPtr /> parameterized_template_functions_cache_;

	ust::unordered_map</Type, TypeinfoCacheElement /> typeinfo_cache_;
	ust::vector</ ClassTypePtr /> typeinfo_class_table_;

	// Maps string -> llvm::GlobalVariable
	tup[
		ust::unordered_map</ust::string8 , LLVMValueRef/>,
		ust::unordered_map</ust::string16, LLVMValueRef/>,
		ust::unordered_map</ust::string32, LLVMValueRef/> ]
		string_literals_cache_;

	LLVMValueRef halt_function_= LLVMValueRef::Null;

	LLVMValueRef malloc_function_= LLVMValueRef::Null;
	LLVMValueRef free_function_= LLVMValueRef::Null;

	// For globals loops detection.
	GlobalThingsStackPtr global_things_stack_ptr_;

	ust::vector</Type/> non_sync_expression_stack_;

	// Store here mixin expansion results.
	// It's useful to reuse expansions of same mixins in different templates if result text is identical.
	ust::unordered_map</MixinExpansionKey, ust::shared_ptr_final</Synt::NamespaceElements/>/> namespace_mixin_expansions_;
	ust::unordered_map</MixinExpansionKey, ust::shared_ptr_final</Synt::ClassElements/>/> class_mixin_expansions_;
	ust::unordered_map</MixinExpansionKey, ust::shared_ptr_final</Synt::BlockElements/>/> block_mixin_expansions_;
	ust::unordered_map</MixinExpansionKey, ust::shared_ptr_final</Synt::TypeName/>/> type_name_mixin_expansions_;
	ust::unordered_map</MixinExpansionKey, ust::shared_ptr_final</Synt::Expression/>/> expression_mixin_expansions_;

	// Normalized file path to contents mapping.
	ust::unordered_map</ ust::string8, ust::optional</ust::string8/> /> embed_cache_;

	// Debug info
	bool imut build_debug_info_;
	ust::optional</DebugInfoBuilder/> debug_info_builder_;

	// Lifetimes.
	bool imut create_lifetimes_;
	bool imut generate_lifetime_start_end_debug_calls_;
	LLVMValueRef lifetime_start_intrinsic_= LLVMValueRef::Null;
	LLVMValueRef lifetime_end_intrinsic_= LLVMValueRef::Null;
	LLVMValueRef lifetime_start_debug_func_= LLVMValueRef::Null;
	LLVMValueRef lifetime_end_debug_func_= LLVMValueRef::Null;
	LLVMTypeRef lifetime_function_arg_type_= LLVMTypeRef::Null;

	// Coroutines
	struct Coro
	{
		LLVMValueRef id= LLVMValueRef::Null;
		LLVMValueRef alloc= LLVMValueRef::Null;
		LLVMValueRef free= LLVMValueRef::Null;
		LLVMValueRef size= LLVMValueRef::Null;
		LLVMValueRef begin= LLVMValueRef::Null;
		LLVMValueRef end= LLVMValueRef::Null;
		LLVMValueRef suspend= LLVMValueRef::Null;

		LLVMValueRef resume= LLVMValueRef::Null;
		LLVMValueRef destroy= LLVMValueRef::Null;
		LLVMValueRef done= LLVMValueRef::Null;
		LLVMValueRef promise= LLVMValueRef::Null;
	}
	Coro coro_;

	ust::unordered_map</ CoroutineTypeDescription, ClassTypePtr /> coroutine_classes_;

	ust::unordered_map</ LambdaKey, ClassTypePtr /> lambda_classes_table_;
	ust::shared_ptr_nullable_mut</ ClassType /> lambda_preprocessing_dummy_class_;  // Lazily created.
}

} // namespace U1
