import "../lex_synt_lib/source_graph.uh"
import "/code_builder_errors.uh"
import "constexpr_function_evaluator.uh"
import "function_context.uh"
import "mangling.uh"
import "structs_combined.uh"

// Macro for loops generation.
// TODO - use Function instead.
// Use "counter_value" in loop block
?macro <? CB_GENERATE_LOOP:block( ?function_context:expr, ?iteration_count:expr, ?b:block )?>
->
<?
	if( ?iteration_count != 0u64 )
	{
		unsafe
		{
			auto zero_value= LLVMConstNull( fundamental_llvm_types_.int_ptr );
			auto one_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, 1u64, LLVMBool::False );
			auto loop_count_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, ?iteration_count, LLVMBool::False );

			auto block_before_loop= LLVMGetInsertBlock( ?function_context.llvm_ir_builder ) ;
			auto loop_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
			auto block_after_loop= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

			LLVMBuildBr( ?function_context.llvm_ir_builder, loop_block );

			LLVMAppendExistingBasicBlock( ?function_context.llvm_function, loop_block );
			LLVMPositionBuilderAtEnd( ?function_context.llvm_ir_builder, loop_block );

			auto counter_value= LLVMBuildPhi( ?function_context.llvm_ir_builder, fundamental_llvm_types_.int_ptr, "\0"[0] );
			auto counter_value_plus_one= LLVMBuildAdd( ?function_context.llvm_ir_builder, counter_value, one_value, "\0"[0] );

			safe{ ?b }

			auto counter_test= LLVMBuildICmp( ?function_context.llvm_ir_builder, LLVMIntPredicate::ULT, counter_value_plus_one, loop_count_value, "\0"[0] );
			LLVMBuildCondBr( ?function_context.llvm_ir_builder, counter_test, loop_block, block_after_loop );

			var [ LLVMValueRef, 2 ] mut incoming_values[ zero_value, counter_value_plus_one ];
			var [ LLVMBasicBlockRef, 2 ] mut incoming_blocks[ block_before_loop, LLVMGetInsertBlock( ?function_context.llvm_ir_builder ) ];
			LLVMAddIncoming( counter_value, $<(incoming_values[0]), $<(incoming_blocks[0]), 2u );

			LLVMAppendExistingBasicBlock( ?function_context.llvm_function, block_after_loop );
			LLVMPositionBuilderAtEnd( ?function_context.llvm_ir_builder, block_after_loop );
		}
	}
?>

namespace U1
{

type GlobalThingsStack= ust::vector</NamesScopeValue/>;
type GlobalThingsStackPtr= ust::shared_ptr_mut</GlobalThingsStack/>;

// This enum must match same enum in Compiler0 code!
enum ManglingScheme : u8
{
	ItaniumABI,
	MSVC, // Auto-select 32-bit or 64-bit scheme.
	MSVC32,
	MSVC64,
}

struct CodeBuilderOptions
{
	bool build_debug_info= false;
	bool create_lifetimes= true;
	bool generate_lifetime_start_end_debug_calls= false;
	ManglingScheme mangling_scheme= ManglingScheme::ItaniumABI;
}

class CodeBuilder
{
public:
	// llvm context, data layout should live longer, than this class.
	fn constructor(
		LLVMContextRef llvm_context,
		LLVMTargetDataRef data_layout,
		ust::string8 target_triple_str, // should be null-terminated
		CodeBuilderOptions& options );

	struct BuildResult
	{
		ust::vector</CodeBuilderError/> errors;
		LLVMModuleRef llvm_module;
	}

	fn BuildProgram( mut this, SourceGraph& source_graph ) : BuildResult;

private:
	fn BuildSourceGraphNode( mut this, SourceGraph& source_graph, size_type node_index );

	fn NamesScopeValueToValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeValue& names_scope_value, SrcLoc& src_loc ) : Value;
	fn ResolveValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : Value;
	fn ResolveValue(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Synt::ComplexName& complex_name,
		bool skip_last_template_args ) : Value;

	// Returns value itself, visibility label, namespace of class where this value was found (class itself or one of parents).
	fn ResolveClassValue(
		mut this,
		ClassTypePtr& class_type,
		ust::string8& name ) : ust::optional</ tup[ NamesScopeValue, Synt::ClassVisibility, NamesScopePtr ] />;
	fn ResolveClassValueImpl(
		mut this,
		ClassTypePtr& class_type,
		ust::string8& name,
		bool recursive_call ) : ust::optional</ tup[ NamesScopeValue, Synt::ClassVisibility, NamesScopePtr ] />;

	fn FillGlobalNamesScope( this, NamesScope &mut names_scope );

	fn NamesScopeMerge(
		NamesScopeMutPtr& dst_ptr,
		NamesScope& src,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table );

	fn DeepCopyNamesScopeValue(
		NamesScopeValue& value,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue(
		ClassTypePtr& class_type,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue(
		NamesScopeMutPtr& namespace_,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Type/>& t ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</NamesScopeVariable/>& variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</NamesScopeFunctionsSet/>& functions_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</ClassField/>& class_field ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( EnumTypePtr& enum_type ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeAlias/>& type_alias ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TemplateArg/>& template_arg ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalVariable/>& global_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts ) : NamesScopeValue;

	fn NamesScopeMergeValues(
		NamesScopeValue& dst,
		NamesScopeValue& src,
		ust::string8& name,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table );

	fn GetValueSrcLoc( NamesScopeValue& value ) : SrcLoc; // Get src_loc or empty value

	fn NamesScopeFillClass( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Namespace/>& namespace_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility, size_type field_index );
	fn NamesScopeFillOutOfLineElements( this, NamesScopePtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeAddClass( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ ) : ust::shared_ptr_nullable_mut</ClassType/>;

	fn NamesScopeBuild( mut this, NamesScopePtr& names_scope_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScope/>& namespace_ );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Type/>& t );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeVariable/>& variable );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeFunctionsSet/>& functions_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassType/>& class_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassField/>& class_field );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Enum/>& enum_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TemplateArg/>& template_arg );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts_set_ptr );

	// Global things build.

	fn DetectGlobalsLoop( this, NamesScopeValue& global_thing ) : bool;

	fn BuildFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeFunctionsSet/> functions_set, bool build_body );
	fn PrepareClassParentsList( mut this, ClassTypePtr& class_type );
	fn BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type );
	fn BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type );
	fn BuildTypeAlias( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr );
	fn BuildGlobalVariable( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );

	// Returns "true" if ok.
	fn PrepareFunction(
		mut this,
		ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
		NamesScopePtr& names_scope_ptr,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionsSet &mut functions_set,
		bool is_out_of_line_function ) : bool;

	fn CheckOverloadedOperator(
		this,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionType& func_type,
		OverloadedOperator operator,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc );

	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ArrayType& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TupleType& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::RawPointerType/>& raw_pointer_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerType& raw_pointer_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type_ptr ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Type;
	fn PrepareFunctionType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type, ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionType;
	fn FillLLVMFunctionType( this, FunctionType &mut function_type );

	fn GetLLVMCallingConvention(
		this,
		ust::optional</ust::string8/>& calling_convention_name,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc ) : LLVMCallConvID;

	// Returns constant value if initializer is contant
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Initializer& initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::EmptyVariant& empty_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& expression_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::SequenceInitializer& sequence_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::StructNamedInitializer& struct_named_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ConstructorInitializer& constructor_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ZeroInitializer& zero_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::UninitializedInitializer& uninitialized_initializer ) : LLVMValueRef;
	fn BuildEmptyInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::string8& variable_name, SrcLoc& src_loc ) : LLVMValueRef;
	fn BuildConstructorInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args, SrcLoc& src_loc )  : LLVMValueRef;

	fn InitializeFunctionPointer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& initializer_expression ) : LLVMValueRef;

	fn InitializeReferenceField( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ClassField& field, Synt::Initializer& initializer ) : LLVMValueRef;

	fn BuildConstructorInitialization(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Synt::StructNamedInitializer& constructor_initialization_list );

	fn CheckClassFieldsInitializers( mut this, ClassTypePtr& class_type );

	fn BuildFuncCode( mut this, NamesScopePtr& names_scope_ptr, FunctionVariable &mut func_variable );

	struct BlockElementBuildInfo
	{
		bool have_terminal_instruction_inside= false;
	}

	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticIfOperator& static_if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RangeForOperator& range_for_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CStyleForOperator& c_style_for_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WithOperator& with_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::TypeAlias& type_alias ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo;

	fn BuildDeltaOneOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc, i32 delta );

	fn BuildExpressionCodeEnsureVariable( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable;

	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StringLiteral& string_literal ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeinfo& typeinfo_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SharedExpression& shared_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRef& cast_ref_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRefUnsafe& cast_ref_unsafe_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastImut& cast_imut_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastMut& cast_mut_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MoveOperator& move_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TakeOperator& take_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TernaryOperator& ternary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReferenceToRawPointerOperator& reference_to_raw_pointer_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerToReferenceOperator& raw_pointer_to_reference_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MemberAccessOperator& member_access_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryPlus& unary_plus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::RawPointerType/>& raw_pointer_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type ) : Value;

	fn DoReferenceCast( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name, Synt::Expression& expression, SrcLoc& src_loc, bool allow_unsafe ) : Value;

	fn BuildBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Variable& l_var, Variable& r_var, BinaryOperatorType operator, SrcLoc& src_loc ) : Value;
	fn BuildLazyBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;

	fn TryCallOverloadedBinaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		ArgsEvaluationOrder args_evaluation_order,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn CallBinaryOperatorForArrayOrTuple(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		SrcLoc& src_loc ) : Value;

	fn TryCallOverloadedUnaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		Variable& variable,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn TryCallOverloadedPostfixOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		Variable& variable,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& synt_args,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn CallFunctionsSet(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::optional_ref_imut</ Variable /> mut this_,
		FunctionsSet& functions_set,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::optional_ref_imut</ Variable /> this_,
		FunctionVariable& function,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;

	enum ArgsEvaluationOrder{ Direct, Reversed }

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		FunctionVariable& function,
		ust::array_view_imut</ Variable />& preevaluated_args,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		ArgsEvaluationOrder args_evaluation_order,
		SrcLoc& src_loc ) : Value;

	fn BuildTempVariableConstruction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Type& t,
		ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;


	// Shared stuff

	fn GetTypeShared( mut this, Type& t, NamesScopePtr& names_scope, SrcLoc& src_loc ) : bool;
	fn GetTypeSharedImpl( mut this, ust::vector</Type/> &mut prev_types_stack, Type& t, NamesScopePtr& names_scope, SrcLoc& src_loc ) : bool;
	fn CheckClassSharedTagExpression( mut this, ClassTypePtr& class_type );
	fn CheckClassSharedTagInheritance( mut this, ClassTypePtr& class_type );

	// Templates
	fn PrepareTypeTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::TypeTemplate/>& type_template_syntax_element,
		TypeTemplatesSet &mut out_templates_set );

	fn PrepareFunctionTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template_syntax_element,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionTemplatePtr;

	fn PrepareTemplateParams(
		mut this,
		NamesScopePtr& names_scope,
		ust::vector</Synt::TemplateParam/>& in_params ) : ust::vector</ TemplateBase::Param />;

	fn FillVariableTemplateParamsTypes(
		mut this,
		NamesScopePtr& names_scope,
		ust::vector</Synt::TemplateParam/>& in_params,
		ust::vector</TemplateBase::Param/> &mut template_params,
		ust::vector</bool/> &mut template_params_usage_flags );

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::Expression& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::ComplexName& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::TypeName& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::ArrayType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::TupleType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::RawPointerType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::FunctionType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam( mut this, NamesScopePtr& names_scope, Value& value, SrcLoc& src_loc ) : TemplateSignatureParam;

	fn GenTemplateType(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
		Synt::TemplateArgs& template_args,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>;

	struct TemplateTypeArgsEvaluationResult
	{
		TypeTemplatePtr type_template;
		NamesScopeMutPtr args_names_scope; // Where we place template arguments
		TemplateArgsFinished signature_args;
	}

	fn EvaluateTemplateTypeArgs(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		TypeTemplatePtr& type_template_ptr,
		Synt::TemplateArgs& template_args,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</TemplateTypeArgsEvaluationResult/>;

	fn FinishTypeTemplateGeneration(
		mut this,
		TemplateTypeArgsEvaluationResult& template_args_evaluation_result,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>;

	fn GenTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		ust::array_view_imut</VariableTypeExtended/> mut args,
		bool first_arg_is_this,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn GenTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		TemplateArgsFinished& known_template_args,
		ust::array_view_imut</VariableTypeExtended/> mut args,
		bool first_arg_is_this,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn FinishFunctionTemplateParametrization(
		mut this,
		ParametrizedFunctionTemplate& parametrized_function_template,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn FinishTemplateFunctionGeneration(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		NamesScopeMutPtr& result_names_scope,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn ParametrizeTemplateFunctions(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		FunctionsSet& functions_set,
		Synt::TemplateArgs& template_args,
		SrcLoc& src_loc ) : ust::optional</NamesScopeValue/>;

	// Returns true if ok
	fn MatchTemplateArgument(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam& param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TemplateParam& template_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TypeParam& type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::VariableParam& variable_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::ArrayTypeParam& array_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TupleTypeParam& tuple_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::RawPointerTypeParam& raw_pointer_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::FunctionTypeParam& function_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::SpecializedTemplateParam& specialized_template_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn AddNewTemplateThing( mut this, ust::string8 mut key, NamesScopePtr& thing );

	fn TypeIsValidForTemplateVariableArgument( Type& t ) : bool;

	// Typeinfo
	fn BuildTypeinfo( mut this, Type& t, NamesScopePtr& root_namespace ) : Variable;
	fn GetTypeinfoPrototype( mut this, Type& t, NamesScopePtr& root_namespace ) : Variable;
	fn BuildFullTypeinfo( mut this, Type& t ) : Variable;

	fn CreateTypeinfoClass( mut this, NamesScopePtr& root_namespace, Type& src_type, ust::string8& name ) : ClassTypePtr;
	fn FinishTypeinfoClass( mut this, ClassTypePtr& typeinfo_class, ust::vector</LLVMTypeRef/>& fields_llvm_types );

	fn BuildTypeinfoTupleElementsList( mut this, NamesScopePtr& root_namespace, TupleType& tuple_type ) : Variable;
	fn BuildTypeinfoFunctionParamsList( mut this, NamesScopePtr& root_namespace, FunctionType& function_type ) : Variable;
	fn BuildTypeinfoClassFieldsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : Variable;
	fn BuildTypeinfoClassFunctionsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : Variable;
	fn BuildTypeinfoClassTypesList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : Variable;
	fn BuildTypeinfoClassParentsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : Variable;
	fn BuildTypeinfoEnumElementsList( mut this, NamesScopePtr& root_namespace, EnumTypePtr& enum_type ) : Variable;

	// Debug info

	fn CreateFunctionDebugInfo( mut this, FunctionVariable& func_variable );

	fn SetCurrentDebugLocation( mut this, FunctionContext& function_context, SrcLoc& src_loc );
	fn DebugInfoStartBlock( mut this, FunctionContext &mut function_context, SrcLoc& src_loc ) : LLVMMetadataRef;
	fn DebugInfoEndBlock( mut this, FunctionContext &mut function_context, LLVMMetadataRef prev_block );

	fn CreateVariableDebugInfo( mut this, FunctionContext& function_context, NamesScopeVariable& variable, ust::string8& name, SrcLoc& src_loc );
	fn CreateReferenceVariableDebugInfo( mut this, FunctionContext& function_context, NamesScopeVariable& variable, ust::string8& name, SrcLoc& src_loc );

	fn CreateDIType( mut this, Type& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, FundamentalType& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, ArrayType& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, TupleType& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, RawPointerType& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, FunctionType& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, FunctionPointerType& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, ClassTypePtr& t ) : LLVMMetadataRef;
	fn CreateDITypeImpl( mut this, EnumTypePtr& t ) : LLVMMetadataRef;

	// Virtual stuff
	fn CheckvirtualFunctionOverridingReferenceNotation(
		this,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc,
		FunctionVariable& src_function,
		FunctionVariable& new_function,
		ClassType& new_class_type );
	fn PrepareClassVirtualTable( this, ClassTypePtr& class_type_ptr );
	fn PrepareClassVirtualTableType( mut this, ClassTypePtr& class_type_ptr );

	fn BuildClassPolymorphTypeId( mut this, ClassTypePtr& class_type_ptr );
	fn BuildClassVirtualTable_r( this, ClassType& ancestor_class, ClassType& dst_class, u64 offset ) : LLVMValueRef;
	fn BuildClassVirtualTable( mut this, ClassTypePtr& class_type_ptr );

	fn SetupVirtualTablePointers_r(
		this,
		LLVMValueRef this_,
		LLVMValueRef ptr_to_vtable_ptr,
		ClassType& class_type,
		FunctionContext &mut function_context );

	fn SetupVirtualTablePointers(
		this,
		LLVMValueRef this_,
		ClassTypePtr& class_type_ptr,
		FunctionContext &mut function_context );

	fn TryFetchVirtualFunction(
		this,
		Variable& this_,
		FunctionVariable& function,
		FunctionContext &mut function_context ) : tup[ Variable, LLVMValueRef ];

	// Overloading

	fn GetFunctionWithSameType( FunctionsSet &'x mut functions_set, Type& function_type ) : ust::optional_ref_mut</ FunctionVariable />'x';

	fn ApplyOverloadedFunction(
		FunctionsSet &mut functions_set,
		FunctionVariable mut function,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc ) : bool;

	fn GetOverloadedFunctionImpl(
		mut this,
		FunctionsSet& functions_set,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc,
		bool allow_type_conversions,
		bool produce_errors ) : ust::optional</FunctionVariable/>;

	fn GetOverloadedFunction(
		mut this,
		FunctionsSet& functions_set,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn GetOverloadedOperator(
		mut this,
		ust::array_view_imut</VariableTypeExtended/> args,
		OverloadedOperator operator,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn GetConversionConstructor( mut this, NamesScopePtr& names_scope, Type& dst, Type& src, SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Returns index of more specialized or ~0s
	fn SelectMoreSpecializedTemplate(
		mut this,
		ust::array_view_imut</TypeTemplatePtr/> type_templates,
		size_type signature_args_to_check ) : size_type;

	// Methods generation

	fn TryGenerateDefaultConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyAssignmentOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateEqualityCompareOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructorPrototype( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructor( mut this, ClassTypePtr& class_type );

	// Sets "constexpr" flag for method and checks for errors.
	fn ProcessGeneratedMethodConstexprFlag( ClassTypePtr& class_type, FunctionContext& function_context_after_body_generation, FunctionVariable &mut method );

	fn BuildCopyConstructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc );
	fn BuildCopyAssignmentOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc );
	fn BuildEqualityCompareOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef l_address, LLVMValueRef r_address, Type& t, LLVMBasicBlockRef false_basic_block, SrcLoc& src_loc );
	fn BuildDestructorPart( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef value, Type& t, SrcLoc& src_loc );
	fn BuildMembersDestructors( this, FunctionContext &mut function_context, LLVMValueRef value, ClassTypePtr& class_type );

	fn TryCallCopyConstructor(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef dst, LLVMValueRef src,
		ClassTypePtr& class_type,
		SrcLoc& src_loc );

	fn CallDestructorsForVariablesFrame( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variables_frame_index, SrcLoc& src_loc );
	fn CallDestructorsForTopVariablesFrame( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CallDestructorsForAllVariablesFrames( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CallDestructorsForLoopInnerVariables( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );

	fn DestroyUnusedTemporaryVariables( this, NamesScopePtr& names_scope, FunctionContext& mut function_context, SrcLoc& src_loc );

	fn RegisterTemporaryVariable( FunctionContext& mut function_context, Variable& variable );

	fn IsReferenceAllowedForReturn( this, FunctionContext& function_context, ReferencesGraph::NodeId variable_node ) : bool;
	fn CheckReferencesPollutionBeforeReturn( this, NamesScopePtr& names_scope, FunctionContext& function_context, SrcLoc& src_loc );

	fn MergeReferencesGraphsAfterConditionalBranches( ust::array_view_imut</ReferencesGraph/> branches, NamesScopePtr names_scope, SrcLoc& src_loc ) : ReferencesGraph; // TODO - rename
	fn CheckReferencesGraphAfterLoop( ReferencesGraph& state_before, ReferencesGraph& state_after, NamesScopePtr names_scope, SrcLoc& src_loc );

	fn SetupReferencesInCopyOrMove(
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Type& dst_type,
		ReferencesGraph::NodeId dst_node,
		ReferencesGraph::NodeId src_node,
		SrcLoc& src_loc );

	// Returns "false" if not complete.
	fn IsTypeComplete( this, Type& t ) : bool;
	fn EnsureTypeComplete( mut this, Type& t ) : bool;

	fn IsDefaultConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyAssignmentOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsEqualityCompareOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;

	fn AddGlobalConstantVariable( this, ust::string8& name_null_terminated, LLVMTypeRef llvm_type, LLVMValueRef initializer ) : LLVMValueRef;
	fn AddGlobalMutableVariable( this, ust::string8& name_null_terminated, LLVMTypeRef llvm_type ) : LLVMValueRef;

	fn AddFunctionAttribute( this, LLVMValueRef llvm_function, u32 index, ust::array_view_imut</char8/> attr_name );

	fn SetupFunctionParamsAndRetAttributes( mut this, FunctionVariable& mut function_variable );
	// Requires complete types
	fn SetupDereferenceableFunctionParamsAndRetAttributes( this, FunctionVariable& mut function_variable );

	fn SetupDereferenceableFunctionParamsAndRetAttributes_r( this, NamesScope& names_scope );

	fn MarkLoadInstructionWithNonNullMetadata( this, LLVMValueRef load_instruction );

	fn GetFundamentalLLVMType( this, U_FundamentalType t ) : LLVMTypeRef;
	fn GetZeroGEPIndex( this ) : LLVMValueRef;
	fn CreateMoveToLLVMRegisterInstruction( this, Variable& variable, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateReferenceCast( this, LLVMValueRef ref, Type& src_type, Type& dst_type, FunctionContext& function_context ) : LLVMValueRef;

	fn CreateFieldGEP( this, LLVMValueRef value, ClassField& field, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateParentFieldGEP( this, LLVMValueRef value, ClassType::Parent& parent, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateBaseClassFieldGEP( this, LLVMValueRef value, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateTupleElementGEP( this, LLVMValueRef value, size_type element_index, FunctionContext& function_context ) : LLVMValueRef;

	fn MoveConstantToMemory( this, LLVMValueRef ptr, LLVMValueRef constant, FunctionContext& function_context );

	fn CopyBytes( this, LLVMValueRef dst, LLVMValueRef src, Type& t, FunctionContext &mut function_context );

	fn ConstexprCompareEqual(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef l,
		LLVMValueRef r,
		Type& t,
		SrcLoc& src_loc ) : LLVMValueRef;

	fn CreateLifetimeStart( this, FunctionContext &mut function_context, LLVMValueRef llvm_value );
	fn CreateLifetimeEnd( this, FunctionContext &mut function_context, LLVMValueRef llvm_value );

	struct InstructionsState
	{
		LLVMValueRef current_block_last_instruction;
		LLVMValueRef alloca_block_last_instruction;
		LLVMBasicBlockRef current_block;
		ReferencesGraph references_graph;
	}

	fn SaveInstructionsState( FunctionContext& function_context ) : InstructionsState;
	fn RestoreInstructionsState( FunctionContext &mut function_context, InstructionsState& state );

	// Dummy function context for places outside actual function.
	fn CreateGlobalFunctionContext( this ) : FunctionContext;

private:
	LLVMContextRef imut llvm_context_;
	LLVMTargetDataRef imut data_layout_;
	ust::string8 imut target_triple_str_; // null-terminated
	ConstexprFunctionEvaluator constexpr_function_evaluator_;
	ust::box</IMangler/> mangler_;

	struct FundamentalLLVMTypes
	{
		LLVMTypeRef  i8_;
		LLVMTypeRef  u8_;
		LLVMTypeRef i16_;
		LLVMTypeRef u16_;
		LLVMTypeRef i32_;
		LLVMTypeRef u32_;
		LLVMTypeRef i64_;
		LLVMTypeRef u64_;
		LLVMTypeRef i128_;
		LLVMTypeRef u128_;

		LLVMTypeRef f32_;
		LLVMTypeRef f64_;

		LLVMTypeRef char8_ ;
		LLVMTypeRef char16_;
		LLVMTypeRef char32_;

		LLVMTypeRef void_;
		LLVMTypeRef void_for_ret_;
		LLVMTypeRef invalid_type_;
		LLVMTypeRef bool_;

		LLVMTypeRef int_ptr; // Type with width of pointer.
	}
	FundamentalLLVMTypes fundamental_llvm_types_= zero_init;

	Type invalid_type_;
	Type void_type_;
	Type bool_type_;
	Type size_type_; // Alias for u32 or u64
	LLVMTypeRef polymorph_type_id_table_element_type_= LLVMTypeRef::Null;

	LLVMModuleRef module_= LLVMModuleRef::Null;

	LLVMValueRef global_llvm_function_= LLVMValueRef::Null; // For global function context

	ErrorsContainerPtr root_errors_container_;

	type ClassesMembersNamespacesTable= ust::unordered_map</ ClassTypePtr, ust::shared_ptr_imut</ NamesScope /> />;
	struct SourceGraphNodeBuildResult
	{
		ust::shared_ptr_nullable_imut</NamesScope/> names_scope;
		ClassesMembersNamespacesTable classes_members_namespaces_table;
	}
	ust::vector</ SourceGraphNodeBuildResult /> source_graph_nodes_build_results_;

	// Class table of current source graph node.
	ust::vector</ ClassTypePtr /> class_table_;

	// Store template things in global container to use same things for same template arguments.
	ust::unordered_map</ ust::string8, NamesScopePtr /> generated_template_things_;
	// Template things for current source graph node added sequentialy into this vector too.
	ust::vector</ ust::string8 /> generated_template_things_sequence_;

	// TODO - use unorederd_map
	struct TypeinfoStruct{ Type t; Variable v; }
	ust::vector</TypeinfoStruct/> typeinfo_cache_;
	ust::vector</ ClassTypePtr /> typeinfo_class_table_;

	// Maps string -> llvm::GlobalVariable
	tup[
		ust::unordered_map</ust::string8 , LLVMValueRef/>,
		ust::unordered_map</ust::string16, LLVMValueRef/>,
		ust::unordered_map</ust::string32, LLVMValueRef/> ]
		string_literals_cache_;

	LLVMValueRef halt_function_= LLVMValueRef::Null;

	// For globals loops detection.
	GlobalThingsStackPtr global_things_stack_ptr_;

	ust::vector</Type/> shared_expression_stack_;

	// Debug info
	bool imut build_debug_info_;

	struct DebugInfo
	{
		LLVMDIBuilderRef builder= LLVMDIBuilderRef::Null;
		ust::vector</LLVMMetadataRef/> source_file_entries; // Entry for each file in sources graph.
		LLVMMetadataRef compile_unit= LLVMMetadataRef::Null;

		// Cache of debug info types for classes and enums.
		ust::unordered_map</ ClassTypePtr, LLVMMetadataRef /> classes_di_types;
		ust::unordered_map</ EnumTypePtr, LLVMMetadataRef /> enums_di_types;
	}
	DebugInfo debug_info_;

	// Lifetimes.
	bool imut create_lifetimes_;
	bool imut generate_lifetime_start_end_debug_calls_;
	LLVMValueRef lifetime_start_intrinsic_= LLVMValueRef::Null;
	LLVMValueRef lifetime_end_intrinsic_= LLVMValueRef::Null;
	LLVMValueRef lifetime_start_debug_func_= LLVMValueRef::Null;
	LLVMValueRef lifetime_end_debug_func_= LLVMValueRef::Null;
	LLVMTypeRef lifetime_function_arg_type_= LLVMTypeRef::Null;
}

} // namespace U1
