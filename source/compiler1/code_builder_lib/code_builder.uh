import "../lex_synt_lib/source_graph.uh"
import "/code_builder_errors.uh"
import "constexpr_function_evaluator.uh"
import "function_context.uh"
import "structs_combined.uh"

// Macro for loops generation.
// TODO - use Function instead.
// Use "counter_value" in loop block
?macro <? CB_GENERATE_LOOP:block( ?function_context:expr, ?iteration_count:expr, ?b:block )?>
->
<?
	if( ?iteration_count != 0u64 )
	{
		unsafe
		{
			auto zero_value= LLVMConstNull( fundamental_llvm_types_.int_ptr );
			auto one_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, 1u64, LLVMBool::False );
			auto loop_count_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, ?iteration_count, LLVMBool::False );

			auto block_before_loop= LLVMGetInsertBlock( ?function_context.llvm_ir_builder ) ;
			auto loop_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
			auto block_after_loop= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

			LLVMBuildBr( ?function_context.llvm_ir_builder, loop_block );

			LLVMAppendExistingBasicBlock( ?function_context.llvm_function, loop_block );
			LLVMPositionBuilderAtEnd( ?function_context.llvm_ir_builder, loop_block );

			auto counter_value= LLVMBuildPhi( ?function_context.llvm_ir_builder, fundamental_llvm_types_.int_ptr, "\0"[0] );

			safe{ ?b }

			auto counter_value_plus_one= LLVMBuildAdd( ?function_context.llvm_ir_builder, counter_value, one_value, "\0"[0] );
			auto counter_test= LLVMBuildICmp( ?function_context.llvm_ir_builder, LLVMIntPredicate::ULT, counter_value_plus_one, loop_count_value, "\0"[0] );
			LLVMBuildCondBr( ?function_context.llvm_ir_builder, counter_test, loop_block, block_after_loop );

			var [ LLVMValueRef, 2 ] incoming_values[ zero_value, counter_value_plus_one ];
			var [ LLVMBasicBlockRef, 2 ] incoming_blocks[ block_before_loop, LLVMGetInsertBlock( ?function_context.llvm_ir_builder ) ];
			LLVMAddIncoming( counter_value, incoming_values[0], incoming_blocks[0], 2u );

			LLVMAppendExistingBasicBlock( ?function_context.llvm_function, block_after_loop );
			LLVMPositionBuilderAtEnd( ?function_context.llvm_ir_builder, block_after_loop );
		}
	}
?>

namespace U
{

class CodeBuilder
{
public:
	// llvm context, data layout should live longer, than this class.
	fn constructor( LLVMContextRef llvm_context, LLVMTargetDataRef data_layout );

	struct BuildResult
	{
		ust::vector</CodeBuilderError/> errors;
		LLVMModuleRef llvm_module;
	}

	fn BuildProgram( mut this, SourceGraph& source_graph ) : BuildResult;

private:
	fn BuildSourceGraphNode( mut this, ErrorsContainerPtr& errors_container, SourceGraph& source_graph, size_type node_index );

	fn NamesScopeValueToValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeValue& names_scope_value, FilePos& file_pos ) : Value;
	fn ResolveValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : Value;
	fn ResolveValue(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Synt::ComplexName& complex_name,
		bool skip_last_template_args ) : Value;

	fn FillGlobalNamesScope( this, NamesScope &mut names_scope );

	fn NamesScopeMerge( NamesScopeMutPtr& dst_ptr, NamesScope& src );

	fn DeepCopyNamesScopeValue( NamesScopeValue& value, NamesScopePtr& target_names_scope ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue( ClassTypePtr& class_type, NamesScopePtr& target_names_scope ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( NamesScopeMutPtr& namespace_, NamesScopePtr& target_names_scope ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Type/>& t ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</NamesScopeVariable/>& variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</NamesScopeFunctionsSet/>& functions_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</ClassField/>& class_field ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( EnumTypePtr& enum_type ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeAlias/>& type_alias ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TemplateArg/>& template_arg ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalVariable/>& global_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts ) : NamesScopeValue;

	fn NamesScopeMergeValues( NamesScopeValue& dst, NamesScopeValue& src, ust::string8& name, NamesScopePtr& target_names_scope );

	fn NamesScopeFillClass( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Namespace/>& namespace_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFillOutOfLineElements( this, NamesScopePtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeAddClass( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ ) : ust::shared_ptr_nullable_mut</ClassType/>;

	fn NamesScopeBuild( mut this, NamesScopePtr& names_scope_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScope/>& namespace_ );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Type/>& t );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeVariable/>& variable );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeFunctionsSet/>& functions_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassType/>& class_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassField/>& class_field );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Enum/>& enum_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TemplateArg/>& template_arg );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts_set_ptr );

	fn BuildFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScopeFunctionsSet/> functions_set, bool build_body );
	fn BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type );
	fn BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type );
	fn BuildTypeAlias( mut this, NamesScopePtr& names_scope, TypeAlias& mut type_alias );
	fn BuildGlobalVariable( mut this, NamesScopePtr& names_scope, GlobalVariable& mut global_variable );
	fn BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope, GlobalAutoVariable& mut global_auto_variable );

	// Returns "true" if ok.
	fn PrepareFunction(
		mut this,
		ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
		NamesScopePtr& names_scope_ptr,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionsSet &mut functions_set,
		bool is_out_of_line_function ) : bool;

	fn CheckOverloadedOperator(
		this,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionType& func_type,
		OverloadedOperator operator,
		NamesScopePtr& names_scope,
		FilePos& file_pos );

	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ArrayType& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TupleType& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type_ptr ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Type;
	fn PrepareFunctionType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type, ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionType;

	// Returns constant value if initializer is contant
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Initializer& initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::EmptyVariant& empty_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& expression_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::SequenceInitializer& sequence_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::StructNamedInitializer& struct_named_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ConstructorInitializer& constructor_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::ZeroInitializer& zero_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::UninitializedInitializer& uninitialized_initializer ) : LLVMValueRef;
	fn BuildEmptyInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::string8& variable_name, FilePos& file_pos );
	fn BuildConstructorInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args, FilePos& file_pos )  : LLVMValueRef;

	fn InitializeFunctionPointer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, Synt::Expression& initializer_expression ) : LLVMValueRef;

	fn InitializeReferenceField( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeVariable& variable, ClassField& field, Synt::Initializer& initializer ) : LLVMValueRef;

	fn BuildConstructorInitialization(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Synt::StructNamedInitializer& constructor_initialization_list );

	fn BuildFuncCode( mut this, NamesScopePtr& names_scope_ptr, FunctionVariable &mut func_variable );

	struct BlockElementBuildInfo
	{
		bool have_terminal_instruction_inside= false;
	}

	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::Block/>& block_ptr ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo;

	fn BuildDeltaOneOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, FilePos& file_pos, i32 delta );

	fn BuildExpressionCodeEnsureVariable( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Variable;

	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StringLiteral& string_literal ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeinfo& typeinfo_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BracketExpression& bracket_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MemberAccessOperator& member_access_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryPlus& unary_plus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type ) : Value;

	fn BuildBinaryOperator( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Variable& l_var, Variable& r_var, BinaryOperatorType operator, FilePos& file_pos ) : Value;
	fn BuildLazyBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;

	fn TryCallOverloadedBinaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		ArgsEvaluationOrder args_evaluation_order,
		FilePos& file_pos ) : ust::optional</Value/>;

	fn CallBinaryOperatorForTuple(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		FilePos& file_pos ) : Value;

	fn CallFunctionsSet(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::optional_ref</ Variable, false /> mut this_,
		FunctionsSet& functions_set,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		FilePos& file_pos ) : Value;

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::optional_ref</ Variable, false />& this_,
		FunctionVariable& function,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		FilePos& file_pos ) : Value;

	enum ArgsEvaluationOrder{ Direct, Reversed }

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		FunctionVariable& function,
		ust::array_view_imut</ Variable />& preevaluated_args,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		ArgsEvaluationOrder args_evaluation_order,
		FilePos& file_pos ) : Value;

	fn BuildTempVariableConstruction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Type& t,
		ust::vector</ ust::shared_ptr_final</Synt::Expression/> />& args,
		FilePos& file_pos ) : Value;

	// Templates
	fn BuiltTypeTemplatesSet(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr );

	fn PrepareTypeTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::TypeTemplate/>& type_template_syntax_element,
		TypeTemplatesSet &mut out_templates_set );

	fn PrepareFunctionTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template_syntax_element,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionTemplatePtr;

	fn PrepareTemplateParams(
		mut this,
		NamesScopePtr& names_scope,
		ust::vector</Synt::TemplateParam/>& in_params ) : ust::vector</ TemplateBase::Param />;

	fn FillVariableTemplateParamsTypes(
		mut this,
		NamesScopePtr& names_scope,
		ust::vector</Synt::TemplateParam/>& in_params,
		ust::vector</TemplateBase::Param/> &mut template_params,
		ust::vector</bool/> &mut template_params_usage_flags );

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::Expression& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::ComplexName& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::TypeName& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::ArrayType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::TupleType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::vector</TemplateBase::Param/>& template_params,
		Synt::FunctionType& signature_param,
		ust::vector</bool/> &mut template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam( mut this, NamesScopePtr& names_scope, Value& value, FilePos& file_pos ) : TemplateSignatureParam;

	fn GenTemplateType(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
		Synt::TemplateArgs& template_args,
		FilePos& template_instantiation_file_pos ) : ust::optional</Type/>;

	struct TemplateTypeArgsEvaluationResult
	{
		TypeTemplatePtr type_template;
		NamesScopeMutPtr args_names_scope; // Where we place template arguments
		TemplateArgsFinished signature_args;
	}

	fn EvaluateTemplateTypeArgs(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		TypeTemplatePtr& type_template_ptr,
		Synt::TemplateArgs& template_args,
		FilePos& template_instantiation_file_pos ) : ust::optional</TemplateTypeArgsEvaluationResult/>;

	fn FinishTypeTemplateGeneration(
		mut this,
		TemplateTypeArgsEvaluationResult& template_args_evaluation_result ) : ust::optional</Type/>;

	fn GenTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		ust::array_view_imut</FunctionType::Param/> mut args,
		bool first_arg_is_this,
		FilePos& file_pos ) : ust::optional</FunctionVariable/>;

	fn GenTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		TemplateArgsFinished& known_template_args,
		ust::array_view_imut</FunctionType::Param/> mut args,
		bool first_arg_is_this,
		FilePos& file_pos ) : ust::optional</FunctionVariable/>;

	fn FinishFunctionTemplateParametrization(
		mut this,
		ParametrizedFunctionTemplate& parametrized_function_template,
		FilePos& file_pos ) : ust::optional</FunctionVariable/>;

	fn FinishTemplateFunctionGeneration(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		NamesScopeMutPtr& result_names_scope,
		FilePos& file_pos ) : ust::optional</FunctionVariable/>;

	fn ParametrizeTemplateFunctions(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		FunctionsSet& functions_set,
		Synt::TemplateArgs& template_args,
		FilePos& file_pos ) : ust::optional</NamesScopeValue/>;

	// Returns true if ok
	fn MatchTemplateArgument(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam& param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TemplateParam& template_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TypeParam& type_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::VariableParam& variable_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::ArrayTypeParam& array_type_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TupleTypeParam& tuple_type_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::FunctionTypeParam& function_type_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::SpecializedTemplateParam& specialized_template_param,
		Value& given_arg,
		FilePos& file_pos ) : bool;

	fn TypeIsValidForTemplateVariableArgument( Type& t ) : bool;

	// Typeinfo
	fn BuildTypeinfo( mut this, Type& t, NamesScopePtr& root_namespace ) : Variable;
	fn GetTypeinfoPrototype( mut this, Type& t, NamesScopePtr& root_namespace ) : Variable;
	fn BuildFullTypeinfo( mut this, Type& t ) : Variable;
	fn CreateTypeinfoClass( this, NamesScopePtr& root_namespace, Type& src_type, ust::string8& name ) : ClassTypePtr;

	// Virtual stuff
	fn PrepareClassVirtualTable( this, ClassTypePtr& class_type_ptr );
	fn PrepareClassVirtualTableType( this, ClassTypePtr& class_type_ptr );

	fn BuildClassVirtualTable_r( this, ClassType& ancestor_class, ClassType& dst_class, LLVMValueRef dst_class_ptr_null_based ) : LLVMValueRef;
	fn BuildClassVirtualTable( this, ClassTypePtr& class_type_ptr );

	fn SetupVirtualTablePointers_r(
		this,
		LLVMValueRef this_,
		LLVMValueRef ptr_to_vtable_ptr,
		ClassType& class_type,
		FunctionContext &mut function_context );

	fn SetupVirtualTablePointers(
		this,
		LLVMValueRef this_,
		ClassTypePtr& class_type_ptr,
		FunctionContext &mut function_context );

	fn TryFetchVirtualFunction(
		this,
		Variable& this_,
		FunctionVariable& function,
		FunctionContext &mut function_context ) : tup[ Variable, LLVMValueRef ];

	// Overloading

	fn ApplyOverloadedFunction(
		FunctionsSet &mut functions_set,
		FunctionVariable mut function,
		NamesScopePtr& names_scope,
		FilePos& file_pos ) : bool;

	fn GetOverloadedFunction(
		mut this,
		FunctionsSet &'x functions_set,
		ust::array_view_imut</FunctionType::Param/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		FilePos& file_pos,
		bool produce_errors ) : ust::optional</FunctionVariable/>;

	fn GetOverloadedOperator(
		mut this,
		ust::array_view_imut</FunctionType::Param/> args,
		OverloadedOperator operator,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		FilePos& file_pos ) : ust::optional</FunctionVariable/>;

	// Returns index of more specialized or ~0s
	fn SelectMoreSpecializedTemplate(
		mut this,
		ust::array_view_imut</TypeTemplatePtr/> type_templates,
		size_type signature_args_to_check ) : size_type;

	// Methods generation

	fn TryGenerateDefaultConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyAssignmentOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructorPrototype( this, ClassTypePtr& class_type );
	fn TryGenerateDestructor( this, ClassTypePtr& class_type );

	fn BuildCopyConstructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, FilePos& file_pos );
	fn BuildCopyAssignmentOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, FilePos& file_pos );
	fn BuildDestructorPart( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef value, Type& t, FilePos& file_pos );
	fn BuildMembersDestructors( this, FunctionContext &mut function_context, LLVMValueRef value, ClassTypePtr& class_type );

	fn TryCallCopyConstructor(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef dst, LLVMValueRef src,
		ClassTypePtr& class_type,
		FilePos& file_pos );

	fn CallDestructorsForVariablesFrame( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variables_frame_index, FilePos& file_pos );
	fn CallDestructorsForTopVariablesFrame( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, FilePos& file_pos );
	fn CallDestructorsForAllVariablesFrames( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, FilePos& file_pos );
	fn CallDestructorsForLoopInnerVariables( this, NamesScopePtr& names_scope, FunctionContext &mut function_context, FilePos& file_pos );

	// Returns "false" if not complete.
	fn EnsureTypeComplete( mut this, Type& t ) : bool;

	fn GetFunctionWithSameType( FunctionsSet &'x mut functions_set, Type& function_type ) : ust::optional_ref</ FunctionVariable, true />'x';

	fn IsDefaultConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyAssignmentOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;

	fn GetFundamentalLLVMType( this, U_FundamentalType t ) : LLVMTypeRef;
	fn GetZeroGEPIndex( this ) : LLVMValueRef;
	fn CreateMoveToLLVMRegisterInstruction( Variable& variable, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateReferenceCast( this, LLVMValueRef ref, Type& src_type, Type& dst_type, FunctionContext& function_context ) : LLVMValueRef;

	fn CreateFieldGEP( this, LLVMValueRef value, ClassField& field, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateParentFieldGEP( this, LLVMValueRef value, ClassType::Parent& parent, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateBaseClassFieldGEP( this, LLVMValueRef value, FunctionContext& function_context ) : LLVMValueRef;

	fn MoveConstantToMemory( this, LLVMValueRef ptr, LLVMValueRef constant, FunctionContext& function_context );

	struct InstructionsState
	{
		LLVMValueRef current_block_last_instruction;
		LLVMValueRef alloca_block_last_instruction;
		LLVMBasicBlockRef current_block;
	}

	fn SaveInstructionsState( FunctionContext& function_context ) : InstructionsState;
	fn RestoreInstructionsState( FunctionContext &mut function_context, InstructionsState& state );

	// Dummy function context for places outside actual function.
	fn CreateGlobalFunctionContext( this ) : FunctionContext;

private:
	LLVMContextRef imut llvm_context_;
	LLVMTargetDataRef imut data_layout_;
	ConstexprFunctionEvaluator1 constexpr_function_evaluator_;

	struct FundamentalLLVMTypes
	{
		LLVMTypeRef  i8_;
		LLVMTypeRef  u8_;
		LLVMTypeRef i16_;
		LLVMTypeRef u16_;
		LLVMTypeRef i32_;
		LLVMTypeRef u32_;
		LLVMTypeRef i64_;
		LLVMTypeRef u64_;
		LLVMTypeRef i128_;
		LLVMTypeRef u128_;

		LLVMTypeRef f32_;
		LLVMTypeRef f64_;

		LLVMTypeRef char8_ ;
		LLVMTypeRef char16_;
		LLVMTypeRef char32_;

		LLVMTypeRef void_;
		LLVMTypeRef void_for_ret_;
		LLVMTypeRef invalid_type_;
		LLVMTypeRef bool_;

		LLVMTypeRef int_ptr; // Type with width of pointer.
	}
	FundamentalLLVMTypes fundamental_llvm_types_= zero_init;

	Type invalid_type_;
	Type void_type_;
	Type void_type_for_ret_;
	Type bool_type_;
	Type size_type_; // Alias for u32 or u64

	LLVMModuleRef module_= LLVMModuleRef::Null;

	LLVMValueRef global_llvm_function_= LLVMValueRef::Null; // For global function context

	struct SourceGraphNodeBuildResult
	{
		ust::shared_ptr_nullable_imut</NamesScope/> names_scope;
		ust::unordered_map</ ClassTypePtr, ClassType /> class_table;
	}
	ust::vector</ SourceGraphNodeBuildResult /> compiled_sources_cache_;

	// Class table of current source graph node.
	ust::vector</ ClassTypePtr /> current_class_table_;

	ust::unordered_map</ ust::string8, NamesScopePtr /> generated_template_things_;

	// TODO - use unorederd_map
	struct TypeinfoStruct{ Type t; Variable v; }
	ust::vector</TypeinfoStruct/> typeinfo_cache_;

	LLVMValueRef halt_function_= LLVMValueRef::Null;
}

} // namespace U
