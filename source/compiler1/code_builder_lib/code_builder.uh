import "../lex_synt_lib/source_graph.uh"
import "/code_builder_errors.uh"
import "constexpr_function_evaluator.uh"
import "debug_info_builder.uh"
import "function_context.uh"
import "mangling.uh"
import "references_graph.uh"
import "tbaa_metadata_builder.uh"

// Macro for loops generation.
// TODO - use Function instead.
// Use "counter_value" in loop block
?macro <? CB_GENERATE_LOOP:block( ?function_context:expr, ?iteration_count:expr, ?b:block )?>
->
<?
	if( ?function_context.is_functionless_context )
	{
		auto counter_value= unsafe( LLVMConstNull( fundamental_llvm_types_.int_ptr ) );
		?b
	}
	else if( ?iteration_count != 0u64 )
	{
		unsafe
		{
			auto zero_value= LLVMConstNull( fundamental_llvm_types_.int_ptr );
			auto one_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, 1u64, LLVMBool::False );
			auto loop_count_value= LLVMConstInt( fundamental_llvm_types_.int_ptr, ?iteration_count, LLVMBool::False );

			auto block_before_loop= LLVMGetInsertBlock( ?function_context.llvm_ir_builder ) ;
			auto loop_block= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );
			auto block_after_loop= LLVMCreateBasicBlockInContext( llvm_context_, "\0"[0] );

			LLVMBuildBr( ?function_context.llvm_ir_builder, loop_block );

			LLVMAppendExistingBasicBlock( ?function_context.llvm_function, loop_block );
			LLVMPositionBuilderAtEnd( ?function_context.llvm_ir_builder, loop_block );

			auto counter_value= LLVMBuildPhi( ?function_context.llvm_ir_builder, fundamental_llvm_types_.int_ptr, "\0"[0] );
			auto counter_value_plus_one= LLVMBuildAdd( ?function_context.llvm_ir_builder, counter_value, one_value, "\0"[0] );

			safe{ ?b }

			auto counter_test= LLVMBuildICmp( ?function_context.llvm_ir_builder, LLVMIntPredicate::ULT, counter_value_plus_one, loop_count_value, "\0"[0] );
			LLVMBuildCondBr( ?function_context.llvm_ir_builder, counter_test, loop_block, block_after_loop );

			var [ LLVMValueRef, 2 ] mut incoming_values[ zero_value, counter_value_plus_one ];
			var [ LLVMBasicBlockRef, 2 ] mut incoming_blocks[ block_before_loop, LLVMGetInsertBlock( ?function_context.llvm_ir_builder ) ];
			LLVMAddIncoming( counter_value, $<(incoming_values[0]), $<(incoming_blocks[0]), 2u );

			LLVMAppendExistingBasicBlock( ?function_context.llvm_function, block_after_loop );
			LLVMPositionBuilderAtEnd( ?function_context.llvm_ir_builder, block_after_loop );
		}
	}
?>

namespace U1
{

type GlobalThingsStack= ust::vector</NamesScopeValue/>;
type GlobalThingsStackPtr= ust::shared_ptr_mut</GlobalThingsStack/>;

// This enum must match same enum in Compiler0 code!
enum ManglingScheme
{
	ItaniumABI,
	MSVC, // Auto-select 32-bit or 64-bit scheme.
	MSVC32,
	MSVC64,
}

struct CodeBuilderOptions
{
	bool build_debug_info= false;
	bool create_lifetimes= true;
	bool generate_lifetime_start_end_debug_calls= false;
	bool generate_tbaa_metadata= false;
	bool report_about_unused_names= true;
	ManglingScheme mangling_scheme= ManglingScheme::ItaniumABI;
}

class CodeBuilder
{
public:
	// llvm context, data layout should live longer, than this class.
	fn constructor(
		LLVMContextRef llvm_context,
		LLVMTargetDataRef data_layout,
		ust::string8 target_triple_str, // should be null-terminated
		CodeBuilderOptions& options );

	struct BuildResult
	{
		ust::vector</CodeBuilderError/> errors;
		LLVMModuleRef llvm_module;
	}

	fn BuildProgram( mut this, SourceGraph& source_graph ) : BuildResult;

private:
	fn BuildSourceGraphNode( mut this, SourceGraph& source_graph, size_type node_index );

	//
	// Resolving
	//

	fn NamesScopeValueToValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, NamesScopeValue& names_scope_value, SrcLoc& src_loc ) : Value;
	fn ResolveValue( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : Value;

	fn ResolveValueInternal( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& complex_name ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NameLookup& name_lookup ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RootNamespaceNameLookup& root_namespace_name_lookup ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NamesScopeNameFetch& names_scope_fetch ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TemplateParametrization& template_parametrization ) : ust::optional</NamesScopeValue/>;
	fn ResolveValueImpl( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeof& typeof_ ) : ust::optional</NamesScopeValue/>;

	fn BuildGlobalThingDuringResolveIfNecessary( mut this, NamesScopePtr& names_scope, NamesScopeValue& value );

	// Value with scope where it was found.
	type NameLookupResult= ust::optional</tup[NamesScopePtr, NamesScopeValue]/>;

	fn LookupName( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::string8& name, SrcLoc& src_loc ) : NameLookupResult;

	// Returns value itself, visibility label, namespace of class where this value was found (class itself or one of parents).
	fn ResolveClassValue(
		mut this,
		ClassTypePtr& class_type,
		ust::string8& name ) : ust::optional</ tup[ NamesScopeValue, Synt::ClassVisibility, NamesScopePtr ] />;
	fn ResolveClassValueImpl(
		mut this,
		ClassTypePtr& class_type,
		ust::string8& name,
		bool recursive_call ) : ust::optional</ tup[ NamesScopeValue, Synt::ClassVisibility, NamesScopePtr ] />;

	//
	// NamesScope-related functions
	//

	fn FillGlobalNamesScope( this, NamesScope &mut names_scope );

	fn NamesScopeMerge(
		NamesScopeMutPtr& dst_ptr,
		NamesScope& src,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table );

	fn DeepCopyNamesScopeValue(
		NamesScopeValue& value,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue(
		ClassTypePtr& class_type,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue(
		NamesScopeMutPtr& namespace_,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table ) : NamesScopeValue;

	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Type/>& t ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</Variable/>& variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</FunctionsSet/>& functions_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</ClassField/>& class_field ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( EnumTypePtr& enum_type ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeAlias/>& type_alias ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</TemplateArg/>& template_arg ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalVariable/>& global_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable ) : NamesScopeValue;
	fn DeepCopyNamesScopeValue( ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts ) : NamesScopeValue;

	fn NamesScopeMergeValues(
		NamesScopeValue& dst,
		NamesScopeValue& src,
		ust::string8& name,
		NamesScopePtr& target_names_scope,
		ClassesMembersNamespacesTable& src_classes_members_namespaces_table );

	fn GetValueSrcLoc( NamesScopeValue& value ) : SrcLoc; // Get src_loc or empty value

	fn NamesScopeFillClass( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::ClassElements& class_elements, ClassTypePtr& class_type );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Function/>& function, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Enum/>& enum_, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::TypeTemplate/>& type_template, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::VariablesDeclaration/>& variables_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::AutoVariableDeclaration/>& auto_variable_declaration, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::StaticAssert/>& static_asert, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Namespace/>& namespace_ );
	fn NamesScopeFill( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::ClassField/>& class_field, ust::shared_ptr_nullable_mut</ClassType/>& class_type, Synt::ClassVisibility visibility, u32 field_index );
	fn NamesScopeFillOutOfLineElements( this, NamesScopePtr& names_scope_ptr, Synt::NamespaceElements& namespace_elements );
	fn NamesScopeAddClass( mut this, NamesScopeMutPtr& names_scope_ptr, ust::shared_ptr_final</Synt::Class/>& class_ ) : ust::shared_ptr_nullable_mut</ClassType/>;

	fn NamesScopeBuild( mut this, NamesScopePtr& names_scope_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</NamesScope/>& namespace_ );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Type/>& t );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Variable/>& variable );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassType/>& class_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</ClassField/>& class_field );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</Enum/>& enum_type );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TemplateArg/>& template_arg );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );
	fn NamesScopeBuildElement( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalStaticAssertsSet/>& global_static_asserts_set_ptr );

	// Global things build.

	fn DetectGlobalsLoop( this, NamesScopeValue& global_thing ) : bool;

	fn BuildFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/> functions_set, bool build_body );
	fn PrepareClassParentsList( mut this, ClassTypePtr& class_type );
	fn BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type );
	fn BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type );
	fn BuildTypeAlias( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr );
	fn BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr );
	fn BuildGlobalVariable( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr );
	fn BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr );

	// Returns "true" if ok.
	fn PrepareFunction(
		mut this,
		ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
		NamesScopePtr& names_scope_ptr,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionsSet &mut functions_set,
		bool is_out_of_line_function ) : bool;

	fn CheckOverloadedOperator(
		this,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type,
		FunctionType& func_type,
		OverloadedOperator operator,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc );

	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ArrayType& array_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TupleType& tuple_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::RawPointerType/>& raw_pointer_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerType& raw_pointer_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type_ptr ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::GeneratorType/>& generator_type_ptr ) : Type;
	fn PrepareType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::GeneratorType& generator_type ) : Type;
	fn PrepareFunctionType( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::FunctionType& function_type, ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionType;
	fn GetLLVMFunctionType( mut this, FunctionType& function_type ) : LLVMTypeRef;

	fn FunctionTypeToPointer( mut this, FunctionType function_type ) : FunctionPointerType;

	fn GetLLVMCallingConvention(
		this,
		ust::optional</ust::string8/>& calling_convention_name,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc ) : LLVMCallConvID;

	// Requires return type to be complete.
	fn FunctionTypeIsSRet( FunctionType& function_type ) : bool;

	// Returns scalar type, if this is a scalar type of a composite type, containing (recursively) such type.
	// Returns null otherwise.
	// Requires type to be complete.
	fn GetSingleScalarType( LLVMTypeRef t ) : LLVMTypeRef;

	// Returns constant value if initializer is contant
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::Initializer& initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::EmptyVariant& empty_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::Expression& expression_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::SequenceInitializer& sequence_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::StructNamedInitializer& struct_named_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::ConstructorInitializer& constructor_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::ZeroInitializer& zero_initializer ) : LLVMValueRef;
	fn BuildInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptre, Synt::UninitializedInitializer& uninitialized_initializer ) : LLVMValueRef;
	fn BuildEmptyInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, ust::string8& variable_name, SrcLoc& src_loc ) : LLVMValueRef;
	fn BuildConstructorInitializer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> /> args, SrcLoc& src_loc )  : LLVMValueRef;

	fn InitializeFunctionPointer( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, Synt::Expression& initializer_expression ) : LLVMValueRef;

	fn InitializeReferenceField( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, VariablePtr& variable_ptr, ClassField& field, Synt::Initializer& initializer ) : LLVMValueRef;

	fn BuildConstructorInitialization(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Synt::StructNamedInitializer& constructor_initialization_list );

	fn CheckClassFieldsInitializers( mut this, ClassTypePtr& class_type );

	fn BuildFuncCode( mut this, NamesScopePtr& names_scope_ptr, FunctionVariable &mut func_variable );

	struct BlockElementBuildInfo
	{
		bool have_terminal_instruction_inside= false;
	}

	fn BuildBlockElements( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, ust::array_view_imut</Synt::BlockElement/>& elements ) : BlockElementBuildInfo;
	fn BuildBlock( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;

	fn BuildIfAlternative( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfAlternative& if_alternative ) : BlockElementBuildInfo;

	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Block& block ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ScopeBlock/>& scope_block_ptr ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::VariablesDeclaration& variables_declaration ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, Synt::AutoVariableDeclaration& auto_variable_declaration ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReturnOperator& return_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::YieldOperator& yield_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AssignmentOperator& assignment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::AdditiveAssignmentOperator& additive_assignment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IncrementOperator& increment_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::DecrementOperator& decrement_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfOperator& if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticIfOperator& static_if_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IfCoroAdvanceOperator& if_coro_advance_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SwitchOperator& switch_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WhileOperator& while_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LoopOperator& loop_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RangeForOperator& range_for_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CStyleForOperator& c_style_for_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BreakOperator& break_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ContinueOperator& continue_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::WithOperator& with_operator ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StaticAssert& static_assert_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopeMutPtr& names_scope, FunctionContext &mut function_context, ust::shared_ptr_final</Synt::TypeAlias/>& type_alias_ptr ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Halt& halt_ ) : BlockElementBuildInfo;
	fn BuildBlockElement( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::HaltIf& halt_if ) : BlockElementBuildInfo;

	fn BuildEmptyReturn( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );

	fn AddLoopFrame(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMBasicBlockRef break_block,
		LLVMBasicBlockRef continue_block,
		ust::optional</Synt::Label/>& label_ );

	// Returns index or ~0 if not found.
	fn FetchLoopFrame(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::optional</Synt::Label/>& label_ ) : size_type;

	fn BuildDeltaOneOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc, i32 delta );

	fn BuildExpressionCodeEnsureVariable( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : VariablePtr;

	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::EmptyVariant& empty_variant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NumericConstant& numeric_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BooleanConstant& boolean_constant ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::StringLiteral& string_literal ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ComplexName& named_operand ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Typeinfo& typeinfo_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NonSyncExpression& non_sync_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRef& cast_ref_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastRefUnsafe& cast_ref_unsafe_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastImut& cast_imut_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CastMut& cast_mut_ ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::SafeExpression& safe_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnsafeExpression& unsafe_expression ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MoveOperator& move_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TakeOperator& take_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TernaryOperator& ternary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::ReferenceToRawPointerOperator& reference_to_raw_pointer_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::RawPointerToReferenceOperator& raw_pointer_to_reference_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::IndexationOperator& indexation_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::CallOperator& call_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::MemberAccessOperator& member_access_operator ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryPlus& unary_plus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::UnaryMinus& unary_minus ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::LogicalNot& logical_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BitwiseNot& bitwise_not ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::ArrayType/>& array_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::TupleType/>& tuple_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::RawPointerType/>& raw_pointer_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::FunctionType/>& function_type ) : Value;
	fn BuildExpressionCode( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, ust::box</Synt::GeneratorType/>& generator_type ) : Value;

	fn DoReferenceCast( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::TypeName& type_name, Synt::Expression& expression, SrcLoc& src_loc, bool allow_unsafe ) : Value;

	fn AccessClassBase( mut this, NamesScopePtr& names_scope, FunctionContext& mut function_context, VariablePtr& variable_ptr, SrcLoc& src_loc ) : VariablePtr;
	fn AccessClassField(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& variable_ptr,
		ClassField& field,
		ust::string8& field_name,
		SrcLoc& src_loc ) : Value;

	fn AccessDirectClassField(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& variable_ptr,
		ClassField& field,
		ust::string8& field_name,
		SrcLoc& src_loc ) : VariablePtr;

	fn BuildBinaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariableLite& l_var,
		VariableLite& r_var,
		BinaryOperatorType operator,
		SrcLoc& src_loc ) : Value;
	fn BuildLazyBinaryOperator( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::BinaryOperator& binary_operator ) : Value;

	fn TryCallOverloadedBinaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		ArgsEvaluationOrder args_evaluation_order,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn CallBinaryOperatorForArrayOrTuple(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		ust::shared_ptr_final</Synt::Expression/>& arg_l,
		ust::shared_ptr_final</Synt::Expression/>& arg_r,
		SrcLoc& src_loc ) : Value;

	fn TryCallOverloadedUnaryOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		VariablePtr& variable_ptr,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn TryCallOverloadedPostfixOperator(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		OverloadedOperator operator,
		VariablePtr& variable,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& synt_args,
		SrcLoc& src_loc ) : ust::optional</Value/>;

	fn CallFunctionsSet(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariableNullablePtr this_,
		FunctionsSetPtr& functions_set,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariableNullablePtr& this_,
		FunctionType& function_type,
		LLVMValueRef function,
		bool is_constexpr,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		SrcLoc& src_loc ) : Value;

	enum ArgsEvaluationOrder{ Direct, Reversed }

	fn DoCallFunction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		FunctionType& function_type,
		LLVMValueRef function,
		bool is_constexpr,
		ust::array_view_imut</ VariablePtr />& preevaluated_args,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> />& args,
		ArgsEvaluationOrder args_evaluation_order,
		SrcLoc& src_loc ) : Value;

	fn BuildTempVariableConstruction(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		Type& t,
		ust::array_view_imut</ ust::shared_ptr_final</Synt::Expression/> /> args,
		SrcLoc& src_loc ) : Value;

	fn ConvertVariable(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& src,
		Type& dst_type,
		FunctionVariable& conversion_constructor_,
		SrcLoc& src_loc ) : VariablePtr;

	fn EvaluateBoolConstantExpression( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression ) : bool;

	// NonSync stuff

	fn GetTypeNonSync( mut this, Type& t, NamesScopePtr& names_scope, SrcLoc& src_loc ) : bool;
	fn GetTypeNonSyncImpl( mut this, ust::vector</Type/> &mut prev_types_stack, Type& t, NamesScopePtr& names_scope, SrcLoc& src_loc ) : bool;
	fn ImmediateEvaluateNonSyncTag( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::NonSyncTag& non_sync_tag ) : bool;
	fn CheckClassNonSyncTagExpression( mut this, ClassTypePtr& class_type );
	fn CheckClassNonSyncTagInheritance( mut this, ClassTypePtr& class_type );

	// Templates
	fn PrepareTypeTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::TypeTemplate/>& type_template_syntax_element,
		TypeTemplatesSet &mut out_templates_set );

	fn PrepareFunctionTemplate(
		mut this,
		NamesScopePtr& names_scope,
		ust::shared_ptr_final</Synt::FunctionTemplate/>& function_template_syntax_element,
		ust::shared_ptr_nullable_mut</ClassType/>& class_type ) : FunctionTemplatePtr;

	fn PrepareTemplateParams(
		mut this,
		NamesScopePtr& names_scope,
		ust::array_view_imut</Synt::TemplateParam/> in_params ) : ust::vector</ TemplateBase::Param />;

	fn FillVariableTemplateParamsTypes(
		mut this,
		NamesScopePtr& names_scope,
		ust::array_view_imut</Synt::TemplateParam/> in_params,
		ust::array_view_mut</TemplateBase::Param/> template_params,
		ust::array_view_mut</bool/> template_params_usage_flags );

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::Expression& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::ComplexName& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::TypeName& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::ArrayType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::TupleType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::RawPointerType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::FunctionType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		ust::array_view_imut</TemplateBase::Param/> template_params,
		Synt::GeneratorType& signature_param,
		ust::array_view_mut</bool/> template_params_usage_flags ) : TemplateSignatureParam;

	fn CreateTemplateSignatureParam( mut this, NamesScopePtr& names_scope, Value& value, SrcLoc& src_loc ) : TemplateSignatureParam;

	fn GenTemplateType(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr,
		Synt::TemplateArgs& template_args,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>;

	struct TemplateTypeArgsEvaluationResult
	{
		TypeTemplatePtr type_template;
		NamesScopeMutPtr args_names_scope; // Where we place template arguments
		TemplateArgsFinished signature_args;
	}

	fn EvaluateTemplateTypeArgs(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		TypeTemplatePtr& type_template_ptr,
		Synt::TemplateArgs& template_args,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</TemplateTypeArgsEvaluationResult/>;

	fn FinishTypeTemplateGeneration(
		mut this,
		TemplateTypeArgsEvaluationResult& template_args_evaluation_result,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& template_instantiation_src_loc ) : ust::optional</Type/>;

	fn GenTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		ust::array_view_imut</VariableTypeExtended/> mut args,
		bool first_arg_is_this,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn GenTemplateFunction(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		TemplateArgsFinished& known_template_args,
		ust::array_view_imut</VariableTypeExtended/> mut args,
		bool first_arg_is_this,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn FinishFunctionTemplateParametrization(
		mut this,
		ParametrizedFunctionTemplate& parametrized_function_template,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn FinishTemplateFunctionGeneration(
		mut this,
		FunctionTemplatePtr& function_template_ptr,
		NamesScopeMutPtr& result_names_scope,
		NamesScopePtr& instantiation_point_names_scope,
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn ParametrizeTemplateFunctions(
		mut this,
		NamesScopePtr& args_names_scope,
		FunctionContext &mut function_context,
		FunctionsSet& functions_set,
		ust::shared_ptr_nullable_mut</ClassType/> functions_set_class,
		Synt::TemplateArgs& template_args,
		SrcLoc& src_loc ) : ust::optional</NamesScopeValue/>;

	// Returns true if ok
	fn MatchTemplateArgument(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam& param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TemplateParam& template_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TypeParam& type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::VariableParam& variable_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::ArrayTypeParam& array_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::TupleTypeParam& tuple_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::RawPointerTypeParam& raw_pointer_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::FunctionTypeParam& function_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::CoroutineTypeParam& coroutine_type_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn MatchTemplateArgumentImpl(
		mut this,
		NamesScopePtr& names_scope,
		TemplateBase& template_,
		TemplateSignatureParam::SpecializedTemplateParam& specialized_template_param,
		TemplateArgFinished& given_arg,
		SrcLoc& src_loc ) : bool;

	fn FillKnownFunctionTemplateArgsIntoNamespace(
		mut this,
		FunctionTemplate& function_template,
		TemplateArgsFinished& known_template_args,
		NamesScopeMutPtr& target_namespace );

	fn AddNewTemplateThing( mut this, ust::string8 mut key, NamesScopePtr& thing );

	fn TypeIsValidForTemplateVariableArgument( Type& t ) : bool;

	// Typeinfo
	fn BuildTypeinfo( mut this, Type& t, NamesScopePtr& root_namespace ) : VariablePtr;
	fn GetTypeinfoPrototype( mut this, Type& t, NamesScopePtr& root_namespace ) : VariablePtr;
	fn BuildFullTypeinfo( mut this, Type& t ) : VariablePtr;

	fn CreateTypeinfoClass( mut this, NamesScopePtr& root_namespace, Type& src_type, ust::string8& name ) : ClassTypePtr;
	fn FinishTypeinfoClass( mut this, ClassTypePtr& typeinfo_class, ust::array_view_imut</LLVMTypeRef/> fields_llvm_types );

	fn BuildTypeinfoTupleElementsList( mut this, NamesScopePtr& root_namespace, TupleType& tuple_type ) : VariableLite;
	fn BuildTypeinfoFunctionParamsList( mut this, NamesScopePtr& root_namespace, FunctionType& function_type ) : VariableLite;
	fn BuildTypeinfoClassFieldsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariableLite;
	fn BuildTypeinfoClassFunctionsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariableLite;
	fn BuildTypeinfoClassTypesList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariableLite;
	fn BuildTypeinfoClassParentsList( mut this, NamesScopePtr& root_namespace, ClassTypePtr& class_type ) : VariableLite;
	fn BuildTypeinfoEnumElementsList( mut this, NamesScopePtr& root_namespace, EnumTypePtr& enum_type ) : VariableLite;

	// Virtual stuff
	fn CheckvirtualFunctionOverridingReferenceNotation(
		this,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc,
		FunctionVariable& src_function,
		FunctionVariable& new_function,
		ClassType& new_class_type );
	fn PrepareClassVirtualTable( this, ClassTypePtr& class_type_ptr );
	fn PrepareClassVirtualTableType( mut this, ClassTypePtr& class_type_ptr );

	fn BuildClassPolymorphTypeId( mut this, ClassTypePtr& class_type_ptr );
	fn BuildClassVirtualTable_r( mut this, ClassType& ancestor_class, ClassType& dst_class, u64 offset ) : LLVMValueRef;
	fn BuildClassVirtualTable( mut this, ClassTypePtr& class_type_ptr );

	fn SetupVirtualTablePointers_r(
		mut this,
		LLVMValueRef this_,
		LLVMValueRef ptr_to_vtable_ptr,
		ClassType& class_type,
		FunctionContext &mut function_context );

	fn SetupVirtualTablePointers(
		mut this,
		LLVMValueRef this_,
		ClassTypePtr& class_type_ptr,
		FunctionContext &mut function_context );

	fn TryFetchVirtualFunction(
		mut this,
		VariablePtr& this_ptr,
		FunctionVariable& function,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		SrcLoc& src_loc ) : tup[ VariablePtr, LLVMValueRef ];

	// Overloading

	fn GetFunctionWithSameType( FunctionsSet &'x mut functions_set, FunctionType& function_type ) : ust::optional_ref_mut</ FunctionVariable />'x';

	fn ApplyOverloadedFunction(
		FunctionsSet &mut functions_set,
		FunctionVariable mut function,
		NamesScopePtr& names_scope,
		SrcLoc& src_loc ) : bool;

	fn GetOverloadedFunctionImpl(
		mut this,
		FunctionsSet& functions_set,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc,
		bool allow_type_conversions,
		bool produce_errors ) : ust::optional</FunctionVariable/>;

	fn GetOverloadedFunction(
		mut this,
		FunctionsSet& functions_set,
		ust::array_view_imut</VariableTypeExtended/> actual_args,
		bool first_actual_arg_is_this,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn GetOverloadedOperator(
		mut this,
		ust::array_view_imut</VariableTypeExtended/> args,
		OverloadedOperator operator,
		NamesScopePtr& names_scope, // Needed only for errors reporting
		SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	fn GetConversionConstructor( mut this, NamesScopePtr& names_scope, Type& dst, Type& src, SrcLoc& src_loc ) : ust::optional</FunctionVariable/>;

	// Returns index of more specialized or ~0s
	fn SelectMoreSpecializedTemplate(
		mut this,
		ust::array_view_imut</TypeTemplatePtr/> type_templates,
		size_type signature_args_to_check ) : size_type;

	// Coroutines
	fn GetGeneratorFunctionReturnType( mut this, NamesScopePtr& root_namespace, FunctionType& generator_function_type, bool non_sync_ )  : ClassTypePtr;
	fn GetGeneratorFunctionReturnReferences( mut this, FunctionType& generator_function_type ) : ust::vector</FunctionType::ParamReference/>;

	fn GetCoroutineType( mut this, NamesScopePtr& root_namespace, CoroutineTypeDescription& coroutine_type_description ) : ClassTypePtr;

	// This function should be called for generator function just after aruments preparation.
	fn PrepareGeneratorBlocks( this, FunctionContext &mut function_context );
	fn GeneratorYield( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, Synt::Expression& expression, SrcLoc& src_loc );
	fn GeneratorSuspend( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn GeneratorFinalSuspend( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );

	// Methods generation

	fn TryGenerateDefaultConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyConstructor( mut this, ClassTypePtr& class_type );
	fn TryGenerateCopyAssignmentOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateEqualityCompareOperator( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructorPrototype( mut this, ClassTypePtr& class_type );
	fn TryGenerateDestructor( mut this, ClassTypePtr& class_type );

	// Sets "constexpr" flag for method and checks for errors.
	fn ProcessGeneratedMethodConstexprFlag( ClassTypePtr& class_type, FunctionContext& function_context_after_body_generation, FunctionVariable &mut method );

	fn BuildCopyConstructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc );
	fn BuildCopyAssignmentOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc );
	fn BuildEqualityCompareOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef l_address, LLVMValueRef r_address, Type& t, LLVMBasicBlockRef false_basic_block, SrcLoc& src_loc );
	fn BuildDestructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef value, Type& t, SrcLoc& src_loc );
	fn BuildMembersDestructors( mut this, FunctionContext &mut function_context, LLVMValueRef value, ClassTypePtr& class_type );

	fn TryCallCopyConstructor(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef dst, LLVMValueRef src,
		ClassTypePtr& class_type,
		SrcLoc& src_loc );

	// Unused name error generation stuff.
	fn CheckForUnusedGlobalNames( this, NamesScopePtr& names_scope );
	fn CheckForUnusedLocalNames( this, NamesScopePtr& names_scope );
	fn VariableExistanceMayHaveSideEffects( Type& variable_type ) : bool;

	fn CallDestructorsForVariablesFrame( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variables_frame_index, SrcLoc& src_loc );
	fn CallDestructorsForTopVariablesFrame( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CallDestructorsForAllVariablesFrames( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc );
	fn CallDestructorsForLoopInnerVariables( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variable_frames_stack_size, SrcLoc& src_loc );

	fn DestroyUnusedTemporaryVariables( mut this, NamesScopePtr& names_scope, FunctionContext& mut function_context, SrcLoc& src_loc );

	fn RegisterTemporaryVariable( FunctionContext& mut function_context, VariablePtr variable );
	fn RegisterTopFrameVariable( FunctionContext& mut function_context, VariablePtr variable );
	fn RegisterFrameVariable( FunctionContext& mut function_context, VariablePtr variable, size_type frame_index_from_top );

	fn IsReferenceAllowedForReturn( this, FunctionContext& function_context, VariablePtr& variable_node ) : bool;
	fn CheckReferencesPollutionBeforeReturn( this, NamesScopePtr& names_scope, FunctionContext& function_context, SrcLoc& src_loc );

	fn MergeReferencesGraphsAfterConditionalBranches( ust::array_view_imut</ReferencesGraph/> branches, NamesScopePtr names_scope, SrcLoc& src_loc ) : ReferencesGraph; // TODO - rename
	fn CheckReferencesGraphAfterLoop( ReferencesGraph& state_before, ReferencesGraph& state_after, NamesScopePtr names_scope, SrcLoc& src_loc );

	fn SetupReferencesInCopyOrMove(
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		VariablePtr& dst_node,
		VariablePtr& src_node,
		SrcLoc& src_loc );

	// Returns "false" if not complete.
	fn IsTypeComplete( this, Type& t ) : bool;
	fn EnsureTypeComplete( mut this, Type& t ) : bool;

	fn IsDefaultConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsCopyAssignmentOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;
	fn IsEqualityCompareOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool;

	fn AddGlobalConstantVariable( this, ust::string8& name_null_terminated, LLVMTypeRef llvm_type, LLVMValueRef initializer ) : LLVMValueRef;
	fn AddGlobalMutableVariable( this, ust::string8& name_null_terminated, LLVMTypeRef llvm_type, bool externally_available ) : LLVMValueRef;

	fn GetAttributeKindByName( ust::string_view8 attr_name ) : u32;
	fn AddFunctionAttribute( this, LLVMValueRef llvm_function, u32 index, ust::string_view8 attr_name );
	fn AddFunctionTypeAttribute( this, LLVMValueRef llvm_function, u32 index, ust::string_view8 attr_name, LLVMTypeRef t );

	// Creates LLVM function and its LLVM type lazily. This call may trigger types competion.
	fn EnsureLLVMFunctionCreated( mut this, FunctionVariable& function_variable ) : LLVMValueRef;

	fn SetupFunctionParamsAndRetAttributes( mut this, FunctionVariable& mut function_variable );
	// Requires complete types
	fn SetupDereferenceableFunctionParamsAndRetAttributes( this, FunctionVariable& mut function_variable );

	fn SetupDereferenceableFunctionParamsAndRetAttributes_r( this, NamesScope& names_scope );

	fn IsGlobalVariable( VariablePtr& variable ) : bool;

	fn MarkInstructionWithTBAAMetadata( this, LLVMValueRef instruction, LLVMMetadataRef metadata );
	fn MarkLoadInstructionWithNonNullMetadata( this, LLVMValueRef load_instruction );

	fn CreateTypedLoad( mut this, FunctionContext& function_context, Type& t, LLVMValueRef address ) : LLVMValueRef;
	fn CreateTypedReferenceLoad( mut this, FunctionContext& function_context, Type& t, LLVMValueRef address ) : LLVMValueRef;
	fn CreateTypedStore( mut this, FunctionContext& function_context, Type& t, LLVMValueRef value_to_store, LLVMValueRef address );
	fn CreateTypedReferenceStore( mut this, FunctionContext& function_context, Type& t, LLVMValueRef value_to_store, LLVMValueRef address );

	fn GetFundamentalLLVMType( this, U_FundamentalType t ) : LLVMTypeRef;
	fn GetZeroGEPIndex( this ) : LLVMValueRef;
	fn CreateMoveToLLVMRegisterInstruction( mut this, VariableLite& variable, FunctionContext& function_context ) : LLVMValueRef;
	fn CreateReferenceCast( this, LLVMValueRef ref, Type& src_type, Type& dst_type, FunctionContext& function_context ) : LLVMValueRef;

	fn CreateClassFieldGEP( this, FunctionContext& function_context, VariableLite& class_variable, ClassField& field ) : LLVMValueRef;
	fn CreateClassFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value, ClassField& field ) : LLVMValueRef;
	fn CreateClassParentFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value, ClassType::Parent& parent ) : LLVMValueRef;
	fn CreateBaseClassFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value ) : LLVMValueRef;
	fn CreateTupleElementGEP( this, FunctionContext& function_context, VariableLite& tuple_variable, u32 element_index ) : LLVMValueRef;
	fn CreateTupleElementGEP( this, FunctionContext& function_context, TupleType& t, LLVMValueRef value, u32 element_index ) : LLVMValueRef;
	fn CreateArrayElementGEP( this, FunctionContext& function_context, ArrayType& t, LLVMValueRef value, u32 index ) : LLVMValueRef;
	fn CreateArrayElementGEP( this, FunctionContext& function_context, ArrayType& t, LLVMValueRef value, LLVMValueRef index ) : LLVMValueRef;
	fn CreateIndexValue( this, u32 index ) : LLVMValueRef;

	// Create GEP instruction even in functionless context.
	fn ForceCreateConstantIndexGEP( this, FunctionContext& function_context, LLVMTypeRef t, LLVMValueRef value, u32 index ) : LLVMValueRef;

	fn WrapRawScalarConstant( LLVMValueRef constant, LLVMTypeRef dst_type ) : LLVMValueRef;
	fn UnwrapRawScalarConstant( LLVMValueRef constant ) : LLVMValueRef;

	fn MoveConstantToMemory( this, LLVMValueRef ptr, LLVMValueRef constant, FunctionContext& function_context );

	fn CopyBytes( mut this, LLVMValueRef dst, LLVMValueRef src, Type& t, FunctionContext &mut function_context );

	fn ConstexprCompareEqual(
		mut this,
		NamesScopePtr& names_scope,
		FunctionContext &mut function_context,
		LLVMValueRef l,
		LLVMValueRef r,
		Type& t,
		SrcLoc& src_loc ) : LLVMValueRef;

	fn CreateLifetimeStart( this, FunctionContext &mut function_context, LLVMValueRef llvm_value );
	fn CreateLifetimeEnd( this, FunctionContext &mut function_context, LLVMValueRef llvm_value );

	fn GetIntrinsic( this, ust::string_view8 name, ust::array_view_imut</LLVMTypeRef/> types ) : LLVMValueRef;

	struct FunctionContextState
	{
		LLVMBasicBlockRef current_block;
		ReferencesGraph references_graph;
	}

	fn SaveFunctionContextState( FunctionContext& function_context ) : FunctionContextState;
	fn RestoreFunctionContextState( FunctionContext &mut function_context, FunctionContextState& state );

	// Dummy function context for places outside actual function.
	fn CreateGlobalFunctionContext( this ) : FunctionContext;

private:
	LLVMContextRef imut llvm_context_;
	LLVMTargetDataRef imut data_layout_;
	ust::string8 imut target_triple_str_; // null-terminated
	ConstexprFunctionEvaluator constexpr_function_evaluator_;
	bool imut generate_tbaa_metadata_;
	bool imut report_about_unused_names_;
	TBAAMetadataBuilder tbaa_metadata_builder_;
	ust::box</IMangler/> mangler_;

	struct FundamentalLLVMTypes
	{
		LLVMTypeRef invalid_type_;

		LLVMTypeRef void_;
		LLVMTypeRef bool_;

		LLVMTypeRef  i8_;
		LLVMTypeRef  u8_;
		LLVMTypeRef i16_;
		LLVMTypeRef u16_;
		LLVMTypeRef i32_;
		LLVMTypeRef u32_;
		LLVMTypeRef i64_;
		LLVMTypeRef u64_;
		LLVMTypeRef i128_;
		LLVMTypeRef u128_;

		LLVMTypeRef f32_;
		LLVMTypeRef f64_;

		LLVMTypeRef char8_ ;
		LLVMTypeRef char16_;
		LLVMTypeRef char32_;

		LLVMTypeRef byte8_  ;
		LLVMTypeRef byte16_ ;
		LLVMTypeRef byte32_ ;
		LLVMTypeRef byte64_ ;
		LLVMTypeRef byte128_;

		LLVMTypeRef void_for_ret_;

		LLVMTypeRef int_ptr; // Type with width of pointer.
	}
	FundamentalLLVMTypes fundamental_llvm_types_= zero_init;

	Type invalid_type_;
	Type void_type_;
	Type bool_type_;
	Type size_type_; // Alias for u32 or u64
	LLVMTypeRef virtual_function_pointer_type_= LLVMTypeRef::Null; // Use common type for all function pointers in virtual table - for simplicity.
	LLVMTypeRef polymorph_type_id_table_element_type_= LLVMTypeRef::Null;

	LLVMModuleRef module_= LLVMModuleRef::Null;

	LLVMValueRef global_llvm_function_= LLVMValueRef::Null; // For global function context

	ErrorsContainerPtr root_errors_container_;

	type ClassesMembersNamespacesTable= ust::unordered_map</ ClassTypePtr, ust::shared_ptr_imut</ NamesScope /> />;
	struct SourceGraphNodeBuildResult
	{
		ust::shared_ptr_nullable_imut</NamesScope/> names_scope;
		ClassesMembersNamespacesTable classes_members_namespaces_table;
	}
	ust::vector</ SourceGraphNodeBuildResult /> source_graph_nodes_build_results_;

	// Class table of current source graph node.
	ust::vector</ ClassTypePtr /> class_table_;

	// Store template things in global container to use same things for same template arguments.
	ust::unordered_map</ ust::string8, NamesScopePtr /> generated_template_things_;
	// Template things for current source graph node added sequentialy into this vector too.
	ust::vector</ ust::string8 /> generated_template_things_sequence_;

	ust::unordered_map</Type, VariablePtr /> typeinfo_cache_;
	ust::vector</ ClassTypePtr /> typeinfo_class_table_;

	// Maps string -> llvm::GlobalVariable
	tup[
		ust::unordered_map</ust::string8 , LLVMValueRef/>,
		ust::unordered_map</ust::string16, LLVMValueRef/>,
		ust::unordered_map</ust::string32, LLVMValueRef/> ]
		string_literals_cache_;

	LLVMValueRef halt_function_= LLVMValueRef::Null;

	LLVMValueRef malloc_function_= LLVMValueRef::Null;
	LLVMValueRef free_function_= LLVMValueRef::Null;

	// For globals loops detection.
	GlobalThingsStackPtr global_things_stack_ptr_;

	ust::vector</Type/> non_sync_expression_stack_;

	// Debug info
	bool imut build_debug_info_;
	ust::optional</DebugInfoBuilder/> debug_info_builder_;

	// Lifetimes.
	bool imut create_lifetimes_;
	bool imut generate_lifetime_start_end_debug_calls_;
	LLVMValueRef lifetime_start_intrinsic_= LLVMValueRef::Null;
	LLVMValueRef lifetime_end_intrinsic_= LLVMValueRef::Null;
	LLVMValueRef lifetime_start_debug_func_= LLVMValueRef::Null;
	LLVMValueRef lifetime_end_debug_func_= LLVMValueRef::Null;
	LLVMTypeRef lifetime_function_arg_type_= LLVMTypeRef::Null;

	// Coroutines
	struct Coro
	{
		LLVMValueRef id= LLVMValueRef::Null;
		LLVMValueRef alloc= LLVMValueRef::Null;
		LLVMValueRef free= LLVMValueRef::Null;
		LLVMValueRef size= LLVMValueRef::Null;
		LLVMValueRef begin= LLVMValueRef::Null;
		LLVMValueRef end= LLVMValueRef::Null;
		LLVMValueRef suspend= LLVMValueRef::Null;

		LLVMValueRef resume= LLVMValueRef::Null;
		LLVMValueRef destroy= LLVMValueRef::Null;
		LLVMValueRef done= LLVMValueRef::Null;
		LLVMValueRef promise= LLVMValueRef::Null;
	}
	Coro coro_;

	ust::unordered_map</ CoroutineTypeDescription, ClassTypePtr /> coroutine_classes_;
}

} // namespace U1
