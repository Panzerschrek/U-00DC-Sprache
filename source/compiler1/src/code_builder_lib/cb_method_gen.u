import "/assert.u"
import "/CodeBuilderLib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CodeBuilder::TryGenerateDefaultConstructor( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	auto& class_members= class_members_lock.deref();

	// Search for explicit default constructor.
	auto mut has_explicit_noncopy_constructors= false;

	// Constructors value should always exists and should always be FunctionsSet.
	auto constructors_ptr= class_members.GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).try_deref().Get</FunctionsSet/>();
	auto mut constructors_lock= constructors_ptr.try_lock_mut();
	var FunctionsSet &mut constructors= constructors_lock.deref();

	// Search for copy constructor.
	auto mut constructor_index= ~0s;
	for( auto mut i= 0s; i < constructors.functions.size(); ++i )
	{
		auto& constructor_= constructors.functions[i];
		if( IsDefaultConstructor( constructor_, class_type ) )
		{
			if( constructor_.is_generated )
			{
				constructor_index= i;
				break;
			}
			else
			{
				auto mut class_lock= class_type.lock_mut();
				class_lock.deref().is_default_constructible= !constructor_.is_deleted;
				return;
			}
		}
		else if( IsCopyConstructor( constructor_, class_type ) ) {}
		else
		{
			// Generation of default constructor disabled because class has explicit noncopy constructors.
			has_explicit_noncopy_constructors= true;
		}
	}

	if( has_explicit_noncopy_constructors && constructor_index == ~0s )
	{
		return;
	}

	// Check if all fields are default-constructible.
	auto mut all_fields_are_default_constructible= true;
	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		auto& field= field_lock.deref();

		if( field.syntax_element.deref().initializer.has</Synt::EmptyVariant/>() &&
			( field.is_reference || !field.t.IsDefaultConstructible() ) )
		{
			all_fields_are_default_constructible= false;
			break;
		}
	}

	auto base_class= class_type.lock_imut().deref().base_class;
	if( !base_class.empty() && !base_class.try_lock_imut().deref().is_default_constructible )
	{
		all_fields_are_default_constructible= false;
	}

	if( !all_fields_are_default_constructible )
	{
		if( constructor_index != ~0s )
		{
			REPORT_ERROR( MethodBodyGenerationFailed, class_members_ptr, constructors.functions[constructor_index].prototype_syntax_element.try_deref().src_loc )
		}
		return;
	}

	// All ok - set default constructible flag.
	with( mut lock : class_type.lock_mut() )
	{
		lock.deref().is_default_constructible= true;
	}

	if( constructor_index == ~0s )
	{
		// Prepare function type.
		var FunctionType mut function_type
		{
			.return_type( void_type_ ),
			.return_value_type= ValueType::Value,
			.params( 1s, FunctionType::Param{ .t( class_type ), .value_type= ValueType::ReferenceMut } )
		};

		// Prepare function variable.

		constructor_index= constructors.functions.size();
		constructors.functions.push_back(
			FunctionVariable
			{
				.is_this_call= true,
				.is_generated= true,
				.llvm_function( LazyLLVMFunction(
					mangler_.deref().MangleFunction(
						class_members,
						KeywordToString( Keyword::constructor_ ),
						function_type ) ) ),
				.t= move(function_type),
			} );
	}
	var FunctionVariable &mut function_variable= constructors.functions[constructor_index];

	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( function_variable );

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		llvm_function,
		function_variable.t );

	auto this_llvm_value= unsafe( LLVMGetParam( llvm_function, 0u ) );

	var SrcLoc src_loc= GetClassSrcLoc( class_type );

	if( !base_class.empty() )
	{
		var VariablePtr base_variable_ptr=
			Variable
			{
				.t= base_class.try_to_non_nullable(),
				.value_type= ValueType::ReferenceMut,
				.location= Variable::Location::Pointer,
				.llvm_value= CreateBaseClassFieldGEP( function_context, class_type, this_llvm_value ),
				.name= KeywordToString( Keyword::base_ ),
			}.CreatePtr();

		function_context.references_graph.AddNode( base_variable_ptr );

		ApplyEmptyInitializer( class_members_ptr, function_context, base_variable_ptr, KeywordToString( Keyword::base_ ), src_loc );

		function_context.references_graph.RemoveNode( base_variable_ptr );
	}

	// Use initial class members namespace for own fields initializers evaluation.
	auto class_members_initial= class_type.lock_imut().deref().members_initial;

	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		var ClassField & class_field= field_lock.deref();

		if( class_field.index == ~0u ){ continue; } // May be in case of error

		var VariablePtr field_variable_ptr=
			Variable
			{
				.t= class_field.t,
				.value_type= ValueType::ReferenceMut,
				.location= Variable::Location::Pointer,
				.llvm_value= CreateClassFieldGEP( function_context, class_type, this_llvm_value, class_field ),
				.name= field_pair[0],
			}.CreatePtr();

		function_context.references_graph.AddNode( field_variable_ptr );

		auto& initializer= class_field.syntax_element.deref().initializer;
		if( initializer.has</Synt::EmptyVariant/>() )
		{
			ApplyEmptyInitializer( class_members_ptr, function_context, field_variable_ptr, field_pair[0], src_loc );
		}
		else
		{
			if( class_field.is_reference )
			{
				var VariablePtr this_variable_ptr=
					Variable
					{
						.t= class_type,
						.llvm_value= this_llvm_value,
						.value_type= ValueType::ReferenceMut,
						.location= Variable::Location::Pointer,
						.name= KeywordToString( Keyword::this_ ),
					}.CreatePtr();

				function_context.references_graph.AddNode( this_variable_ptr );
				InitializeReferenceField( class_members_initial, function_context, this_variable_ptr, class_field, initializer );
				function_context.references_graph.RemoveNode( this_variable_ptr );
			}
			else
			{
				ApplyInitializer( class_members_initial, function_context, field_variable_ptr, initializer );
			}
		}

		function_context.references_graph.RemoveNode( field_variable_ptr );
	}

	SetupVirtualTablePointers( this_llvm_value, class_type, function_context );

	// Finish function - add remaining instructions.
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	ProcessGeneratedMethodConstexprFlag( class_type, function_context, function_variable );
}

fn CodeBuilder::TryGenerateCopyConstructor( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	auto& class_members= class_members_lock.deref();

	// Constructors value should always exists and should always be FunctionsSet.
	auto constructors_ptr= class_members.GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).try_deref().Get</FunctionsSet/>();
	auto mut constructors_lock= constructors_ptr.try_lock_mut();
	var FunctionsSet &mut constructors= constructors_lock.deref();

	// Search for copy constructor.
	auto mut constructor_index= ~0s;
	for( auto mut i= 0s; i < constructors.functions.size(); ++i )
	{
		auto& constructor_= constructors.functions[i];
		if( IsCopyConstructor( constructor_, class_type ) )
		{
			if( constructor_.is_generated )
			{
				constructor_index= i;
				break;
			}
			else
			{
				auto mut class_lock= class_type.lock_mut();
				class_lock.deref().is_copy_constructible= !constructor_.is_deleted;
				return;
			}
		}
	}

	// Check if all fields are copy-constructible.
	auto mut all_fields_are_copy_constructible= true;
	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		auto& field= field_lock.deref();
		if( !field.is_reference && !field.t.IsCopyConstructible() )
		{
			all_fields_are_copy_constructible= false;
			break;
		}
	}

	auto base_class= class_type.lock_imut().deref().base_class;
	if( !base_class.empty() && !base_class.try_lock_imut().deref().is_copy_constructible )
	{
		all_fields_are_copy_constructible= false;
	}

	if( !all_fields_are_copy_constructible )
	{
		if( constructor_index != ~0s )
		{
			REPORT_ERROR( MethodBodyGenerationFailed, class_members_ptr, constructors.functions[constructor_index].prototype_syntax_element.try_deref().src_loc )
		}
		return;
	}

	// All ok - set copy constructible flag.
	with( mut lock : class_type.lock_mut() )
	{
		auto &mut class_= lock.deref();

		if( class_.kind != ClassType::Kind::Struct && constructor_index == ~0s )
		{
			// By-default do not generate copy constructors for classes, generate them only for structs.
			class_.is_copy_constructible= false;
			return;
		}

		class_.is_copy_constructible= true;
	}

	if( constructor_index == ~0s )
	{
		// Prepare function type.
		var FunctionType mut function_type
		{
			.return_type( void_type_ ),
			.return_value_type= ValueType::Value,
			.params= ust::make_array(
				FunctionType::Param{ .t( class_type ), .value_type= ValueType::ReferenceMut },
				FunctionType::Param{ .t( class_type ), .value_type= ValueType::ReferenceImut } ),
			.references_pollution=
				ust::make_vector_from_filler_function(
					class_type.lock_imut().deref().inner_references.size(),
					lambda[i= 0u] mut () : auto
					{
						auto index= u8(i);
						++i;
						return
							FunctionType::ReferencePollution
							{
								.dst{ .param_index= 0u8, .reference_index= index },
								.src{ .param_index= 1u8, .reference_index= index },
							};
					} )
		};

		NormalizeReferencesPollution( function_type.references_pollution );

		// Prepare function variable.
		constructor_index= constructors.functions.size();
		constructors.functions.push_back(
			FunctionVariable
			{
				.is_this_call= true,
				.is_generated= true,
				.llvm_function( LazyLLVMFunction(
					mangler_.deref().MangleFunction(
						class_members,
						KeywordToString( Keyword::constructor_ ),
						function_type ) ) ),
				.t= move(function_type),
			} );
	}
	var FunctionVariable &mut function_variable= constructors.functions[ constructor_index ];

	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( function_variable );

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		llvm_function,
		function_variable.t );

	var LLVMValueRef dst_llvm_value= unsafe( LLVMGetParam( llvm_function, 0u ) );
	var LLVMValueRef src_llvm_value= unsafe( LLVMGetParam( llvm_function, 1u ) );

	var SrcLoc src_loc= GetClassSrcLoc( class_type );

	if( !base_class.empty() )
	{
		auto dst_member_value= CreateBaseClassFieldGEP( function_context, class_type, dst_llvm_value );
		auto src_member_value= CreateBaseClassFieldGEP( function_context, class_type, src_llvm_value );

		BuildCopyConstructorPart( class_members_ptr, function_context, dst_member_value, src_member_value, base_class.try_to_non_nullable(), src_loc );
	}

	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		var ClassField & class_field= field_lock.deref();

		if( class_field.index == ~0u ){ continue; } // May be in case of error

		auto dst_member_value= CreateClassFieldGEP( function_context, class_type, dst_llvm_value, class_field );
		auto src_member_value= CreateClassFieldGEP( function_context, class_type, src_llvm_value, class_field );

		if( class_field.is_reference )
		{
			auto val= CreateTypedReferenceLoad( function_context, class_field.t, src_member_value );
			CreateTypedReferenceStore( function_context, class_field.t, val, dst_member_value );
		}
		else
		{
			BuildCopyConstructorPart( class_members_ptr, function_context, dst_member_value, src_member_value, class_field.t, src_loc );
		}
	}

	SetupVirtualTablePointers( dst_llvm_value, class_type, function_context );

	// Finish function - add remaining instructions
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	ProcessGeneratedMethodConstexprFlag( class_type, function_context, function_variable );
}

fn CodeBuilder::TryGenerateCopyAssignmentOperator( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	auto& class_members= class_members_lock.deref();

	// Assignment operators value should always exists and should always be FunctionsSet.
	auto operators_ptr= class_members.GetThisScopeValue( OverloadedOperatorToString( OverloadedOperator::Assign ) ).try_deref().Get</FunctionsSet/>();
	auto mut operators_lock= operators_ptr.try_lock_mut();
	var FunctionsSet &mut operators= operators_lock.deref();

	// Search for copy assignment operator.
	auto mut operator_index= ~0s;
	for( auto mut i= 0s; i < operators.functions.size(); ++i )
	{
		auto& operator= operators.functions[i];
		if( IsCopyAssignmentOperator( operator, class_type ) )
		{
			if( operator.is_generated )
			{
				operator_index= i;
				break;
			}
			else
			{
				auto mut class_lock= class_type.lock_mut();
				class_lock.deref().is_copy_assignable= !operator.is_deleted;
				return;
			}
		}
	}

	// Check if all fields are copy-assignable.
	auto mut all_fields_are_copy_assignable= true;
	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		auto& field= field_lock.deref();
		if( field.is_reference || !field.is_mutable || !field.t.IsCopyAssignable() )
		{
			all_fields_are_copy_assignable= false;
			break;
		}
	}

	auto base_class= class_type.lock_imut().deref().base_class;
	if( !base_class.empty() && !base_class.try_lock_imut().deref().is_copy_assignable )
	{
		all_fields_are_copy_assignable= false;
	}

	if( !all_fields_are_copy_assignable )
	{
		if( operator_index != ~0s )
		{
			REPORT_ERROR( MethodBodyGenerationFailed, class_members_ptr, operators.functions[operator_index].prototype_syntax_element.try_deref().src_loc )
		}
		return;
	}

	// All ok - set copy constructible flag.
	{
		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.deref();

		if( class_.kind != ClassType::Kind::Struct && operator_index == ~0s )
		{
			// By-default do not generate copy assignment operators for classes, generate them only for structs.
			class_.is_copy_assignable= false;
			return;
		}

		class_.is_copy_assignable= true;
	}

	if( operator_index == ~0s )
	{
		// Prepare function type.
		var FunctionType mut function_type
		{
			.return_type( void_type_ ),
			.return_value_type= ValueType::Value,
			.params= ust::make_array(
				FunctionType::Param{ .t( class_type ), .value_type= ValueType::ReferenceMut },
				FunctionType::Param{ .t( class_type ), .value_type= ValueType::ReferenceImut } ),
			.references_pollution=
				ust::make_vector_from_filler_function(
					class_type.lock_imut().deref().inner_references.size(),
					lambda[i= 0u] mut () : auto
					{
						auto index= u8(i);
						++i;
						return
							FunctionType::ReferencePollution
							{
								.dst{ .param_index= 0u8, .reference_index= index },
								.src{ .param_index= 1u8, .reference_index= index },
							};
					} )
		};

		NormalizeReferencesPollution( function_type.references_pollution );

		// Prepare function variable.
		operator_index= operators.functions.size();
		operators.functions.push_back(
			FunctionVariable
			{
				.is_this_call= true,
				.is_generated= true,
				.llvm_function( LazyLLVMFunction(
					mangler_.deref().MangleFunction(
						class_members,
						OverloadedOperatorToString( OverloadedOperator::Assign ),
						function_type ) ) ),
				.t= move(function_type),
			} );
	}
	var FunctionVariable &mut function_variable= operators.functions[operator_index];

	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( function_variable );

	// Build code itself.

	var FunctionContext mut function_context(
		llvm_context_,
		llvm_function,
		function_variable.t );

	var LLVMValueRef dst_llvm_value= unsafe( LLVMGetParam( llvm_function, 0u ) );
	var LLVMValueRef src_llvm_value= unsafe( LLVMGetParam( llvm_function, 1u ) );

	var SrcLoc src_loc= GetClassSrcLoc( class_type );

	if( !base_class.empty() )
	{		
		auto dst_member_value= CreateBaseClassFieldGEP( function_context, class_type, dst_llvm_value );
		auto src_member_value= CreateBaseClassFieldGEP( function_context, class_type, src_llvm_value );

		BuildCopyAssignmentOperatorPart( class_members_ptr, function_context, dst_member_value, src_member_value, base_class.try_to_non_nullable(), src_loc );
	}

	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		var ClassField & class_field= field_lock.deref();

		if( class_field.index == ~0u ){ continue; } // May be in case of error

		auto dst_member_value= CreateClassFieldGEP( function_context, class_type, dst_llvm_value, class_field );
		auto src_member_value= CreateClassFieldGEP( function_context, class_type, src_llvm_value, class_field );

		BuildCopyAssignmentOperatorPart( class_members_ptr, function_context, dst_member_value, src_member_value, class_field.t, src_loc );
	}

	// Finish function - add remaining instructions.
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}

	ProcessGeneratedMethodConstexprFlag( class_type, function_context, function_variable );
}

fn CodeBuilder::TryGenerateEqualityCompareOperator( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;

	auto mut operator_index= ~0s;
	var bool mut contains_other_equality_compare_operators= false;

	auto op_name= OverloadedOperatorToString( OverloadedOperator::CompareEqual );

	var ust::shared_ptr_nullable_mut</FunctionsSet/> mut operators_ptr;
	if_var( &val : class_members_ptr.lock_imut().deref().GetThisScopeValue( op_name ) )
	{
		operators_ptr= val.Get</FunctionsSet/>();
	}
	if( !operators_ptr.empty() )
	{
		auto mut operators_lock= operators_ptr.try_lock_mut();
		var FunctionsSet &mut operators= operators_lock.deref();

		// Search for copy "==" operator.
		for( auto mut i= 0s; i < operators.functions.size(); ++i )
		{
			auto& operator= operators.functions[i];
			if( IsEqualityCompareOperator( operator, class_type ) )
			{
				if( operator.is_generated )
				{
					operator_index= i;
					break;
				}
				else
				{
					auto mut class_lock= class_type.lock_mut();
					class_lock.deref().is_equality_comparable= !operator.is_deleted;
					return;
				}
			}
			else
			{
				contains_other_equality_compare_operators= true;
			}
		}

		if( !operators.function_templates.empty() )
		{
			contains_other_equality_compare_operators= true;
		}
	}

	// Check if all fields are equality-comparable.
	auto mut all_fields_are_equality_comparable= true;
	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		auto& field= field_lock.deref();
		if( !( field.t.IsEqualityComparable() && !field.is_reference ) )
		{
			all_fields_are_equality_comparable= false;
			break;
		}
	}

	auto base_class= class_type.lock_imut().deref().base_class;
	if( !base_class.empty() && !base_class.try_lock_imut().deref().is_equality_comparable )
	{
		all_fields_are_equality_comparable= false;
	}

	if( !all_fields_are_equality_comparable )
	{
		if( operator_index != ~0s )
		{
			auto operators_lock= operators_ptr.try_lock_imut();
			auto& operators= operators_lock.deref();
			REPORT_ERROR( MethodBodyGenerationFailed, class_members_ptr, operators.functions[operator_index].prototype_syntax_element.try_deref().src_loc )
		}
		return;
	}

	// All ok - set equiality comparable flag.
	with( mut lock : class_type.lock_mut() )
	{
		auto &mut class_= lock.deref();

		if( operator_index == ~0s )
		{
			if( class_.kind != ClassType::Kind::Struct )
			{
				// By-default do not generate "==" operators for classes, generate them only for structs.
				class_.is_equality_comparable= false;
				return;
			}
			if( contains_other_equality_compare_operators )
			{
				// Do not generate "==" if user specified "==" inside this class for other types. Do this to prevent typos/mistakes.
				class_.is_equality_comparable= false;
				return;
			}
		}

		class_.is_equality_comparable= true;
	}

	if( operators_ptr.empty() )
	{
		auto mut class_members_lock= class_members_ptr.lock_mut();
		auto &mut class_members= class_members_lock.deref();

		auto mut operators_ptr_non_null= ust::make_shared_ptr( FunctionsSet{ .class_= class_type } );
		operators_ptr= operators_ptr_non_null;

		class_members.AddName( op_name, NamesScopeValue( move( operators_ptr_non_null ) ) );
	}
	auto mut operators_lock= operators_ptr.try_lock_mut();
	var FunctionsSet &mut operators= operators_lock.deref();

	if( operator_index == ~0s )
	{
		// Prepare function type.
		var FunctionType mut function_type
		{
			.return_type( bool_type_ ),
			.return_value_type= ValueType::Value,
			.params( 2s, FunctionType::Param{ .t( class_type ), .value_type= ValueType::ReferenceImut } )
		};

		// Prepare function variable.
		operator_index= operators.functions.size();
		operators.functions.push_back(
			FunctionVariable
			{
				.is_this_call= true,
				.is_generated= true,
				.llvm_function( LazyLLVMFunction(
					mangler_.deref().MangleFunction(
						class_members_ptr.lock_imut().deref(),
						op_name,
						function_type ) ) ),
				.t= move(function_type),
			} );
	}

	var FunctionVariable &mut function_variable= operators.functions[operator_index];

	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( function_variable );

	var FunctionContext mut function_context(
		llvm_context_,
		llvm_function,
		function_variable.t );

	auto src_loc= GetClassSrcLoc(class_type);

	unsafe
	{
		var LLVMValueRef l_address= LLVMGetParam( llvm_function, 0u );
		var LLVMValueRef r_address= LLVMGetParam( llvm_function, 1u );
		var LLVMBasicBlockRef false_basic_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

		if( !base_class.empty() )
		{
			var LLVMValueRef l_base= CreateBaseClassFieldGEP( function_context, class_type, l_address );
			var LLVMValueRef r_base= CreateBaseClassFieldGEP( function_context, class_type, r_address );

			BuildEqualityCompareOperatorPart( class_members_ptr, function_context, l_base, r_base, base_class.try_to_non_nullable(), false_basic_block, src_loc );
		}

		foreach( &field_pair : class_type.lock_imut().deref().fields_order )
		{
			auto field_lock= field_pair[1].lock_imut();
			var ClassField & class_field= field_lock.deref();

			if( class_field.index == ~0u ){ continue; } // May be in case of error

			auto l_member= CreateClassFieldGEP( function_context, class_type, l_address, class_field );
			auto r_member= CreateClassFieldGEP( function_context, class_type, r_address, class_field );

			BuildEqualityCompareOperatorPart( class_members_ptr, function_context, l_member, r_member, class_field.t, false_basic_block, src_loc );
		}

		var LLVMValueRef false_value= LLVMConstInt( fundamental_llvm_types_.bool_, 0u64, LLVMBool::False );
		var LLVMValueRef true_value = LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False );

		// True branch.
		LLVMBuildRet( function_context.llvm_ir_builder, true_value );

		LLVMAppendExistingBasicBlock( function_context.llvm_function, false_basic_block );
		if( U1_BasicBlockHasPredecessors( false_basic_block ) )
		{
			// False branch.
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, false_basic_block );
			LLVMBuildRet( function_context.llvm_ir_builder, false_value );
		}
		else
		{
			// "false" block was not used. Probably because class contains no fields.
			LLVMDeleteBasicBlock( false_basic_block );
		}

		// Finish allocations block.
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
	}

	ProcessGeneratedMethodConstexprFlag( class_type, function_context, function_variable );
}

fn CodeBuilder::TryGenerateDestructorPrototype( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	auto& class_members= class_members_lock.deref();

	// Destructors value should always exists and should always be FunctionsSet.
	auto destructors_ptr= class_members.GetThisScopeValue( KeywordToString( Keyword::destructor_ ) ).try_deref().Get</FunctionsSet/>();
	auto mut destructors_lock= destructors_ptr.try_lock_mut();
	var FunctionsSet &mut destructors= destructors_lock.deref();

	if( !destructors.functions.empty() )
	{
		return; // user already specified destructor.
	}

	// Prepare function type.
	var FunctionType mut function_type
	{
		.return_type( void_type_ ),
		.return_value_type= ValueType::Value,
		.params( 1s, FunctionType::Param{ .t( Type( class_type ) ), .value_type= ValueType::ReferenceMut } )
	};

	// Prepare function variable.
	destructors.functions.push_back(
		FunctionVariable
		{
			.is_this_call= true,
			.is_generated= true,
			.llvm_function( LazyLLVMFunction(
				mangler_.deref().MangleFunction(
					class_members,
					KeywordToString( Keyword::destructor_ ),
					function_type ) ) ),
			.t= move(function_type),
		} );
}

fn CodeBuilder::TryGenerateDestructor( mut this, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;
	auto class_members_lock= class_members_ptr.lock_imut();
	auto& class_members= class_members_lock.deref();

	// Destructors value should always exists and should always be FunctionsSet.
	auto destructors_ptr= class_members.GetThisScopeValue( KeywordToString( Keyword::destructor_ ) ).try_deref().Get</FunctionsSet/>();
	auto mut destructors_lock= destructors_ptr.try_lock_mut();
	var FunctionsSet &mut destructors= destructors_lock.deref();

	if( !destructors.functions.back().is_generated ) // Should be nonempty - contain user-specified destructor of prepared prototype.
	{
		return; // user already specified destructor.
	}

	// Generate body for previously generated prototype.
	var FunctionVariable &mut function_variable= destructors.functions.back();

	// Build code itself.
	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( function_variable );

	var FunctionContext mut function_context(
		llvm_context_,
		llvm_function,
		function_variable.t );

	auto this_llvm_value= unsafe( LLVMGetParam( llvm_function, 0u ) );

	BuildMembersDestructors( function_context, this_llvm_value, class_type );

	// Finish function - add remaining instructions.
	unsafe
	{
		LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		LLVMBuildRetVoid( function_context.llvm_ir_builder );
	}
}

fn CodeBuilder::ProcessGeneratedMethodConstexprFlag( ClassTypePtr& class_type, FunctionContext& function_context_after_body_generation, FunctionVariable &mut method )
{
	var bool is_constexpr= class_type.lock_imut().deref().can_be_constexpr && !function_context_after_body_generation.has_non_constexpr_operations_inside;
	method.constexpr_kind= ( is_constexpr ? FunctionVariable::ConstexprKind::ConstexprComplete : FunctionVariable::ConstexprKind::NonConstexpr );

	if( !is_constexpr )
	{
		auto class_members_ptr= class_type.lock_imut().deref().members;
		if( !method.prototype_syntax_element.empty() && method.prototype_syntax_element.try_deref().constexpr_ )
		{
			REPORT_ERROR( ConstexprFunctionContainsUnallowedOperations, class_members_ptr, method.prototype_syntax_element.try_deref().src_loc )
		}
		if( !method.body_syntax_element.empty() && method.body_syntax_element.try_deref().constexpr_ )
		{
			REPORT_ERROR( ConstexprFunctionContainsUnallowedOperations, class_members_ptr, method.body_syntax_element.try_deref().src_loc )
		}
	}
}

fn CodeBuilder::BuildCopyConstructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc )
{
	if(
		!t.GetFundamentalType().empty() ||
		!t.GetEnumType().empty() ||
		!t.GetRawPointerType().empty() ||
		!t.GetFunctionPointerType().empty() )
	{
		unsafe
		{
			debug_assert( LLVMTypeOf( dst ) == LLVMTypeOf( src ), "Copying incompatible types!" );
			auto mut value= CreateTypedLoad( function_context, t, src );
			CreateTypedStore( function_context, t, value, dst );
		}
	}
	else if_var( &array_type : t.GetArrayType() )
	{
		GenerateLoop(
			function_context,
			array_type.element_count,
			lambda[&]( CodeBuilder &mut self, FunctionContext& mut function_context, LLVMValueRef counter_value )
			{
				auto dst_element_value= self.CreateArrayElementGEP( function_context, array_type, dst, counter_value );
				auto src_element_value= self.CreateArrayElementGEP( function_context, array_type, src, counter_value );
				self.BuildCopyConstructorPart( names_scope, function_context, dst_element_value, src_element_value, array_type.element_type, src_loc );
			} );
	}
	else if_var( &tuple_type : t.GetTupleType() )
	{
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			auto dst_element_value= CreateTupleElementGEP( function_context, tuple_type, dst, u32(i) );
			auto src_element_value= CreateTupleElementGEP( function_context, tuple_type, src, u32(i) );
			BuildCopyConstructorPart( names_scope, function_context, dst_element_value, src_element_value, tuple_type.element_types[i], src_loc );
		}
	}
	else if_var( &class_type : t.GetClassType() )
	{
		if( !class_type.lock_imut().deref().is_copy_constructible )
		{
			REPORT_ERROR( CopyConstructValueOfNoncopyableType, names_scope, src_loc, Type(class_type) )
			return;
		}

		// Constructors value should always exists and should always be FunctionsSet.
		auto class_members= class_type.lock_imut().deref().members;
		auto constructors_ptr= class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).try_deref().Get</FunctionsSet/>().try_to_non_nullable();
		PrepareFunctionsSetAndBuildConstexprBodies( class_members, constructors_ptr );

		// Search for copy constructor.
		foreach( &constructor_ : constructors_ptr.lock_imut().deref().functions )
		{
			if( IsCopyConstructor( constructor_, class_type ) )
			{
				if( !( constructor_.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || constructor_.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
				{
					function_context.has_non_constexpr_operations_inside= true;
				}

				// Call it.
				var[ LLVMValueRef, 2 ] mut llvm_args[ dst, src ];
				var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( constructor_ );
				var LLVMValueRef call_instruction= unsafe( LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType( llvm_function ), llvm_function, $<(llvm_args[0]), 2u, g_null_string ) );
				unsafe( LLVMSetInstructionCallConv( call_instruction, GetLLVMCallingConvention( constructor_.t.calling_convention ) ) );

				break;
			}
		}
	}
	else
	{
		halt; // Unhandled type kind
	}
}

fn CodeBuilder::BuildCopyAssignmentOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef dst, LLVMValueRef src, Type& t, SrcLoc& src_loc )
{
	if(
		!t.GetFundamentalType().empty() ||
		!t.GetEnumType().empty() ||
		!t.GetRawPointerType().empty() ||
		!t.GetFunctionPointerType().empty() )
	{
		unsafe
		{
			debug_assert( LLVMTypeOf( dst ) == LLVMTypeOf( src ), "Copying incompatible types!" );
			auto mut value= CreateTypedLoad( function_context, t, src );
			CreateTypedStore( function_context, t, value, dst );
		}
	}
	else if_var( &array_type : t.GetArrayType() )
	{
		GenerateLoop(
			function_context,
			array_type.element_count,
			lambda[&]( CodeBuilder &mut self, FunctionContext& mut function_context, LLVMValueRef counter_value )
			{
				auto dst_element_value= self.CreateArrayElementGEP( function_context, array_type, dst, counter_value );
				auto src_element_value= self.CreateArrayElementGEP( function_context, array_type, src, counter_value );
				self.BuildCopyAssignmentOperatorPart( names_scope, function_context, dst_element_value, src_element_value, array_type.element_type, src_loc );
			} );
	}
	else if_var( &tuple_type : t.GetTupleType() )
	{
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			auto dst_element_value= CreateTupleElementGEP( function_context, tuple_type, dst, u32(i) );
			auto src_element_value= CreateTupleElementGEP( function_context, tuple_type, src, u32(i) );
			BuildCopyAssignmentOperatorPart( names_scope, function_context, dst_element_value, src_element_value, tuple_type.element_types[i], src_loc );
		}
	}
	else if_var( &class_type : t.GetClassType() )
	{
		if( !class_type.lock_imut().deref().is_copy_assignable )
		{
			// TODO - maybe generate error here?
			return;
		}

		// Assignment operators value should always exists and should always be FunctionsSet.
		auto class_members= class_type.lock_imut().deref().members;
		auto operators_ptr= class_members.lock_imut().deref().GetThisScopeValue( OverloadedOperatorToString( OverloadedOperator::Assign ) ).try_deref().Get</FunctionsSet/>().try_to_non_nullable();
		PrepareFunctionsSetAndBuildConstexprBodies( class_members, operators_ptr );

		// Search for copy assignment operator.
		foreach( &operator_ : operators_ptr.lock_imut().deref().functions )
		{
			if( IsCopyAssignmentOperator( operator_, class_type ) )
			{
				if( !( operator_.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || operator_.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
				{
					function_context.has_non_constexpr_operations_inside= true;
				}

				// Call it.
				var[ LLVMValueRef, 2 ] mut llvm_args[ dst, src ];
				var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( operator_ );
				var LLVMValueRef call_instruction= unsafe( LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType( llvm_function ), llvm_function, $<(llvm_args[0]), 2u, g_null_string ) );
				unsafe( LLVMSetInstructionCallConv( call_instruction, GetLLVMCallingConvention( operator_.t.calling_convention ) ) );

				break;
			}
		}
	}
	else
	{
		halt; // Unhandled type kind
	}
}

fn CodeBuilder::BuildEqualityCompareOperatorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef l_address, LLVMValueRef r_address, Type& t, LLVMBasicBlockRef false_basic_block, SrcLoc& src_loc )
{
	if( t == void_type_ )
	{
		return;
	}

	if(
		!t.GetFundamentalType().empty() ||
		!t.GetEnumType().empty() ||
		!t.GetRawPointerType().empty() ||
		!t.GetFunctionPointerType().empty() )
	{
		unsafe
		{
			var LLVMValueRef l= CreateTypedLoad( function_context, t, l_address );
			var LLVMValueRef r= CreateTypedLoad( function_context, t, r_address );

			var LLVMTypeKind type_kind= LLVMGetTypeKind( t.GetLLVMType() );
			var bool is_float=
				type_kind == LLVMTypeKind::Half ||
				type_kind == LLVMTypeKind::Float ||
				type_kind == LLVMTypeKind::Double ||
				type_kind == LLVMTypeKind::X86_FP80 ||
				type_kind == LLVMTypeKind::P128 ||
				type_kind == LLVMTypeKind::PPC_FP128;

			var LLVMValueRef eq=
				( is_float
					? LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OEQ, l, r, g_null_string )
					: LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::EQ, l, r, g_null_string ) );

			var LLVMBasicBlockRef next_bb= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

			LLVMBuildCondBr( function_context.llvm_ir_builder, eq, next_bb, false_basic_block );

			LLVMAppendExistingBasicBlock( function_context.llvm_function, next_bb );
			LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, next_bb );
		}
	}
	else if_var( &array_type : t.GetArrayType() )
	{
		GenerateLoop(
			function_context,
			array_type.element_count,
			lambda[&]( CodeBuilder &mut self, FunctionContext& mut function_context, LLVMValueRef counter_value )
			{
				auto l= self.CreateArrayElementGEP( function_context, array_type, l_address, counter_value );
				auto r= self.CreateArrayElementGEP( function_context, array_type, r_address, counter_value );
				self.BuildEqualityCompareOperatorPart( names_scope, function_context, l, r, array_type.element_type, false_basic_block, src_loc );
			} );
	}
	else if_var( &tuple_type : t.GetTupleType() )
	{
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			var LLVMValueRef l= CreateTupleElementGEP( function_context, tuple_type, l_address, u32(i) );
			var LLVMValueRef r= CreateTupleElementGEP( function_context, tuple_type, r_address, u32(i) );
			BuildEqualityCompareOperatorPart( names_scope, function_context, l, r, tuple_type.element_types[i], false_basic_block, src_loc );
		}
	}
	else if_var( &class_type : t.GetClassType() )
	{
		if( !class_type.lock_imut().deref().is_equality_comparable )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, Type(class_type) )
			return;
		}

		// Search for "==" operator.
		auto class_members= class_type.lock_imut().deref().members;
		auto operators_ptr= class_members.lock_imut().deref().GetThisScopeValue( OverloadedOperatorToString( OverloadedOperator::CompareEqual ) ).try_deref().Get</FunctionsSet/>().try_to_non_nullable();
		PrepareFunctionsSetAndBuildConstexprBodies( class_members, operators_ptr );

		foreach( &op_ : operators_ptr.lock_imut().deref().functions )
		{
			if( !IsEqualityCompareOperator( op_, class_type ) )
			{
				continue;
			}
			// Found proper "==" operator.
			if( !( op_.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete || op_.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprComplete ) )
			{
				function_context.has_non_constexpr_operations_inside= true;
			}

			unsafe
			{
				var[ LLVMValueRef, 2 ] mut llvm_args[ l_address, r_address ];
				var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( op_ );
				var LLVMValueRef eq= LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType( llvm_function ),llvm_function, $<(llvm_args[0]), 2u, g_null_string );
				unsafe( LLVMSetInstructionCallConv( eq, GetLLVMCallingConvention( op_.t.calling_convention ) ) );

				var LLVMBasicBlockRef next_bb= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

				LLVMBuildCondBr( function_context.llvm_ir_builder, eq, next_bb, false_basic_block );

				LLVMAppendExistingBasicBlock( function_context.llvm_function, next_bb );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, next_bb );
			}

			return;
		}

		halt; // Operator not found - wtf?
	}
	else
	{
		halt; // Unhandled type kind
	}
}

fn CodeBuilder::BuildDestructorPart( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, LLVMValueRef value, Type& t, SrcLoc& src_loc )
{
	if_var( &array_type : t.GetArrayType() )
	{
		GenerateLoop(
			function_context,
			array_type.element_count,
			lambda[&]( CodeBuilder &mut self, FunctionContext& mut function_context, LLVMValueRef counter_value )
			{
				auto element_value= self.CreateArrayElementGEP( function_context, array_type, value, counter_value );
				self.BuildDestructorPart( names_scope, function_context, element_value, array_type.element_type, src_loc );
			} );
	}
	else if_var( &tuple_type : t.GetTupleType() )
	{
		for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			var LLVMValueRef element_value= CreateTupleElementGEP( function_context, tuple_type, value, u32(i) );
			BuildDestructorPart( names_scope, function_context, element_value, tuple_type.element_types[i], src_loc );
		}
	}
	else if_var( &class_type : t.GetClassType() )
	{
		// Destructors value should always exists and should always be FunctionsSet.
		auto class_members= class_type.lock_imut().deref().members;
		auto destructors_ptr= class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::destructor_ ) ).try_deref().Get</FunctionsSet/>().try_to_non_nullable();
		PrepareFunctionsSetAndBuildConstexprBodies( class_members, destructors_ptr );

		// Destructors set should contain exactly one function.
		auto destructors_lock= destructors_ptr.lock_imut();
		var FunctionVariable& destructor_= destructors_lock.deref().functions.front();

		// Call it.
		auto mut v= value;
		var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( destructor_ );
		var LLVMValueRef call_instruction= unsafe( LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType( llvm_function ), llvm_function, $<(v), 1u, g_null_string ) );
		unsafe( LLVMSetInstructionCallConv( call_instruction, GetLLVMCallingConvention( destructor_.t.calling_convention ) ) );
	}
}

fn CodeBuilder::BuildMembersDestructors( mut this, FunctionContext &mut function_context, LLVMValueRef value, ClassTypePtr& class_type )
{
	auto class_members_ptr= class_type.lock_imut().deref().members;

	var SrcLoc mut src_loc;
	if_var( &syntax_element : class_type.lock_imut().deref().syntax_element )
	{
		src_loc= syntax_element.src_loc;
	}

	foreach( &parent : class_type.lock_imut().deref().parents )
	{
		auto parent_llvm_value= CreateClassParentFieldGEP( function_context, class_type, value, parent );
		BuildDestructorPart( class_members_ptr, function_context, parent_llvm_value, parent.class_, src_loc );
	}

	foreach( &field_pair : class_type.lock_imut().deref().fields_order )
	{
		auto field_lock= field_pair[1].lock_imut();
		var ClassField& class_field= field_lock.deref();

		if( class_field.index == ~0u ){ continue; } // May be in case of error
		if( class_field.is_reference ) { continue; }
		if( !class_field.t.HasDestructor() ) { continue; }

		auto field_llvm_value= CreateClassFieldGEP( function_context, class_type, value, class_field );

		BuildDestructorPart( class_members_ptr, function_context, field_llvm_value, class_field.t, src_loc ); // TODO - maybe use field src_loc instead?
	}
}

fn GetClassSrcLoc( ClassTypePtr& class_type_ptr ) : SrcLoc
{
	if_var( &syntax_element : class_type_ptr.lock_imut().deref().syntax_element )
	{
		return syntax_element.src_loc;
	}

	// TODO - save some SrcLoc in the class for such case.
	return SrcLoc();
}

} // namespace U1
