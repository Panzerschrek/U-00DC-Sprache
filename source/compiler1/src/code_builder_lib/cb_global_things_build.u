import "/assert.u"
import "/scoped_array.u"
import "/CodeBuilderLib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

?macro <? GLOBALS_LOOP_DETECT:block ?value : expr ?>
->
<?
	if( DetectGlobalsLoop( ?value ) ){ return; }
	var GlobalThingHolder ??holder( global_things_stack_ptr_, ?value );
?>

namespace U1
{

class GlobalThingHolder
{
public:
	fn constructor( GlobalThingsStackPtr mut stack, NamesScopeValue mut value )
		( stack_(move(stack)) )
	{
		auto mut lock= stack_.lock_mut();
		lock.deref().push_back( move(value) );
	}

	fn destructor()
	{
		auto mut lock= stack_.lock_mut();
		lock.deref().drop_back();
	}

private:
	GlobalThingsStackPtr imut stack_;
}

fn GlobalValueToString( NamesScopeValue& global_thing ) : ust::string8
{
	{
		auto functions_set_ptr= global_thing.Get</FunctionsSet/>();
		if( !functions_set_ptr.empty() )
		{
			auto lock= functions_set_ptr.try_lock_imut();
			var FunctionsSet& functions_set= lock.deref();

			if( !functions_set.syntax_elements.empty() )
			{
				return functions_set.syntax_elements.front().deref().name.back();
			}
			if( !functions_set.out_of_line_syntax_elements.empty() )
			{
				return functions_set.out_of_line_syntax_elements.front().deref().name.back();
			}
			if( !functions_set.function_templates_syntax_elements.empty() )
			{
				return functions_set.function_templates_syntax_elements.front().deref().name;
			}

			foreach( &function : functions_set.functions )
			{
				if_var( &el : function.prototype_syntax_element )
				{
					return el.name.back();
				}
				if_var( &el : function.body_syntax_element )
				{
					return el.name.back();
				}
			}

			if( !functions_set.function_templates.empty() )
			{
				return functions_set.function_templates.front().lock_imut().deref().syntax_element.deref().name;
			}
		}
	}
	{
		auto class_type_ptr= global_thing.Get</ClassType/>();
		if( !class_type_ptr.empty() )
		{
			return Type( class_type_ptr.try_to_non_nullable() ).ToString();
		}
	}
	{
		auto enum_type_ptr= global_thing.Get</Enum/>();
		if( !enum_type_ptr.empty() )
		{
			return Type( enum_type_ptr.try_to_non_nullable() ).ToString();
		}
	}
	{
		auto type_alias_ptr= global_thing.Get</Enum/>();
		if( !type_alias_ptr.empty() )
		{
			return type_alias_ptr.try_lock_imut().deref().syntax_element.deref().name;
		}
	}
	{
		auto type_templates_set_ptr= global_thing.Get</TypeTemplatesSet/>();
		if( !type_templates_set_ptr.empty() )
		{
			auto lock= type_templates_set_ptr.try_lock_imut();
			var TypeTemplatesSet& type_templates_set= lock.deref();

			if( !type_templates_set.syntax_elements.empty() )
			{
				return type_templates_set.syntax_elements.front().deref().name;
			}
			if( !type_templates_set.type_templates.empty() )
			{
				return type_templates_set.type_templates.front().lock_imut().deref().syntax_element.deref().name;
			}
		}
	}
	{
		auto global_variable_ptr= global_thing.Get</GlobalVariable/>();
		if( !global_variable_ptr.empty() )
		{
			auto lock= global_variable_ptr.try_lock_imut();
			var GlobalVariable& global_variable= lock.deref();
			return global_variable.syntax_element.deref().variables[ size_type(global_variable.variable_index) ].name;
		}
	}
	{
		auto global_auto_variable_ptr= global_thing.Get</GlobalAutoVariable/>();
		if( !global_auto_variable_ptr.empty() )
		{
			return global_auto_variable_ptr.try_lock_imut().deref().syntax_element.deref().name;
		}
	}

	return "";
}

fn AddAncestorsAccessRights_r( NamesScope &mut dst_class_members, ClassTypePtr& ancestor_class )
{
	dst_class_members.AddAccessRightsFor( ancestor_class, Synt::ClassVisibility::Protected );
	foreach( &parent : ancestor_class.lock_imut().deref().parents )
	{
		AddAncestorsAccessRights_r( dst_class_members, parent.class_ );
	}
}

fn CodeBuilder::DetectGlobalsLoop( this, NamesScopeValue& global_thing ) : bool
{
	auto lock= global_things_stack_ptr_.lock_imut();
	var GlobalThingsStack& stack= lock.deref();

	auto mut i= 0s;
	while( i < stack.size() && stack[i] != global_thing ){ ++i; }

	if( i == stack.size() )
	{
		return false; // No loop detected
	}

	var ust::string8 mut description;
	for( ; i < stack.size(); ++i )
	{
		description+= GlobalValueToString(stack[i]);
		description+= " -> ";
	}
	description+= GlobalValueToString(global_thing);

	auto mut errors_container_lock= root_errors_container_.try_lock_mut();

	errors_container_lock.deref().push_back(
		ReportError( CodeBuilderErrorCode::GlobalsLoopDetected, GetValueSrcLoc(global_thing), description ) );

	return true;
}

fn CodeBuilder::PrepareFunctionsSet( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set_ptr )
{
	// First, lock as imut and check if complete.
	with( &functions_set : functions_set_ptr.lock_imut().deref() )
	{
		if( functions_set.syntax_elements.empty() &&
			functions_set.out_of_line_syntax_elements.empty() &&
			functions_set.function_templates_syntax_elements.empty() ) // Already complete
		{
			return;
		}
	}

	GLOBALS_LOOP_DETECT( functions_set_ptr )

	// Take copy, and make manipulations only with it. Update value inside shareed pointer in one operation.
	var FunctionsSet mut functions_set= functions_set_ptr.lock_imut().deref();

	// Preapare functions set itself.
	while( !functions_set.syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.syntax_elements.back();
		auto class_type_ptr= functions_set.class_;
		PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set, false );
		functions_set.syntax_elements.drop_back();
	}
	while( !functions_set.out_of_line_syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.out_of_line_syntax_elements.back();
		auto class_type_ptr= functions_set.class_;
		PrepareFunction( syntax_element_ptr, names_scope_ptr, class_type_ptr, functions_set, true );
		functions_set.out_of_line_syntax_elements.drop_back();
	}
	while( !functions_set.function_templates_syntax_elements.empty() )
	{
		auto syntax_element_ptr= functions_set.function_templates_syntax_elements.back();
		auto function_template= PrepareFunctionTemplate( names_scope_ptr, syntax_element_ptr, functions_set.class_ );
		functions_set.function_templates.push_back( function_template );
		functions_set.function_templates_syntax_elements.drop_back();
	}

	// Immediately build auto-return functions.
	foreach( &mut func_variable : functions_set.functions )
	{
		if( !func_variable.body_syntax_element.empty() &&
			!func_variable.body_syntax_element.try_deref().block.empty() &&
			func_variable.body_syntax_element.try_deref().function_type.IsAutoReturn() )
		{
			auto llvm_function= func_variable.llvm_function.lock_imut().deref().function;
			if( llvm_function == LLVMValueRef::Null || unsafe( LLVMCountBasicBlocks( llvm_function ) ) == 0u )
			{
				// Preprocess function in order to deduce return type and reference notation.
				var ReturnTypeDeductionContext return_type_deduction_context;

				auto return_type_deduction_context_ptr= ust::make_shared_ptr( ReturnTypeDeductionContext() );

				auto reference_notation_deduction_context_ptr= ust::make_shared_ptr( ReferenceNotationDeductionContext() );

				if( func_variable.constexpr_kind == FunctionVariable::ConstexprKind::NonConstexpr )
				{
					// We can deduce "constexpr" property for all auto-return functions.
					func_variable.constexpr_kind= FunctionVariable::ConstexprKind::ConstexprAuto;
				}

				BuildFuncCode(
					names_scope_ptr,
					func_variable,
					return_type_deduction_context_ptr,
					reference_notation_deduction_context_ptr,
					ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext />() );

				// Update function type.
				auto return_type= return_type_deduction_context_ptr.lock_imut().deref().return_type;
				func_variable.t.return_type= return_type.deref_or( void_type_ );

				with( mut lock : reference_notation_deduction_context_ptr.lock_mut() )
				{
					func_variable.t.return_references= take( lock.deref().return_references );
					NormalizeParamReferencesList( func_variable.t.return_references );

					func_variable.t.return_inner_references= take( lock.deref().return_inner_references );
					foreach( &mut list : func_variable.t.return_inner_references )
					{
						NormalizeParamReferencesList( list );
					}

					func_variable.t.references_pollution= take( lock.deref().references_pollution );
					NormalizeReferencesPollution( func_variable.t.references_pollution );
				}

				// Remove old LLVM function and create new one (with name based on exact deduced function type).
				auto prev_llvm_function= func_variable.llvm_function.lock_imut().deref().function;
				if( prev_llvm_function != LLVMValueRef::Null )
				{
					unsafe( LLVMDeleteFunction( prev_llvm_function ) );
				}

				with( &name : func_variable.body_syntax_element.try_deref().name.back() )
				{
					func_variable.llvm_function.reset(
						LazyLLVMFunction(
							( func_variable.no_mangle
								? name + "\0"
								: mangler_.deref().MangleFunction( names_scope_ptr.lock_imut().deref(), name, func_variable.t ) ) ) );
				}

				// Compile function when its type is exactly known.
				BuildFuncCode(
					names_scope_ptr,
					func_variable,
					ust::shared_ptr_nullable_mut</ ReturnTypeDeductionContext />(),
					ust::shared_ptr_nullable_mut</ ReferenceNotationDeductionContext />(),
					ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext />() );
			}
		}
	}

	functions_set.has_unbuilt_constexpr_functions= false;
	foreach( &function : functions_set.functions )
	{
		functions_set.has_unbuilt_constexpr_functions |= function.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete;
	}

	// Update functions set after prepareation process.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref()= move(functions_set);
	}
}

fn CodeBuilder::BuildFunctionsSetBodies( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set_ptr )
{
	// Prepare functions before building.
	PrepareFunctionsSet( names_scope_ptr, functions_set_ptr );

	// Reset the flag in order to avoid recursion.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref().has_unbuilt_constexpr_functions= false;
	}

	// Take copy, and make manipulations only with it. Update value inside shareed pointer in one operation.
	var FunctionsSet mut functions_set= functions_set_ptr.lock_imut().deref();

	foreach( &mut func_variable : functions_set.functions )
	{
		if( !func_variable.is_inherited )
		{
			BuildFuncCode(
				names_scope_ptr,
				func_variable,
				ust::shared_ptr_nullable_mut</ ReturnTypeDeductionContext />(),
				ust::shared_ptr_nullable_mut</ ReferenceNotationDeductionContext />(),
				ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext />() );
		}
	}

	// Update functions set after body build process.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref()= move(functions_set);
	}
}

fn CodeBuilder::PrepareFunctionsSetAndBuildConstexprBodies( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</FunctionsSet/>& functions_set_ptr )
{
	// Prepare functions before building.
	PrepareFunctionsSet( names_scope_ptr, functions_set_ptr );

	if( !functions_set_ptr.lock_imut().deref().has_unbuilt_constexpr_functions )
	{
		// Nothing to do.
		return;
	}

	// Reset the flag in order to avoid recursion.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref().has_unbuilt_constexpr_functions= false;
	}

	// Take copy, and make manipulations only with it. Update value inside shareed pointer in one operation.
	var FunctionsSet mut functions_set= functions_set_ptr.lock_imut().deref();

	foreach( &mut func_variable : functions_set.functions )
	{
		if( !func_variable.is_inherited && func_variable.constexpr_kind == FunctionVariable::ConstexprKind::ConstexprIncomplete )
		{
			BuildFuncCode(
				names_scope_ptr,
				func_variable,
				ust::shared_ptr_nullable_mut</ ReturnTypeDeductionContext />(),
				ust::shared_ptr_nullable_mut</ ReferenceNotationDeductionContext />(),
				ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext />() );
		}
	}

	// Update functions set after body build process.
	with( mut lock : functions_set_ptr.lock_mut() )
	{
		lock.deref()= move(functions_set);
	}
}

fn CodeBuilder::PrepareClassParentsList( mut this, ClassTypePtr& class_type )
{
	if( class_type.lock_imut().deref().parents_list_prepared )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( class_type )

	var ust::vector</ClassType::Parent/> mut parents;

	auto syntax_element_ptr= class_type.lock_imut().deref().syntax_element;
	if( !syntax_element_ptr.empty() && !syntax_element_ptr.try_deref().parents.empty() )
	{
		auto& syntax_element= syntax_element_ptr.try_deref();

		var NamesScopeMutPtr class_members= class_type.lock_imut().deref().members;
		var NamesScopePtr names_scope_ptr= class_members.lock_imut().deref().GetParent().try_to_non_nullable();

		auto mut global_function_context= CreateGlobalFunctionContext();

		foreach( &parent_name : syntax_element.parents )
		{
			auto parent_type= PrepareTypeImpl( names_scope_ptr, global_function_context, parent_name );
			if( parent_type.GetClassType().empty() )
			{
				REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.src_loc, parent_type )
				continue;
			}

			var ClassTypePtr parent_class= parent_type.GetClassType().try_deref();

			auto mut duplicated= false;
			foreach( &prev_parent : parents )
			{
				duplicated|= prev_parent.class_ == parent_class;
			}
			if( duplicated )
			{
				REPORT_ERROR( DuplicatedParentClass, names_scope_ptr, syntax_element.src_loc, parent_type )
				continue;
			}

			{ // Give access from this class to protected members of all ancestor classes.
				auto mut members_lock= class_members.lock_mut();
				AddAncestorsAccessRights_r( members_lock.deref(), parent_class );
			}

			parents.push_back( ClassType::Parent{ .class_= parent_class } );
		}
	}

	auto mut lock= class_type.lock_mut();
	var ClassType& mut class_= lock.deref();
	class_.parents_list_prepared= true;
	class_.parents= move(parents);
}

fn CodeBuilder::BuildClass( mut this, NamesScopePtr& names_scope_ptr, ClassTypePtr& class_type )
{
	if( class_type.lock_imut().deref().is_complete )
	{
		return;
	}
	with( mut lock : class_type.lock_imut() )
	{
		auto mut description_opt= lock.deref().generated_class_data.get</ TypeinfoClassDescription />();
		if( !description_opt.empty() )
		{
			var Type t= description_opt.try_deref().source_type;
			move(description_opt);
			move(lock);
			BuildFullTypeinfo( t );
			return;
		}
	}
	if( class_type.lock_imut().deref().syntax_element.empty() )
	{
		return;
	}

	PrepareClassParentsList( class_type );

	GLOBALS_LOOP_DETECT( class_type )

	auto syntax_element_ptr= class_type.lock_imut().deref().syntax_element;
	auto& syntax_element= syntax_element_ptr.try_deref();

	auto mut global_function_context= CreateGlobalFunctionContext();

	// Perform remaining check of parents.
	{
		auto parents= class_type.lock_imut().deref().parents;

		var ust::shared_ptr_nullable_mut</ClassType/> mut base_class;
		foreach( &parent : parents )
		{
			var ClassTypePtr& parent_class= parent.class_;
			var Type parent_type= parent_class;

			if( !EnsureTypeComplete( parent_class ) )
			{
				REPORT_ERROR( UsingIncompleteType, names_scope_ptr, syntax_element.src_loc, parent_type )
				return;
			}

			auto parent_kind= parent_class.lock_imut().deref().kind;
			if( !( parent_kind == ClassType::Kind::Abstract || parent_kind == ClassType::Kind::Interface || parent_kind == ClassType::Kind::PolymorphNonFinal ) )
			{
				REPORT_ERROR( CanNotDeriveFromThisType, names_scope_ptr, syntax_element.src_loc, parent_type )
				return;
			}

			if( parent_kind != ClassType::Kind::Interface ) // not interface=base
			{
				if( !base_class.empty() )
				{
					REPORT_ERROR( DuplicatedBaseClass, names_scope_ptr, syntax_element.src_loc, parent_type )
					return;
				}
				base_class= parent_class;
			}
		}

		auto mut class_lock= class_type.lock_mut();
		auto &mut class_= class_lock.deref();
		class_.base_class= move(base_class);
	}

	// Pre-mark class as polymorph, because it's needed for functions checks. Exact kind of class we will known later.
	with( mut lock : class_type.lock_mut() )
	{
		auto &mut class_= lock.deref();

		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
			syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
			!syntax_element.parents.empty() )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else
		{
			class_.kind= ClassType::Kind::NonPolymorph;
		}

		// Set also "nodiscard" flag.
		class_.no_discard= syntax_element.no_discard;
	}

	// Prepare fields types.
	auto class_members= class_type.lock_imut().deref().members;
	auto mut field_count= 0u;
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto field_ptr= member.value().Get</ ClassField />();
		if( !field_ptr.empty() )
		{
			++field_count;

			auto mut field_lock= field_ptr.try_lock_mut();
			var ClassField &mut field= field_lock.deref();

			field.t= PrepareType( class_members, global_function_context, field.syntax_element.deref().t );

			if( !EnsureTypeComplete( field.t ) )
			{
				REPORT_ERROR( UsingIncompleteType, class_members, field.syntax_element.deref().src_loc, field.t )
				field.t= invalid_type_;
				continue;
			}
			if( !field.is_reference && field.t.IsAbstract() )
			{
				REPORT_ERROR( ConstructingAbstractClassOrInterface, names_scope_ptr, field.syntax_element.deref().src_loc, field.t )
				continue;
			}
			if( field.is_reference )
			{
				auto reference_tag_count= field.t.ReferenceTagCount();
				if( reference_tag_count > 0u )
				{
					if( field.t.GetSecondOrderInnerReferenceKind(0s) != SecondOrderInnerReferenceKind::None )
					{
						REPORT_ERROR( ReferenceIndirectionDepthExceeded, names_scope_ptr, field.syntax_element.deref().src_loc, 2, field.syntax_element.deref().name )
						field.t= invalid_type_;
						continue;
					}

					if( reference_tag_count > 1u )
					{
						REPORT_ERROR( MoreThanOneInnerReferenceTagForSecondOrderReferenceField, names_scope_ptr, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
						field.t= invalid_type_;
						continue;
					}
				}
			}
		}
	}

	// Allocate virtual table pointer, if class has no parents.
	// If class has at least one parent, reuse it's virtual table pointer.
	auto allocate_virtual_table_pointer= syntax_element.parents.empty() && (
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface );

	// Determine class data layout.
	var ust::vector</ LLVMTypeRef /> mut fields_llvm_types;

	if( allocate_virtual_table_pointer )
	{
		fields_llvm_types.push_back( unsafe( LLVMPointerType( fundamental_llvm_types_.size_type_, 0u ) ) );// set exact type later.
	}

	with( mut lock : class_type.lock_mut() )
	{
		// Make base class first field. Add parent classes fields.
		auto &mut class_= lock.deref();

		auto base_class= class_.base_class;
		if( !base_class.empty() )
		{
			fields_llvm_types.push_back( base_class.try_lock_imut().deref().llvm_type );
		}

		foreach( &mut parent : class_.parents )
		{
			if( parent.class_ != base_class )
			{
				parent.field_number= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( parent.class_.lock_imut().deref().llvm_type );
			}
			else
			{
				parent.field_number= 0u;
			}
		}
	}
	{
		var ust::vector</ ust::shared_ptr_mut</ClassField/> /> mut fields_left;
		foreach( &member : class_members.lock_imut().deref() )
		{
			auto field_ptr= member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				fields_left.push_back( field_ptr.try_to_non_nullable() );
			}
		}

		// Calculate start offset, include parents fields, virtual table pointer.
		var u32 mut current_offset= 0u;
		foreach( llvm_type : fields_llvm_types )
		{
			var u32 alignment= unsafe( LLVMABIAlignmentOfType( data_layout_, llvm_type ) );
			var u32 padding= ( alignment - current_offset % alignment ) % alignment;
			current_offset+= padding;
			current_offset+= u32( unsafe( LLVMABISizeOfType( data_layout_, llvm_type ) ) );
		}

		var ust::vector</ClassType::FieldOrdered/> mut fields_order;
		if( syntax_element.keep_fields_order )
		{
			// Sort fields by original index.
			// TODO - use libary sorting function?
			while( !fields_left.empty() )
			{
				var u32 mut min_original_index= ~0u;
				var size_type mut min_index_index= ~0s;
				for( auto mut i= 0s; i < fields_left.size(); ++i )
				{
					var u32 original_index= fields_left[i].lock_imut().deref().original_index;
					if( original_index < min_original_index )
					{
						min_original_index= original_index;
						min_index_index= i;
					}
				}

				auto fields_left_size= fields_left.size();
				fields_left.swap( min_index_index, fields_left_size - 1s );
				auto field_ptr= fields_left.pop_back();

				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				auto mut llvm_type= field.t.GetLLVMType();
				if( field.is_reference ) { llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) ); }

				field.index= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( llvm_type );
				fields_order.push_back( ust::make_tuple( field.syntax_element.deref().name, field_ptr ) );
			}
		}
		else
		{
			while( !fields_left.empty() )
			{
				// Find best fit field with minimal original index (try to keep original fields order).
				var u32 mut best_field_padding= ~0u;
				auto mut best_padding_field_index= 0s;
				for( auto mut i= 0s; i < fields_left.size(); ++i )
				{
					auto field_lock= fields_left[i].lock_imut();
					var ClassField& field= field_lock.deref();
					auto mut llvm_type= field.t.GetLLVMType();
					if( field.is_reference ) { llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) ); }

					var u32 alignment= unsafe( LLVMABIAlignmentOfType( data_layout_, llvm_type ) );
					var u32 padding= ( alignment - current_offset % alignment ) % alignment;
					if( padding < best_field_padding )
					{
						best_field_padding= padding;
						best_padding_field_index= i;
					}
					else if( padding == best_field_padding )
					{
						// Prefer first field with same padding.
						if( field.original_index < cast_imut(fields_left)[best_padding_field_index].lock_imut().deref().original_index )
						{
							best_padding_field_index= i;
						}
					}
				}

				auto fields_left_size= fields_left.size();
				fields_left.swap( best_padding_field_index, fields_left_size - 1s );
				auto field_ptr= fields_left.pop_back();

				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				auto mut llvm_type= field.t.GetLLVMType();
				if( field.is_reference ) { llvm_type= unsafe( LLVMPointerType( llvm_type, 0u ) ); }

				field.index= u32(fields_llvm_types.size());
				fields_llvm_types.push_back( llvm_type );
				fields_order.push_back( ust::make_tuple( field.syntax_element.deref().name, field_ptr ) );

				current_offset+= best_field_padding;
				current_offset+= u32( unsafe( LLVMABISizeOfType( data_layout_, llvm_type ) ) );
			}
		}

		auto mut lock= class_type.lock_mut();
		lock.deref().fields_order= move(fields_order);
	}

	// Setup inner reference kind. Do this before methods generation and virtual table preparation.
	{
		var ust::vector</ClassFieldPtr/> mut reference_fields;
		var ust::vector</ClassFieldPtr/> mut fields_with_references_inside;
		var ust::vector</ClassFieldPtr/> mut fields_with_no_references_inside_but_inner_references_notation;

		var bool mut has_parents_with_references_inside= false;
		var bool mut has_fields_with_reference_notation= false;

		with( mut lock : class_type.lock_mut() )
		{
			auto &mut class_= lock.deref();

			// Inherit inner references of parents.
			// Normally any reference may be inhhereted only from base, but not interfaces.
			class_.inner_references.clear();
			if( !class_.base_class.empty() )
			{
				class_.inner_references= class_.base_class.try_lock_imut().deref().inner_references;
			}
			has_parents_with_references_inside= !class_.inner_references.empty();

			// Collect fields for which reference notation is required.
			foreach( &field_pair : class_.fields_order )
			{
				auto& field_ptr= field_pair[1];
				auto field_lock= field_ptr.lock_imut();
				var ClassField& field= field_lock.deref();

				if( field.is_reference )
				{
					reference_fields.push_back( field_ptr );

					if( !field.syntax_element.deref().inner_reference_tags_expression.has</Synt::EmptyVariant/>() )
					{
						// Reference tags of a struct are used only for reference fields or value fields with references inside.
						// They are not used for second order references.
						// So, they are useless or even confusing.
						REPORT_ERROR( InnerReferenceTagsForReferenceField, class_members, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
					}
				}
				else
				{
					if( field.t.ReferenceTagCount() > 0u )
					{
						fields_with_references_inside.push_back( field_ptr );
					}
					else
					{
						fields_with_no_references_inside_but_inner_references_notation.push_back( field_ptr );
					}
				}

				has_fields_with_reference_notation |=
					!field.syntax_element.deref().reference_tag_expression.has</Synt::EmptyVariant/>() ||
					!field.syntax_element.deref().inner_reference_tags_expression.has</Synt::EmptyVariant/>();
			}
		}

		foreach( & field_ptr : fields_with_no_references_inside_but_inner_references_notation )
		{
			auto field_lock= field_ptr.lock_imut();
			var ClassField& field= field_lock.deref();

			if( !field.syntax_element.deref().inner_reference_tags_expression.has</Synt::EmptyVariant/>() )
			{
				if_var( &reference_tags : EvaluateReferenceFieldInnerTags( class_members, global_function_context, field.syntax_element.deref().inner_reference_tags_expression ) )
				{
					if( !reference_tags.empty() )
					{
						REPORT_ERROR( InnerReferenceTagCountMismatch, class_members, field.syntax_element.deref().src_loc, 0, reference_tags.size() )
					}
				}
			}
		}

		if( reference_fields.size() == 1s && fields_with_references_inside.size() == 0s && !has_fields_with_reference_notation && !has_parents_with_references_inside )
		{
			// Special case - class contains single reference field.
			auto mut field_lock= reference_fields.front().lock_mut();
			var ClassField &mut field= field_lock.deref();

			auto mut class_lock= class_type.lock_mut();
			var ClassType& mut class_= class_lock.deref();

			field.reference_tag= 0u8;
			class_.inner_references.push_back( InnerReference{ .kind= ( field.is_mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut ) } );
		}
		else if( reference_fields.size() == 0s && fields_with_references_inside.size() == 1s && !has_fields_with_reference_notation && !has_parents_with_references_inside )
		{
			// Special case - class contains single field with references inside. Map reference tags of this field to reference tags of the whole class.
			auto mut field_lock= fields_with_references_inside.front().lock_mut();
			var ClassField &mut field= field_lock.deref();

			auto mut class_lock= class_type.lock_mut();
			var ClassType& mut class_= class_lock.deref();

			auto reference_tag_count= field.t.ReferenceTagCount();
			field.inner_reference_tags.resize( size_type(reference_tag_count), u8(0) );
			for( auto mut i= 0s; i < size_type(reference_tag_count); ++i )
			{
				field.inner_reference_tags[i]= u8(i);
				class_.inner_references.push_back( InnerReference{ .kind= field.t.GetInnerReferenceKind(i) } );
			}
		}
		else
		{
			// General case - require reference notation.

			foreach( &field_ptr : reference_fields )
			{
				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				var ust::optional</u8/> mut reference_tag;
				if( !field.syntax_element.deref().reference_tag_expression.has</Synt::EmptyVariant/>() )
				{
					reference_tag= EvaluateReferenceFieldTag( class_members, global_function_context, field.syntax_element.deref().reference_tag_expression );
				}
				else
				{
					REPORT_ERROR( ExpectedReferenceNotation, class_members, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
				}

				auto mut class_lock= class_type.lock_mut();
				var ClassType& mut class_= class_lock.deref();

				var InnerReferenceKind inner_reference_kind= ( field.is_mutable ? InnerReferenceKind::Mut : InnerReferenceKind::Imut );

				if_var( tag : reference_tag )
				{
					field.reference_tag= tag;

					if( size_type(tag) >= class_.inner_references.size() )
					{
						class_.inner_references.resize( size_type(tag) + 1s, InnerReference{ .kind= InnerReferenceKind::Imut } );
					}

					class_.inner_references[ size_type(tag) ].kind= inner_reference_kind;
				}
				else
				{
					// Fallback for error cases with no notation - link reference field with tag 0.
					field.reference_tag= 0u8;
					if( class_.inner_references.empty() )
					{
						class_.inner_references.push_back( InnerReference{ .kind= InnerReferenceKind::Imut } );
					}
					class_.inner_references[ size_type(field.reference_tag) ].kind= inner_reference_kind;
				}
			}

			foreach( &field_ptr : fields_with_references_inside )
			{
				auto mut field_lock= field_ptr.lock_mut();
				var ClassField &mut field= field_lock.deref();

				var ust::optional</ust::vector</u8/>/> mut reference_tags;
				if( !field.syntax_element.deref().inner_reference_tags_expression.has</Synt::EmptyVariant/>() )
				{
					reference_tags= EvaluateReferenceFieldInnerTags( class_members, global_function_context, field.syntax_element.deref().inner_reference_tags_expression );
				}
				else
				{
					REPORT_ERROR( ExpectedReferenceNotation, class_members, field.syntax_element.deref().src_loc, field.syntax_element.deref().name )
				}

				auto mut class_lock= class_type.lock_mut();
				var ClassType& mut class_= class_lock.deref();

				auto reference_tag_count= field.t.ReferenceTagCount();

				if( !reference_tags.empty() )
				{
					field.inner_reference_tags= reference_tags.try_take();
					if( field.inner_reference_tags.size() != size_type(reference_tag_count) )
					{
						REPORT_ERROR( InnerReferenceTagCountMismatch,class_.members, field.syntax_element.deref().src_loc, reference_tag_count, field.inner_reference_tags.size() )
						field.inner_reference_tags.resize( size_type(reference_tag_count), 0u8 );
					}

					for( auto mut i= 0s; i < size_type(reference_tag_count); ++i )
					{
						auto tag= field.inner_reference_tags[i];
						if( size_type(tag) >= class_.inner_references.size() )
						{
							class_.inner_references.resize( size_type(tag) + 1s, InnerReference{ .kind= InnerReferenceKind::Imut } );
						}

						class_.inner_references[ size_type(tag) ].kind= field.t.GetInnerReferenceKind(i);
					}
				}
				else
				{
					// Fallback for error cases with no notation - link all field tags with tag 0.
					field.inner_reference_tags.resize( size_type(reference_tag_count), u8(0) );
					if( class_.inner_references.empty() )
					{
						class_.inner_references.push_back( InnerReference{ .kind= InnerReferenceKind::Imut } );
					}
				}
			}
		}

		with( mut class_lock : class_type.lock_mut() )
		{
			var ClassType& mut class_= class_lock.deref();

			// Setup second order inner references.

			foreach( &field_ptr : reference_fields )
			{
				with( &field : field_ptr.lock_imut().deref() )
				{
					if( field.t.ReferenceTagCount() > 0u )
					{
						auto i= size_type(field.reference_tag);
						var InnerReference& mut inner_reference= class_.inner_references[i];

						var SecondOrderInnerReferenceKind second_order_kind=
							( field.t.GetInnerReferenceKind(0s) == InnerReferenceKind::Imut
								? SecondOrderInnerReferenceKind::Imut
								: SecondOrderInnerReferenceKind::Mut );

						if( inner_reference.second_order_kind == SecondOrderInnerReferenceKind::None )
						{
							inner_reference.second_order_kind= second_order_kind;
						}
						else if( inner_reference.second_order_kind != second_order_kind )
						{
							var ust::string8 mut s;
							s.push_back( char8( size_type('a') + i ) );
							REPORT_ERROR( MixingMutableAndImmutableSecondOrderReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
						}
					}
				}
			}

			foreach( &field_ptr : fields_with_references_inside )
			{
				with( &field : field_ptr.lock_imut().deref() )
				{
					for( auto mut j= 0s; j < field.inner_reference_tags.size(); ++j )
					{
						auto i= size_type(field.inner_reference_tags[j]);
						var InnerReference& mut inner_reference= class_.inner_references[i];

						var SecondOrderInnerReferenceKind second_order_kind= field.t.GetSecondOrderInnerReferenceKind(j);

						if( inner_reference.second_order_kind == SecondOrderInnerReferenceKind::None )
						{
							inner_reference.second_order_kind= second_order_kind;
						}
						else if( inner_reference.second_order_kind != second_order_kind )
						{
							var ust::string8 mut s;
							s.push_back( char8( size_type('a') + i ) );
							REPORT_ERROR( MixingMutableAndImmutableSecondOrderReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
						}
					}
				}
			}
		}

		with( &class_ : class_type.lock_imut().deref() )
		{
			// Perform additional checks.
			scoped_array bool mut reference_tags_usage_flags[ class_.inner_references.size() ]( false );

			foreach( &parent : class_.parents )
			{
				with( &parent_class : parent.class_.lock_imut().deref() )
				{
					if( class_.inner_references.size() != parent_class.inner_references.size() )
					{
						// Forbid changing inner references in inheritance.
						// Otherwise it may be possible to break reference-checking rules by using virtual methods.
						// Forbidding changing inner references ensures that no control for inner references can be skipped by casting a reference to a parent with less inner references.
						REPORT_ERROR(
							ChangingReferenceTagCountInInheritance,
							class_.members,
							syntax_element.src_loc,
							parent_class.inner_references.size(),
							class_.inner_references.size() )
					}
					else
					{
						for( auto mut i= 0s; i < parent_class.inner_references.size(); ++i )
						{
							reference_tags_usage_flags[i]= true;
							if( parent_class.inner_references[i].kind != class_.inner_references[i].kind )
							{
								var ust::string8 s( 1s, char8( size_type( 'a' ) + i ) );
								REPORT_ERROR( MixingMutableAndImmutableReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
							}
							if( parent_class.inner_references[i].second_order_kind != class_.inner_references[i].second_order_kind )
							{
								var ust::string8 s( 1s, char8( size_type( 'a' ) + i ) );
								REPORT_ERROR( MixingMutableAndImmutableSecondOrderReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
							}
						}
					}
				}
			}

			foreach( &field_pair : class_.fields_order )
			{
				auto& field_ptr= field_pair[1];
				auto field_lock= field_ptr.lock_imut();
				var ClassField& field= field_lock.deref();

				if( field.is_reference )
				{
					reference_tags_usage_flags[ size_type(field.reference_tag) ]= true;
					if(
						(  field.is_mutable && class_.inner_references[ size_type(field.reference_tag) ].kind == InnerReferenceKind::Imut ) ||
						( !field.is_mutable && class_.inner_references[ size_type(field.reference_tag) ].kind == InnerReferenceKind::Mut ) )
					{
						var ust::string8 s( 1s, char8( size_type( 'a' ) + size_type(field.reference_tag) ) );
						REPORT_ERROR( MixingMutableAndImmutableReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
					}
				}

				for( auto mut i= 0s; i < field.inner_reference_tags.size(); ++i )
				{
					auto tag= field.inner_reference_tags[i];
					reference_tags_usage_flags[ size_type(tag) ]= true;

					if( class_.inner_references[ size_type(tag) ].kind != field.t.GetInnerReferenceKind(i) )
					{
						var ust::string8 s( 1s, char8( size_type( 'a' ) + size_type(tag) ) );
						REPORT_ERROR( MixingMutableAndImmutableReferencesInSameReferenceTag, class_.members, syntax_element.src_loc, s )
					}
				}
			}

			for( auto mut i= 0s; i < class_.inner_references.size(); ++i )
			{
				if( !reference_tags_usage_flags[i] )
				{
					var ust::string8 s( 1s, char8( size_type( 'a' ) + i ) );
					REPORT_ERROR( UnusedReferenceTag, class_.members, syntax_element.src_loc, s )
				}
			}
		}
	}

	// Build declarations for some necessary methods.
	// Do it before generating methods, but after setting up inner references.
	foreach( &member : class_members.lock_imut().deref() )
	{
		auto functions_set_ptr= member.value().Get</ FunctionsSet />();
		if( !functions_set_ptr.empty() )
		{
			auto& name= member.key();

			// We need to prepare special methods.
			var bool mut need_to_prepare=
				name == KeywordToString( Keyword::constructor_ ) ||
				name == KeywordToString( Keyword::destructor_ ) ||
				name == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
				name == OverloadedOperatorToString( OverloadedOperator::CompareEqual );

			if( !need_to_prepare )
			{
				// Functions declared virtual requires preparation in order to build virtual table later.
				with( &functions_set : functions_set_ptr.try_lock_imut().deref() )
				{
					foreach( &function_variable : functions_set.functions )
					{
						need_to_prepare|=
							!function_variable.prototype_syntax_element.empty() &&
							function_variable.prototype_syntax_element.try_deref().virtual_kind != Synt::Function::VirtualKind::None;
					}
					foreach( &synt_function : functions_set.syntax_elements )
					{
						need_to_prepare|= synt_function.deref().virtual_kind != Synt::Function::VirtualKind::None;
					}
				}
			}
			if( !need_to_prepare )
			{
				// Also we need to check parent for virtual functions.
				foreach( &parent : class_type.lock_imut().deref().parents )
				{
					if_var( &parent_member : parent.class_.lock_imut().deref().members.lock_imut().deref().GetThisScopeValue( name ) )
					{
						auto parent_functions_set= parent_member.Get</ FunctionsSet />();
						if( !parent_functions_set.empty() )
						{
							foreach( &parent_function : parent_functions_set.try_lock_imut().deref().functions )
							{
								need_to_prepare|= parent_function.virtual_table_index != ~0u;
							}
						}
					}
				}
			}

			if( need_to_prepare )
			{
				PrepareFunctionsSet( class_members, functions_set_ptr.try_to_non_nullable() );
			}
		}
	}

	// Generate destructor prototype before perparing virtual table to mark it as virtual and setup virtual table index.
	TryGenerateDestructorPrototype( class_type );

	// Prepare virtual table.
	if( !syntax_element.parents.empty() ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface ||
		syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
	{
		PrepareClassVirtualTable( class_type );
		PrepareClassVirtualTableType( class_type );
		if( allocate_virtual_table_pointer )
		{
			fields_llvm_types.front()= unsafe( LLVMPointerType( class_type.lock_imut().deref().virtual_table_llvm_type, 0u ) );
		}
	}

	with( mut lock : class_type.lock_mut() )
	{
		var ClassType &mut class_= lock.deref();

		unsafe
		{
			// Check opaque before set body for cases of errors (class body duplication).
			if( LLVMIsOpaqueStruct( class_.llvm_type ) == LLVMBool::True )
			{
				LLVMStructSetBody( class_.llvm_type, fields_llvm_types.data(), u32(fields_llvm_types.size()), LLVMBool::False );
			}
		}
	}

	// Setup class kind.
	with( mut lock : class_type.lock_mut() )
	{
		auto &mut class_= lock.deref();

		auto mut class_contains_pure_virtual_functions= false;
		foreach( &virtual_table_entry : class_.virtual_table )
		{
			class_contains_pure_virtual_functions|= virtual_table_entry.is_pure;
		}

		auto has_parents= class_.parents.empty();
		if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Struct )
		{
			class_.kind= ClassType::Kind::Struct;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Class )
		{
			class_.kind= ( has_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphNonFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Final )
		{
			class_.kind= ( has_parents ? ClassType::Kind::NonPolymorph : ClassType::Kind::PolymorphFinal );
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Polymorph )
		{
			class_.kind= ClassType::Kind::PolymorphNonFinal;
			if( class_contains_pure_virtual_functions )
			{
				REPORT_ERROR( ClassContainsPureVirtualFunctions, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
				class_.kind= ClassType::Kind::Abstract;
			}
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Interface )
		{
			if( !class_.base_class.empty() )
			{
				REPORT_ERROR( BaseClassForInterface, names_scope_ptr, syntax_element.src_loc )
			}
			if( field_count != 0u )
			{
				REPORT_ERROR( FieldsForInterfacesNotAllowed, names_scope_ptr, syntax_element.src_loc )
			}

			{
				// Constructors value should always exists and should always be FunctionsSet.
				auto constructors_ptr= class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ).try_deref().Get</FunctionsSet/>();
				auto constructors_lock= constructors_ptr.try_lock_imut();
				auto& constructors= constructors_lock.deref();
				if( !constructors.functions.empty() || !constructors.function_templates.empty() )
				{
					REPORT_ERROR( ConstructorForInterface, names_scope_ptr, syntax_element.src_loc )
				}
			}
			foreach( &virtual_table_entry : class_.virtual_table )
			{
				if( !virtual_table_entry.is_pure && virtual_table_entry.name != KeywordToString( Keyword::destructor_ ) )
				{
					// TODO - report using function src_loc for each function.
					REPORT_ERROR( NonPureVirtualFunctionInInterface, names_scope_ptr, syntax_element.src_loc, syntax_element.name )
					break;
				}
			}

			class_.kind= ClassType::Kind::Interface;
		}
		else if( syntax_element.kind_attribute == Synt::Class::KindAttribute::Abstract )
		{
			class_.kind= ClassType::Kind::Abstract;
		}
		else{ halt; }
	}

	with( mut lock : class_type.lock_mut() )
	{ // Setup "constexpr" property. Do this before methods generation.
		auto &mut class_= lock.deref();

		class_.can_be_constexpr= class_.kind == ClassType::Kind::Struct;

		foreach( &member : class_members.lock_imut().deref() )
		{
			auto field_ptr= member.value().Get</ ClassField />();
			if( !field_ptr.empty() )
			{
				auto field_lock= field_ptr.try_lock_imut();
				auto& field= field_lock.deref();
				// Disable constexpr, if field type can not be constexpr, or if field is mutable reference.
				class_.can_be_constexpr&= field.t.CanBeConstexpr() && !( field.is_mutable && field.is_reference );
			}

			// Disable constexpr possibility for structs with:
			// * explicit destructors
			// * non-default copy-assignment operators
			// * non-default copy constructors
			// * non-default equality compare operators
			auto functions_set_ptr= member.value().Get</ FunctionsSet />();
			if( !functions_set_ptr.empty() )
			{
				foreach( &function : functions_set_ptr.try_lock_imut().deref().functions )
				{
					if( member.key() == KeywordToString( Keyword::destructor_ ) &&
						!function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == KeywordToString( Keyword::constructor_ ) &&
						IsCopyConstructor( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) &&
						IsCopyAssignmentOperator( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
					if( member.key() == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) &&
						IsEqualityCompareOperator( function, class_type ) && !function.is_generated )
					{
						class_.can_be_constexpr= false;
					}
				}
			}
		}
	}

	BuildClassPolymorphTypeId( class_type );
	BuildClassVirtualTable( class_type );

	TryGenerateDefaultConstructor( class_type );
	TryGenerateCopyConstructor( class_type );
	TryGenerateCopyAssignmentOperator( class_type );
	TryGenerateEqualityCompareOperator( class_type );
	TryGenerateDestructor( class_type );

	with( mut lock : class_type.lock_mut() )
	{
		var ClassType &mut class_= lock.deref();

		// Search for explicit noncopy constructors.
		if_var( constructors : class_members.lock_imut().deref().GetThisScopeValue( KeywordToString( Keyword::constructor_ ) ) )
		{
			auto functions_set_ptr= constructors.Get</FunctionsSet/>();
			auto lock= functions_set_ptr.try_lock_imut();
			var FunctionsSet& functions_set= lock.deref();
			// Should be functions set 100%
			foreach( &function_variable : functions_set.functions )
			{
				if( function_variable.is_generated )
				{
					continue;
				}

				if( IsDefaultConstructor( function_variable, class_type ) )
				{
					class_.has_explicit_noncopy_constructors= true;
				}
				else if( IsCopyConstructor( function_variable, class_type ) ) {}
				else
				{
					class_.has_explicit_noncopy_constructors= true;
				}
			}
			class_.has_explicit_noncopy_constructors |= !functions_set.function_templates.empty();
		}
	}

	// Merge functions sets of parents into functions sets of this class.
	// Do the same for type templates sets.
	// Merge functions sets in order to have possibility to fetch functions sets, combined from sets of multiple parents.
	// Do not borrow other kinds of symbols (type aliases, variables, etc.) in order to avoid global things build inside wrong namespace.
	with( parents : class_type.lock_imut().deref().parents )
	{
		foreach( &parent : parents )
		{
			auto parent_members= parent.class_.lock_imut().deref().members;
			foreach( &member_value : parent_members.lock_imut().deref() )
			{
				auto parent_member_visibility= parent.class_.lock_imut().deref().GetMemberVisibility( member_value.key() );
				if( parent_member_visibility == Synt::ClassVisibility::Private )
				{
					continue; // Do not inherit private members.
				}

				var bool has_name = !class_members.lock_imut().deref().GetThisScopeValue( member_value.key() ).empty();

				auto src_functions_set_nullable_ptr= member_value.value().Get</FunctionsSet/>();
				if( !src_functions_set_nullable_ptr.empty() )
				{
					// SPARCHE_TODO - maybe also skip compound-assignment operators?
					if( member_value.key() == KeywordToString( Keyword::constructor_ ) ||
						member_value.key() == KeywordToString( Keyword::destructor_ ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) ||
						member_value.key() == OverloadedOperatorToString( OverloadedOperator::CompareOrder ) )
					{
						continue; // Did not inherit constructors, destructors, assignment operators, compare operators.
					}

					auto src_functions_set_ptr= src_functions_set_nullable_ptr.try_to_non_nullable();

					// Prepare source functions set before merging.
					PrepareFunctionsSet( parent_members, src_functions_set_ptr );

					auto src_functions_set_lock= src_functions_set_ptr.lock_imut();
					auto& src_functions_set= src_functions_set_lock.deref();
					if( has_name )
					{
						auto result_functions_set_nullable_ptr= class_members.lock_imut().deref().GetThisScopeValue( member_value.key() ).try_deref().Get</FunctionsSet/>();
						if( !result_functions_set_nullable_ptr.empty() )
						{
							auto result_functions_set_ptr= result_functions_set_nullable_ptr.try_to_non_nullable();

							// Prepare destination functions set before merging.
							PrepareFunctionsSet( class_members, result_functions_set_ptr );

							// Merge functions sets.
							auto mut result_functions_set_lock= result_functions_set_ptr.lock_mut();
							auto &mut result_functions_set= result_functions_set_lock.deref();

							if( parent_member_visibility != class_type.lock_imut().deref().GetMemberVisibility( member_value.key() ) )
							{
								var SrcLoc mut src_loc= syntax_element.src_loc;
								if( !result_functions_set.functions.empty() )
								{
									auto& f= result_functions_set.functions.front();
									if_var( &prototype_syntax_element : f.prototype_syntax_element )
									{
										src_loc= prototype_syntax_element.src_loc;
									}
									if_var( &body_syntax_element : f.body_syntax_element )
									{
										src_loc= body_syntax_element.src_loc;
									}
								}
								else if( !result_functions_set.function_templates.empty() )
								{
									src_loc= result_functions_set.function_templates.front().lock_imut().deref().syntax_element.deref().src_loc;
								}
								REPORT_ERROR( FunctionsVisibilityMismatch, names_scope_ptr, src_loc, member_value.key() )
							}

							foreach( &src_function : src_functions_set.functions )
							{
								if( !GetFunctionWithSameType( result_functions_set, src_function.t ).empty() )
								{
									continue; // New class function shadows function with same type in source class, so, skip it.
								}
								if( ApplyOverloadedFunction( result_functions_set, src_function, class_members, syntax_element.src_loc ) )
								{
									result_functions_set.functions.back().is_inherited= true;
								}
							}

							// TODO - merge function templates smarter.
							foreach( &function_template : src_functions_set.function_templates )
							{
								result_functions_set.function_templates.push_back( function_template );
							}
						}
					}
					else
					{
						// Copy functions set value itself, not just shared_ptr.
						var FunctionsSet mut functions_set_copy= src_functions_set;
						foreach( &mut function : functions_set_copy.functions )
						{
							function.is_inherited= true;
						}

						with( mut dst_members_lock : class_members.lock_mut() )
						{
							dst_members_lock.deref().AddName( member_value.key(), NamesScopeValue( move(functions_set_copy) ) );
						}

						auto mut lock= class_type.lock_mut();
						lock.deref().SetMemberVisibility( member_value.key(), parent_member_visibility );
					}
				} // if function set
				auto src_type_templates_set_nullable_ptr= member_value.value().Get</TypeTemplatesSet/>();
				if( !src_type_templates_set_nullable_ptr.empty() )
				{
					auto src_type_templates_set_ptr= src_type_templates_set_nullable_ptr.try_to_non_nullable();

					// Build source type templates set before merging.
					BuiltTypeTemplatesSet( parent_members, src_type_templates_set_ptr );

					auto src_type_templates_set_lock= src_type_templates_set_ptr.lock_imut();
					auto& src_type_templates_set= src_type_templates_set_lock.deref();

					if( has_name )
					{
						auto result_type_templates_set_ptr= class_members.lock_imut().deref().GetThisScopeValue( member_value.key() ).try_deref().Get</TypeTemplatesSet/>().try_to_non_nullable();

						// Build destination type templates set before merging.
						BuiltTypeTemplatesSet( class_members, result_type_templates_set_ptr );

						// Merge type template sets.
						auto mut result_type_templates_set_lock= result_type_templates_set_ptr.lock_mut();
						auto &mut result_type_templates_set= result_type_templates_set_lock.deref();

						if( parent_member_visibility != class_type.lock_imut().deref().GetMemberVisibility( member_value.key() ) )
						{
							var SrcLoc mut src_loc;
							if( !result_type_templates_set.type_templates.empty() )
							{
								src_loc= result_type_templates_set.type_templates.front().lock_imut().deref().syntax_element.deref().src_loc;
							}
							REPORT_ERROR( TypeTemplatesVisibilityMismatch, names_scope_ptr, src_loc, member_value.key() )
						}

						foreach( &src_type_template : src_type_templates_set.type_templates ) label type_templates_loop
						{
							foreach( &result_type_template : result_type_templates_set.type_templates )
							{
								if( src_type_template.lock_imut().deref().signature_params == result_type_template.lock_imut().deref().signature_params )
								{
									// Overrides.
									continue label type_templates_loop;
								}
							}

							result_type_templates_set.type_templates.push_back( src_type_template );
						}
					}
					else
					{
						// Copy type templates set value itself, not just shared_ptr.
						// TODO - set "inherited" flag.
						var NamesScopeValue mut value_for_copy(src_type_templates_set);

						with( mut dst_members_lock : class_members.lock_mut() )
						{
							dst_members_lock.deref().AddName( member_value.key(), move(value_for_copy) );
						}
						auto mut lock= class_type.lock_mut();
						lock.deref().SetMemberVisibility( member_value.key(), parent_member_visibility );
					}
				} // if type templates set
			} // for parent members
		} // for parents
	}

	// Finally, make class complete.
	with( mut lock : class_type.lock_mut() )
	{
		lock.deref().is_complete= true;
	}

	CheckClassFieldsInitializers( class_type );
}

fn CodeBuilder::BuildEnum( mut this, NamesScopePtr& names_scope_ptr, EnumTypePtr& enum_type )
{
	if( enum_type.lock_imut().deref().underlying_type.llvm_type != LLVMTypeRef::Null )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( enum_type )

	auto enum_declaration_ptr= enum_type.lock_imut().deref().syntax_element;
	auto& enum_declaration= enum_declaration_ptr.deref();

	var FundamentalType mut underlying_type;

	if_var( &underlying_type_name : enum_declaration.underlying_type )
	{
		var FunctionContext mut function_context= CreateGlobalFunctionContext();
		auto t= PrepareTypeImpl( names_scope_ptr, function_context, underlying_type_name );

		auto fundamental_type= t.GetFundamentalType();
		if( fundamental_type.empty() || !IsInteger( fundamental_type.try_deref().fundamental_type ) )
		{
			// SPRACHE_TODO - maybe allow inheritance of enums?
			REPORT_ERROR( TypesMismatch, names_scope_ptr, enum_declaration.src_loc, "any integer type", t )
			underlying_type= FundamentalType( U_FundamentalType::u8_, fundamental_llvm_types_.u8_ );
		}
		else
		{
			underlying_type= fundamental_type.try_deref();
		}

		var u64 bit_width( GetFundamentalTypeSize( underlying_type.fundamental_type ) * 8u );
		if( bit_width < 32u64 ) // Assume that 64 bits are enough for all enums.
		{
			auto max_value_plus_one=
				1u64 << ( bit_width - ( IsSignedInteger( underlying_type.fundamental_type ) ? 1u64 : 0u64 ) );
			auto max_value= max_value_plus_one - 1u64;

			if( u64(enum_declaration.elements.size()) > max_value )
			{
				REPORT_ERROR( UnderlyingTypeForEnumIsTooSmall, names_scope_ptr, enum_declaration.src_loc, enum_declaration.elements.size() - 1s, max_value )
			}
		}
	}
	else
	{
		switch( enum_declaration.elements.size() )
		{
			0s ->
			{
				// Technically this branch is unreachable due to syntax analyzer limitations - it always should parse at least one element.
				REPORT_ERROR( NotImplemented, names_scope_ptr, enum_declaration.src_loc, "zero element enums" )
				underlying_type= FundamentalType( U_FundamentalType::u8_, fundamental_llvm_types_.u8_ );
			},
			1s ... 256s ->
			{ underlying_type= FundamentalType( U_FundamentalType::u8_ , fundamental_llvm_types_.u8_  ); },
			257s ... 65536s ->
			{ underlying_type= FundamentalType( U_FundamentalType::u16_, fundamental_llvm_types_.u16_ ); },
			65537s ... ->
			{ underlying_type= FundamentalType( U_FundamentalType::u32_, fundamental_llvm_types_.u32_ ); },
		}
	}

	var NamesScopePtr enum_inernal_names_scope= enum_type.lock_imut().deref().names_scope;

	var ust::unordered_map</ ust::string8, Enum::Element /> mut enum_elements;
	foreach( &element : enum_declaration.elements )
	{
		if( IsKeyword( element.name ) )
		{
			REPORT_ERROR( UsingKeywordAsName, names_scope_ptr, element.src_loc )
		}

		if( enum_elements.exists( element.name ) )
		{
			REPORT_ERROR( Redefinition,  names_scope_ptr, element.src_loc, element.name )
		}

		var Enum::Element mut out_element;

		auto name_mangled= mangler_.deref().MangleGlobalVariable( enum_inernal_names_scope.lock_imut().deref(), element.name, enum_type, true );
		out_element.constexpr_value= unsafe( LLVMConstInt( underlying_type.llvm_type, u64(enum_elements.size()), LLVMBool::False ) );
		out_element.llvm_value= AddGlobalConstantVariable( name_mangled, underlying_type.llvm_type, out_element.constexpr_value );

		enum_elements.insert( element.name, move(out_element) );
	}

	// Finally, update enum itself.
	auto mut lock= enum_type.lock_mut();
	var Enum &mut enum_= lock.deref();
	enum_.underlying_type= move(underlying_type);
	enum_.elements= move(enum_elements);
	enum_.no_discard= enum_declaration.no_discard;
}

fn CodeBuilder::BuildTypeAlias( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</TypeAlias/>& type_alias_ptr )
{
	if( !type_alias_ptr.lock_imut().deref().t.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( type_alias_ptr )

	auto syntax_element_ptr= type_alias_ptr.lock_imut().deref().syntax_element;

	var FunctionContext mut function_context= CreateGlobalFunctionContext();
	var Type mut t= PrepareType( names_scope_ptr, function_context, syntax_element_ptr.deref().type_name );

	// Finally, update type alias.
	auto mut lock= type_alias_ptr.lock_mut();
	lock.deref().t.reset( move(t) );
}

fn CodeBuilder::BuiltTypeTemplatesSet( mut this, NamesScopePtr& names_scope, ust::shared_ptr_mut</TypeTemplatesSet/>& type_templates_set_ptr )
{
	if( type_templates_set_ptr.lock_imut().deref().syntax_elements.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( type_templates_set_ptr )

	// Process copy of shared pointer value.
	var TypeTemplatesSet mut type_templates_set= type_templates_set_ptr.lock_imut().deref();

	while( !type_templates_set.syntax_elements.empty() )
	{
		auto syntax_element= type_templates_set.syntax_elements.pop_back();
		PrepareTypeTemplate( names_scope, syntax_element, type_templates_set );
	}

	// Finally, update value in shared pointer.
	auto mut lock= type_templates_set_ptr.lock_mut();
	lock.deref()= move(type_templates_set);
}

fn CodeBuilder::BuildGlobalVariable( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalVariable/>& global_variable_ptr )
{
	if( !global_variable_ptr.lock_imut().deref().variable.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( global_variable_ptr )

	auto variables_declaration_ptr= global_variable_ptr.lock_imut().deref().syntax_element;
	auto& variables_declaration= variables_declaration_ptr.deref();
	auto& variable_declaration= variables_declaration.variables[ size_type(global_variable_ptr.lock_imut().deref().variable_index) ];

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	var bool is_mutable= variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable;
	var Type t= PrepareType( names_scope_ptr, function_context, variables_declaration.t );

	if( !EnsureTypeComplete( t ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope_ptr, variables_declaration.src_loc, t )
		return;
	}
	if( !t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope_ptr, variable_declaration.src_loc )
		return;
	}

	auto mut variable_ptr=
		Variable
		{
			.t= t,
			.value_type= ( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
			.location= Variable::Location::Pointer,
			.name= variable_declaration.name,
		}.CreatePtr();

	auto mut constexpr_value= LLVMValueRef::Null;
	if( variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= mangler_.deref().MangleGlobalVariable( names_scope_ptr.lock_imut().deref(), variable_declaration.name, t, !is_mutable );
		auto llvm_value= ( is_mutable
			? AddGlobalMutableVariable( name_mangled, t.GetLLVMType(), variable_declaration.src_loc )
			: AddGlobalConstantVariable( name_mangled, t.GetLLVMType(), LLVMValueRef::Null ) );

		if( variable_declaration.is_thread_local )
		{
			debug_assert( is_mutable ); // All thread-local vaiables should be mutable.
			unsafe( LLVMSetThreadLocal( llvm_value, LLVMBool::True ) );
		}

		with( mut lock : variable_ptr.lock_mut() )
		{
			lock.deref().llvm_value= llvm_value;
		}

		function_context.references_graph.AddNode( variable_ptr );
		{
			var VariablePtr variable_for_initialization_ptr=
				Variable
				{
					.t= t,
					.value_type= ValueType::ReferenceMut,
					.location= Variable::Location::Pointer,
					.name= variable_declaration.name,
					.llvm_value= llvm_value,
				}.CreatePtr();

			function_context.references_graph.AddNode( variable_for_initialization_ptr );
			function_context.references_graph.AddLink( variable_ptr, variable_for_initialization_ptr );

			if( variable_declaration.initializer.has</Synt::EmptyVariant/>() )
			{
				constexpr_value= ApplyEmptyInitializer( names_scope_ptr, function_context, variable_ptr, variable_declaration.name, variable_declaration.src_loc );
			}
			else
			{
				constexpr_value= ApplyInitializer( names_scope_ptr, function_context, variable_ptr, variable_declaration.initializer );
			}

			function_context.references_graph.RemoveNode( variable_for_initialization_ptr );
		}
		function_context.references_graph.RemoveNode( variable_ptr );

		if( constexpr_value != LLVMValueRef::Null ) // May be in case of error.
		{
			unsafe( LLVMSetInitializer( llvm_value, constexpr_value ) );
		}
	}
	else if( variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( is_mutable ) // Disable global mutable references because of problems with initializers and references protection.
		{
			REPORT_ERROR( MutableGlobalReferencesAreNotAllowed, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		if( variable_declaration.initializer.has</Synt::EmptyVariant/>() )
		{
			REPORT_ERROR( ExpectedInitializer, names_scope_ptr, variable_declaration.src_loc, variable_declaration.name )
			return;
		}

		var ust::optional_ref_imut</Synt::Expression/> mut initializer_expression;
		if_var( &expression_initializer : variable_declaration.initializer.get</Synt::Expression/>() )
		{
			initializer_expression.reset(expression_initializer);
		}
		if_var( &constructor_initializer : variable_declaration.initializer.get</Synt::ConstructorInitializer/>() )
		{
			if( constructor_initializer.args.size() != 1s )
			{
				REPORT_ERROR( ReferencesHaveConstructorsWithExactlyOneParameter, names_scope_ptr, constructor_initializer.src_loc )
				return;
			}

			initializer_expression.reset( constructor_initializer.args.front().deref() );
		}

		if( initializer_expression.empty() )
		{
			REPORT_ERROR( UnsupportedInitializerForReference, names_scope_ptr, variable_declaration.src_loc )
			return;
		}

		with( &expression_result : BuildExpressionCodeEnsureVariable( names_scope_ptr, function_context, initializer_expression.try_deref() ).lock_imut().deref() )
		{
			if( expression_result.t != t )
			{
				REPORT_ERROR( TypesMismatch, names_scope_ptr, variable_declaration.src_loc, t, expression_result.t )
				return;
			}
			if( expression_result.value_type == ValueType::Value )
			{
				REPORT_ERROR( ExpectedReferenceValue, names_scope_ptr, variable_declaration.src_loc )
				return;
			}

			with( mut lock : variable_ptr.lock_mut() )
			{
				lock.deref().llvm_value= expression_result.llvm_value;
			}
			constexpr_value= expression_result.constexpr_value;
		}
	}
	else{ halt; }

	if( constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope_ptr, variable_declaration.src_loc )
		return;
	}

	if( !is_mutable )
	{
		// Set constexpr value only for immutable variables.
		with( &mut lock : variable_ptr.lock_mut() )
		{
			lock.deref().constexpr_value= constexpr_value;
		}
	}

	// TODO - maybe clear here dummy global function?

	// Finally, set result variable.
	auto mut lock= global_variable_ptr.lock_mut();
	lock.deref().variable= move(variable_ptr);
}

fn CodeBuilder::BuildGlobalAutoVariable( mut this, NamesScopePtr& names_scope_ptr, ust::shared_ptr_mut</GlobalAutoVariable/>& global_auto_variable_ptr )
{
	if( !global_auto_variable_ptr.lock_imut().deref().variable.empty() )
	{
		return;
	}

	GLOBALS_LOOP_DETECT( global_auto_variable_ptr )

	auto auto_variable_declaration_ptr= global_auto_variable_ptr.lock_imut().deref().syntax_element;
	auto& auto_variable_declaration= auto_variable_declaration_ptr.deref();

	var FunctionContext mut function_context= CreateGlobalFunctionContext();

	var bool is_mutable= auto_variable_declaration.mutability_modifier == Synt::MutabilityModifier::Mutable;

	var Variable mut variable
	{
		.location= Variable::Location::Pointer,
		.value_type= ( is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
		.name= auto_variable_declaration.name,
	};

	var VariablePtr expr_ptr= BuildExpressionCodeEnsureVariable( names_scope_ptr, function_context, auto_variable_declaration.initializer_expression );
	auto expr_lock= expr_ptr.lock_imut();
	var Variable& expr= expr_lock.deref();

	variable.t= expr.t;
	if( variable.t == invalid_type_ )
	{
		return; // Some error was generated before.
	}
	if( !variable.t.CanBeConstexpr() )
	{
		REPORT_ERROR( InvalidTypeForConstantExpressionVariable, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	// Disable global mutable references because of problems with initializers and references protection.
	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference && is_mutable )
	{
		REPORT_ERROR( MutableGlobalReferencesAreNotAllowed, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	variable.constexpr_value= expr.constexpr_value;
	if( variable.constexpr_value == LLVMValueRef::Null )
	{
		REPORT_ERROR( VariableInitializerIsNotConstantExpression, names_scope_ptr, auto_variable_declaration.src_loc )
		return;
	}

	if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::Reference )
	{
		if( expr.value_type == ValueType::Value )
		{
			REPORT_ERROR( ExpectedReferenceValue, names_scope_ptr, auto_variable_declaration.src_loc )
			return;
		}

		variable.llvm_value= expr.llvm_value;
	}
	else if( auto_variable_declaration.reference_modifier == Synt::ReferenceModifier::None )
	{
		auto name_mangled= mangler_.deref().MangleGlobalVariable( names_scope_ptr.lock_imut().deref(), auto_variable_declaration.name, variable.t, !is_mutable );
		variable.llvm_value= ( is_mutable
			? AddGlobalMutableVariable( name_mangled, variable.t.GetLLVMType(), auto_variable_declaration.src_loc )
			: AddGlobalConstantVariable( name_mangled, variable.t.GetLLVMType(), expr.constexpr_value ) );

		unsafe( LLVMSetInitializer( variable.llvm_value, expr.constexpr_value ) );
	}
	else { halt; }

	if( is_mutable )
	{
		// Reset constexpr flag for mutable variables.
		variable.constexpr_value = LLVMValueRef::Null;
	}

	// Finally, set result variable.
	auto mut lock= global_auto_variable_ptr.lock_mut();
	lock.deref().variable= move(variable).CreatePtr();
}

} // namespace U1
