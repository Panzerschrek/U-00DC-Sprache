import "/helpers.u"
import "/string_conversions.u"
import "/CodeBuilderLib/keywords.uh"
import "structs_combined.uh"

namespace U1
{

// Sizes for 8-bit pointers.
static_assert( typeinfo</Type/>.size_of <= 24s, "size of Type is too big" ); // 1 pointer for variant, 2 pointers for variant contents
static_assert( typeinfo</Value/>.size_of <= 32s, "size of Value is too big" );
static_assert( typeinfo</NamesScopeValue/>.size_of <= 16s, "size of NamesScopeValue is too big" ); // 1 pointer for variant and 1 pointer for contents.

//
// Type
//

namespace ToStringHelper
{

template</type T/>
fn ToString( ust::shared_ptr_final</T/>& b ) : ust::string8
{
	return ToString( b.deref() );
}

fn ToString( FundamentalType& fundamental_type ) : ust::string8
{
	return GetFundamentalTypeName( fundamental_type.fundamental_type );
}

fn ToString( ArrayType& array_type ) : ust::string8
{
	return ust::concat( "[ ", array_type.element_type.ToString(), ", ", ust::to_string8(array_type.element_count), " ]" );
}

fn ToString( TupleType& tuple_type ) : ust::string8
{
	var ust::string8 mut result;
	result+= KeywordToString( Keyword::tup_ );

	if( tuple_type.element_types.empty() )
	{
		result+= "[]";
		return result;
	}

	result+= "[ ";

	foreach( &element_type : tuple_type.element_types )
	{
		result+= element_type.ToString();
		if( ust::ref_cmp_ne( element_type, tuple_type.element_types.back() ) )
		{
			result+= ", ";
		}
	}

	result+= " ]";
	return result;
}

fn ToString( RawPointerType& raw_pointer_type ) : ust::string8
{
	return ust::concat( "$", "(", raw_pointer_type.element_type.ToString(), ")" );
}

fn ToString( FunctionType& function_type ) : ust::string8
{
	// TODO - add references pollution/return references

	var ust::string8 mut result;

	result+= KeywordToString( Keyword::fn_ );

	if( function_type.params.empty() )
	{
		result+= "()";
	}
	else
	{
		result+= "( ";
		result+= FunctionParamsToString( function_type.params );
		result+= " )";
	}

	if( function_type.is_unsafe )
	{
		result+= " ";
		result+= KeywordToString( Keyword::unsafe_ );
	}

	switch( function_type.calling_convention )
	{
		CallingConvention::Default -> {},
		CallingConvention::C ->
		{
			result+= " ";
			result+= KeywordToString( Keyword::call_conv_ );
			result+= " (\"";
			result+= "C";
			result+= "\")";
		},
		CallingConvention::Fast ->
		{
			result+= " ";
			result+= KeywordToString( Keyword::call_conv_ );
			result+= " (\"";
			result+= "fast";
			result+= "\")";
		},
		CallingConvention::Cold ->
		{
			result+= " ";
			result+= KeywordToString( Keyword::call_conv_ );
			result+= " (\"";
			result+= "cold";
			result+= "\")";
		},
		CallingConvention::System ->
		{
			result+= " ";
			result+= KeywordToString( Keyword::call_conv_ );
			result+= " (\"";
			result+= "system";
			result+= "\")";
		},
	}

	result+= " : ";

	result+= function_type.return_type.ToString();

	if( function_type.return_value_type == ValueType::ReferenceMut )
	{
		result+= " &mut";
	}
	if( function_type.return_value_type == ValueType::ReferenceImut )
	{
		result+= " &imut";
	}

	return result;
}

fn ToString( FunctionPointerType& function_pointer_type ) : ust::string8
{
	return ToString( function_pointer_type.function_type );
}

fn ToString( ClassTypePtr& class_type ) : ust::string8
{
	return class_type.lock_imut().deref().members.lock_imut().deref().ToString();
}

fn ToString( EnumTypePtr& enum_type ) : ust::string8
{
	return enum_type.lock_imut().deref().names_scope.lock_imut().deref().ToString();
}

} // namespace ToStringHelper

fn FundamentalType::constructor( U_FundamentalType in_fundamental_type, LLVMTypeRef in_llvm_type )
	( fundamental_type= in_fundamental_type, llvm_type= in_llvm_type )
{}

op FundamentalType::==( FundamentalType& l, FundamentalType& r ) : bool
{
	return l.fundamental_type == r.fundamental_type;
}

op ArrayType::==( ArrayType& l, ArrayType& r ) : bool
{
	return l.element_type == r.element_type && l.element_count == r.element_count;
}

op TupleType::==( TupleType& l, TupleType& r ) : bool
{
	return l.element_types == r.element_types;
}

op RawPointerType::==( RawPointerType& l, RawPointerType& r ) : bool
{
	return l.element_type == r.element_type;
}

op FunctionType::ParamReference::<=>(ParamReference& l, ParamReference& r) : i32
{
	if( l.param_index != r.param_index )
	{
		return l.param_index <=> r.param_index;
	}
	return l.reference_index <=> r.reference_index;
}

op FunctionType::ReferencePollution::<=>(ReferencePollution& l, ReferencePollution& r) : i32
{
	if( l.dst != r.dst )
	{
		return l.dst <=> r.dst;
	}
	return l.src <=> r.src;
}

fn StringToCallingConvention( ust::string_view8 s ) : ust::optional</CallingConvention/>
{
	if( s == "default" || s == "Ãœ" )
	{
		return CallingConvention::Default;
	}
	if( s == "C" )
	{
		return CallingConvention::C;
	}
	if( s == "fast" )
	{
		return CallingConvention::Fast;
	}
	if( s == "cold" )
	{
		return CallingConvention::Cold;
	}
	if( s == "system" )
	{
		return CallingConvention::System;
	}

	return ust::null_optional;
}

fn CallingConventionToString( CallingConvention c ) : ust::string_view8
{
	switch( c )
	{
	CallingConvention::Default -> { return "default"; },
	CallingConvention::C -> { return "C"; },
	CallingConvention::Fast -> { return "fast"; },
	CallingConvention::Cold -> { return "cold"; },
	CallingConvention::System -> { return "system"; },
	}
}

fn FunctionType::PointerCanBeConvertedTo( this, FunctionType& dst ) : bool
{
	if(
		this.return_type != dst.return_type ||
		( this.return_value_type == ValueType::Value ) != ( dst.return_value_type == ValueType::Value ) ||
		( this.return_value_type == ValueType::ReferenceImut && dst.return_value_type == ValueType::ReferenceMut ) || // Allow mutability conversions, except mut->imut
		( this.is_unsafe && !dst.is_unsafe ) || // Disable unsafe function to safe function conversion
		this.calling_convention != dst.calling_convention ||
		this.params.size() != dst.params.size() )
	{
		return false;
	}

	// Can convert pointer to function returning less references to pointer to function, returning more references.
	foreach( &src_param_reference : this.return_references ) label src_return_references_loop
	{
		foreach( &dst_param_reference : dst.return_references )
		{
			if( src_param_reference == dst_param_reference )
			{
				continue label src_return_references_loop;
			}
		}

		return false; // Not found.
	}

	// TODO - perform checks for inner tags.
	if( this.return_inner_references != dst.return_inner_references )
	{
		return false;
	}

	// Can convert function, linkink less references to function, linking more references.
	foreach( &src_pollution : this.references_pollution ) label src_pollution_loop
	{
		foreach( &dst_pollution : dst.references_pollution )
		{
			if( src_pollution == dst_pollution )
			{
				continue label src_pollution_loop;
			}
		}

		return false; // Not found.
	}

	foreach( pair : params.iter().zip( dst.params.iter() ) )
	{
		auto& this_param= pair.first;
		auto& dst_param= pair.second;
		if( this_param.t != dst_param.t ||
			( this_param.value_type == ValueType::Value ) != ( dst_param.value_type == ValueType::Value ) ||
			this_param.value_type == ValueType::ReferenceMut && dst_param.value_type == ValueType::ReferenceImut ) // Allow mutability conversions, except mut->imut
		{
			return false;
		}
	}

	return true;
}

fn FunctionType::ReturnsCompositeValue( this ) : bool
{
	return
		return_value_type == ValueType::Value &&
		( !return_type.GetClassType().empty() || !return_type.GetArrayType().empty() || !return_type.GetTupleType().empty() );
}

fn FunctionParamsToString( ust::array_view_imut</FunctionType::Param/> params ) : ust::string8
{
	var ust::string8 mut result;

	foreach( &param : params )
	{
		result+= param.t.ToString();
		result+= " ";

		if( param.value_type == ValueType::ReferenceMut )
		{
			result+= "&mut ";
		}
		if( param.value_type == ValueType::ReferenceImut )
		{
			result+= "&imut ";
		}

		result+= "_"; // use some dummy for param name.

		if( ust::ref_cmp_ne( param, params.back() ) )
		{
			result+= ", ";
		}
	}

	return result;
}

op FunctionPointerType::==( FunctionPointerType& l, FunctionPointerType& r ) : bool
{
	return l.function_type == r.function_type;
}

fn Type::conversion_constructor( FundamentalType mut fundamental_type )
	( something_( move(fundamental_type) ) )
{}

fn Type::conversion_constructor( ArrayType mut array_type )
	( something_( ust::make_shared_ptr_final(move(array_type)) ) )
{}

fn Type::conversion_constructor( TupleType mut tuple_type )
	( something_( ust::make_shared_ptr_final(move(tuple_type)) ) )
{}

fn Type::conversion_constructor( RawPointerType mut raw_pointer_type )
	( something_( ust::make_shared_ptr_final(move(raw_pointer_type)) ) )
{}

fn Type::conversion_constructor( FunctionPointerType mut function_pointer_type )
	( something_( ust::make_shared_ptr_final(move(function_pointer_type)) ) )
{}

fn Type::conversion_constructor( ClassTypePtr mut class_type )
	( something_( move(class_type) ) )
{}

fn Type::conversion_constructor( EnumTypePtr mut enum_type )
	( something_( move(enum_type) ) )
{}

fn Type::GetFundamentalType( imut this ) : ust::optional_ref_imut</FundamentalType /> @( ret_tags )
{
	return something_.get</FundamentalType/>();
}

fn Type::GetArrayType( imut this ) : ust::optional_ref_imut</ArrayType /> @( ret_tags )
{
	if_var( &b : something_.get</ust::shared_ptr_final</ArrayType/>/>() )
	{
		return b.deref();
	}

	return ust::null_optional_ref;
}

fn Type::GetTupleType( imut this ) : ust::optional_ref_imut</TupleType /> @( ret_tags )
{
	if_var( &b : something_.get</ust::shared_ptr_final</TupleType/>/>() )
	{
		return b.deref();
	}

	return ust::null_optional_ref;
}

fn Type::GetRawPointerType( imut this ) : ust::optional_ref_imut</RawPointerType /> @( ret_tags )
{
	if_var( &b : something_.get</ust::shared_ptr_final</RawPointerType/>/>() )
	{
		return b.deref();
	}

	return ust::null_optional_ref;
}

fn Type::GetFunctionPointerType( imut this ) : ust::optional_ref_imut</FunctionPointerType /> @( ret_tags )
{
	if_var( &b : something_.get</ust::shared_ptr_final</FunctionPointerType/>/>() )
	{
		return b.deref();
	}

	return ust::null_optional_ref;
}

fn Type::GetClassType( imut this ) : ust::optional_ref_imut</ClassTypePtr /> @( ret_tags )
{
	return something_.get</ClassTypePtr/>();
}

fn Type::GetEnumType( imut this ) : ust::optional_ref_imut</EnumTypePtr /> @( ret_tags )
{
	return something_.get</EnumTypePtr/>();
}

fn Type::GetLLVMType( this ) : LLVMTypeRef
{
	if_var( &fundamental_type : GetFundamentalType() )
	{
		return fundamental_type.llvm_type;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.llvm_type;
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.llvm_type;
	}
	if_var( &raw_pointer_type : GetRawPointerType() )
	{
		return raw_pointer_type.llvm_type;
	}
	if_var( &function_pointer_type : GetFunctionPointerType() )
	{
		return function_pointer_type.llvm_type;
	}
	if_var( &class_type_ptr : GetClassType() )
	{
		return class_type_ptr.lock_imut().deref().llvm_type;
	}
	if_var( &enum_type_ptr : GetEnumType() )
	{
		return enum_type_ptr.lock_imut().deref().underlying_type.llvm_type;
	}

	halt;
}

fn Type::IsDefaultConstructible( this ) : bool
{
	if_var( &fundamental_type : GetFundamentalType() )
	{
		return fundamental_type.fundamental_type == U_FundamentalType::void_;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count == 0u64 || array_type.element_type.IsDefaultConstructible();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().all( IsDefaultConstructible );
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_default_constructible;
	}
	return false;
}

fn Type::IsCopyConstructible( this ) : bool
{
	if( !GetFundamentalType().empty() |
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		return true;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count == 0u64 || array_type.element_type.IsCopyConstructible();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().all( IsCopyConstructible );
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_copy_constructible;
	}
	return false;
}

fn Type::IsCopyAssignable( this ) : bool
{
	if( !GetFundamentalType().empty() |
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		return true;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count == 0u64 || array_type.element_type.IsCopyAssignable();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().all( IsCopyAssignable );
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_copy_assignable;
	}
	return false;
}

fn Type::IsEqualityComparable( this ) : bool
{
	if( !GetFundamentalType().empty() |
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		return true;
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.IsEqualityComparable();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().all( IsEqualityComparable );
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().is_equality_comparable;
	}
	return false;
}

fn Type::HasDestructor( this ) : bool
{
	if_var( &class_type_ptr : GetClassType() )
	{
		// Assume all classes except typeinfo have destructors.
		return !class_type_ptr.lock_imut().deref().generated_class_data.has</ TypeinfoClassDescription />();
	}
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.HasDestructor();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().any( HasDestructor );
	}

	return false;
}

fn Type::CanBeConstexpr( this ) : bool
{
	if( !GetFundamentalType().empty() || !GetEnumType().empty() || !GetFunctionPointerType().empty() )
	{
		return true;
	}

	// Raw pointer type is not constexpr, because pointer dereference and pointer arithmetic can break functional purity of constexpr functions.

	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.CanBeConstexpr();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().all( CanBeConstexpr );
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().can_be_constexpr;
	}

	return false;
}

fn Type::IsAbstract( this ) : bool
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_count > 0u64 && array_type.element_type.IsAbstract();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().any( IsAbstract );
	}
	if_var( &class_type : GetClassType() )
	{
		auto kind= class_type.lock_imut().deref().kind;
		return kind == ClassType::Kind::Abstract || kind == ClassType::Kind::Interface;
	}

	return false;
}

fn Type::IsValidForTemplateVariableArgument( this ) : bool
{
	if( !GetEnumType().empty() )
	{
		// All enums are valid.
		return true;
	}
	else if_var( &fundamental_type : GetFundamentalType() )
	{
		return
			IsInteger( fundamental_type.fundamental_type ) ||
			IsChar( fundamental_type.fundamental_type ) ||
			IsByte( fundamental_type.fundamental_type ) ||
			fundamental_type.fundamental_type == U_FundamentalType::bool_;
	}
	else if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.IsValidForTemplateVariableArgument();
	}
	else if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().all( IsValidForTemplateVariableArgument );
	}

	return false;
}

fn Type::IsNoDiscard( this ) : bool
{
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().no_discard;
	}
	else if_var( &enum_type : GetEnumType() )
	{
		return enum_type.lock_imut().deref().no_discard;
	}
	else if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.IsNoDiscard();
	}
	else if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().any( IsNoDiscard );
	}

	// Other type kinds aren't "nodiscard".
	return false;
}

fn Type::ReferenceTagCount( this ) : u32
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.ReferenceTagCount();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		// Combine all tags of tuple elements.
		auto mut result= 0u;
		foreach( &element_type : tuple_type.element_types )
		{
			result+= element_type.ReferenceTagCount();
		}
		return result;
	}
	if_var( &class_type : GetClassType() )
	{
		return u32( class_type.lock_imut().deref().inner_references.size() );
	}

	return 0u;
}

fn Type::GetInnerReferenceKind( this, size_type index ) : InnerReferenceKind
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.GetInnerReferenceKind(index);
	}
	if_var( &tuple_type : GetTupleType() )
	{
		var size_type mut offset= 0s;
		foreach( &element_type : tuple_type.element_types )
		{
			var size_type count( element_type.ReferenceTagCount() );
			if( index >= offset && index < offset + count )
			{
				return element_type.GetInnerReferenceKind( index - offset );
			}
			offset+= count;
		}
		halt; // Unreachable.
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().inner_references[index].kind;
	}

	halt; // Unreachable.
}

fn Type::GetSecondOrderInnerReferenceKind( this, size_type index ) : SecondOrderInnerReferenceKind
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.GetSecondOrderInnerReferenceKind(index);
	}
	if_var( &tuple_type : GetTupleType() )
	{
		var size_type mut offset= 0s;
		foreach( &element_type : tuple_type.element_types )
		{
			var size_type count( element_type.ReferenceTagCount() );
			if( index >= offset && index < offset + count )
			{
				return element_type.GetSecondOrderInnerReferenceKind( index - offset );
			}
			offset+= count;
		}
		halt; // Unreachable.
	}
	if_var( &class_type : GetClassType() )
	{
		return class_type.lock_imut().deref().inner_references[index].second_order_kind;
	}

	halt; // Unreachable.
}

fn Type::GetReferenceIndirectionDepth( this ) : size_type
{
	if( !GetFundamentalType().empty() ||
		!GetEnumType().empty() ||
		!GetFunctionPointerType().empty() ||
		!GetRawPointerType().empty() )
	{
		// These types have no references inside.
		return 0s;
	}

	if_var( &class_type_ptr : GetClassType() )
	{
		with( &class_type : class_type_ptr.lock_imut().deref() )
		{
			auto mut depth= 0s;
			foreach( &inner_reference : class_type.inner_references )
			{
				// For now no more than depth 2 is possible.
				ust::max_assign( depth, 1s + ( inner_reference.second_order_kind == SecondOrderInnerReferenceKind::None ? 0s : 1s ) );
			}
			return depth;
		}
	}

	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.GetReferenceIndirectionDepth();
	}

	if_var( &tuple_type : GetTupleType() )
	{
		auto mut depth= 0s;
		foreach( &element_type : tuple_type.element_types )
		{
			ust::max_assign( depth, element_type.GetReferenceIndirectionDepth() );
		}
		return depth;
	}

	halt; // Unhandled type kind.
}

fn Type::ContainsMutableReferences( this ) : bool
{
	if_var( &array_type : GetArrayType() )
	{
		return array_type.element_type.ContainsMutableReferences();
	}
	if_var( &tuple_type : GetTupleType() )
	{
		return tuple_type.element_types.iter().any( ContainsMutableReferences );
	}
	if_var( &class_type : GetClassType() )
	{
		foreach( &inner_reference : class_type.lock_imut().deref().inner_references )
		{
			if( inner_reference.kind == InnerReferenceKind::Mut ||
				inner_reference.second_order_kind == SecondOrderInnerReferenceKind::Mut )
			{
				return true;
			}
		}
	}

	return false;
}

fn Type::ReferenceIsConvertibleTo( this, Type& dst ) : bool
{
	if( this == dst )
	{
		return true;
	}

	if_var( &src_class_type : this.GetClassType() )
	{
		if_var( &dst_class_type : dst.GetClassType() )
		{
			foreach( &parent : src_class_type.lock_imut().deref().parents )
			{
				if( dst_class_type == parent.class_ || Type(parent.class_).ReferenceIsConvertibleTo(dst) )
				{
					return true;
				}
			}
		}
	}
	return false;
}

fn Type::ToString( this ) : ust::string8
{
	variant_visit( &t : something_ )
	{
		return ToStringHelper::ToString(t);
	}
	halt;
}

template</type T/>
fn TypeEqualImpl( T& l, T& r ) : bool
{
	return l == r;
}

template</type T/>
fn TypeEqualImpl( ust::shared_ptr_final</T/>& l, ust::shared_ptr_final</T/>& r ) : bool
{
	return l.deref() == r.deref();
}

op Type::==( Type& l, Type& r ) : bool
{
	if( l.something_.index() != r.something_.index() )
	{
		return false;
	}

	variant_visit( &l_t : l.something_ )
	{
		type LeftT= typeof(l_t);
		return TypeEqualImpl( l_t, r.something_.try_get</ LeftT />() );
	}

	halt;
}

//
// ClassType
//

fn ClassType::GetMemberVisibility( this, ust::string_view8 member_name ) : Synt::ClassVisibility
{
	return members_visibility.find(member_name).deref_or( Synt::ClassVisibility::Public );
}

fn ClassType::SetMemberVisibility( mut this, ust::string_view8 member_name, Synt::ClassVisibility visibility )
{
	if( visibility == Synt::ClassVisibility::Public )
	{
		members_visibility.drop_if_exists( member_name );
	}
	else
	{
		members_visibility.insert_or_update( member_name, visibility );
	}
}

fn ClassType::HasAncestor( this, ClassTypePtr& possible_ancestor ) : bool
{
	foreach( &parent : parents )
	{
		if( parent.class_ == possible_ancestor || parent.class_.lock_imut().deref().HasAncestor( possible_ancestor ) )
		{
			return true;
		}
	}

	return false;
}

//
// Value
//

fn Variable::CreatePtr( byval mut this ) : VariablePtr
{
	this.inner_reference_nodes=
		ust::make_vector_from_filler_function(
			size_type( this.t.ReferenceTagCount() ),
			lambda[&v= this, i= 0s] mut () : VariablePtr
			{
				auto index= i;
				++i;

				return VariablePtr(
					Variable
					{
						.value_type= ( v.t.GetInnerReferenceKind(index) == InnerReferenceKind::Mut ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
						.location= Variable::Location::Pointer,
						.name= ust::concat( v.name, " inner reference ", ust::to_string8(index) ),
						.is_variable_inner_reference_node= v.value_type == ValueType::Value,
						.is_inner_reference_node= true,
					} );
			});

	return VariablePtr( move(this) );
}

fn Variable::CreateChildPtr( byval mut this, VariablePtr& parent ) : VariablePtr
{
	this.parent= parent;
	return VariablePtr( move(this) );
}

fn ConstantVariableToString( Type& t, LLVMValueRef constant_value ) : ust::string8
{
	if( constant_value == Null::LLVMValueRef )
	{
		return "";
	}

	if_var( &fundamental_type : t.GetFundamentalType() )
	{
		if( fundamental_type.fundamental_type == U_FundamentalType::bool_ )
		{
			return ( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) == 0u64 ? ust::string8("false") : ust::string8("true") );
		}
		else if( IsSignedInteger( fundamental_type.fundamental_type ) )
		{
			var ust::string_view8 mut suffix;
			if( fundamental_type.fundamental_type == U_FundamentalType::i32_ )
			{  suffix= "";  }
			else
			{  suffix= GetFundamentalTypeName( fundamental_type.fundamental_type );  }

			return ust::to_string8( unsafe( LLVMConstIntGetSExtValue( constant_value ) ) ) + suffix;
		}
		else if( IsUnsignedInteger( fundamental_type.fundamental_type ) )
		{
			var ust::string_view8 mut suffix;
			if( fundamental_type.fundamental_type == U_FundamentalType::u32_ )
			{  suffix= "u";  }
			else
			{  suffix= GetFundamentalTypeName( fundamental_type.fundamental_type );  }

			return ust::to_string8( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) ) + suffix;
		}
		else if( IsChar( fundamental_type.fundamental_type ) )
		{
			var ust::string8 mut result;
			result+= GetFundamentalTypeName( fundamental_type.fundamental_type );
			result.push_back( '(' );
			result+= ust::to_string8( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) );
			result.push_back( ')' );
			return result;
		}
		else if( IsByte( fundamental_type.fundamental_type ) )
		{
			var ust::string8 mut res;
			res+= GetFundamentalTypeName( fundamental_type.fundamental_type );
			res+= "( ";

			res+= ust::to_string8( unsafe( LLVMConstIntGetZExtValue( constant_value ) ) );
			switch( fundamental_type.fundamental_type )
			{
				U_FundamentalType::byte8_   -> { res+= GetFundamentalTypeName( U_FundamentalType::u8_   ); },
				U_FundamentalType::byte16_  -> { res+= GetFundamentalTypeName( U_FundamentalType::u16_  ); },
				U_FundamentalType::byte32_  -> { res+= GetFundamentalTypeName( U_FundamentalType::u32_  ); },
				U_FundamentalType::byte64_  -> { res+= GetFundamentalTypeName( U_FundamentalType::u64_  ); },
				U_FundamentalType::byte128_ -> { res+= GetFundamentalTypeName( U_FundamentalType::u128_ ); },
				default -> { halt; },
			}

			res+= " )";
			return res;
		}
	}
	if_var( &enum_type : t.GetEnumType() )
	{
		foreach( &element : enum_type.lock_imut().deref().elements )
		{
			// LLVM constants are deduplicated, so, comparing pointers should work.
			if( constant_value == element.value().constexpr_value  )
			{
				var ust::string8 mut res;
				res+= t.ToString();
				res+= "::";
				res+= element.key();
				return res;
			}
		}
	}
	if_var( &array_type : t.GetArrayType() )
	{
		// For now we have no special syntax for array literals. So, use just a comma-separated list in [].
		var ust::string8 mut res;
		res+= t.ToString();
		res+= "[ ";

		for( auto mut i= 0u64; i < array_type.element_count; ++i )
		{
			res+= ConstantVariableToString( array_type.element_type, unsafe( LLVMGetAggregateElement( constant_value, u32(i) ) ) );
			if( i + 1u64 < array_type.element_count )
			{
				res+= ", ";
			}
		}

		res+= "]";
		return res;
	}
	if_var( &tuple_type : t.GetTupleType() )
	{
		// For now we have no special syntax for tuple literals. So, use just a comma-separated list in [].
		var ust::string8 mut res;
		res+= t.ToString();
		res+= "[ ";

		for(auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
		{
			res+= ConstantVariableToString( tuple_type.element_types[i], unsafe( LLVMGetAggregateElement( constant_value, u32(i) ) ) );
			if( i + 1s < tuple_type.element_types.size() )
			{
				res+= ", ";
			}
		}

		res+= "]";
		return res;
	}

	return "";
}

fn FunctionVariable::VirtuallyEquals( this, FunctionVariable& other ) : bool
{
	halt if( !( this.is_this_call && other.is_this_call ) );

	auto& tl= this.t;
	auto& tr= other.t;

	if( !(
		tl.return_type == tr.return_type &&
		tl.return_value_type == tr.return_value_type &&
		tl.is_unsafe == tr.is_unsafe &&
		tl.calling_convention == tr.calling_convention &&
		tl.params.size() == tr.params.size() &&
		tl.params.size() > 0s &&
		tl.params.front().value_type == tr.params.front().value_type &&
		tl.return_references == tr.return_references &&
		tl.return_inner_references == tl.return_inner_references &&
		tl.references_pollution == tr.references_pollution
		) )
	{
		return false;
	}

	// Compare all args except "this" normally.
	foreach( pair : tl.params.iter().zip( tr.params.iter() ).skip( 1s ) )
	{
		if( pair.first != pair.second )
		{
			return false;
		}
	}

	return true;
}

fn FunctionVariable::IsCoroutine( this ) : bool
{
	switch(kind)
	{
		Kind::Regular -> { return false; },
		Kind::Generator, Kind::Async -> { return true; },
	}
}

namespace ValueKindHelper
{

fn GetValueKind( VariablePtr& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "variable";
}

fn GetValueKind( Type& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "type";
}

fn GetValueKind( FunctionsSetPtr& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "functions set";
}

fn GetValueKind( ThisMethodsSet& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "this + methods set";
}

fn GetValueKind( ust::shared_ptr_imut</TypeTemplatesSet/>& v ) : ust::string_view8
{
	ust::ignore_unused(v);
	return "type templates set";
}

fn GetValueKind( ErrorValue& v ) : ust::string_view8
{
	ust::ignore_unused( v );
	return "error value";
}

} // namespace ValueKindHelper

fn GetValueKindName( Value& v ) : ust::string_view8
{
	variant_visit( &el : v )
	{
		return ValueKindHelper::GetValueKind( el );
	}

	halt;
}

fn TypeTemplate::ToString( this ) : ust::string8
{
	var ust::string8 mut result;
	with( &n : parent_names_scope.upgrade().try_lock_imut().deref() )
	{
		if( !n.GetParent().empty() )
		{
			result += n.ToString();
			result += "::";
		}
	}
	result += syntax_element.deref().name;

	return result;
}

//
// Templates
//

fn TemplateSignatureParam::conversion_constructor( TemplateParam mut template_param )
	( something_( move(template_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( Type mut type_param )
	( something_( move(type_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( Variable mut variable_param )
	( something_( move(variable_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( TypeTemplate mut type_template_param )
	( something_( move(type_template_param) ) )
{}

fn TemplateSignatureParam::conversion_constructor( Array mut array_type_param )
	( something_( ust::make_shared_ptr_final( move(array_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( Tuple mut tuple_type_param )
	( something_( ust::make_shared_ptr_final( move(tuple_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( RawPointer mut raw_pointer_type_param )
	( something_( ust::make_shared_ptr_final( move(raw_pointer_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( Function mut function_type_param )
	( something_( ust::make_shared_ptr_final( move(function_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( Coroutine mut coroutine_type_param )
	( something_( ust::make_shared_ptr_final( move(coroutine_type_param) ) ) )
{}

fn TemplateSignatureParam::conversion_constructor( SpecializedTemplate mut specialized_template_param )
	( something_( ust::make_shared_ptr_final( move(specialized_template_param) ) ) )
{}

fn TemplateSignatureParam::GetTemplateParam(this) : ust::optional_ref_imut</ TemplateParam /> @(ret_tags)
{
	return something_.get</TemplateParam/>();
}

fn TemplateSignatureParam::GetType(this) : ust::optional_ref_imut</ Type /> @(ret_tags)
{
	return something_.get</Type/>();
}

fn TemplateSignatureParam::GetVariable(this) : ust::optional_ref_imut</ Variable /> @(ret_tags)
{
	return something_.get</Variable/>();
}

fn TemplateSignatureParam::GetTypeTemplate(this) : ust::optional_ref_imut</ TypeTemplate /> @(ret_tags)
{
	return something_.get</TypeTemplate/>();
}

fn TemplateSignatureParam::GetArray(this) : ust::optional_ref_imut</ Array /> @(ret_tags)
{
	if_var( &array_type_param : something_.get</ ust::shared_ptr_final</Array/> />() )
	{
		return array_type_param.deref();
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetTuple(this) : ust::optional_ref_imut</ Tuple /> @(ret_tags)
{
	if_var( &tuple_type_param : something_.get</ ust::shared_ptr_final</Tuple/> />() )
	{
		return tuple_type_param.deref();
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetRawPointer(this) : ust::optional_ref_imut</ RawPointer /> @(ret_tags)
{
	if_var( &raw_pointer_type_param : something_.get</ ust::shared_ptr_final</RawPointer/> />() )
	{
		return raw_pointer_type_param.deref();
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetFunction(this) : ust::optional_ref_imut</ Function /> @(ret_tags)
{
	if_var( &function_type_param : something_.get</ ust::shared_ptr_final</Function/> />() )
	{
		return function_type_param.deref();
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetCoroutine(this) : ust::optional_ref_imut</ Coroutine /> @(ret_tags)
{
	if_var( &coroutine_type_param : something_.get</ ust::shared_ptr_final</Coroutine/> />() )
	{
		return coroutine_type_param.deref();
	}

	return ust::null_optional_ref;
}

fn TemplateSignatureParam::GetSpecializedTemplate(this) : ust::optional_ref_imut</ SpecializedTemplate /> @(ret_tags)
{
	if_var( &specialized_template_param : something_.get</ ust::shared_ptr_final</SpecializedTemplate/> />() )
	{
		return specialized_template_param.deref();
	}

	return ust::null_optional_ref;
}

op TemplateSignatureParam::Variable::==(Variable& l, Variable& r) : bool
{
	return
		l.t == r.t &&
		// LLVM constants are deduplicated, so, comparing pointers should work.
		l.constexpr_value == r.constexpr_value;
}

template</type T/>
fn TemplateSignatureParamEqualImpl( T& l, T& r ) : bool
{
	return l == r;
}

template</type T/>
fn TemplateSignatureParamEqualImpl( ust::shared_ptr_final</T/>& l, ust::shared_ptr_final</T/>& r ) : bool
{
	return l.deref() == r.deref();
}

op TemplateSignatureParam::==(TemplateSignatureParam& l, TemplateSignatureParam& r) : bool
{
	if( l.something_.index() != r.something_.index() )
	{
		return false;
	}

	variant_visit( &l_t : l.something_ )
	{
		type LeftT= typeof(l_t);
		return TemplateSignatureParamEqualImpl( l_t, r.something_.try_get</ LeftT />() );
	}

	halt;
}

fn MapTemplateParamsToSignatureParams(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam& param ) : TemplateSignatureParam
{
	if_var( &template_param : param.GetTemplateParam() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, template_param );
	}
	if_var( &type_param : param.GetType() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, type_param );
	}
	if_var( &variable_param : param.GetVariable() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, variable_param );
	}
	if_var( &type_template_param : param.GetTypeTemplate() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, type_template_param );
	}
	if_var( &array_type_param : param.GetArray() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, array_type_param );
	}
	if_var( &tuple_type_param : param.GetTuple() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, tuple_type_param );
	}
	if_var( &raw_pointer_type_param : param.GetRawPointer() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, raw_pointer_type_param );
	}
	if_var( &function_type_param : param.GetFunction() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, function_type_param );
	}
	if_var( &coroutine_type_param : param.GetCoroutine() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, coroutine_type_param );
	}
	if_var( &specialized_template_param : param.GetSpecializedTemplate() )
	{
		return MapTemplateParamsToSignatureParamsImpl( mapping, specialized_template_param );
	}

	halt;
}


fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::TemplateParam& param ) : TemplateSignatureParam
{
	// Map this template param.
	return mapping[ size_type(param.index) ];
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::Type& param ) : TemplateSignatureParam
{
	ust::ignore_unused(mapping);
	// Return type params as is.
	return param;
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::Variable& param ) : TemplateSignatureParam
{
	ust::ignore_unused(mapping);
	// Return variable params as is.
	return param;
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::TypeTemplate& param ) : TemplateSignatureParam
{
	ust::ignore_unused(mapping);
	// Return type template params as is.
	return param;
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::Array& param ) : TemplateSignatureParam
{
	return TemplateSignatureParam::Array
	{
		.element_type= MapTemplateParamsToSignatureParams( mapping, param.element_type ),
		.element_count= MapTemplateParamsToSignatureParams( mapping, param.element_count ),
	};
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::Tuple& param ) : TemplateSignatureParam
{
	return TemplateSignatureParam::Tuple
	{
		.element_types=
			ust::make_vector_from_mapped_range(
				param.element_types,
				lambda[&]( TemplateSignatureParam& p ) : auto { return MapTemplateParamsToSignatureParams( mapping, p ); } )
	};
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::RawPointer& param ) : TemplateSignatureParam
{
	return TemplateSignatureParam::RawPointer
	{
		.element_type= MapTemplateParamsToSignatureParams( mapping, param.element_type )
	};
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::Function& param ) : TemplateSignatureParam
{
	var TemplateSignatureParam::Function mut out_param= param;
	out_param.return_type= MapTemplateParamsToSignatureParams( mapping, param.return_type );

	foreach( &mut function_param : out_param.params )
	{
		function_param.t= MapTemplateParamsToSignatureParams( mapping, function_param.t );
	}

	return out_param;
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::Coroutine& param ) : TemplateSignatureParam
{
	var TemplateSignatureParam::Coroutine mut out_param= param;
	out_param.return_type= MapTemplateParamsToSignatureParams( mapping, param.return_type );
	return out_param;
}

fn MapTemplateParamsToSignatureParamsImpl(
	TemplateParamsToSignatureParamsMappingRef mapping,
	TemplateSignatureParam::SpecializedTemplate& param ) : TemplateSignatureParam
{
	auto map_fn = lambda[mapping]( TemplateSignatureParam& p ) : auto { return MapTemplateParamsToSignatureParams( mapping, p ); };

	return TemplateSignatureParam::SpecializedTemplate
	{
		.type_templates= ust::make_vector_from_mapped_range( param.type_templates, map_fn ),
		.params=  ust::make_vector_from_mapped_range( param.params, map_fn ),
	};
}

// TemplateKey

op TemplateKey::==( TemplateKey& l, TemplateKey& r ) : bool
{
	return l.template_ == r.template_ && TemplateArgsEquals( l.template_args, r.template_args );
}

op ParameterizedFunctionTemplateKey::==( ParameterizedFunctionTemplateKey& l, ParameterizedFunctionTemplateKey& r ) : bool
{
	return l.functions_set == r.functions_set && TemplateArgsEquals( l.template_args, r.template_args );
}

fn TemplateArgsEquals( TemplateArgsFinished& l, TemplateArgsFinished& r ) : bool
{
	if( l.size() != r.size() )
	{
		return false;
	}

	foreach( pair : l.iter().zip( r.iter() ) )
	{
		if( !TemplateArgEquals( pair.first, pair.second ) )
		{
			return false;
		}
	}

	return true;
}

// Use custom comparator, since default comparator compares shared pointer values of VariablePtr.
// But we need to compare constexpr values intself.
fn TemplateArgEquals( TemplateArgFinished& l, TemplateArgFinished& r ) : bool
{
	if_var( &l_type : l.get</Type/>() )
	{
		if_var( &r_type : r.get</Type/>() )
		{
			return l_type == r_type;
		}
	}

	if_var( &l_variable_ptr : l.get</VariablePtr/>() )
	{
		if_var( &r_variable_ptr : r.get</VariablePtr/>() )
		{
			with( &l_variable : l_variable_ptr.lock_imut().deref() )
			{
				with( &r_variable : r_variable_ptr.lock_imut().deref() )
				{
					return
						l_variable.t == r_variable.t &&
						// LLVM constants are deduplicated, so, comparing pointers should work.
						l_variable.constexpr_value == r_variable.constexpr_value;
				}
			}
		}
	}

	if_var( &l_type_template : l.get</TypeTemplatePtr/>() )
	{
		if_var( &r_type_template : r.get</TypeTemplatePtr/>() )
		{
			return l_type_template == r_type_template;
		}
	}

	return false;
}

//
// NamesScope
//

fn NamesScope::constructor(
	ust::string8 mut name,
	ust::shared_ptr_nullable_imut</NamesScope/>& parent )
	(
		name_= move(name),
		parent_(parent)
	)
{
}

fn NamesScope::GetThisScopeValue( this, ust::string_view8 name ) : ust::optional_ref_imut</ NamesScopeValue /> @(ret_tags)
{
	return names_map_.find( name );
}

fn NamesScope::IsInsideTemplate( this ) : bool
{
	if( name_ == c_template_args_namespace_name )
	{
		return true;
	}
	auto parent= GetParent();
	if( !parent.empty() )
	{
		return parent.try_lock_imut().deref().IsInsideTemplate();
	}

	return false;
}

fn NamesScope::AddName( mut this, ust::string8 mut name, NamesScopeValue mut value ) : bool
{
	return names_map_.insert_new( move(name), move(value) );
}

fn NamesScope::GetParent( this ) : ust::shared_ptr_nullable_imut</NamesScope/>
{
	return parent_.upgrade();
}

fn NamesScope::SetErrors( mut this, ErrorsContainerPtr errors_container )
{
	errors_container_= errors_container;
}

fn NamesScope::GetErrors( this ) : ErrorsContainerPtr
{
	if( errors_container_.empty() )
	{
		return parent_.upgrade().try_lock_imut().deref().GetErrors();
	}

	return errors_container_;
}

fn NamesScope::GetThisNamespaceName( this ) : ust::string8&
{
	return name_;
}

fn NamesScope::ToString( this ) : ust::string8
{
	if( !class_.empty() )
	{
		auto class_lock= class_.try_lock_imut();
		auto& class_type= class_lock.deref();
		if_var( &base_template : class_type.generated_class_data.get</ ClassType::BaseTemplate />() )
		{
			// This is class template. So, parent namespace is arguments names scope.
			with( &type_template : base_template.class_template.lock_imut().deref() )
			{
				auto parent= type_template.parent_names_scope.upgrade();
				if( !parent.empty() )
				{
					var ust::string8 mut res;

					auto parent_lock= parent.try_lock_imut();
					if( !parent_lock.deref().GetParent().empty() )
					{
						res+= parent.try_lock_imut().deref().ToString();
						res+= "::";
					}
					res+= type_template.syntax_element.deref().name;

					res+= "</";
					foreach( &arg : base_template.signature_args )
					{
						if_var( &t : arg.get</Type/>() )
						{
							res+= t.ToString();
						}
						else if_var( &v_ptr : arg.get</VariablePtr/>() )
						{
							with( &v : v_ptr.lock_imut().deref() )
							{
								res+= ConstantVariableToString( v.t, v.constexpr_value );
							}
						}
						else if_var( &type_template : arg.get</TypeTemplatePtr/>() )
						{
							res+= type_template.lock_imut().deref().ToString();
						}

						if( ust::ref_cmp_ne( arg, base_template.signature_args.back() ) )
						{
							res+= ", ";
						}
					}
					res+= "/>";

					return res;
				}
			}
		}
		if_var( &typeinfo_class_description : class_type.generated_class_data.get</ TypeinfoClassDescription />() )
		{
			return ust::concat(
				KeywordToString(Keyword::typeof_),
				"(",
				KeywordToString(Keyword::typeinfo_),
				"</",
				typeinfo_class_description.source_type.ToString(),
				 "/>",
				")" );
		}
		if_var( &coroutine_type_description : class_type.generated_class_data.get</ CoroutineTypeDescription />() )
		{
			var ust::string8 mut res;
			switch( coroutine_type_description.kind )
			{
				CoroutineKind::Generator -> { res+= KeywordToString( Keyword::generator_ ); },
				CoroutineKind::AsyncFunc -> { res+= KeywordToString( Keyword::async_ ); },
			}

			// TODO - print inner refernces.

			res+= " ";

			if( coroutine_type_description.non_sync_ )
			{
				res+= KeywordToString( Keyword::non_sync_ );
			}

			res+= ": ";

			res+= coroutine_type_description.return_type.ToString();

			if( coroutine_type_description.return_value_type == ValueType::Value )
			{}
			else if( coroutine_type_description.return_value_type == ValueType::ReferenceImut )
			{
				res+= " &";
				res+= KeywordToString( Keyword::imut_ );
			}
			else if( coroutine_type_description.return_value_type == ValueType::ReferenceMut )
			{
				res+= " &";
				res+= KeywordToString( Keyword::mut_ );
			}
			else { halt; }

			return res;
		}
	}

	var ust::string8 mut res;

	auto mut parent= parent_.upgrade();
	if( !parent.empty() )
	{
		auto parent_lock= parent.try_lock_imut();
		if( !parent_lock.deref().GetParent().empty() )
		{
			res+= parent_lock.deref().ToString();
			res+= "::";
		}
	}

	res+= name_;
	return res;
}

fn NamesScope::SetClass( mut this, ust::shared_ptr_nullable_mut</ClassType/> in_class_ )
{
	class_= in_class_;
}

fn NamesScope::GetClass( this ) : ust::shared_ptr_nullable_mut</ClassType/>
{
	return class_;
}

fn NamesScope::AddAccessRightsFor( mut this, ClassTypePtr& class_type, Synt::ClassVisibility visibility )
{
	access_rights_.insert_or_update( class_type, visibility );
}

fn NamesScope::GetAccessFor( this, ClassTypePtr& class_type ) : Synt::ClassVisibility
{
	auto this_namespace_visibility= access_rights_.find( class_type ).deref_or( Synt::ClassVisibility::Public );

	auto mut parent_namespace_visibility= Synt::ClassVisibility::Public;
	auto parent= GetParent();
	if( !parent.empty() )
	{
		parent_namespace_visibility= parent.try_lock_imut().deref().GetAccessFor( class_type );
	}

	return ust::max( this_namespace_visibility, parent_namespace_visibility );
}

fn NamesScope::CopyAccessRightsFrom( mut this, NamesScope& src )
{
	access_rights_= src.access_rights_;
}

fn GetRootNamespace( NamesScopePtr& names_scope ) : NamesScopePtr
{
	var NamesScopePtr mut root_names_scope= names_scope;
	loop
	{
		auto parent= root_names_scope.lock_imut().deref().GetParent();
		if( parent.empty() )
		{
			return root_names_scope;
		}
		root_names_scope= parent.try_to_non_nullable();
	}
}

fn GetClosestNamedSpaceOrRoot( NamesScopePtr& names_scope ) : NamesScopePtr
{
	var NamesScopePtr mut current= names_scope;

	loop
	{
		var ust::shared_ptr_nullable_imut</NamesScope/> mut parent;
		with( &current_ref : current.lock_imut().deref() )
		{
			if( !current_ref.GetThisNamespaceName().empty() )
			{
				return current;
			}
			parent= current_ref.GetParent();
		}

		if( parent.empty() )
		{
			return current;
		}
		current= parent.try_to_non_nullable();
	}
}

} // namespace U1
