import "/assert.u"
import "/CodeBuilderLib/keywords.uh"
import "error_reporting.uh"
import "code_builder.uh"

namespace U1
{

fn CreateMangler(ManglingScheme scheme, LLVMTargetDataRef data_layout) : ust::box</IMangler/>
{
	switch(scheme)
	{
		ManglingScheme::ItaniumABI -> { return CreateManglerItaniumABI(); },
		ManglingScheme::MSVC -> { return CreateManglerMSVC( unsafe( LLVMPointerSize( data_layout ) ) == 4u ); },
		ManglingScheme::MSVC32 -> { return CreateManglerMSVC(true); },
		ManglingScheme::MSVC64 -> { return CreateManglerMSVC(false); },
	}
}

fn ClearClassInternals( ClassTypePtr& class_type, NamesScopeMutPtr& dummy_class_names_scope )
{
	auto mut lock= class_type.lock_mut();
	auto &mut class_= lock.deref();
	class_.members= dummy_class_names_scope;
	class_.members_initial= dummy_class_names_scope;
	class_.fields_order.clear();
	class_.parents.clear();
	class_.virtual_table.clear();
	class_.generated_class_data= ClassType::NonGeneratedClassTag();
}

fn CodeBuilder::constructor(
	LLVMContextRef llvm_context,
	LLVMTargetDataRef data_layout,
	ust::string8 mut target_triple_str,
	CodeBuilderOptions& options,
	IVfsSharedPtr mut vfs )
	(
		llvm_context_(llvm_context),
		data_layout_(data_layout),
		target_triple_str_(move(target_triple_str)),
		create_lifetimes_(options.create_lifetimes),
		generate_lifetime_start_end_debug_calls_(options.generate_lifetime_start_end_debug_calls),
		constexpr_function_evaluator_(data_layout),
		tbaa_metadata_builder_( llvm_context, data_layout, CreateMangler(options.mangling_scheme, data_layout) ),
		generate_tbaa_metadata_( options.generate_tbaa_metadata ),
		report_about_unused_names_( options.report_about_unused_names ),
		global_things_stack_ptr_(GlobalThingsStack()),
		build_debug_info_(options.build_debug_info),
		mangler_(CreateMangler(options.mangling_scheme, data_layout)),
		vfs_= move(vfs),
		fundamental_llvm_types_
		{
			.i8_  = unsafe( LLVMInt8TypeInContext  ( llvm_context_ ) ),
			.u8_  = unsafe( LLVMInt8TypeInContext  ( llvm_context_ ) ),
			.i16_ = unsafe( LLVMInt16TypeInContext ( llvm_context_ ) ),
			.u16_ = unsafe( LLVMInt16TypeInContext ( llvm_context_ ) ),
			.i32_ = unsafe( LLVMInt32TypeInContext ( llvm_context_ ) ),
			.u32_ = unsafe( LLVMInt32TypeInContext ( llvm_context_ ) ),
			.i64_ = unsafe( LLVMInt64TypeInContext ( llvm_context_ ) ),
			.u64_ = unsafe( LLVMInt64TypeInContext ( llvm_context_ ) ),
			.i128_= unsafe( LLVMInt128TypeInContext( llvm_context_ ) ),
			.u128_= unsafe( LLVMInt128TypeInContext( llvm_context_ ) ),
			.ssize_type_= unsafe( LLVMIntPtrTypeInContext( llvm_context_, data_layout_ ) ),
			.size_type_ = unsafe( LLVMIntPtrTypeInContext( llvm_context_, data_layout_ ) ),
			.f32_ = unsafe( LLVMFloatTypeInContext ( llvm_context_ ) ),
			.f64_ = unsafe( LLVMDoubleTypeInContext ( llvm_context_ ) ),
			.char8_ = unsafe( LLVMInt8TypeInContext ( llvm_context_ ) ),
			.char16_= unsafe( LLVMInt16TypeInContext( llvm_context_ ) ),
			.char32_= unsafe( LLVMInt32TypeInContext( llvm_context_ ) ),
			.byte8_  = unsafe( LLVMInt8TypeInContext  ( llvm_context_ ) ),
			.byte16_ = unsafe( LLVMInt16TypeInContext ( llvm_context_ ) ),
			.byte32_ = unsafe( LLVMInt32TypeInContext ( llvm_context_ ) ),
			.byte64_ = unsafe( LLVMInt64TypeInContext ( llvm_context_ ) ),
			.byte128_= unsafe( LLVMInt128TypeInContext( llvm_context_ ) ),
			.invalid_type_= unsafe( LLVMInt8TypeInContext( llvm_context_ ) ),
			.void_for_ret_= unsafe( LLVMVoidTypeInContext( llvm_context_ ) ),
			.void_= unsafe( LLVMStructCreateNamed( llvm_context_, "__U_void\0"[0] ) ),
			.bool_= unsafe( LLVMInt1TypeInContext( llvm_context_ ) ),
		},
		invalid_type_= FundamentalType( U_FundamentalType::InvalidType, fundamental_llvm_types_.invalid_type_ ),
		void_type_= FundamentalType( U_FundamentalType::void_, fundamental_llvm_types_.void_ ),
		bool_type_= FundamentalType( U_FundamentalType::bool_, fundamental_llvm_types_.bool_ ),
		ssize_type_= FundamentalType( U_FundamentalType::ssize_type_, fundamental_llvm_types_.ssize_type_ ),
		size_type_ = FundamentalType( U_FundamentalType::size_type_ , fundamental_llvm_types_.size_type_  ),
		// A pair of chars.
		// First - number of param from '0' up to '9'.
		// Second - '_' for reference param or letters from 'a' up to 'z' for inner reference tags.
		reference_notation_param_reference_description_type_=
			ArrayType
			{
				.element_type= FundamentalType( U_FundamentalType::char8_, fundamental_llvm_types_.char8_ ),
				.element_count(2),
				.llvm_type= unsafe( LLVMArrayType2( fundamental_llvm_types_.char8_, 2u64 ) ),
			},
		// A pair of reference param descriptions. First - destination, second - source.
		reference_notation_pollution_element_type_=
			ArrayType
			{
				.element_type= reference_notation_param_reference_description_type_,
				.element_count(2),
				.llvm_type= unsafe( LLVMArrayType2( LLVMArrayType2( fundamental_llvm_types_.char8_, 2u64 ), 2u64 ) ),
			},
		virtual_function_pointer_type_= unsafe(LLVMPointerType( LLVMFunctionType( fundamental_llvm_types_.void_for_ret_, ust::nullptr</LLVMTypeRef/>(), 0u, LLVMBool::True ), 0u )),
		polymorph_type_id_table_element_type_= unsafe( LLVMStructCreateNamed( llvm_context_, "__U_polymorph_type_id_table_element\0"[0] ) ),
	)
{
	unsafe( LLVMStructSetBody( fundamental_llvm_types_.void_, ust::nullptr</LLVMTypeRef/>(), 0u, LLVMBool::False ) );

	unsafe
	{
		var [ LLVMTypeRef, 2 ] mut elements
		[
			fundamental_llvm_types_.size_type_,
			LLVMPointerType( polymorph_type_id_table_element_type_, 0u ),
		];
		LLVMStructSetBody( polymorph_type_id_table_element_type_, $<(elements[0]), 2u, LLVMBool::False );
	}
}

fn CodeBuilder::BuildProgram( mut this, SourceGraph& source_graph ) @( ust::reference_notation::pollution::param0_param_1_reference ) : BuildResult
{
	source_graph_.reset( source_graph );
	macro_expansion_contexts_ = source_graph.macro_expansion_contexts;

	unsafe // Create module.
	{
		var ust::string8 mut module_name= source_graph.nodes.front().file_path_normalized;
		module_name += "\0";
		module_ = LLVMModuleCreateWithNameInContext( module_name.front(), llvm_context_ );
		LLVMSetModuleDataLayout( module_, data_layout_ );
		LLVMSetTarget( module_, target_triple_str_.front() );
	}

	unsafe // Prepare dummy function.
	{
		auto global_function_llvm_type= LLVMFunctionType( fundamental_llvm_types_.void_for_ret_, ust::nullptr</LLVMTypeRef/>(), 0u, LLVMBool::False );
		global_llvm_function_= LLVMAddFunction( module_, g_null_string, global_function_llvm_type );
	}

	unsafe // Prepare halt function.
	{
		auto halt_function_llvm_type= LLVMFunctionType( fundamental_llvm_types_.void_for_ret_, ust::nullptr</LLVMTypeRef/>(), 0u, LLVMBool::False );
		halt_function_= LLVMAddFunction( module_, "__U_halt\0"[0], halt_function_llvm_type );
	}
	AddFunctionAttribute( halt_function_, LLVMAttributeFunctionIndex, "noreturn" );
	AddFunctionAttribute( halt_function_, LLVMAttributeFunctionIndex, "nounwind" );

	unsafe // Prepare heap allocations functions
	{
		// Use some temporary names for allocation functions.
		// Do this in order to avoid collisions with user-defined names.
		var LLVMTypeRef mut malloc_size_type= fundamental_llvm_types_.size_type_;
		var LLVMTypeRef mut malloc_result_type= unsafe( LLVMPointerType( fundamental_llvm_types_.u8_, 0u ) );

		malloc_function_= LLVMAddFunction(
			module_,
			"__U_ust_memory_allocate_impl\0"[0],
			LLVMFunctionType( malloc_result_type, $<(malloc_size_type), 1u, LLVMBool::False ) );

		free_function_= LLVMAddFunction(
			module_,
			"__U_ust_memory_free_impl\0"[0],
			LLVMFunctionType( fundamental_llvm_types_.void_for_ret_, $<(malloc_result_type), 1u, LLVMBool::False ) );
	}

	// Get stacksave/stackrestore functions.
	stacksave_intrinsic_= GetIntrinsic( "llvm.stacksave", ust::empty_range );
	stackrestore_intrinsic_= GetIntrinsic( "llvm.stackrestore", ust::empty_range );

	if( create_lifetimes_ )
	{
		lifetime_function_arg_type_= unsafe( LLVMPointerType( fundamental_llvm_types_.u8_, 0u ) );
		var [ LLVMTypeRef, 1 ] types[ lifetime_function_arg_type_ ];
		lifetime_start_intrinsic_= GetIntrinsic( "llvm.lifetime.start", types );
		lifetime_end_intrinsic_= GetIntrinsic( "llvm.lifetime.end", types );

		if( generate_lifetime_start_end_debug_calls_ )
		{
			unsafe
			{
				var LLVMTypeRef mut arg_type= lifetime_function_arg_type_;
				var LLVMTypeRef ret_type= fundamental_llvm_types_.void_for_ret_;
				var LLVMTypeRef function_type= LLVMFunctionType( ret_type, $<(arg_type), 1u, LLVMBool::False );

				lifetime_start_debug_func_= LLVMAddFunction( module_, "__U_debug_lifetime_start\0"[0], function_type );
				lifetime_end_debug_func_= LLVMAddFunction( module_, "__U_debug_lifetime_end\0"[0], function_type );
			}
		}
	}

	// Get coroutine intrisincs.
	{
		coro_.id= GetIntrinsic( "llvm.coro.id", ust::empty_range );
		coro_.alloc= GetIntrinsic( "llvm.coro.alloc", ust::empty_range );
		coro_.free= GetIntrinsic( "llvm.coro.free", ust::empty_range );
		coro_.size= GetIntrinsic( "llvm.coro.size", ust::make_array( fundamental_llvm_types_.size_type_ ) );

		coro_.begin= GetIntrinsic( "llvm.coro.begin", ust::empty_range );
		coro_.end= GetIntrinsic( "llvm.coro.end", ust::empty_range );
		coro_.suspend= GetIntrinsic( "llvm.coro.suspend", ust::empty_range );

		coro_.resume= GetIntrinsic( "llvm.coro.resume", ust::empty_range );
		coro_.destroy= GetIntrinsic( "llvm.coro.destroy", ust::empty_range );
		coro_.done= GetIntrinsic( "llvm.coro.done", ust::empty_range );
		coro_.promise= GetIntrinsic( "llvm.coro.promise", ust::empty_range );
	}

	debug_info_builder_.reset(
		DebugInfoBuilder(
			llvm_context_,
			data_layout_,
			source_graph,
			module_,
			build_debug_info_ ) );

	root_errors_container_= ErrorsContainerPtr( ErrorsContainer() );

	source_graph_nodes_build_results_.resize( source_graph.nodes.size() );
	BuildSourceGraphNode( source_graph, 0s );

	// Perform post-checks for non_sync tags.
	// Do this at the end to avoid dependency loops.
	{
		auto class_table= class_table_;
		foreach( &class_type : class_table )
		{
			CheckClassNonSyncTagExpression( class_type );
			CheckClassNonSyncTagInheritance( class_type );
		}
	}

	// Check for unused names in root file.
	{
		auto main_file_root_namespace= source_graph_nodes_build_results_.front().names_scope.try_to_non_nullable();
		CheckForUnusedGlobalNames( main_file_root_namespace );
	}

	// Finalize "defererenceable" attributes.
	// Do this at end because we needs complete types for params/return values even for only prototypes.
	SetupDereferenceableFunctionParamsAndRetAttributes_r( cast_imut(source_graph_nodes_build_results_).front().names_scope.try_lock_imut().deref() );
	foreach( &name_value_pair : cast_imut(generated_template_things_) )
	{
		SetupDereferenceableFunctionParamsAndRetAttributes_r( name_value_pair.value().lock_imut().deref() );
	}

	// Finalize incomplete typeinfo.
	foreach( &entry : typeinfo_cache_ )
	{
		with( &v : entry.value().variable.lock_imut().deref() )
		{
			auto llvm_type= v.t.GetLLVMType();
			unsafe
			{
				if( LLVMIsOpaqueStruct( llvm_type ) == LLVMBool::True )
				{
					LLVMStructSetBody( llvm_type, ust::nullptr</LLVMTypeRef/>(), 0u, LLVMBool::False );

					auto initializer= LLVMConstNamedStruct( llvm_type, ust::nullptr</LLVMValueRef/>(), 0u );
					LLVMSetInitializer( v.llvm_value, initializer );
				}
			}
		}
	}

	unsafe( LLVMDeleteFunction( global_llvm_function_ ) );
	global_llvm_function_= LLVMValueRef::Null;

	// Reset debug info builder in order to finalize debug info.
	debug_info_builder_.reset();

	{ // Clear classes internals to break strong shared pointers loop and avoid memory leaks.
		var NamesScopeMutPtr dummy_class_names_scope( NamesScope( "", ust::shared_ptr_nullable_imut</NamesScope/>() ) );
		foreach( &class_type : class_table_ )
		{
			ClearClassInternals( class_type, dummy_class_names_scope );
		}

		foreach( &class_type_ptr : typeinfo_class_table_ )
		{
			ClearClassInternals( class_type_ptr, dummy_class_names_scope );
		}

		foreach( &class_type_pair : coroutine_classes_ )
		{
			ClearClassInternals( class_type_pair.value(), dummy_class_names_scope );
		}
		foreach( &class_type_pair : lambda_classes_table_ )
		{
			ClearClassInternals( class_type_pair.value(), dummy_class_names_scope );
		}
		if( !lambda_preprocessing_dummy_class_.empty() )
		{
			ClearClassInternals( lambda_preprocessing_dummy_class_.try_to_non_nullable(), dummy_class_names_scope );
		}
	}
	// Replace usage of temporary allocation functions with usage of library allocation functions.
	// Do such, because we can't just declare internal functions with such names, prior to compiling file with such functions declarations ("alloc.u").
	// Without such approach functions, declared in library file, get suffix, like "ust_memory_allocate_impl.1".
	{
		var LLVMValueRef ust_memory_allocate_impl= unsafe( LLVMGetNamedFunction( module_, "ust_memory_allocate_impl\0"[0] ) );
		if( ust_memory_allocate_impl != LLVMValueRef::Null )
		{
			unsafe( LLVMReplaceAllUsesWith( malloc_function_, ust_memory_allocate_impl ) );
		}
		else
		{
			auto mut name= "ust_memory_allocate_impl";
			unsafe( LLVMSetValueName2( malloc_function_, $<(name[0]), typeinfo</typeof(name)/>.element_count ) );
		}

		var LLVMValueRef ust_memory_free_impl= unsafe( LLVMGetNamedFunction( module_, "ust_memory_free_impl\0"[0] ) );
		if( ust_memory_free_impl != LLVMValueRef::Null )
		{
			unsafe( LLVMReplaceAllUsesWith( free_function_, ust_memory_free_impl ) );
		}
		else
		{
			auto mut name= "ust_memory_free_impl";
			unsafe( LLVMSetValueName2( free_function_, $<(name[0]), typeinfo</typeof(name)/>.element_count ) );
		}
	}

	source_graph_nodes_build_results_.clear();
	generated_template_things_.clear();
	generated_template_things_sequence_.clear();
	typeinfo_cache_.clear();
	non_sync_expression_stack_.clear();
	macro_expansion_contexts_.reset();
	source_graph_.reset();

	var ust::vector</ust::string8/> mut embedded_files;
	foreach( & pair : embed_cache_ )
	{
		embedded_files.push_back( pair.key() );
	}
	embed_cache_.clear();

	var BuildResult mut res
	{
		.llvm_module= module_,
		.errors= root_errors_container_.try_lock_imut().deref(),
		.embedded_files= move(embedded_files),
	 };

	NormalizeErrors( res.errors, source_graph.macro_expansion_contexts.lock_imut().deref() );

	root_errors_container_= ErrorsContainerPtr();

	return res;
}

fn CodeBuilder::BuildSourceGraphNode( mut this, SourceGraph& source_graph, size_type node_index )
{
	var SourceGraph::Node& source_graph_node= source_graph.nodes[node_index];

	var NamesScopeMutPtr mut global_names_scope( NamesScope( "", ust::shared_ptr_nullable_imut</NamesScope/>() ) );

	with( mut lock : global_names_scope.lock_mut() )
	{
		auto &mut n= lock.deref();

		n.SetErrors( root_errors_container_ );

		if( source_graph_node.children.empty() )
		{
			// Fill global names scope only for files with no imports.
			// Files with imports should inherit contents of global namespace from imported files.
			FillGlobalNamesScope( n );
		}
	}

	// Build dependent nodes.
	foreach( child_node_index : source_graph_node.children )
	{
		if( source_graph_nodes_build_results_[child_node_index].names_scope.empty() )
		{
			BuildSourceGraphNode( source_graph, child_node_index );
		}
	}

	// Merge namespaces.
	foreach( child_node_index : source_graph_node.children )
	{
		var SourceGraphNodeBuildResult& child_node_build_result= source_graph_nodes_build_results_[child_node_index];
		NamesScopeMerge(
			global_names_scope,
			child_node_build_result.names_scope.try_to_non_nullable().lock_imut().deref(),
			child_node_build_result.classes_members_namespaces_table );
	}

	auto& program_elements= source_graph_node.synt_result.program_elements;
	NamesScopeFill( global_names_scope, program_elements );
	NamesScopeFillOutOfLineElements( global_names_scope, program_elements );
	ProcessMixins( global_names_scope );
	NamesScopeBuild( global_names_scope );

	// Finalize building template things.
	// Each new template thing added into this vector, so, by iterating through we will build all template things.
	// It's important to use an index instead of iterators during iteration because this vector may be chaged in process.
	for( auto mut i= 0s; i < generated_template_things_sequence_.size(); ++i )
	{
		auto names_scope= generated_template_things_[generated_template_things_sequence_[i]];
		NamesScopeBuild( names_scope );
	}
	generated_template_things_sequence_.clear();

	var SourceGraphNodeBuildResult mut out_node_build_result{ .names_scope= move(global_names_scope) };

	// Fill result classes members namespaces table.
	foreach( &class_type : class_table_ )
	{
		out_node_build_result.classes_members_namespaces_table.insert( class_type, class_type.lock_imut().deref().members );
	}

	source_graph_nodes_build_results_[node_index] = move(out_node_build_result);
}

fn CodeBuilder::IsSrcLocFromMainFile( this, SrcLoc& src_loc ) : bool
{
	return GetRootMacroExpansionLocation( src_loc ).GetFileIndex() == 0u;
}

fn CodeBuilder::IsSrcLocFromOtherImportedFile( this, SrcLoc& src_loc ) : bool
{
	with( &nodes : source_graph_.try_deref().nodes )
	{
		var size_type file_index( GetRootMacroExpansionLocation( src_loc ).GetFileIndex() );
		if( file_index != 0s && file_index < nodes.size() &&
			nodes[file_index].category == SourceGraph::Node::Category::OtherImport )
		{
			return true;
		}
	}

	return false;
}

fn CodeBuilder::GetRootMacroExpansionLocation( this, SrcLoc& src_loc ) : SrcLoc
{
	auto macro_expansion_index= src_loc.GetMacroExpansionIndex();
	if( macro_expansion_index == SrcLoc::c_max_macro_expanison_index )
	{
		return src_loc;
	}

	if( size_type(macro_expansion_index) < macro_expansion_contexts_.try_lock_imut().deref().size() )
	{
		var SrcLoc expansion_src_loc= macro_expansion_contexts_.try_lock_imut().deref()[ size_type(macro_expansion_index) ].src_loc;
		return GetRootMacroExpansionLocation( expansion_src_loc );
	}

	return src_loc;
}

fn CodeBuilder::FillGlobalNamesScope( this, NamesScope &mut names_scope )
{
	var [ tup[ Keyword, U_FundamentalType ], 24 ] constexpr types_table
	[
		[ Keyword::void_, U_FundamentalType::void_ ],
		[ Keyword::bool_, U_FundamentalType::bool_ ],
		[ Keyword::i8_  , U_FundamentalType::i8_   ],
		[ Keyword::u8_  , U_FundamentalType::u8_   ],
		[ Keyword::i16_ , U_FundamentalType::i16_  ],
		[ Keyword::u16_ , U_FundamentalType::u16_  ],
		[ Keyword::i32_ , U_FundamentalType::i32_  ],
		[ Keyword::u32_ , U_FundamentalType::u32_  ],
		[ Keyword::i64_ , U_FundamentalType::i64_  ],
		[ Keyword::u64_ , U_FundamentalType::u64_  ],
		[ Keyword::i128_, U_FundamentalType::i128_ ],
		[ Keyword::u128_, U_FundamentalType::u128_ ],
		[ Keyword::ssize_type_, U_FundamentalType::ssize_type_ ],
		[ Keyword::size_type_ , U_FundamentalType::size_type_  ],
		[ Keyword::f32_ , U_FundamentalType::f32_  ],
		[ Keyword::f64_ , U_FundamentalType::f64_  ],
		[ Keyword::char8_ , U_FundamentalType::char8_  ],
		[ Keyword::char16_, U_FundamentalType::char16_ ],
		[ Keyword::char32_, U_FundamentalType::char32_ ],
		[ Keyword::byte8_  , U_FundamentalType::byte8_   ],
		[ Keyword::byte16_ , U_FundamentalType::byte16_  ],
		[ Keyword::byte32_ , U_FundamentalType::byte32_  ],
		[ Keyword::byte64_ , U_FundamentalType::byte64_  ],
		[ Keyword::byte128_, U_FundamentalType::byte128_ ],
	];

	foreach( &el : types_table )
	{
		names_scope.AddName( KeywordToString( el[0] ), Type( FundamentalType( el[1], GetFundamentalLLVMType(el[1]) ) ) );
	}
}

fn CodeBuilder::PrepareFunction(
	mut this,
	ust::shared_ptr_final</Synt::Function/>& function_declaration_ptr,
	NamesScopePtr& names_scope_ptr,
	ust::shared_ptr_nullable_mut</ClassType/>& class_type,
	FunctionsSet &mut functions_set,
	bool is_out_of_line_function ) : bool
{
	auto& function_declaration= function_declaration_ptr.deref();
	auto& func_name= function_declaration.name.back();

	auto is_constructor= func_name == KeywordToString( Keyword::constructor_ );
	auto is_destructor = func_name == KeywordToString( Keyword::destructor_  );

	if( !function_declaration.constructor_initializer_list.empty() && !is_constructor )
	{
		REPORT_ERROR( InitializationListInNonConstructor, names_scope_ptr, function_declaration.constructor_initializer_list.try_deref().src_loc )
	}

	// TODO - maybe clear global constext after it's usage?
	auto mut global_function_context= CreateGlobalFunctionContext();

	// enable_if
	if_var( &expr : function_declaration.condition )
	{
		if( !EvaluateBoolConstantExpression( names_scope_ptr, global_function_context, expr ) )
		{
			return false; // Function disabled
		}
	}

	if( function_declaration.function_type.IsAutoReturn() )
	{
		if( function_declaration.block.empty() )
		{
			REPORT_ERROR( ExpectedBodyForAutoFunction, names_scope_ptr, function_declaration.src_loc, func_name )
		}
		if( is_constructor ||
			is_destructor ||
			func_name == OverloadedOperatorToString( OverloadedOperator::Assign ) ||
			func_name == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) )
		{
			REPORT_ERROR( AutoForSpecialMethod, names_scope_ptr, function_declaration.src_loc )
		}
		if( function_declaration.virtual_kind != Synt::Function::VirtualKind::None )
		{
			REPORT_ERROR( AutoForVirtualMethod, names_scope_ptr, function_declaration.src_loc )
		}
		if_var( &el : function_declaration.function_type.return_value_reference_expression )
		{
			REPORT_ERROR( ReferenceNotationForAutoFunction, names_scope_ptr, Synt::GetSrcLoc( el ) )
		}
		if_var( &el : function_declaration.function_type.return_value_inner_references_expression )
		{
			REPORT_ERROR( ReferenceNotationForAutoFunction, names_scope_ptr, Synt::GetSrcLoc( el ) )
		}
		if_var( &el : function_declaration.function_type.references_pollution_expression )
		{
			REPORT_ERROR( ReferenceNotationForAutoFunction, names_scope_ptr, Synt::GetSrcLoc( el ) )
		}
	}

	var FunctionType mut function_type= PrepareFunctionType( names_scope_ptr, global_function_context, function_declaration.function_type, class_type );

	var FunctionVariable::Kind mut function_kind= function_declaration.kind;

	if( function_kind != FunctionVariable::Kind::Regular )
	{
		// Perform checks before transforming coroutine function type.
		PerformCoroutineFunctionReferenceNotationChecks( function_type, names_scope_ptr, function_declaration.src_loc );

		TransformCoroutineFunctionType( function_type, function_kind, names_scope_ptr, function_declaration.src_loc );

		if_var( &type_name : function_declaration.function_type.return_type )
		{
			if_var( &complex_name : type_name.get</Synt::ComplexName/>() )
			{
				if_var( &name_lookup : complex_name.get</Synt::NameLookup/>() )
				{
					if( name_lookup.name == KeywordToString( Keyword::auto_ ) )
					{
						REPORT_ERROR( AutoReturnCoroutine, names_scope_ptr, function_declaration.src_loc )
						function_kind= FunctionVariable::Kind::Regular;
					}
				}
			}
		}
		if( function_declaration.virtual_kind != Synt::Function::VirtualKind::None )
		{
			REPORT_ERROR( VirtualCoroutine, names_scope_ptr, function_declaration.src_loc )
		}
		if( function_type.calling_convention != LLVMCallConv::C )
		{
			REPORT_ERROR( NonDefaultCallingConventionForCoroutine, names_scope_ptr, function_declaration.src_loc )
		}
		// Disable references pollution for coroutines. It is too complicated for now.
		if( !function_declaration.function_type.references_pollution_expression.empty() )
		{
			REPORT_ERROR( NotImplemented, names_scope_ptr, function_declaration.function_type.src_loc, "References pollution for coroutines." )
		}
	}

	var ust::string8 mut llvm_function_name;
	if( function_declaration.no_mangle )
	{
		llvm_function_name= func_name + "\0";
	}
	else
	{
		llvm_function_name=
			mangler_.deref().MangleFunction(
				names_scope_ptr.lock_imut().deref(),
				func_name,
				function_type );
	}

	var FunctionVariable mut function_variable
	{
		.t= move(function_type),
		.llvm_function( LazyLLVMFunction( move(llvm_function_name) ) ),
		.kind= function_kind,
		.no_discard=
			function_declaration.no_discard ||
			// Generators and async functions are all implicitly "nodiscard".
			function_kind == FunctionVariable::Kind::Generator ||
			function_kind == FunctionVariable::Kind::Async,
	};
	if( function_declaration.block.empty() )
	{
		function_variable.prototype_syntax_element= function_declaration_ptr;
	}
	else
	{
		function_variable.body_syntax_element= function_declaration_ptr;
	}

	function_variable.is_this_call=
		!function_declaration.function_type.params.empty() &&
		function_declaration.function_type.params.front().name == KeywordToString( Keyword::this_ );

	if( function_variable.IsCoroutine() && ( is_constructor || is_destructor ) )
	{
		REPORT_ERROR( CoroutineSpecialMethod, names_scope_ptr, function_declaration.src_loc )
	}

	function_variable.is_constructor= is_constructor;
	{
		var FunctionType &mut function_type= function_variable.t;
		if( ( is_constructor || is_destructor ) &&
			!(function_type.return_type == void_type_ && function_type.return_value_type == ValueType::Value ) )
		{
			REPORT_ERROR( ConstructorAndDestructorMustReturnVoid, names_scope_ptr, function_declaration.src_loc )
			function_type.return_type= void_type_;
			function_type.return_value_type= ValueType::Value;
		}
		if( ( is_constructor || is_destructor ) &&
			!function_type.params.empty() && function_type.params.front().value_type == ValueType::Value )
		{
			REPORT_ERROR( ByvalThisForConstructorOrDestructor, names_scope_ptr, function_declaration.src_loc )
			function_type.params.front().value_type= ValueType::ReferenceMut;
		}
		if( is_destructor && function_type.params.size() > 1s )
		{
			REPORT_ERROR( ExplicitArgumentsInDestructor, names_scope_ptr, function_declaration.src_loc )
		}

		CheckOverloadedOperator( class_type, function_type, function_declaration.operator, names_scope_ptr, function_declaration.src_loc );
	}

	// Check conversion constructor.
	if( function_declaration.is_conversion_constructor )
	{
		if( function_variable.t.params.size() == 2s )
		{
			function_variable.is_conversion_constructor= true;

			if( cast_imut(function_variable).t.params[1s].t == cast_imut(function_variable).t.params[0s].t )
			{
				REPORT_ERROR( ConversionConstructorSourceTypeIsIdenticalToDestinationType, names_scope_ptr, function_declaration.src_loc )
			}
		}
		else
		{
			REPORT_ERROR( ConversionConstructorMustHaveOneArgument, names_scope_ptr, function_declaration.src_loc )
		}
	}

	// Check unsafe for special methods.
	if( function_variable.t.is_unsafe && !class_type.empty() )
	{
		auto class_type_non_null= class_type.try_to_non_nullable();
		// Calls to such methods are produced by compiler itself, used in other methods generation, etc.
		// So, to avoid problems with generated unsafe calls just forbid some methods to be unsafe.
		if( is_destructor ||
			( is_constructor && ( IsDefaultConstructor( function_variable, class_type_non_null ) || IsCopyConstructor( function_variable, class_type_non_null ) ) ) ||
			( function_declaration.operator == OverloadedOperator::Assign && IsCopyAssignmentOperator( function_variable, class_type_non_null ) ) ||
			( function_declaration.operator == OverloadedOperator::CompareEqual && IsEqualityCompareOperator( function_variable, class_type_non_null ) ) )
		{
			REPORT_ERROR( ThisMethodCanNotBeUnsafe, names_scope_ptr, function_declaration.src_loc )
			function_variable.t.is_unsafe= false;
		}
	}

	// Check calling convention for methods.
	if( function_variable.t.calling_convention != LLVMCallConv::C &&
		( function_variable.is_this_call || function_declaration.operator != OverloadedOperator::None ) )
	{
		REPORT_ERROR( NonDefaultCallingConventionForClassMethod, names_scope_ptr, function_declaration.src_loc )
	}

	// Setup references pollution for copy methods.
	if( !class_type.empty() )
	{
		auto class_type_non_null= class_type.try_to_non_nullable();
		if( ( is_constructor && IsCopyConstructor( function_variable, class_type_non_null ) ) ||
			( function_declaration.operator == OverloadedOperator::Assign && IsCopyAssignmentOperator( function_variable, class_type_non_null ) ) )
		{
			if( !function_declaration.function_type.references_pollution_expression.empty() )
			{
				if( is_constructor )
				{
					REPORT_ERROR( ExplicitReferencePollutionForCopyConstructor, names_scope_ptr, function_declaration.src_loc )
				}
				else
				{
					REPORT_ERROR( ExplicitReferencePollutionForCopyAssignmentOperator, names_scope_ptr, function_declaration.src_loc )
				}
				function_variable.t.references_pollution.clear();
			}

			// Assume, that this function is called during function preparation, which for class is called after determining number of inner reference tags.
			// So, we can request it.
			auto reference_tag_count= class_type_non_null.lock_imut().deref().inner_references.size();
			for( auto mut i= 0s; i < reference_tag_count; ++i )
			{
				function_variable.t.references_pollution.push_back(
					FunctionType::ReferencePollution
					{
						.dst{ .param_index= 0u8, .reference_index= u8(i) },
						.src{ .param_index= 1u8, .reference_index= u8(i) },
					} );
			}
		}

		if( function_declaration.operator == OverloadedOperator::CompareEqual &&
			IsEqualityCompareOperator( function_variable, class_type_non_null ) &&
			!function_declaration.function_type.references_pollution_expression.empty() )
		{
			REPORT_ERROR( ExplicitReferencePollutionForEqualityCompareOperator, names_scope_ptr, function_declaration.src_loc )
			function_variable.t.references_pollution.clear();
		}

		if( is_constructor )
		{
			foreach( &pollution : function_variable.t.references_pollution )
			{
				if( pollution.src.param_index == 0u8 && pollution.src.reference_index == FunctionType::c_param_reference_number )
				{
					REPORT_ERROR( ConstructorThisReferencePollution, names_scope_ptr, function_declaration.src_loc )
				}
			}
		}
	}

	if( function_declaration.constexpr_ )
	{
		if( function_declaration.block.empty() )
		{
			REPORT_ERROR( ConstexprFunctionsMustHaveBody, names_scope_ptr, function_declaration.src_loc )
		}
		else if( function_declaration.virtual_kind != Synt::Function::VirtualKind::None )
		{
			REPORT_ERROR( ConstexprFunctionCanNotBeVirtual, names_scope_ptr, function_declaration.src_loc )
		}
		else
		{
			function_variable.constexpr_kind= FunctionVariable::ConstexprKind::ConstexprIncomplete;
		}
	}

	if( function_declaration.virtual_kind != Synt::Function::VirtualKind::None )
	{
		if( class_type.empty() )
		{
			REPORT_ERROR( VirtualForNonclassFunction, names_scope_ptr, function_declaration.src_loc, func_name )
		}
		if( !function_variable.is_this_call )
		{
			REPORT_ERROR( VirtualForNonThisCallFunction, names_scope_ptr, function_declaration.src_loc, func_name )
		}
		if( is_constructor )
		{
			REPORT_ERROR( FunctionCanNotBeVirtual, names_scope_ptr, function_declaration.src_loc, func_name )
		}
		if( !class_type.empty() )
		{
			auto class_lock= class_type.try_lock_imut();
			auto& class_ref= class_lock.deref();
			if( class_ref.kind == ClassType::Kind::Struct || class_ref.kind == ClassType::Kind::NonPolymorph )
			{
				REPORT_ERROR( VirtualForNonpolymorphClass, names_scope_ptr, function_declaration.src_loc, func_name )
			}
		}
		if( is_out_of_line_function )
		{
			REPORT_ERROR( VirtualForFunctionImplementation, names_scope_ptr, function_declaration.src_loc, func_name )
		}
		if( function_variable.is_this_call && ! function_variable.t.params.empty() && function_variable.t.params.front().value_type == ValueType::Value )
		{
			REPORT_ERROR( VirtualForByvalThisFunction, names_scope_ptr, function_declaration.src_loc, func_name )
		}
	}

	// Check "=default" / "=delete".
	if( function_declaration.body_kind != Synt::Function::BodyKind::Regular )
	{
		var bool mut invalid_func= false;

		if( class_type.empty() ){ invalid_func= true; }
		else
		{
			auto class_type_non_null= class_type.try_to_non_nullable();
			if( is_constructor && ( IsDefaultConstructor( function_variable, class_type_non_null ) || IsCopyConstructor( function_variable, class_type_non_null ) ) )
			{}
			else if( function_declaration.operator == OverloadedOperator::Assign && IsCopyAssignmentOperator( function_variable, class_type_non_null ) )
			{}
			else if( function_declaration.operator == OverloadedOperator::CompareEqual && IsEqualityCompareOperator( function_variable, class_type_non_null ) )
			{}
			else{ invalid_func= true; }
		}

		if( invalid_func )
		{
			REPORT_ERROR( InvalidMethodForBodyGeneration, names_scope_ptr, function_declaration.src_loc )
		}
		else
		{
			( function_declaration.body_kind == Synt::Function::BodyKind::BodyGenerationRequired ? function_variable.is_generated : function_variable.is_deleted )= true;
		}
	}

	// Check "nodiscard".
	if( function_declaration.no_discard && !class_type.empty() )
	{
		// Do not allow "nodiscard" for constructors, destructors, assignment operators and any operators returning "void".
		// For them "nodiscard" is useless.
		if( is_constructor ||
			is_destructor ||
			function_declaration.operator == OverloadedOperator::Assign ||
			function_declaration.operator == OverloadedOperator::AssignAdd ||
			function_declaration.operator == OverloadedOperator::AssignSub ||
			function_declaration.operator == OverloadedOperator::AssignMul ||
			function_declaration.operator == OverloadedOperator::AssignDiv ||
			function_declaration.operator == OverloadedOperator::AssignRem ||
			function_declaration.operator == OverloadedOperator::AssignAnd ||
			function_declaration.operator == OverloadedOperator::AssignOr ||
			function_declaration.operator == OverloadedOperator::AssignXor ||
			function_declaration.operator == OverloadedOperator::AssignShiftLeft ||
			function_declaration.operator == OverloadedOperator::AssignShiftRight ||
			function_declaration.operator == OverloadedOperator::Increment ||
			function_declaration.operator == OverloadedOperator::Decrement )
		{
			REPORT_ERROR( UselessNodiscardForMethod, names_scope_ptr, function_declaration.src_loc )
		}
	}

	if( function_declaration.no_mangle )
	{
		if( names_scope_ptr.lock_imut().deref().GetParent().empty() )
		{
			function_variable.no_mangle= true;
		}
		else
		{
			REPORT_ERROR( NoMangleForNonglobalFunction, names_scope_ptr, function_declaration.src_loc, func_name )
		}
	}

	if_var( &mut prev_function : GetFunctionWithSameType( functions_set, function_variable.t ) )
	{
		if( prev_function.prototype_syntax_element.empty() )
		{
			prev_function.prototype_syntax_element= function_variable.prototype_syntax_element;
		}
		else if( !function_variable.prototype_syntax_element.empty() )
		{
			REPORT_ERROR(
				FunctionPrototypeDuplication,
				names_scope_ptr,
				ust::max( function_declaration.src_loc, prev_function.prototype_syntax_element.try_deref().src_loc ),
				func_name )
			return false;
		}

		if( prev_function.body_syntax_element.empty() )
		{
			prev_function.body_syntax_element= function_variable.body_syntax_element;
		}
		else if( !function_variable.body_syntax_element.empty() )
		{
			REPORT_ERROR(
				FunctionBodyDuplication,
				names_scope_ptr,
				ust::max( function_declaration.src_loc, prev_function.body_syntax_element.try_deref().src_loc ),
				func_name )
			return false;
		}

		if( prev_function.is_this_call != function_variable.is_this_call )
		{
			REPORT_ERROR( ThiscallMismatch, names_scope_ptr, function_declaration.src_loc, func_name )
			return false;
		}

		if( !is_out_of_line_function &&
			!prev_function.body_syntax_element.empty() && !prev_function.prototype_syntax_element.empty() &&
			prev_function.body_syntax_element.try_deref().virtual_kind != prev_function.prototype_syntax_element.try_deref().virtual_kind )
		{
			REPORT_ERROR( VirtualMismatch, names_scope_ptr, prev_function.body_syntax_element.try_deref().src_loc, func_name )
			return false;
		}
		if( !prev_function.body_syntax_element.empty() && !prev_function.prototype_syntax_element.empty() &&
			prev_function.prototype_syntax_element.try_deref().virtual_kind == Synt::Function::VirtualKind::VirtualPure )
		{
			REPORT_ERROR( BodyForPureVirtualFunction, names_scope_ptr, prev_function.body_syntax_element.try_deref().src_loc, func_name )
			return false;
		}

		if( prev_function.is_deleted != function_variable.is_deleted )
		{
			REPORT_ERROR( BodyForDeletedFunction, names_scope_ptr, prev_function.prototype_syntax_element.try_deref().src_loc, func_name )
			return false;
		}
		if( prev_function.is_generated != function_variable.is_generated )
		{
			REPORT_ERROR( BodyForGeneratedFunction, names_scope_ptr, prev_function.prototype_syntax_element.try_deref().src_loc, func_name )
			return false;
		}

		if( prev_function.no_mangle != function_variable.no_mangle )
		{
			REPORT_ERROR( NoMangleMismatch, names_scope_ptr, function_declaration.src_loc, func_name )
			return false;
		}

		if( prev_function.kind != function_variable.kind )
		{
			REPORT_ERROR( CoroutineMismatch, names_scope_ptr, function_declaration.src_loc, func_name )
			return false;
		}

		if( prev_function.no_discard != function_variable.no_discard )
		{
			REPORT_ERROR( NodiscardMismatch, names_scope_ptr, function_declaration.src_loc, func_name )
		}

		if( prev_function.is_conversion_constructor != function_variable.is_conversion_constructor )
		{
			// TODO -use separate error code
			REPORT_ERROR( NotImplemented, names_scope_ptr, function_declaration.src_loc, "changing conversion constructor name" )
			return false;
		}

		if( prev_function.is_inherited )
		{
			REPORT_ERROR( FunctionDeclarationOutsideItsScope, names_scope_ptr, function_declaration.src_loc )
		}

		return true;
	}

	if( is_out_of_line_function )
	{
		REPORT_ERROR( FunctionDeclarationOutsideItsScope, names_scope_ptr, function_declaration.src_loc )
		return false;
	}

	return ApplyOverloadedFunction( functions_set, move(function_variable), names_scope_ptr, function_declaration.src_loc );
}

fn CodeBuilder::CheckOverloadedOperator(
	this,
	ust::shared_ptr_nullable_mut</ClassType/>& class_type,
	FunctionType& func_type,
	OverloadedOperator operator,
	NamesScopePtr& names_scope,
	SrcLoc& src_loc )
{
	if( operator == OverloadedOperator::None ) { return; } // Non-operator

	if( class_type.empty() )
	{
		REPORT_ERROR( OperatorDeclarationOutsideClass, names_scope, src_loc )
		return;
	}

	auto class_type_non_null= class_type.try_to_non_nullable();

	{
		foreach( & param : func_type.params )
		{
			if( param.t == class_type_non_null )
			{
				break label this_call_check;
			}
		}

		REPORT_ERROR( OperatorDoesNotHaveParentClassArguments, names_scope, src_loc )
	} label this_call_check

	auto ret_is_void= func_type.return_type == void_type_ && func_type.return_value_type == ValueType::Value;

	if( operator == OverloadedOperator::Add ||
		operator == OverloadedOperator::Sub )
	{
		if( !( func_type.params.size() == 1s || func_type.params.size() == 2s ) )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
	}
	else
	if( operator == OverloadedOperator::Mul ||
		operator == OverloadedOperator::Div ||
		operator == OverloadedOperator::Rem ||
		operator == OverloadedOperator::And ||
		operator == OverloadedOperator::Or  ||
		operator == OverloadedOperator::Xor ||
		operator == OverloadedOperator::ShiftLeft  ||
		operator == OverloadedOperator::ShiftRight )
	{
		if( func_type.params.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
	}
	else
	if( operator == OverloadedOperator::AssignAdd ||
		operator == OverloadedOperator::AssignSub ||
		operator == OverloadedOperator::AssignMul ||
		operator == OverloadedOperator::AssignDiv ||
		operator == OverloadedOperator::AssignRem ||
		operator == OverloadedOperator::AssignAnd ||
		operator == OverloadedOperator::AssignOr  ||
		operator == OverloadedOperator::AssignXor ||
		operator == OverloadedOperator::AssignShiftLeft  ||
		operator == OverloadedOperator::AssignShiftRight ||
		operator == OverloadedOperator::Assign )
	{
		if( func_type.params.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
		if( !ret_is_void )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, src_loc, void_type_ )
		}
		if( !func_type.params.empty() && func_type.params.front().value_type != ValueType::ReferenceMut )
		{
			REPORT_ERROR( InvalidFirstParamValueTypeForAssignmentLikeOperator, names_scope, src_loc )
		}
	}
	else if( operator == OverloadedOperator::CompareEqual )
	{
		if( func_type.params.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
		if( !( func_type.return_type == bool_type_ && func_type.return_value_type == ValueType::Value ) )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, src_loc, void_type_ )
		}
	}
	else if( operator == OverloadedOperator::CompareOrder )
	{
		if( func_type.params.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
		if( !(
			!func_type.return_type.GetFundamentalType().empty() &&
			func_type.return_type.GetFundamentalType().try_deref().fundamental_type == U_FundamentalType::i32_ &&
			func_type.return_value_type == ValueType::Value ) )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, src_loc, GetFundamentalTypeName( U_FundamentalType::i32_ ) )
		}
	}
	else
	if( operator == OverloadedOperator::LogicalNot ||
		operator == OverloadedOperator::BitwiseNot )
	{
		if( func_type.params.size() != 1s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
	}
	else
	if( operator == OverloadedOperator::Increment ||
		operator == OverloadedOperator::Decrement )
	{
		if( func_type.params.size() != 1s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
		if( !ret_is_void )
		{
			REPORT_ERROR( InvalidReturnTypeForOperator, names_scope, src_loc, void_type_ )
		}
	}
	else if( operator == OverloadedOperator::Indexing )
	{
		if( func_type.params.size() != 2s )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
		// Indexing operator must have first argument of parent class.
		if( !func_type.params.empty() && func_type.params.front().t != class_type_non_null )
		{
			REPORT_ERROR( OperatorDoesNotHaveParentClassArguments, names_scope, src_loc )
		}
		// TODO - maybe also disable non-this-call indexing operator?
	}
	else if( operator == OverloadedOperator::Call )
	{
		if( func_type.params.empty() )
		{
			REPORT_ERROR( InvalidArgumentCountForOperator, names_scope, src_loc )
		}
		// Call operator must have first argument of parent class.
		if( !func_type.params.empty() && func_type.params.front().t != class_type_non_null )
		{
			REPORT_ERROR( OperatorDoesNotHaveParentClassArguments, names_scope, src_loc )
		}
	}
}

fn CodeBuilder::BuildFuncCode(
	mut this,
	NamesScopePtr& names_scope,
	FunctionVariable &mut func_variable,
	ust::shared_ptr_nullable_mut</ ReturnTypeDeductionContext /> mut return_type_deduction_context,
	ust::shared_ptr_nullable_mut</ ReferenceNotationDeductionContext /> mut reference_notation_deduction_context,
	ust::shared_ptr_nullable_mut</ LambdaPreprocessingContext /> mut lambda_preprocessing_context )
{
	if( func_variable.body_syntax_element.empty() )
	{
		return;
	}

	var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( func_variable );

	if( unsafe( LLVMCountBasicBlocks( llvm_function ) ) != 0u )
	{
		return; // Body already exists
	}

	// Mark this function specially in order to prevent its execution in constexpr context during its building.
	SetGlobalMetadata( llvm_function, "__U_incomplete_function_marker", unsafe( LLVMMDNodeInContext2( llvm_context_, ust::nullptr</LLVMMetadataRef/>(), 0s ) ) );

	auto body_syntax_element_ptr= func_variable.body_syntax_element.try_to_non_nullable();
	var Synt::Function& body_syntax_element= body_syntax_element_ptr.deref();

	var LLVMVisibility mut visibility= LLVMVisibility::Hidden;
	if( !func_variable.prototype_syntax_element.empty() &&
		IsSrcLocFromOtherImportedFile( func_variable.prototype_syntax_element.try_deref().src_loc ) )
	{
		// This function is declared within an imported file,
		// which means that is should be acessible outside current build target.
		// Mark such functions with default visibility. Other functions should have hidden visibility.
		visibility= LLVMVisibility::Default;
	}
	else
	{
		visibility= LLVMVisibility::Hidden;
	}

	if( names_scope.lock_imut().deref().IsInsideTemplate() )
	{
		// Set private visibility for functions inside templates.
		// There is no need to use external linkage, since each user of the template must import file with source template.
		unsafe( LLVMSetLinkage( llvm_function, LLVMLinkage::Private ) );
	}
	else if( !IsSrcLocFromMainFile( body_syntax_element.src_loc ) )
	{
		// This function is defined inside imported file - no need to use private linkage for it.
		unsafe( LLVMSetLinkage( llvm_function, LLVMLinkage::Private ) );
	}
	else if( func_variable.no_mangle )
	{
		// The only reason to use "nomangle" functions is to interact with external code.
		// For such purposes  external linkage is essential.
		unsafe( LLVMSetLinkage( llvm_function, LLVMLinkage::External ) );
		unsafe( LLVMSetVisibility( llvm_function, visibility ) );
	}
	else if( func_variable.prototype_syntax_element.empty() || IsSrcLocFromMainFile( func_variable.prototype_syntax_element.try_deref().src_loc ) )
	{
		// This function has no portotype in imported files.
		// There is no reason to use external linkage for it.
		unsafe( LLVMSetLinkage( llvm_function, LLVMLinkage::Private ) );
	}
	else
	{
		// This is a non-template function in main file, that has prototype in imported file. Use external linkage.
		unsafe( LLVMSetLinkage( llvm_function, LLVMLinkage::External ) );
		unsafe( LLVMSetVisibility( llvm_function, visibility ) );
	}

	debug_info_builder_.try_deref().CreateFunctionInfo( func_variable );

	var FunctionContext mut function_context(
		llvm_context_,
		llvm_function,
		func_variable.t );
	function_context.return_type_deduction_context= move(return_type_deduction_context);
	function_context.reference_notation_deduction_context= move(reference_notation_deduction_context);
	function_context.lambda_preprocessing_context= move(lambda_preprocessing_context);

	var NamesScopeMutPtr args_names_scope_ptr( NamesScope( "", names_scope ) );

	// Ensure type completness even for reference args because of reference checking.
	foreach( &param : func_variable.t.params )
	{
		if( !EnsureTypeComplete( param.t ) )
		{
			REPORT_ERROR( UsingIncompleteType, names_scope, body_syntax_element.src_loc, param.t )
			return;
		}
	}

	if( !EnsureTypeComplete( func_variable.t.return_type ) )
	{
		REPORT_ERROR( UsingIncompleteType, names_scope, body_syntax_element.src_loc, func_variable.t.return_type )
	}

	if( function_context.reference_notation_deduction_context.empty() )
	{
		// Perform notation checks only after requesting type completeness.
		CheckCompleteFunctionReferenceNotation( func_variable.t, names_scope, body_syntax_element.src_loc );
	}

	debug_info_builder_.try_deref().SetCurrentLocation( function_context, body_syntax_element.src_loc );

	with( mut args_names_scope_lock : args_names_scope_ptr.lock_mut() )
	{
		auto &mut args_names_scope= args_names_scope_lock.deref();

		var bool is_s_ret= FunctionTypeIsSRet( func_variable.t );
		if( is_s_ret )
		{
			unsafe
			{
				function_context.s_ret= LLVMGetParam( llvm_function, 0u );
				var ust::string_view8 param_name= "_return_value";
				LLVMSetValueName2( function_context.s_ret, param_name.data(), param_name.size() );
			}
		}

		auto first_llvm_arg= ( is_s_ret ? 1u : 0u );
		for( auto mut arg_n= 0s; arg_n < func_variable.t.params.size(); ++arg_n )
		{
			auto& in_param= body_syntax_element.function_type.params[arg_n];
			var FunctionType::Param& type_param= func_variable.t.params[arg_n];
			var u32 llvm_arg_n= first_llvm_arg + u32(arg_n);

			var Variable mut variable
			{
				.t= type_param.t,
				.value_type= ValueType::Value,
				.location= Variable::Location::Pointer,
				.name= in_param.name,
			};

			var LLVMValueRef arg_value= unsafe( LLVMGetParam( llvm_function, llvm_arg_n ) );
			unsafe( LLVMSetValueName2( arg_value, cast_mut(in_param.name).data(), in_param.name.size() ) );

			if( type_param.value_type == ValueType::Value )
			{
				if( !type_param.t.GetClassType().empty() || !type_param.t.GetArrayType().empty() || !type_param.t.GetTupleType().empty() )
				{
					var LLVMTypeRef single_scalar_type= GetSingleScalarType( type_param.t.GetLLVMType() );
					if( single_scalar_type != LLVMTypeRef::Null )
					{
						variable.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, type_param.t.GetLLVMType(), (in_param.name + "\0").front() ) );
						CreateLifetimeStart( function_context, variable.llvm_value );

						// Reinterpretete composite type address as scalar type address and store value in it.=
						unsafe( LLVMBuildStore( function_context.llvm_ir_builder, arg_value, variable.llvm_value ) );
					}
					else
					{
						// Large aggregate types are passed by reference.
						if( func_variable.IsCoroutine() )
						{
							// In coroutines we must save value args, passed by hidden reference, on local stack (this may be compiled as heap allocation).
							// This is needed, because address, allocated by coroutine function initial call, does not live long enough.
							variable.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, type_param.t.GetLLVMType(), (in_param.name + "\0").front() ) );
							CreateLifetimeStart( function_context, variable.llvm_value );
							CopyBytes( variable.llvm_value, arg_value, type_param.t, function_context );
						}
						else
						{
							variable.llvm_value= arg_value;
						}
					}
				}
				else
				{
					variable.llvm_value= unsafe( LLVMBuildAlloca( function_context.alloca_ir_builder, type_param.t.GetLLVMType(), (in_param.name + "\0").front() ) );
					CreateLifetimeStart( function_context, variable.llvm_value );
					CreateTypedStore( function_context, type_param.t, arg_value, variable.llvm_value );
				}

				debug_info_builder_.try_deref().CreateVariableInfo( function_context, variable, in_param.name, in_param.src_loc );

			}
			else
			{
				unsafe
				{
					auto arg_value= LLVMGetParam( llvm_function, llvm_arg_n );
					LLVMSetValueName2( arg_value, cast_mut(in_param.name).data(), in_param.name.size() );
					variable.llvm_value= arg_value;
				}

				debug_info_builder_.try_deref().CreateReferenceVariableInfo( function_context, variable, in_param.name, in_param.src_loc );
			}

			var Variable mut variable_reference
			{
				.t= type_param.t,
				.value_type= ( in_param.mutability_modifier == Synt::MutabilityModifier::Mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
				.location= Variable::Location::Pointer,
				.llvm_value= variable.llvm_value,
				.name= in_param.name,
				.src_loc= in_param.src_loc,
				.referenced= type_param.value_type == ValueType::Value && VariableExistenceMayHaveSideEffects(type_param.t)
			};

			var VariablePtr variable_ptr= move(variable).CreatePtr();
			var VariablePtr mut variable_reference_ptr= move(variable_reference).CreatePtr();

			function_context.references_graph.AddNode( variable_ptr );
			function_context.references_graph.AddNode( variable_reference_ptr );
			function_context.references_graph.AddLink( variable_ptr, variable_reference_ptr );

			var tup[ VariablePtr, ust::vector</VariablePtr /> ] mut arg_nodes[ variable_ptr, () ];

			auto reference_tag_count= size_type( type_param.t.ReferenceTagCount() );
			for( auto mut i= 0s; i < reference_tag_count; ++i )
			{
				var VariablePtr variable_inner_reference_node= variable_ptr.lock_imut().deref().inner_reference_nodes[i];
				function_context.references_graph.AddLink(
					variable_inner_reference_node,
					variable_reference_ptr.lock_imut().deref().inner_reference_nodes[i] );

				var VariablePtr accessible_variable_ptr=
					Variable
					{
						.t= invalid_type_,
						.value_type= ValueType::Value,
						.location= Variable::Location::Pointer,
						.name= in_param.name + " referenced variable"
					}.CreatePtr();

				var SecondOrderInnerReferenceKind second_order_inner_reference_kind= type_param.t.GetSecondOrderInnerReferenceKind(i);
				var VariableNullablePtr mut accessible_variable_inner_reference_opt;
				if( second_order_inner_reference_kind != SecondOrderInnerReferenceKind::None )
				{
					var VariablePtr mut accessible_variable_inner_reference=
						Variable
						{
							.t= invalid_type_,
							.value_type=
								( second_order_inner_reference_kind == SecondOrderInnerReferenceKind::Imut
									? ValueType::ReferenceImut
									: ValueType::ReferenceMut ),
							.location= Variable::Location::Pointer,
							.name= ust::concat( in_param.name, " referenced variable ", ust::to_string8(i), " inner reference" ),
							.is_inner_reference_node= true,
							.is_variable_inner_reference_node= true,
						}.CreatePtr();

					accessible_variable_inner_reference_opt= accessible_variable_inner_reference;

					auto mut accessible_variable_lock= accessible_variable_ptr.lock_mut();
					accessible_variable_lock.deref().inner_reference_nodes.push_back( move( accessible_variable_inner_reference ) );
				}

				function_context.references_graph.AddNode( accessible_variable_ptr );

				function_context.references_graph.AddLink( accessible_variable_ptr, variable_inner_reference_node );

				arg_nodes[1].push_back( accessible_variable_ptr );

				if( second_order_inner_reference_kind != SecondOrderInnerReferenceKind::None )
				{
					var VariablePtr second_order_accesible_variable=
						Variable
						{
							.t= invalid_type_,
							.value_type= ValueType::Value,
							.location= Variable::Location::Pointer,
							.name= ust::concat( in_param.name, " second order referenced variable ", ust::to_string8(i) ),
						}.CreatePtr();

					function_context.references_graph.AddNode( second_order_accesible_variable );

					function_context.references_graph.AddLink( second_order_accesible_variable, accessible_variable_inner_reference_opt.try_to_non_nullable() );

					function_context.args_second_order_nodes.resize( func_variable.t.params.size() );
					function_context.args_second_order_nodes[ arg_n ].resize( reference_tag_count );
					function_context.args_second_order_nodes[ arg_n ][i]= second_order_accesible_variable;
				}
			}

			function_context.args_nodes.push_back( move(arg_nodes) );

			// Register arg for destruction and reference checking.
			if( type_param.value_type == ValueType::Value )
			{
				RegisterTopFrameVariable( function_context, variable_ptr );
			}
			RegisterTopFrameVariable( function_context, variable_reference_ptr );

			if( in_param.name == KeywordToString( Keyword::this_ ) && func_variable.is_this_call )
			{
				function_context.this_= move(variable_reference_ptr);
			}
			else
			{
				var bool insert_ok= !args_names_scope.AddName( in_param.name, move(variable_reference_ptr) ).empty();
				if( !insert_ok )
				{
					REPORT_ERROR( Redefinition, names_scope, in_param.src_loc, in_param.name )
				}
			}
		}
	}

	var ust::shared_ptr_nullable_imut</Variable/> mut lambda_this;
	if( !function_context.this_.empty() )
	{
		var VariablePtr this_= function_context.this_.try_to_non_nullable();
		var Type this_t= this_.lock_imut().deref().t;
		if_var( &this_class_type_ptr : this_t.GetClassType() )
		{
			with( &this_class_type : this_class_type_ptr.lock_imut().deref() )
			{
				if( this_class_type.generated_class_data.has</ LambdaClassData />() )
				{
					if( func_variable.t.params.front().value_type == ValueType::Value &&
						body_syntax_element.function_type.params.front().mutability_modifier == Synt::MutabilityModifier::Mutable )
					{
						// If this is a "byval mut" lambda - create names for captured variables as params, in order to have possibility to move them.
						foreach( &field_pair : this_class_type.fields_order )
						{
							auto& field_name= field_pair[0];
							auto field_lock= field_pair[1].lock_imut();
							var ClassField& field= field_lock.deref();

							var LLVMValueRef field_address= CreateClassFieldGEP( function_context, this_class_type_ptr, this_.lock_imut().deref().llvm_value, field );
							var LLVMValueRef llvm_value=
								( field.is_reference
									? CreateTypedReferenceLoad( function_context, field.t, field_address )
									: field_address );

							var VariablePtr variable_ptr=
								Variable
								{
									.t= field.t,
									.value_type= ValueType::Value,
									.location= Variable::Location::Pointer,
									.name= field_name,
									.llvm_value= llvm_value,
								}.CreatePtr();

							var VariablePtr variable_reference_ptr=
								Variable
								{
									.t= field.t,
									.value_type= ( field.is_mutable ? ValueType::ReferenceMut : ValueType::ReferenceImut ),
									.location= Variable::Location::Pointer,
									.name= field_name,
									.llvm_value= llvm_value,
								}.CreatePtr();

							function_context.references_graph.AddNode( variable_ptr );
							function_context.references_graph.AddNode( variable_reference_ptr );
							function_context.references_graph.AddLink( variable_ptr, variable_reference_ptr );

							if( !field.is_reference )
							{
								RegisterTopFrameVariable( function_context, variable_ptr );
							}
							RegisterTopFrameVariable( function_context, variable_reference_ptr );

							auto reference_tag_count= size_type(field.t.ReferenceTagCount());
							for( auto mut i= 0s; i < reference_tag_count; ++i )
							{
								var VariablePtr variable_inner_reference_node= variable_ptr.lock_imut().deref().inner_reference_nodes[i];

								var VariablePtr accessible_variable_ptr=
									Variable
									{
										.t= invalid_type_,
										.value_type= ValueType::Value,
										.location= Variable::Location::Pointer,
										.name= field_name + " referenced variable"
									}.CreatePtr();

								var SecondOrderInnerReferenceKind second_order_inner_reference_kind= field.t.GetSecondOrderInnerReferenceKind(i);
								var VariableNullablePtr mut accessible_variable_inner_reference_opt;
								if( second_order_inner_reference_kind != SecondOrderInnerReferenceKind::None )
								{
									var VariablePtr mut accessible_variable_inner_reference=
										Variable
										{
											.t= invalid_type_,
											.value_type=
												( second_order_inner_reference_kind == SecondOrderInnerReferenceKind::Imut
													? ValueType::ReferenceImut
													: ValueType::ReferenceMut ),
											.location= Variable::Location::Pointer,
											.name= ust::concat( field_name, " referenced variable ", ust::to_string8(i), " inner reference" ),
											.is_inner_reference_node= true,
											.is_variable_inner_reference_node= true,
										}.CreatePtr();

									accessible_variable_inner_reference_opt= accessible_variable_inner_reference;

									auto mut accessible_variable_lock= accessible_variable_ptr.lock_mut();
									accessible_variable_lock.deref().inner_reference_nodes.push_back( move( accessible_variable_inner_reference ) );
								}

								function_context.references_graph.AddNode( accessible_variable_ptr );
								function_context.references_graph.AddLink( accessible_variable_ptr, variable_inner_reference_node );
								function_context.references_graph.AddLink(
									variable_inner_reference_node,
									variable_reference_ptr.lock_imut().deref().inner_reference_nodes[i] );

								if( second_order_inner_reference_kind != SecondOrderInnerReferenceKind::None )
								{
									var VariablePtr second_order_accesible_variable=
										Variable
										{
											.t= invalid_type_,
											.value_type= ValueType::Value,
											.location= Variable::Location::Pointer,
											.name= field_name + " second order referenced variable " + ust::to_string8(i),
										}.CreatePtr();

									function_context.references_graph.AddNode( second_order_accesible_variable );
									function_context.references_graph.AddLink( second_order_accesible_variable, accessible_variable_inner_reference_opt.try_to_non_nullable() );
								}
							}

							with( mut lock : args_names_scope_ptr.lock_mut() )
							{
								lock.deref().AddName( field_name, variable_reference_ptr );
							}
						}

						// Move "this" to prevent its destruction.
						// Destroy instead each member separately.
						var ReferencesGraph::NodesSet this_input_nodes= function_context.references_graph.GetNodeInputLinks( this_ );
						debug_assert( this_input_nodes.size() == 1s );
						function_context.references_graph.MoveNode( this_input_nodes.iter().first().try_deref() );
						function_context.references_graph.MoveNode( this_ );
					}
					else
					{
						// Just create names for lambda fields, if it's not possible to move these fields.
						foreach( &field_pair : this_class_type.fields_order )
						{
							var Value field_value= AccessClassField( args_names_scope_ptr, function_context, this_, field_pair[1].lock_imut().deref(), field_pair[0], body_syntax_element.src_loc );
							if_var( &variable : field_value.get</VariablePtr/>() )
							{
								with( mut lock : args_names_scope_ptr.lock_mut() )
								{
									lock.deref().AddName( field_pair[0], variable );
								}
							}
						}
					}

					// Make "this" unavailable in lambdas.
					// Save "this" into a stack variable in order to prevent its destruction.
					lambda_this= this_;
					function_context.this_.reset();
				}
			}
		}
	}

	if( func_variable.IsCoroutine() )
	{
		// Create coroutine entry block after saving args to stack.
		PrepareCoroutineBlocks( function_context );
		// Generate also initial suspend.
		CoroutineSuspend( args_names_scope_ptr, function_context, body_syntax_element.src_loc );
	}

	{
		auto& block= body_syntax_element.block.try_deref();

		auto& func_name= body_syntax_element.name.back();
		auto is_constructor= func_name == KeywordToString( Keyword::constructor_ );
		auto is_destructor = func_name == KeywordToString( Keyword::destructor_  );
		if( is_constructor )
		{
			WithVariablesFrame(
				function_context,
				lambda[&]( CodeBuilder &mut self, FunctionContext &mut function_context )
				{
					if_var( &initializer : body_syntax_element.constructor_initializer_list )
					{
						self.BuildConstructorInitialization(
							args_names_scope_ptr,
							function_context,
							initializer );
					}
					else
					{
						var Synt::StructNamedInitializer dummy_initializer{ .src_loc= block.src_loc };
						self.BuildConstructorInitialization(
							args_names_scope_ptr,
							function_context,
							dummy_initializer );
					}
				} );
		}
		if( is_destructor )
		{
			function_context.destructor_end_block= unsafe( LLVMCreateBasicBlockInContext( llvm_context_, "destructor_end\0"[0] ) );

			if( !function_context.this_.empty() && function_context.this_.try_lock_imut().deref().t.ContainsMutableReferences() )
			{
				// Do not allow to access "this" in destructors of structs with mutable references inside.
				// Allow only accessing separate fields.
				// This is needed in order to prevent invalidation of possible derived references in destructor calls.
				function_context.whole_this_is_unavailable= true;
			}
		}

		if( is_constructor || is_destructor )
		{
			// Setup virtual table pointers before main body of constructor/destructor and after constructor initialization list.
			var VariablePtr this_ptr= function_context.this_.try_to_non_nullable();
			with( &this_ : this_ptr.lock_imut().deref() )
			{
				auto class_type= this_.t.GetClassType().try_deref();
				SetupVirtualTablePointers( this_.llvm_value, class_type, function_context );

				auto class_kind= class_type.lock_imut().deref().kind;
				if( class_kind == ClassType::Kind::Interface || class_kind == ClassType::Kind::Abstract )
				{
					function_context.whole_this_is_unavailable= true;
				}
			}
		}

		// Reuse names scope of args for root function block.
		auto block_build_info= BuildBlockElements( args_names_scope_ptr, function_context, block.elements );
		if( !block_build_info.has_terminal_instruction_inside )
		{
			if( func_variable.kind == FunctionVariable::Kind::Generator )
			{
				// Finish generator function with final suspend.
				CoroutineFinalSuspend( args_names_scope_ptr, function_context, block.end_src_loc );
			}
			else if( func_variable.kind == FunctionVariable::Kind::Async )
			{
				// Automatically generate final suspend for void-return async functions.
				auto coroutine_type_description= function_context.function_type.return_type.GetClassType().try_deref().lock_imut().deref().generated_class_data.try_get</ CoroutineTypeDescription />();
				if( !( coroutine_type_description.return_type == void_type_ && coroutine_type_description.return_value_type == ValueType::Value ) )
				{
					REPORT_ERROR( NoReturnInFunctionReturningNonVoid, args_names_scope_ptr, block.end_src_loc )
					return;
				}

				CoroutineFinalSuspend( args_names_scope_ptr, function_context, block.end_src_loc );
			}
			else if( !function_context.return_type_deduction_context.empty() )
			{
				if( !function_context.reference_notation_deduction_context.empty() )
				{
					CollectReferencePollution( function_context );
				}
			}
			else
			{
				// Automatically generate "return" for void-return functions.
				if( !( func_variable.t.return_type == void_type_ && func_variable.t.return_value_type == ValueType::Value ) )
				{
					REPORT_ERROR( NoReturnInFunctionReturningNonVoid, args_names_scope_ptr, block.end_src_loc )
					return;
				}

				BuildEmptyReturn( args_names_scope_ptr, function_context, block.end_src_loc );
			}
		}

		// Finsih function - add remaining instructions
		debug_info_builder_.try_deref().SetCurrentLocation( function_context, block.end_src_loc );
		unsafe
		{
			if( function_context.destructor_end_block != LLVMBasicBlockRef::Null && !function_context.this_.empty() )
			{
				LLVMAppendExistingBasicBlock( function_context.llvm_function, function_context.destructor_end_block );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, function_context.destructor_end_block );

				var VariableLite this_copy= function_context.this_.try_to_non_nullable();
				if_var( &class_type : this_copy.t.GetClassType() )
				{
					BuildMembersDestructors( function_context, this_copy.llvm_value, class_type );
				}
				LLVMBuildRetVoid( function_context.llvm_ir_builder );
			}

			LLVMBuildBr( function_context.alloca_ir_builder, function_context.function_basic_block );
		}
	}

	CheckForUnusedLocalNames( args_names_scope_ptr );

	if( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::NonConstexpr )
	{
		auto mut can_be_constexpr= true;

		auto& function_type= func_variable.t;

		can_be_constexpr&=
			!function_type.is_unsafe &&
			function_type.return_type.CanBeConstexpr() &&
			function_type.return_type.GetFunctionPointerType().empty();

		foreach( &param : function_type.params )
		{
			can_be_constexpr&=
				param.t.CanBeConstexpr() &&
				param.t.GetFunctionPointerType().empty();  // Currently function pointers not supported.
		}

		if( !function_context.return_type_deduction_context.empty() )
		{
			with( &return_type_deduction_context : function_context.return_type_deduction_context.try_lock_imut().deref() )
			{
				if_var( &t : return_type_deduction_context.return_type )
				{
					can_be_constexpr&=
						t.CanBeConstexpr() &&
						t.GetFunctionPointerType().empty();
				}
			}
		}

		if( !can_be_constexpr )
		{
			if( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::ConstexprAuto )
			{
				REPORT_ERROR( InvalidTypeForConstexprFunction, names_scope, body_syntax_element.src_loc )
			}
			func_variable.constexpr_kind= FunctionVariable::ConstexprKind::NonConstexpr;
		}
		else if( function_context.has_non_constexpr_operations_inside )
		{
			if( func_variable.constexpr_kind != FunctionVariable::ConstexprKind::ConstexprAuto )
			{
				REPORT_ERROR( ConstexprFunctionContainsUnallowedOperations, names_scope, body_syntax_element.src_loc )
			}
			func_variable.constexpr_kind= FunctionVariable::ConstexprKind::NonConstexpr;
		}
		else
		{
			func_variable.constexpr_kind= FunctionVariable::ConstexprKind::ConstexprComplete;
		}
	}

	// Early return for auto-return function preprocessing.
	if( !function_context.return_type_deduction_context.empty() )
	{
		return;
	}

	// Early return for lambda preprocessing.
	if( !function_context.lambda_preprocessing_context.empty() )
	{
		return;
	}

	// Perform final steps for regular functions (if this is not some preprocessing).

	// Clear incomplete function marker. Now it is safe to execute it in constexpr context.
	EraseGlobalMetadata( llvm_function, "__U_incomplete_function_marker" );

	unsafe( U1_TryToPerformReturnValueAllocationOptimization( llvm_function ) );

}

fn CodeBuilder::TryCallCopyConstructor(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	LLVMValueRef dst, LLVMValueRef src,
	ClassTypePtr& class_type,
	SrcLoc& src_loc )
{
	// TODO - maybe combine this with "BuildCopyConstructorPart" method?
	if( !class_type.lock_imut().deref().is_copy_constructible )
	{
		REPORT_ERROR( CopyConstructValueOfNoncopyableType, names_scope, src_loc, Type(class_type) )
		return;
	}

	if( !class_type.lock_imut().deref().can_be_constexpr )
	{
		function_context.has_non_constexpr_operations_inside= true;
	}

	BuildCopyConstructorPart( names_scope, function_context, dst, src, class_type, src_loc );
}

fn CodeBuilder::CheckForUnusedGlobalNames( this, NamesScopePtr& names_scope )
{
	if( !report_about_unused_names_ )
	{
		return;
	}

	CheckForUnusedGlobalNamesImpl( names_scope );
}

fn CodeBuilder::CheckForUnusedGlobalNamesImpl( this, NamesScopePtr& names_scope )
{
	foreach( &name_pair : names_scope.lock_imut().deref() )
	{
		var ust::string8& name= name_pair.key();
		var NamesScopeValue& names_scope_value= name_pair.value();

		auto inner_namespace= names_scope_value.Get</NamesScope/>();
		if( !inner_namespace.empty() )
		{
			CheckForUnusedGlobalNamesImpl( inner_namespace.try_to_non_nullable() );
		}

		auto functions_set_ptr= names_scope_value.Get</FunctionsSet/>();
		if( !functions_set_ptr.empty() )
		{
			with( &functions_set : functions_set_ptr.try_lock_imut().deref() )
			{
				foreach( &function : functions_set.functions )
				{
					var SrcLoc mut body_src_loc, mut prototye_src_loc;
					if_var( &el : function.prototype_syntax_element )
					{
						body_src_loc= el.src_loc;
						prototye_src_loc= body_src_loc;
					}
					if_var( &el : function.body_syntax_element )
					{
						body_src_loc= el.src_loc;
					}

					if( !function.llvm_function.lock_imut().deref().referenced &&
						// Enable unreferenced "nomangle" functions, but only with body.
						!( function.no_mangle && !function.body_syntax_element.empty() && !function.body_syntax_element.try_deref().block.empty() ) &&
						function.virtual_table_index == ~0u &&
						IsSrcLocFromMainFile( body_src_loc ) &&
						IsSrcLocFromMainFile( prototye_src_loc ) )
					{
						var bool mut is_special_method= false;
						if( !functions_set.class_.empty() )
						{
							auto class_= functions_set.class_.try_to_non_nullable();
							if( name == KeywordToString( Keyword::destructor_ ) ||
								( name == KeywordToString( Keyword::constructor_ ) &&
									( IsCopyConstructor( function, class_ ) || IsDefaultConstructor( function, class_ ) ) ) ||
								( name == OverloadedOperatorToString( OverloadedOperator::Assign ) && IsCopyAssignmentOperator( function, class_ ) ) ||
								( name == OverloadedOperatorToString( OverloadedOperator::CompareEqual ) && IsEqualityCompareOperator( function, class_ ) ) )
							{
								is_special_method= true;
							}
						}

						if( !is_special_method )
						{
							REPORT_ERROR( UnusedName, names_scope, body_src_loc, name )
						}
					}
				}
			}
		}

		auto global_variable_ptr= names_scope_value.Get</GlobalVariable/>();
		if( !global_variable_ptr.empty() )
		{
			with( &global_variable : global_variable_ptr.try_lock_imut().deref() )
			{
				var SrcLoc& src_loc= global_variable.syntax_element.deref().variables[ size_type(global_variable.variable_index) ].src_loc;
				if( !global_variable.referenced && IsSrcLocFromMainFile( src_loc ) )
				{
					REPORT_ERROR( UnusedName, names_scope, src_loc, name )
				}
			}
		}

		auto global_auto_variable_ptr= names_scope_value.Get</GlobalAutoVariable/>();
		if( !global_auto_variable_ptr.empty() )
		{
			with( &global_auto_variable : global_auto_variable_ptr.try_lock_imut().deref() )
			{
				var SrcLoc& src_loc= global_auto_variable.syntax_element.deref().src_loc;
				if( !global_auto_variable.referenced && IsSrcLocFromMainFile( src_loc ) )
				{
					REPORT_ERROR( UnusedName, names_scope, src_loc, name )
				}
			}
		}

		auto class_type_ptr= names_scope_value.Get</ClassType/>();
		if( !class_type_ptr.empty() )
		{
			with( &class_type : class_type_ptr.try_lock_imut().deref() )
			{
				if( !class_type.referenced && !class_type.syntax_element.empty() )
				{
					var SrcLoc& src_loc= class_type.syntax_element.try_deref().src_loc;
					if( IsSrcLocFromMainFile( src_loc ) )
					{
						REPORT_ERROR( UnusedName, names_scope, src_loc, name )
					}
				}
			}

			var NamesScopePtr class_members= class_type_ptr.try_lock_imut().deref().members;
			if( class_members.lock_imut().deref().GetParent() == names_scope )
			{
				CheckForUnusedGlobalNamesImpl( class_members );
			}
		}

		auto enum_type_ptr= names_scope_value.Get</Enum/>();
		if( !enum_type_ptr.empty() )
		{
			with( &enum_ : enum_type_ptr.try_lock_imut().deref() )
			{
				var SrcLoc& src_loc= enum_.syntax_element.deref().src_loc;
				if( !enum_.referenced && IsSrcLocFromMainFile( src_loc ) )
				{
					REPORT_ERROR( UnusedName, names_scope, src_loc, name )
				}
			}
		}

		auto type_alias_ptr= names_scope_value.Get</TypeAlias/>();
		if( !type_alias_ptr.empty() )
		{
			with( &type_alias : type_alias_ptr.try_lock_imut().deref() )
			{
				var SrcLoc& src_loc= type_alias.syntax_element.deref().src_loc;
				if( !type_alias.referenced && IsSrcLocFromMainFile( src_loc ) )
				{
					REPORT_ERROR( UnusedName, names_scope, src_loc, name )
				}
			}
		}

		auto type_templates_set_ptr= names_scope_value.Get</TypeTemplatesSet/>();
		if( !type_templates_set_ptr.empty() )
		{
			with( &type_templates_set : type_templates_set_ptr.try_lock_imut().deref() )
			{
				foreach( &type_template_ptr : type_templates_set.type_templates )
				{
					with( &type_template : type_template_ptr.lock_imut().deref() )
					{
						var SrcLoc& src_loc= type_template.syntax_element.deref().src_loc;
						if( !type_template.used && IsSrcLocFromMainFile( src_loc ) )
						{
							REPORT_ERROR( UnusedName, names_scope, src_loc, name )
						}
					}
				}
			}
		}

		auto class_field_ptr= names_scope_value.Get</ClassField/>();
		if( !class_field_ptr.empty() )
		{
			with( &class_field : class_field_ptr.try_lock_imut().deref() )
			{
				var SrcLoc& src_loc= class_field.syntax_element.deref().src_loc;
				if( !class_field.used && IsSrcLocFromMainFile( src_loc ) )
				{
					REPORT_ERROR( UnusedName, names_scope, src_loc, name )
				}
			}
		}
	}
}

fn CodeBuilder::CheckForUnusedLocalNames( this, NamesScopePtr& names_scope )
{
	if( !report_about_unused_names_ )
	{
		return;
	}

	foreach( &name_pair : names_scope.lock_imut().deref() )
	{
		var ust::string8& name= name_pair.key();
		var NamesScopeValue& names_scope_value= name_pair.value();

		auto variable_ptr= names_scope_value.Get</Variable/>();
		if( !variable_ptr.empty() )
		{
			with( &variable : variable_ptr.try_lock_imut().deref() )
			{
				if( !variable.referenced && IsSrcLocFromMainFile( variable.src_loc ) )
				{
					REPORT_ERROR( UnusedName, names_scope, variable.src_loc, name )
				}
			}
		}

		auto type_alias_ptr= names_scope_value.Get</TypeAlias/>();
		if( !type_alias_ptr.empty() )
		{
			with( &type_alias : type_alias_ptr.try_lock_imut().deref() )
			{
				var SrcLoc& src_loc= type_alias.syntax_element.deref().src_loc;
				if( !type_alias.referenced )
				{
					REPORT_ERROR( UnusedName, names_scope, src_loc, name )
				}
			}
		}
	}
}

fn CodeBuilder::VariableExistenceMayHaveSideEffects( Type& variable_type ) : bool
{
	// Normally we should perform deep inspection in order to know, that existance of the variable has sense.
	// For example, "ust::string8" has non-trivial destructor, but it just frees memory.
	// But such check is too hard to implement, so, assume, that only variables of types with trivial (no-op) destructor may be considered unused.
	var bool destructor_is_trivial=
		// Constexpr types are fundamentals, enums, function pointers, some structs.
		variable_type.CanBeConstexpr() ||
		// Raw pointers are non-constexpr, but trivially-destructible.
		!variable_type.GetRawPointerType().empty();

	return !destructor_is_trivial;
}

fn CodeBuilder::CallDestructorsForVariablesFrame( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variables_frame_index, SrcLoc& src_loc )
{
	// Call destructors in reverse order.
	for( auto mut i= function_context.variables_frames[variables_frame_index].variables.size(); i > 0s; --i )
	{
		auto variable_ptr= function_context.variables_frames[variables_frame_index].variables[i - 1s];
		auto variable_lock= variable_ptr.lock_imut();
		var Variable& variable= variable_lock.deref();

		// Call destructors for variables, but not for references.
		if( variable.value_type == ValueType::Value )
		{
			if( function_context.references_graph.HasOutgoingLinks( variable_ptr ) )
			{
				REPORT_ERROR( DestroyedVariableStillHasReferences, names_scope, src_loc, variable.name )
			}
			if( !function_context.references_graph.NodeIsMoved( variable_ptr ) )
			{
				if( variable.t.HasDestructor() )
				{
					BuildDestructorPart( names_scope, function_context, variable.llvm_value, variable.t, src_loc );
				}

				// Do not create lifetime for variables existing only in llvm register (without any address).
				if( variable.location == Variable::Location::Pointer )
				{
					CreateLifetimeEnd( function_context, variable.llvm_value );
				}
			}
		}

		function_context.references_graph.RemoveNode( variable_ptr );
	}

	if( !function_context.is_functionless_context )
	{
		// Free memory allocated for "alloca" declarations.
		// It's important to do this in reverse order, since allocations are made mostly by manipulation of the program stack.
		for( auto mut i= function_context.variables_frames[variables_frame_index].allocas.size(); i > 0s; --i )
		{
			var AllocaInfo& alloca_info= function_context.variables_frames[variables_frame_index].allocas[ i - 1s ];

			var LLVMValueRef mut ptr_for_free= alloca_info.ptr_for_free;

			unsafe // Because of LLVM callse
			{
				var LLVMBasicBlockRef stack_allocation_block= LLVMCreateBasicBlockInContext( llvm_context_, "stack_allocation_free_block\0"[0] );
				var LLVMBasicBlockRef heap_allocation_block= LLVMCreateBasicBlockInContext( llvm_context_, "heap_allocation_free_block\0"[0] );
				var LLVMBasicBlockRef end_block= LLVMCreateBasicBlockInContext( llvm_context_, g_null_string );

				LLVMBuildCondBr( function_context.llvm_ir_builder, alloca_info.is_stack_allocation, stack_allocation_block, heap_allocation_block );

				// Stack allocation block.
				LLVMAppendExistingBasicBlock( function_context.llvm_function, stack_allocation_block );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, stack_allocation_block );
				LLVMBuildCall2(
					function_context.llvm_ir_builder,
					U1_GetFunctionType( stackrestore_intrinsic_ ),
					stackrestore_intrinsic_,
					$<(ptr_for_free),
					1u,
					g_null_string );
				LLVMBuildBr( function_context.llvm_ir_builder, end_block );

				// Heap allocation block.
				LLVMAppendExistingBasicBlock( function_context.llvm_function, heap_allocation_block );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, heap_allocation_block );
				LLVMBuildCall2(
					function_context.llvm_ir_builder,
					U1_GetFunctionType( free_function_ ),
					free_function_,
					$<(ptr_for_free),
					1u,
					g_null_string );
				LLVMBuildBr( function_context.llvm_ir_builder, end_block );

				// End block.
				LLVMAppendExistingBasicBlock( function_context.llvm_function, end_block );
				LLVMPositionBuilderAtEnd( function_context.llvm_ir_builder, end_block );
			}
		}
	}
}

fn CodeBuilder::CallDestructorsForTopVariablesFrame( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc )
{
	auto variables_frame_index= function_context.variables_frames.size() - 1s;
	CallDestructorsForVariablesFrame( names_scope, function_context, variables_frame_index, src_loc );
}

fn CodeBuilder::CallDestructorsForAllVariablesFrames( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, SrcLoc& src_loc )
{
	for( auto mut i= function_context.variables_frames.size(); i > 0s; --i )
	{
		CallDestructorsForVariablesFrame( names_scope, function_context, i - 1s, src_loc );
	}
}

fn CodeBuilder::CallDestructorsForLoopInnerVariables( mut this, NamesScopePtr& names_scope, FunctionContext &mut function_context, size_type variable_frames_stack_size, SrcLoc& src_loc )
{
	for( var size_type mut i= function_context.variables_frames.size(); i > variable_frames_stack_size; --i )
	{
		CallDestructorsForVariablesFrame( names_scope, function_context, i - 1s, src_loc );
	}
}

fn CodeBuilder::DestroyUnusedTemporaryVariables( mut this, NamesScopePtr& names_scope, FunctionContext& mut function_context, SrcLoc& src_loc )
{
	/// Try to remove unused nodes (variables and references) until we can't remove anything.
	// Multiple iterations needed to process complex references chains.
	loop
	{
		// Perform removal with total order preservation.
		var size_type s= function_context.variables_frames.back().variables.size(), mut i_src(0), mut i_dst(0);
		for( ; i_src < s; ++i_src )
		{
			var VariablePtr variable_ptr= function_context.variables_frames.back().variables[i_src];
			auto variable_lock= variable_ptr.lock_imut();
			var Variable& variable= variable_lock.deref();

			// Destroy variables without links.
			// Destroy all references, because all actual references that holds values should not yet be registered.
			// Preserve variables with "preserve_temporary" flag set, unless they are already moved.
			if( variable.preserve_temporary )
			{
				if( function_context.references_graph.NodeIsMoved( variable_ptr ) )
				{
					function_context.references_graph.RemoveNode( variable_ptr );
					// Remove this variable from the container.
				}
				else
				{
					// Preserve this variable in the container.
					function_context.variables_frames.back().variables[i_dst]= variable_ptr;
					++i_dst;
				}
			}
			else if( variable.value_type != ValueType::Value || !function_context.references_graph.HasOutgoingLinks( variable_ptr ) )
			{
				// Emit destructions call code only if it is a non-moved variable.
				if( variable.value_type == ValueType::Value && !function_context.is_functionless_context && !function_context.references_graph.NodeIsMoved( variable_ptr ) )
				{
					if( variable.llvm_value != LLVMValueRef::Null && variable.t.HasDestructor() )
					{
						BuildDestructorPart( names_scope, function_context, variable.llvm_value, variable.t, src_loc );
					}

					// Do not create lifetime for variables existing only in llvm register (without any address).
					if( variable.location == Variable::Location::Pointer )
					{
						CreateLifetimeEnd( function_context, variable.llvm_value );
					}
				}

				function_context.references_graph.RemoveNode( variable_ptr );
				// Remove this variable from the container.
			}
			else
			{
				// Preserve this variable in the container.
				function_context.variables_frames.back().variables[i_dst]= variable_ptr;
				++i_dst;
			}
		}

		if( i_dst == s )
		{
			// Nothing was removed.
			return;
		}

		function_context.variables_frames.back().variables.drop_back( s - i_dst );
	}
}

fn CodeBuilder::RegisterTemporaryVariable( FunctionContext& mut function_context, VariablePtr mut variable )
{
	function_context.variables_frames.back().variables.push_back( move(variable) );
}

fn CodeBuilder::RegisterTopFrameVariable( FunctionContext& mut function_context, VariablePtr mut variable )
{
	RegisterFrameVariable( function_context, move(variable), 0s );
}

fn CodeBuilder::RegisterFrameVariable( FunctionContext& mut function_context, VariablePtr mut variable, size_type frame_index_from_top )
{
	auto frame_index= function_context.variables_frames.size() - frame_index_from_top - 1s;
	function_context.variables_frames[frame_index].variables.push_back( move(variable) );
}

fn CodeBuilder::IsTypeComplete( this, Type& t ) : bool
{
	if_var( &class_type_ptr : t.GetClassType() )
	{
		return class_type_ptr.lock_imut().deref().is_complete;
	}
	if_var( &enum_type_ptr : t.GetEnumType() )
	{
		return enum_type_ptr.lock_imut().deref().underlying_type.llvm_type != LLVMTypeRef::Null;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		return IsTypeComplete( array_type.element_type );
	}
	if_var( &tuple_type : t.GetTupleType() )
	{
		var bool mut complete= true;
		foreach( &element_type : tuple_type.element_types )
		{
			complete&= IsTypeComplete( element_type );
		}
		return complete;
	}

	return true;
}

fn CodeBuilder::EnsureTypeComplete( mut this, Type& t ) : bool
{
	if_var( &class_type_ptr : t.GetClassType() )
	{
		// TODO - maybe names scope is not needed here?
		auto class_parent_scope= class_type_ptr.lock_imut().deref().members.lock_imut().deref().GetParent().try_to_non_nullable();

		BuildClass( class_parent_scope, class_type_ptr );
		return class_type_ptr.lock_imut().deref().is_complete;
	}
	if_var( &enum_type_ptr : t.GetEnumType() )
	{
		auto enum_parent_scope= enum_type_ptr.lock_imut().deref().names_scope.lock_imut().deref().GetParent().try_to_non_nullable();
		BuildEnum( enum_parent_scope, enum_type_ptr );

		return enum_type_ptr.lock_imut().deref().underlying_type.llvm_type != LLVMTypeRef::Null;
	}
	if_var( &array_type : t.GetArrayType() )
	{
		return EnsureTypeComplete( array_type.element_type );
	}
	if_var( &tuple_type : t.GetTupleType() )
	{
		var bool mut ok= true;
		foreach( &element_type : tuple_type.element_types )
		{
			ok&= EnsureTypeComplete( element_type );
		}
		return ok;
	}

	return true;
}

fn CodeBuilder::IsDefaultConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( !function_variable.is_this_call ){ return false; }
	if( function_variable.t.params.size() != 1s ){ return false; }

	auto& param= function_variable.t.params.front();
	return param.t == class_type && param.value_type == ValueType::ReferenceMut;
}

fn CodeBuilder::IsCopyConstructor( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( !function_variable.is_this_call ){ return false; }
	if( function_variable.t.params.size() != 2s ){ return false; }

	auto& param_dst= function_variable.t.params.front();
	auto& param_src= function_variable.t.params.back();
	return
		param_dst.t == class_type && param_dst.value_type == ValueType::ReferenceMut &&
		param_src.t == class_type && param_src.value_type == ValueType::ReferenceImut;
}

fn CodeBuilder::IsCopyAssignmentOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( function_variable.t.params.size() != 2s ){ return false; }

	auto& param_dst= function_variable.t.params.front();
	auto& param_src= function_variable.t.params.back();
	return
		param_dst.t == class_type && param_dst.value_type == ValueType::ReferenceMut &&
		param_src.t == class_type && param_src.value_type == ValueType::ReferenceImut;
}

fn CodeBuilder::IsEqualityCompareOperator( FunctionVariable& function_variable, ClassTypePtr& class_type ) : bool
{
	if( function_variable.t.params.size() != 2s ){ return false; }

	auto& param_l= function_variable.t.params.front();
	auto& param_r= function_variable.t.params.back();
	return
		param_l.t == class_type && param_l.value_type == ValueType::ReferenceImut &&
		param_r.t == class_type && param_r.value_type == ValueType::ReferenceImut &&
		!function_variable.t.return_type.GetFundamentalType().empty() && function_variable.t.return_type.GetFundamentalType().try_deref().fundamental_type == U_FundamentalType::bool_ &&
		function_variable.t.return_value_type == ValueType::Value;
}

fn CodeBuilder::AddGlobalConstantVariable( this, ust::string_view8 name_null_terminated, LLVMTypeRef llvm_type, LLVMValueRef initializer ) : LLVMValueRef
{
	debug_assert( !name_null_terminated.empty() && name_null_terminated.back() == '\0', "String is not null-terminated as expected!" );

	unsafe
	{
		// Reuse existing global variable with same name and initializer.
		var LLVMValueRef prev_global_variable= LLVMGetNamedGlobal( module_, name_null_terminated.front() );
		if( prev_global_variable != LLVMValueRef::Null && LLVMGetInitializer( prev_global_variable ) == initializer )
		{
			return prev_global_variable;
		}

		var LLVMValueRef global_value= LLVMAddGlobal( module_, llvm_type, name_null_terminated.front() );
		LLVMSetLinkage( global_value, LLVMLinkage::Private );
		LLVMSetUnnamedAddress( global_value, LLVMUnnamedAddr::GlobalUnnamedAddr );
		LLVMSetGlobalConstant( global_value, LLVMBool::True );
		if( initializer != LLVMValueRef::Null )
		{
			LLVMSetInitializer( global_value, initializer );
		}
		return global_value;
	}
}

fn CodeBuilder::AddGlobalMutableVariable( this, ust::string_view8 name_null_terminated, LLVMTypeRef llvm_type, SrcLoc& src_loc ) : LLVMValueRef
{
	// Extract "src_loc" of the root macro expansion.
	// Avoid using "src_loc" as is, because it may come from different file.
	var size_type file_index( GetRootMacroExpansionLocation( src_loc ).GetFileIndex() );

	// Add suffix based on file path hash.
	// This is needed to avoid merging global mutable variables which share same name, but defined in different files.
	// Use file path hash and not file contents hash in order to avoid merging variables from different files which have identical contents.

	debug_assert( !name_null_terminated.empty() && name_null_terminated.back() == '\0', "String is not null-terminated as expected!" );

	var ust::string8 mut name_with_suffix= name_null_terminated;
	name_with_suffix.back() = '.'; // Replace terminating null.

	var SourceGraph& source_graph= source_graph_.try_deref();
	if( file_index <= source_graph.nodes.size() )
	{
		name_with_suffix+= source_graph.nodes[ file_index ].file_path_hash;
	}
	name_with_suffix.push_back( '\0' );

	unsafe
	{
		var LLVMValueRef global_variable= LLVMAddGlobal( module_, llvm_type, name_with_suffix.front() );
		LLVMSetGlobalConstant( global_variable, LLVMBool::False );

		// Use external linkage and comdat for global mutable variables to guarantee address uniqueness.
		LLVMSetLinkage( global_variable, LLVMLinkage::External );
		auto comdat= LLVMGetOrInsertComdat( module_, name_with_suffix.front() );
		LLVMSetComdatSelectionKind( comdat, LLVMComdatSelectionKind::Any );
		LLVMSetComdat( global_variable, comdat );

		// Use hidden visibility - in order to avoid exporting variables from shared libraries (we don't support it).
		LLVMSetVisibility( global_variable, LLVMVisibility::Hidden );

		return global_variable;
	}
}

fn CodeBuilder::GetAttributeKindByName( ust::string_view8 attr_name ) : u32
{
	return unsafe( LLVMGetEnumAttributeKindForName( attr_name.data(), attr_name.size() ) );
}

fn CodeBuilder::AddFunctionAttribute( this, LLVMValueRef llvm_function, u32 index, ust::string_view8 attr_name )
{
	unsafe
	{
		auto attr= LLVMCreateEnumAttribute( llvm_context_, GetAttributeKindByName(attr_name), 0u64 );
		LLVMAddAttributeAtIndex( llvm_function, index, attr );
	}
}

fn CodeBuilder::AddFunctionTypeAttribute( this, LLVMValueRef llvm_function, u32 index, ust::string_view8 attr_name, LLVMTypeRef t )
{
	unsafe
	{
		auto attr= LLVMCreateTypeAttribute( llvm_context_, GetAttributeKindByName(attr_name), t );
		LLVMAddAttributeAtIndex( llvm_function, index, attr );
	}
}

fn CodeBuilder::EnsureLLVMFunctionCreated( mut this, FunctionVariable& function_variable ) : LLVMValueRef
{
	auto mut lock= function_variable.llvm_function.lock_mut();
	var LazyLLVMFunction &mut lazy_function= lock.deref();
	var LLVMValueRef& mut llvm_function= lazy_function.function;
	if( llvm_function != LLVMValueRef::Null )
	{
		return llvm_function;
	}

	llvm_function=
		unsafe( LLVMAddFunction(
			module_,
			lazy_function.name_mangled.front(),
			GetLLVMFunctionType( function_variable.t ) ) );

	unsafe( LLVMSetFunctionCallConv( llvm_function, function_variable.t.calling_convention ) );

	// Use "private" linkage for generated functions since such functions are emitted in every compilation unit.
	if( function_variable.is_generated )
	{
		unsafe( LLVMSetLinkage( llvm_function, LLVMLinkage::Private ) );
	}

	if( function_variable.IsCoroutine() )
	{
		unsafe( AddFunctionAttribute( llvm_function, LLVMAttributeFunctionIndex, "presplitcoroutine" ) );
	}

	// Merge functions with identical code.
	// We doesn't need different addresses for different functions.
	unsafe( LLVMSetUnnamedAddress( llvm_function, LLVMUnnamedAddr::GlobalUnnamedAddr ) );

	// We do not support exceptions. So, mark all functions as "nounwind".
	AddFunctionAttribute( llvm_function, LLVMAttributeFunctionIndex, "nounwind" );

	if( build_debug_info_ ) // Unwind table entry for function needed for debug info.
	{
		unsafe
		{
			auto attr= LLVMCreateEnumAttribute( llvm_context_, GetAttributeKindByName("uwtable"), 2u64 /* async uwtable */ );
			LLVMAddAttributeAtIndex( llvm_function, LLVMAttributeFunctionIndex, attr );
		}
	}

	var bool is_s_ret= FunctionTypeIsSRet( function_variable.t );
	if( is_s_ret )
	{
		AddFunctionTypeAttribute( llvm_function, LLVMAttributeFirstParamIndex, "sret", function_variable.t.return_type.GetLLVMType() );
		AddFunctionAttribute( llvm_function, LLVMAttributeFirstParamIndex, "noalias" );
	}
	if( function_variable.t.return_value_type != ValueType::Value )
	{
		AddFunctionAttribute( llvm_function, LLVMAttributeReturnIndex, "nonnull" );
	}

	for( auto mut i= 0s; i < function_variable.t.params.size(); ++i )
	{
		var FunctionType::Param& param= function_variable.t.params[i];
		var u32 llvm_param_n= LLVMAttributeFirstParamIndex + ( is_s_ret ? 1u : 0u ) + u32(i);

		var bool pass_value_param_by_hidden_ref=
			param.value_type == ValueType::Value &&
			( !param.t.GetClassType().empty() || !param.t.GetArrayType().empty() || !param.t.GetTupleType().empty() ) &&
			GetSingleScalarType( param.t.GetLLVMType() ) == LLVMTypeRef::Null;

		// Mark pointer-parameters as "nonnull".
		if( param.value_type != ValueType::Value || pass_value_param_by_hidden_ref )
		{
			AddFunctionAttribute( llvm_function, llvm_param_n, "nonnull" );
		}
		// Mutable reference args or composite value-args must not alias.
		// Also we can mark as "noalias" non-mutable references. See https://releases.llvm.org/9.0.0/docs/AliasAnalysis.html#must-may-or-no.
		if( param.value_type != ValueType::Value || pass_value_param_by_hidden_ref )
		{
			AddFunctionAttribute( llvm_function, llvm_param_n, "noalias" );
		}
		// Mark as "readonly" immutable reference params.
		if( param.value_type == ValueType::ReferenceImut )
		{
			AddFunctionAttribute( llvm_function, llvm_param_n, "readonly" );
		}
		// Mark as "nocapture" value args of composite types, which is actually passed by hidden reference.
		// It is not possible to capture this reference.
		if( param.value_type == ValueType::Value && pass_value_param_by_hidden_ref )
		{
			AddFunctionAttribute( llvm_function, llvm_param_n, "nocapture" );
		}
	}

	return llvm_function;
}

fn CodeBuilder::SetupDereferenceableFunctionParamsAndRetAttributes( this, FunctionVariable& mut function_variable )
{
	var LLVMValueRef llvm_function= function_variable.llvm_function.lock_imut().deref().function;
	if( llvm_function == LLVMValueRef::Null )
	{
		// Do not force to create llvm function, if it was not created previously.
		// This means, that this is only unused declaration.
		return;
	}

	var bool is_s_ret= FunctionTypeIsSRet( function_variable.t );

	for( auto mut i= 0s; i < function_variable.t.params.size(); ++i )
	{
		var FunctionType::Param& param= function_variable.t.params[i];
		var u32 llvm_param_n= LLVMAttributeFirstParamIndex + ( is_s_ret ? 1u : 0u ) + u32(i);

		var bool pass_value_param_by_hidden_ref=
			param.value_type == ValueType::Value &&
			( !param.t.GetClassType().empty() || !param.t.GetArrayType().empty() || !param.t.GetTupleType().empty() ) &&
			GetSingleScalarType( param.t.GetLLVMType() ) == LLVMTypeRef::Null;

		// Mark reference params and passed by hidden reference params with "dereferenceable" attribute.
		if( param.value_type != ValueType::Value || pass_value_param_by_hidden_ref )
		{
			var LLVMTypeRef llvm_type= param.t.GetLLVMType();
			unsafe
			{
				if( LLVMTypeIsSized( llvm_type ) != LLVMBool::True )
				{
					continue; // May be in case of error.
				}

				U1_FunctionAddDereferenceableAttr( llvm_function, llvm_param_n, LLVMABISizeOfType( data_layout_, llvm_type ) );
			}
		}
	}

	unsafe
	{
		var LLVMTypeRef llvm_type= function_variable.t.return_type.GetLLVMType();
		if( LLVMTypeIsSized( llvm_type ) != LLVMBool::True )
		{
			return; // May be in case of error.
		}

		if( is_s_ret )
		{
			U1_FunctionAddDereferenceableAttr( llvm_function, LLVMAttributeFirstParamIndex, LLVMABISizeOfType( data_layout_, llvm_type ) );
		}
		else if( function_variable.t.return_value_type != ValueType::Value )
		{
			U1_FunctionAddDereferenceableAttr( llvm_function, LLVMAttributeReturnIndex, LLVMABISizeOfType( data_layout_, llvm_type ) );
		}
	}
}

fn CodeBuilder::SetupDereferenceableFunctionParamsAndRetAttributes_r( this, NamesScope& names_scope )
{
	foreach( &el : names_scope )
	{
		var NamesScopeValue& value = el.value();
		if_var( &child_names_scope : value.something_.get</NamesScopeMutPtr/>() )
		{
			SetupDereferenceableFunctionParamsAndRetAttributes_r( child_names_scope.lock_imut().deref() );
		}
		if_var( &class_type : value.something_.get</ClassTypePtr/>() )
		{
			SetupDereferenceableFunctionParamsAndRetAttributes_r( class_type.lock_imut().deref().members.lock_imut().deref() );
		}
		if_var( &functions_set_ptr : value.something_.get</ ust::shared_ptr_mut</FunctionsSet/> />() )
		{
			auto mut lock= functions_set_ptr.lock_mut();
			foreach( &mut function : lock.deref().functions )
			{
				SetupDereferenceableFunctionParamsAndRetAttributes( function );
			}
		}
	}
}

fn CodeBuilder::IsGlobalVariable( VariablePtr& variable ) : bool
{
	with( &v : variable.lock_imut().deref() )
	{
		return
			v.location == Variable::Location::Pointer &&
			v.llvm_value != LLVMValueRef::Null &&
			unsafe( LLVMIsConstant( v.llvm_value ) ) == LLVMBool::True;
	}
}

fn CodeBuilder::SetGlobalMetadata( this, LLVMValueRef global_value, ust::string_view8 name, LLVMMetadataRef metadata )
{
	unsafe( LLVMGlobalSetMetadata(
		global_value,
		LLVMGetMDKindIDInContext( llvm_context_, name.data(), u32( name.size() ) ),
		metadata ) );
}

fn CodeBuilder::EraseGlobalMetadata( this, LLVMValueRef global_value, ust::string_view8 name )
{
	unsafe( LLVMGlobalEraseMetadata(
		global_value,
		LLVMGetMDKindIDInContext( llvm_context_, name.data(), u32( name.size() ) )
		) );
}

fn CodeBuilder::MarkInstructionWithTBAAMetadata( this, LLVMValueRef instruction, LLVMMetadataRef metadata )
{
	auto& name= "tbaa";
	unsafe( LLVMSetMetadata(
		instruction,
		LLVMGetMDKindIDInContext( llvm_context_, $<(cast_mut(name[0])), u32( typeinfo</typeof(name)/>.element_count ) ),
		LLVMMetadataAsValue( llvm_context_, metadata ) ) );
}

fn CodeBuilder::MarkLoadInstructionWithNonNullMetadata( this, LLVMValueRef load_instruction )
{
	if( load_instruction == LLVMValueRef::Null )
	{
		return;
	}

	auto& name= "nonnull";
	unsafe( LLVMSetMetadata(
		load_instruction,
		LLVMGetMDKindIDInContext( llvm_context_, $<(cast_mut(name[0])), u32( typeinfo</typeof(name)/>.element_count ) ),
		LLVMMetadataAsValue( llvm_context_, LLVMMDNodeInContext2( llvm_context_, ust::nullptr</LLVMMetadataRef/>(), 0s ) ) ) );
}

fn CodeBuilder::MarkInstructionWithEmptyMetadata( this, LLVMValueRef instruction, ust::string_view8 name )
{
	unsafe( LLVMSetMetadata(
		instruction,
		LLVMGetMDKindIDInContext( llvm_context_, name.data(), u32( name.size() ) ),
		LLVMMetadataAsValue( llvm_context_, LLVMMDNodeInContext2( llvm_context_, ust::nullptr</LLVMMetadataRef/>(), 0s ) ) ) );
}

fn CodeBuilder::CreateTypedLoad( mut this, FunctionContext& function_context, Type& t, LLVMValueRef address ) : LLVMValueRef
{
	if( address == LLVMValueRef::Null || function_context.is_functionless_context )
	{
		return LLVMValueRef::Null;
	}

	if( t == void_type_ )
	{
		return unsafe( LLVMGetUndef( fundamental_llvm_types_.void_ ) );
	}

	auto result= unsafe( LLVMBuildLoad2( function_context.llvm_ir_builder, t.GetLLVMType(), address, g_null_string ) );

	if( generate_tbaa_metadata_ )
	{
		auto access_tag= tbaa_metadata_builder_.CreateAccessTag(t);
		MarkInstructionWithTBAAMetadata( result, access_tag );
	}

	return result;
}

fn CodeBuilder::CreateTypedReferenceLoad( mut this, FunctionContext& function_context, Type& t, LLVMValueRef address ) : LLVMValueRef
{
	if( address == LLVMValueRef::Null || function_context.is_functionless_context )
	{
		return LLVMValueRef::Null;
	}

	auto result= unsafe( LLVMBuildLoad2( function_context.llvm_ir_builder, LLVMPointerType( t.GetLLVMType(), 0u ), address, g_null_string ) );

	if( generate_tbaa_metadata_ )
	{
		auto access_tag= tbaa_metadata_builder_.CreateReferenceAccessTag(t);
		MarkInstructionWithTBAAMetadata( result, access_tag );
	}

	// References are never null, so, mark result of reference load with "nonnull" metadata.
	MarkLoadInstructionWithNonNullMetadata( result );

	return result;
}

fn CodeBuilder::CreateTypedStore( mut this, FunctionContext& function_context, Type& t, LLVMValueRef value_to_store, LLVMValueRef address )
{
	if( function_context.is_functionless_context )
	{
		return;
	}
	if( t == void_type_ )
	{
		return;
	}

	auto result= unsafe( LLVMBuildStore( function_context.llvm_ir_builder, value_to_store, address ) );

	if( generate_tbaa_metadata_ )
	{
		auto access_tag= tbaa_metadata_builder_.CreateAccessTag(t);
		MarkInstructionWithTBAAMetadata( result, access_tag );
	}
}

fn CodeBuilder::CreateTypedReferenceStore( mut this, FunctionContext& function_context, Type& t, LLVMValueRef value_to_store, LLVMValueRef address )
{
	if( function_context.is_functionless_context )
	{
		return;
	}

	auto result= unsafe( LLVMBuildStore( function_context.llvm_ir_builder, value_to_store, address ) );

	if( generate_tbaa_metadata_ )
	{
		auto access_tag= tbaa_metadata_builder_.CreateReferenceAccessTag(t);
		MarkInstructionWithTBAAMetadata( result, access_tag );
	}
}

fn CodeBuilder::GetFundamentalLLVMType( this, U_FundamentalType t ) : LLVMTypeRef
{
	switch(t)
	{
		U_FundamentalType::InvalidType	-> { return fundamental_llvm_types_.invalid_type_; },
		U_FundamentalType::void_		-> { return fundamental_llvm_types_.void_; },
		U_FundamentalType::bool_		-> { return fundamental_llvm_types_.bool_; },
		U_FundamentalType::i8_			-> { return fundamental_llvm_types_.i8_	; },
		U_FundamentalType::u8_			-> { return fundamental_llvm_types_.u8_	; },
		U_FundamentalType::i16_		-> { return fundamental_llvm_types_.i16_	; },
		U_FundamentalType::u16_		-> { return fundamental_llvm_types_.u16_	; },
		U_FundamentalType::i32_		-> { return fundamental_llvm_types_.i32_	; },
		U_FundamentalType::u32_		-> { return fundamental_llvm_types_.u32_	; },
		U_FundamentalType::i64_		-> { return fundamental_llvm_types_.i64_	; },
		U_FundamentalType::u64_		-> { return fundamental_llvm_types_.u64_	; },
		U_FundamentalType::i128_	-> { return fundamental_llvm_types_.i128_; },
		U_FundamentalType::u128_	-> { return fundamental_llvm_types_.u128_; },
		U_FundamentalType::ssize_type_	-> { return fundamental_llvm_types_.ssize_type_; },
		U_FundamentalType::size_type_	-> { return fundamental_llvm_types_.size_type_ ; },
		U_FundamentalType::f32_		-> { return fundamental_llvm_types_.f32_; },
		U_FundamentalType::f64_		-> { return fundamental_llvm_types_.f64_; },
		U_FundamentalType::char8_	-> { return fundamental_llvm_types_.char8_ ; },
		U_FundamentalType::char16_	-> { return fundamental_llvm_types_.char16_; },
		U_FundamentalType::char32_	-> { return fundamental_llvm_types_.char32_; },
		U_FundamentalType::byte8_	-> { return fundamental_llvm_types_.byte8_  ; },
		U_FundamentalType::byte16_	-> { return fundamental_llvm_types_.byte16_ ; },
		U_FundamentalType::byte32_	-> { return fundamental_llvm_types_.byte32_ ; },
		U_FundamentalType::byte64_	-> { return fundamental_llvm_types_.byte64_ ; },
		U_FundamentalType::byte128_	-> { return fundamental_llvm_types_.byte128_; },
	}
}

fn CodeBuilder::GetFundamentalTypeSize( this, U_FundamentalType t ) : u32
{
	// Handle here all cases except size_type and ssize_type, which have variable size.
	switch(t)
	{
		U_FundamentalType::InvalidType -> { return 0u; },
		U_FundamentalType::void_ -> { return 0u; },
		U_FundamentalType::bool_ -> { return 1u; },
		U_FundamentalType::i8_  , U_FundamentalType::u8_  , U_FundamentalType::byte8_   -> { return  1u; },
		U_FundamentalType::i16_ , U_FundamentalType::u16_ , U_FundamentalType::byte16_  -> { return  2u; },
		U_FundamentalType::i32_ , U_FundamentalType::u32_ , U_FundamentalType::byte32_  -> { return  4u; },
		U_FundamentalType::i64_ , U_FundamentalType::u64_ , U_FundamentalType::byte64_  -> { return  8u; },
		U_FundamentalType::i128_, U_FundamentalType::u128_, U_FundamentalType::byte128_ -> { return 16u; },
		U_FundamentalType::ssize_type_ -> { return u32( unsafe( LLVMABISizeOfType( data_layout_, fundamental_llvm_types_.ssize_type_ ) ) ); },
		U_FundamentalType::size_type_  -> { return u32( unsafe( LLVMABISizeOfType( data_layout_, fundamental_llvm_types_.size_type_  ) ) ); },
		U_FundamentalType::f32_ -> { return 4u; },
		U_FundamentalType::f64_ -> { return 8u; },
		U_FundamentalType::char8_  -> { return 1u; },
		U_FundamentalType::char16_ -> { return 2u; },
		U_FundamentalType::char32_ -> { return 4u; },
	}
}

fn CodeBuilder::GetZeroGEPIndex( this ) : LLVMValueRef
{
	return unsafe( LLVMConstNull( fundamental_llvm_types_.i32_ ) );
}

fn CodeBuilder::CreateMoveToLLVMRegisterInstruction( mut this, VariableLite& variable, FunctionContext& function_context ) : LLVMValueRef
{
	if( variable.constexpr_value != LLVMValueRef::Null )
	{
		return variable.constexpr_value;
	}
	if( variable.location == Variable::Location::Pointer )
	{
		return CreateTypedLoad( function_context, variable.t, variable.llvm_value );
	}
	if( variable.location == Variable::Location::LLVMRegister )
	{
		return variable.llvm_value;
	}

	halt;
}

fn CodeBuilder::CreateReferenceCast( this, LLVMValueRef ref, Type& src_type, Type& dst_type, FunctionContext& function_context ) : LLVMValueRef
{
	if( src_type == dst_type )
	{
		return ref;
	}
	if( ref == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}

	if( function_context.is_functionless_context && unsafe(LLVMIsConstant(ref)) == LLVMBool::False )
	{
		return LLVMValueRef::Null;
	}

	auto src_class_type= src_type.GetClassType().try_deref();
	foreach( &parent : src_class_type.lock_imut().deref().parents )
	{
		auto sub_ref= CreateClassParentFieldGEP( function_context, src_class_type, ref, parent );
		if( parent.class_ == dst_type )
		{
			return sub_ref;
		}
		else if( Type(parent.class_).ReferenceIsConvertibleTo( dst_type ) )
		{
			return CreateReferenceCast( sub_ref, parent.class_, dst_type, function_context );
		}
	}

	halt;
}

fn CodeBuilder::CreateClassFieldGEP( this, FunctionContext& function_context, VariableLite& class_variable, ClassField& field ) : LLVMValueRef
{
	return CreateClassFieldGEP( function_context, class_variable.t.GetClassType().try_deref(), class_variable.llvm_value, field );
}

fn CodeBuilder::CreateClassFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value, ClassField& field ) : LLVMValueRef
{
	if( value == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}
	if( function_context.is_functionless_context && unsafe(LLVMIsConstant(value)) == LLVMBool::False )
	{
		return LLVMValueRef::Null;
	}

	auto op_name_nt= ust::concat( ".", field.syntax_element.deref().name, "\0" );
	unsafe
	{
		var [ LLVMValueRef, 2 ] mut indexes
		[
			GetZeroGEPIndex(),
			CreateIndexValue(field.index),
		];

		return LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, class_type.lock_imut().deref().llvm_type, value, $<(indexes[0]), 2u, op_name_nt.front() );
	}
}

fn CodeBuilder::CreateClassParentFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value, ClassType::Parent& parent ) : LLVMValueRef
{
	if( value == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}
	if( function_context.is_functionless_context && unsafe(LLVMIsConstant(value)) == LLVMBool::False )
	{
		return LLVMValueRef::Null;
	}

	unsafe
	{
		var [ LLVMValueRef, 2 ] mut indexes
		[
			GetZeroGEPIndex(),
			CreateIndexValue( parent.field_number ),
		];

		return LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, class_type.lock_imut().deref().llvm_type, value, $<(indexes[0]), 2u, g_null_string );
	}
}

fn CodeBuilder::CreateBaseClassFieldGEP( this, FunctionContext& function_context, ClassTypePtr& class_type, LLVMValueRef value ) : LLVMValueRef
{
	if( value == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}
	if( function_context.is_functionless_context && unsafe(LLVMIsConstant(value)) == LLVMBool::False )
	{
		return LLVMValueRef::Null;
	}

	var [ LLVMValueRef, 2 ] mut indexes
	[
		GetZeroGEPIndex(),
		GetZeroGEPIndex(), // Base class is always zero field.
	];

	return unsafe( LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, class_type.lock_imut().deref().llvm_type, value, $<(indexes[0]), 2u, ".base\0"[0] ) );
}

fn CodeBuilder::CreateTupleElementGEP( this, FunctionContext& function_context, VariableLite& tuple_variable, u32 element_index ) : LLVMValueRef
{
	return CreateTupleElementGEP( function_context, tuple_variable.t.GetTupleType().try_deref(), tuple_variable.llvm_value, element_index );
}

fn CodeBuilder::CreateTupleElementGEP( this, FunctionContext& function_context, TupleType& t, LLVMValueRef value, u32 element_index ) : LLVMValueRef
{
	if( value == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}
	if( function_context.is_functionless_context && unsafe(LLVMIsConstant(value)) == LLVMBool::False )
	{
		return LLVMValueRef::Null;
	}

	auto op_name_nt= ust::concat( "[", ust::to_string8(element_index), "]\0" );
	unsafe
	{
		var [ LLVMValueRef, 2 ] mut indexes
		[
			GetZeroGEPIndex(),
			CreateIndexValue(element_index)
		];

		return LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, t.llvm_type, value, $<(indexes[0]), 2u, op_name_nt.front() );
	}
}

fn CodeBuilder::CreateArrayElementGEP( this, FunctionContext& function_context, ArrayType& t, LLVMValueRef value, u32 index ) : LLVMValueRef
{
	return CreateArrayElementGEP( function_context, t, value, CreateIndexValue(index) );
}

fn CodeBuilder::CreateArrayElementGEP( this, FunctionContext& function_context, ArrayType& t, LLVMValueRef value, LLVMValueRef index ) : LLVMValueRef
{
	if( value == LLVMValueRef::Null || index == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}
	if( function_context.is_functionless_context &&
		( unsafe(LLVMIsConstant(value)) == LLVMBool::False || unsafe(LLVMIsConstant(index)) == LLVMBool::False ) )
	{
		return LLVMValueRef::Null;
	}

	unsafe
	{
		var [ LLVMValueRef, 2 ] mut indexes[ GetZeroGEPIndex(), index ];
		return LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, t.llvm_type, value, $<(indexes[0]), 2u, g_null_string );
	}
}

fn CodeBuilder::CreateIndexValue( this, u32 index ) : LLVMValueRef
{
	return unsafe( LLVMConstInt( fundamental_llvm_types_.u32_, u64(index), LLVMBool::False ) );
}

fn CodeBuilder::ForceCreateConstantIndexGEP( this, FunctionContext& function_context, LLVMTypeRef t, LLVMValueRef value, u32 index ) : LLVMValueRef
{
	if( value == LLVMValueRef::Null )
	{
		return LLVMValueRef::Null;
	}

	if( unsafe( LLVMIsConstant(value) ) == LLVMBool::True )
	{
		// Constant will be folded properly and no instruction will be actiually inserted.
		var [ LLVMValueRef, 2 ] mut indexes[ GetZeroGEPIndex(), CreateIndexValue( index ) ];
		var LLVMValueRef gep= unsafe( LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, t, value, $<(indexes[0]), 2u, g_null_string ) );
		return gep;
	}

	var [ LLVMValueRef, 2 ] mut indexes[ GetZeroGEPIndex(), CreateIndexValue( index ) ];
	var LLVMValueRef gep= unsafe( U1_CreateOrphanInBoundsGEP( t, value, $<(indexes[0]), 2u ) );

	// Try to insert "GEP" instruction with constant index directly after of value calculation.
	// This is needed in order to have possibility to reuse this instruction in diffirent basic blocks.
	if( unsafe( LLVMIsAInstruction( value ) != LLVMValueRef::Null ) )
	{
		unsafe( U1_InsertInstructionAfterAnother( value, gep ) );
	}
	else if( unsafe( LLVMIsAArgument( value ) ) != LLVMValueRef::Null )
	{
		unsafe( LLVMInsertIntoBuilder( function_context.alloca_ir_builder, gep ) );
	}
	else
	{
		unsafe( LLVMInsertIntoBuilder( function_context.llvm_ir_builder, gep ) ); // TODO - maybe add assert here?
	}

	return gep;
}

fn CodeBuilder::WrapRawScalarConstant( LLVMValueRef constant, LLVMTypeRef dst_type ) : LLVMValueRef
{
	var LLVMTypeKind type_kind= unsafe( LLVMGetTypeKind( dst_type ) );
	if( type_kind == LLVMTypeKind::Struct )
	{
		var [ LLVMValueRef, 1 ] mut i[ WrapRawScalarConstant( constant, unsafe( LLVMStructGetTypeAtIndex( dst_type, 0u ) ) ) ];
		return unsafe( LLVMConstNamedStruct( dst_type, $<(i[0]), 1u ) );
	}
	if( type_kind == LLVMTypeKind::Array )
	{
		var LLVMTypeRef element_type= unsafe( LLVMGetElementType( dst_type ) );
		var [ LLVMValueRef, 1 ] mut i[ WrapRawScalarConstant( constant, element_type ) ];
		return unsafe( LLVMConstArray2( element_type, $<(i[0]), 1u64 ) );
	}

	return constant;
}

fn CodeBuilder::UnwrapRawScalarConstant( LLVMValueRef constant ) : LLVMValueRef
{
	var LLVMTypeKind type_kind= unsafe( LLVMGetTypeKind( LLVMTypeOf( constant ) ) );
	if( type_kind == LLVMTypeKind::Struct || type_kind == LLVMTypeKind::Array )
	{
		return UnwrapRawScalarConstant( unsafe( LLVMGetAggregateElement( constant, 0u ) ) );
	}

	return constant;
}

fn CodeBuilder::MoveConstantToMemory( this, LLVMValueRef ptr, LLVMValueRef constant, FunctionContext& function_context )
{
	if( function_context.is_functionless_context )
	{
		return;
	}

	unsafe
	{
		auto constant_type= LLVMTypeOf( constant );
		auto constant_type_kind= LLVMGetTypeKind( constant_type );
		if( constant_type_kind == LLVMTypeKind::Array )
		{
			var u32 length( LLVMGetArrayLength2( constant_type ) );
			for( auto mut i= 0u; i < length; ++i )
			{
				var [ LLVMValueRef, 2 ] mut indexes
				[
					GetZeroGEPIndex(),
					CreateIndexValue(i)
				];
				auto element_ptr= LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, constant_type, ptr, $<(indexes[0]), 2u, ".\0"[0] );

				auto constant_element= LLVMGetAggregateElement( constant, i );

				MoveConstantToMemory( element_ptr, constant_element, function_context );
			}
		}
		else if( constant_type_kind == LLVMTypeKind::Struct )
		{
			auto length= LLVMCountStructElementTypes( constant_type );
			for( auto mut i= 0u; i < length; ++i )
			{
				var [ LLVMValueRef, 2 ] mut indexes
				[
					GetZeroGEPIndex(),
					CreateIndexValue(i)
				];
				auto element_ptr= LLVMBuildInBoundsGEP2( function_context.llvm_ir_builder, constant_type, ptr, $<(indexes[0]), 2u, ".\0"[0] );

				auto constant_element= LLVMGetAggregateElement( constant, i );

				MoveConstantToMemory( element_ptr, constant_element, function_context );
			}
		}
		else
		{
			LLVMBuildStore( function_context.llvm_ir_builder, constant, ptr );
		}
	}
}

fn CodeBuilder::CopyBytes( mut this, LLVMValueRef dst, LLVMValueRef src, Type& t, FunctionContext &mut function_context )
{
	if( function_context.is_functionless_context )
	{
		return;
	}

	unsafe
	{
		var LLVMTypeRef llvm_type= t.GetLLVMType();
		var LLVMTypeKind type_kind= LLVMGetTypeKind( llvm_type );
		if( type_kind == LLVMTypeKind::Integer ||
			type_kind == LLVMTypeKind::Float ||
			type_kind == LLVMTypeKind::Double ||
			type_kind == LLVMTypeKind::Pointer )
		{
			// Simple scalar - create load/store.
			auto value= CreateTypedLoad( function_context, t, src );
			CreateTypedStore( function_context, t, value, dst );
		}
		else
		{
			// Create memcpy for aggregate types.
			var u64 size= LLVMABISizeOfType( data_layout_, llvm_type );
			var u32 alignment= LLVMABIAlignmentOfType( data_layout_, llvm_type );

			LLVMBuildMemCpy(
				function_context.llvm_ir_builder,
				dst, alignment,
				src, alignment,
				LLVMConstInt( fundamental_llvm_types_.u64_, size, LLVMBool::False ) );
		}
	}
}

fn CodeBuilder::ConstexprCompareEqual(
	mut this,
	NamesScopePtr& names_scope,
	FunctionContext &mut function_context,
	LLVMValueRef l,
	LLVMValueRef r,
	Type& t,
	SrcLoc& src_loc ) : LLVMValueRef
{
	if(
		!t.GetFundamentalType().empty() ||
		!t.GetEnumType().empty() ||
		!t.GetRawPointerType().empty() ||
		!t.GetFunctionPointerType().empty() )
	{
		unsafe
		{
			if( t == void_type_ )
			{
				return LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False );
			}

			var LLVMTypeKind type_kind= LLVMGetTypeKind( t.GetLLVMType() );
			var bool is_float=
				type_kind == LLVMTypeKind::Half ||
				type_kind == LLVMTypeKind::Float ||
				type_kind == LLVMTypeKind::Double ||
				type_kind == LLVMTypeKind::X86_FP80 ||
				type_kind == LLVMTypeKind::P128 ||
				type_kind == LLVMTypeKind::PPC_FP128;

			return
				( is_float
					? LLVMBuildFCmp( function_context.llvm_ir_builder, LLVMRealPredicate::OEQ, l, r, g_null_string )
					: LLVMBuildICmp( function_context.llvm_ir_builder, LLVMIntPredicate::EQ, l, r, g_null_string ) );
		}
	}
	else if_var( &array_type : t.GetArrayType() )
	{
		unsafe
		{
			var LLVMValueRef mut res= LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False );
			for( auto mut i= 0u64; i < array_type.element_count; ++i )
			{
				var u32 index(i);
				var LLVMValueRef l_element= LLVMGetAggregateElement( l, index );
				var LLVMValueRef r_element= LLVMGetAggregateElement( r, index );
				var LLVMValueRef element_res= ConstexprCompareEqual( names_scope, function_context, l_element, r_element, array_type.element_type, src_loc );
				res= LLVMBuildAnd( function_context.llvm_ir_builder, res, element_res, g_null_string );
			}

			return res;
		}
	}
	else if_var( &tuple_type : t.GetTupleType() )
	{
		unsafe
		{
			var LLVMValueRef mut res= LLVMConstInt( fundamental_llvm_types_.bool_, 1u64, LLVMBool::False );
			for( auto mut i= 0s; i < tuple_type.element_types.size(); ++i )
			{
				var u32 index(i);
				var LLVMValueRef l_element= LLVMGetAggregateElement( l, index );
				var LLVMValueRef r_element= LLVMGetAggregateElement( r, index );
				var LLVMValueRef element_res= ConstexprCompareEqual( names_scope, function_context, l_element, r_element, tuple_type.element_types[i], src_loc );
				res= LLVMBuildAnd( function_context.llvm_ir_builder, res, element_res, g_null_string );
			}

			return res;
		}
	}
	else if_var( &class_type : t.GetClassType() )
	{
		if( !class_type.lock_imut().deref().is_equality_comparable )
		{
			REPORT_ERROR( OperationNotSupportedForThisType, names_scope, src_loc, Type(class_type) )
			return unsafe( LLVMConstInt( fundamental_llvm_types_.bool_, 0u64, LLVMBool::False ) );
		}

		// Search for "==" operator.
		auto operators_value= class_type.lock_imut().deref().members.lock_imut().deref().GetThisScopeValue( OverloadedOperatorToString( OverloadedOperator::CompareEqual ) ).try_deref();
		foreach( &op_ : operators_value.Get</FunctionsSet/>().try_lock_imut().deref().functions )
		{
			if( !IsEqualityCompareOperator( op_, class_type ) )
			{
				continue;
			}
			// Found proper "==" operator.
			// TODO - what if "==" is unsafe?

			var LLVMValueRef llvm_function= EnsureLLVMFunctionCreated( op_ );
			result_match( constexpr_function_evaluator_.Evaluate( llvm_function, ust::make_array( l, r ) ) )
			{
				Ok(constant) -> { return constant; },
				Err(errors) ->
				{
					with( mut lock : names_scope.lock_imut().deref().GetErrors().try_lock_mut() )
					{
						foreach( &err : errors )
						{
							lock.deref().push_back(
								CodeBuilderError
								{
									.code= CodeBuilderErrorCode::ConstexprFunctionEvaluationError,
									.src_loc= src_loc,
									.text= err,
								} );
						}
					}

					return unsafe( LLVMConstInt( fundamental_llvm_types_.bool_, 0u64, LLVMBool::False ) );
				}
			}
		}

		halt; // Operator not found - wtf?
	}
	else { halt; }
}

fn CodeBuilder::CreateLifetimeStart( this,  FunctionContext &mut function_context, LLVMValueRef llvm_value )
{
	if( !create_lifetimes_ )
	{
		return;
	}

	if( llvm_value == LLVMValueRef::Null )
	{
		return;
	}

	unsafe
	{
		auto alloca_inst= LLVMIsAAllocaInst( llvm_value );
		if( alloca_inst == LLVMValueRef::Null )
		{
			return;
		}

		var LLVMTypeRef t= LLVMGetAllocatedType( alloca_inst );
		if( LLVMTypeIsSized( t ) == LLVMBool::False ) // May be in case of error.
		{
			return;
		}

		var u64 size_of= LLVMABISizeOfType( data_layout_, t );
		var LLVMValueRef size_of_value= LLVMConstInt( fundamental_llvm_types_.u64_, size_of, LLVMBool::False );
		var LLVMValueRef mut ptr_converted= LLVMBuildPointerCast( function_context.llvm_ir_builder, llvm_value, lifetime_function_arg_type_, g_null_string );

		var [ LLVMValueRef, 2 ] mut args[ size_of_value, ptr_converted ];
		LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(lifetime_start_intrinsic_), lifetime_start_intrinsic_, $<(args[0]), 2u, g_null_string );

		if( generate_lifetime_start_end_debug_calls_ )
		{
			LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(lifetime_start_debug_func_), lifetime_start_debug_func_, $<(ptr_converted), 1u, g_null_string );
		}
	}
}

fn CodeBuilder::CreateLifetimeEnd( this, FunctionContext &mut function_context, LLVMValueRef llvm_value )
{
	if( !create_lifetimes_ )
	{
		return;
	}
	if( llvm_value == LLVMValueRef::Null )
	{
		return;
	}

	unsafe
	{
		auto alloca_inst= LLVMIsAAllocaInst( llvm_value );
		if( alloca_inst == LLVMValueRef::Null )
		{
			return;
		}

		var LLVMTypeRef t= LLVMGetAllocatedType( alloca_inst );
		if( LLVMTypeIsSized( t ) == LLVMBool::False ) // May be in case of error.
		{
			return;
		}

		var u64 size_of= LLVMABISizeOfType( data_layout_, t );
		var LLVMValueRef size_of_value= LLVMConstInt( fundamental_llvm_types_.u64_, size_of, LLVMBool::False );
		var LLVMValueRef mut ptr_converted= LLVMBuildPointerCast( function_context.llvm_ir_builder, llvm_value, lifetime_function_arg_type_, g_null_string );

		var [ LLVMValueRef, 2 ] mut args[ size_of_value, ptr_converted ];
		LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(lifetime_end_intrinsic_), lifetime_end_intrinsic_, $<(args[0]), 2u, g_null_string );

		if( generate_lifetime_start_end_debug_calls_ )
		{
			LLVMBuildCall2( function_context.llvm_ir_builder, U1_GetFunctionType(lifetime_end_debug_func_), lifetime_end_debug_func_, $<(ptr_converted), 1u, g_null_string );
		}
	}
}

fn CodeBuilder::GetIntrinsic( this, ust::string_view8 name, ust::array_view_imut</LLVMTypeRef/> types ) : LLVMValueRef
{
	return unsafe(
		LLVMGetIntrinsicDeclaration(
			module_,
			LLVMLookupIntrinsicID( name.data(), name.size() ),
			types.data(),
			types.size() ) );
}

fn CodeBuilder::SaveFunctionContextState( FunctionContext& function_context ) : FunctionContextState
{
	return FunctionContextState
	{
		.current_block= unsafe( LLVMGetInsertBlock( function_context.llvm_ir_builder ) ),
		.references_graph= function_context.references_graph,
	};
}

fn CodeBuilder::RestoreFunctionContextState( FunctionContext &mut function_context, FunctionContextState& state )
{
	// Make sure no new basic blocks were added.
	debug_assert( state.current_block == unsafe( LLVMGetInsertBlock( function_context.llvm_ir_builder ) ), "Basic blocks were added during preevaluation!" );
	// New instructions may still be added - in case of GEP for structs or tuples. But it is fine since such instructions have no side-effects.

	function_context.references_graph= state.references_graph;
}

fn CodeBuilder::CreateGlobalFunctionContext( this ) : FunctionContext
{
	var FunctionContext mut function_context(
		llvm_context_,
		global_llvm_function_,
		FunctionType{ .return_type= void_type_, .return_value_type= ValueType::Value } );

	function_context.is_functionless_context= true;

	return function_context;
}

} // namespace U1
