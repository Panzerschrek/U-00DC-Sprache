import "../lex_synt_lib/source_graph.uh"
import "../code_builder_lib/code_builder.uh"
import "print.uh"
import "funcs_u.uh"


fn nomangle U1_BuildProgram(
	U1_StringView& program_text,
	LLVMContextRef llvm_context,
	LLVMTargetDataRef data_layout ) unsafe : LLVMModuleRef
{
	unsafe
	{
		auto program_text= U1::StringToArrayView( program_text.data, program_text.size );

		safe
		{
			var U1::TestVfs mut test_vfs( program_text );
			auto source_graph= U1::LoadSourceGraph( test_vfs, "_" );

			if( source_graph.have_errors || source_graph.nodes.empty() )
			{
				return LLVMModuleRef::Null;
			}

			var U1::CodeBuilder mut code_builder( llvm_context, data_layout );
			auto code_builder_res= code_builder.BuildProgram( source_graph );

			foreach( & err : code_builder_res.errors )
			{
				unsafe
				{
					auto stream= U1_GetCerr();
					U1_PrintInt( stream, i64(err.file_pos.GetLine()) );
					U1_PrintStr( stream, ":\0"[0] );
					U1_PrintInt( stream, i64(err.file_pos.GetColumn()) );
					U1_PrintStr( stream, (": " + err.text + "\n\0").front() );
					U1_PrintEndl( stream );
				}
			}
			if( !code_builder_res.errors.empty() )
			{
				unsafe{  LLVMDisposeModule( code_builder_res.llvm_module );  }
				return LLVMModuleRef::Null;
			}

			return code_builder_res.llvm_module;
		}
	}
}

fn nomangle U1_BuildProgramWithErrors(
	U1_StringView& program_text,
	LLVMContextRef llvm_context,
	LLVMTargetDataRef data_layout,
	ErrorHanglerFunc error_handler_func,
	void &mut data ) unsafe : bool
{
	unsafe
	{
		auto program_text= U1::StringToArrayView( program_text.data, program_text.size );

		safe
		{
			var U1::TestVfs mut test_vfs( program_text );
			auto source_graph= U1::LoadSourceGraph( test_vfs, "_" );

			if( source_graph.have_errors || source_graph.nodes.empty() )
			{
				return false;
			}

			var U1::CodeBuilder mut code_builder( llvm_context, data_layout );
			auto code_builder_res= code_builder.BuildProgram( source_graph );

			unsafe{  LLVMDisposeModule( code_builder_res.llvm_module );  }

			foreach( & err : code_builder_res.errors )
			{
				var U1_StringView text_view{ .data= err.text.front(), .size= err.text.size() };
				unsafe
				{
					error_handler_func( data, err.file_pos.GetLine(), err.file_pos.GetColumn(), u32(err.code), text_view );
				}
			}
		}
	}

	return true;
}

fn nomangle U1_BuildProgramWithSyntaxErrors(
	U1_StringView& program_text,
	ErrorHanglerFunc error_handler_func,
	void &mut data ) unsafe
{
	unsafe
	{
		auto program_text= U1::StringToArrayView( program_text.data, program_text.size );

		var U1::TestVfs mut test_vfs( program_text );
		auto source_graph= U1::LoadSourceGraph( test_vfs, "_", U1_GetNullStream() );

		foreach( &node : source_graph.nodes )
		{
			foreach( &err : node.synt_result.error_messages )
			{
				var U1_StringView text_view{ .data= err.text.front(), .size= err.text.size() };
				unsafe
				{
					error_handler_func( data, err.file_pos.GetLine(), err.file_pos.GetColumn(), u32(U1::CodeBuilderErrorCode::BuildFailed), text_view );
				}
			}
		}
	}

}

fn nomangle U1_CodeBuilderCodeToString(
	u32 error_code,
	CharPtr &mut out_text,
	size_type &mut out_text_length )
{
	for( &el : typeinfo</U1::CodeBuilderErrorCode/>.elements_list )
	{
		if( error_code == u32(el.value) )
		{
			unsafe{  cast_ref_unsafe</size_type/>(out_text)= ust::ref_to_int(el.name[0]);  }
			out_text_length= typeinfo</ typeof(el.name) />.element_count;
			return;
		}
	}
}

fn nomangle U1_BuildMultisourceProgram(
	U1_SourceFile& source_files,
	size_type source_file_count,
	U1_StringView& root_file_path,
	LLVMContextRef llvm_context,
	LLVMTargetDataRef data_layout ) unsafe : LLVMModuleRef
{
	var U1::TestVfs::SourceEntries mut source_entries;
	unsafe
	{
		auto& files_array= cast_ref_unsafe</ [ U1_SourceFile, 1000000 ] />( source_files );
		for( auto mut i= 0s; i < source_file_count; ++i )
		{
			auto &source_file= files_array[i];
			var U1::TestVfs::SourceEntry mut entry
			{
				.file_path= U1::StringToArrayView( source_file.file_path.data, source_file.file_path.size ),
				.file_content= U1::StringToArrayView( source_file.file_content.data, source_file.file_content.size ),
			};
			source_entries.push_back( move(entry) );
		}
	}

	var ust::string8 mut root_file_path_str;
	unsafe{ root_file_path_str= U1::StringToArrayView( root_file_path.data, root_file_path.size ); }

	var U1::TestVfs mut test_vfs( move(source_entries) );
	auto source_graph= U1::LoadSourceGraph( test_vfs, root_file_path_str );

	if( source_graph.have_errors || source_graph.nodes.empty() )
	{
		return LLVMModuleRef::Null;
	}

	var U1::CodeBuilder mut code_builder( llvm_context, data_layout );
	auto code_builder_res= code_builder.BuildProgram( source_graph );

	foreach( & err : code_builder_res.errors )
	{
		unsafe
		{
			auto stream= U1_GetCerr();
			U1_PrintInt( stream, i64(err.file_pos.GetLine()) );
			U1_PrintStr( stream, ":\0"[0] );
			U1_PrintInt( stream, i64(err.file_pos.GetColumn()) );
			U1_PrintStr( stream, (": " + err.text + "\n\0").front() );
			U1_PrintEndl( stream );
		}
	}
	if( !code_builder_res.errors.empty() )
	{
		unsafe{  LLVMDisposeModule( code_builder_res.llvm_module );  }
		return LLVMModuleRef::Null;
	}

	return code_builder_res.llvm_module;
}

fn nomangle U1_BuildMultisourceProgramWithErrors(
	U1_SourceFile& source_files,
	size_type source_file_count,
	U1_StringView& root_file_path,
	LLVMContextRef llvm_context,
	LLVMTargetDataRef data_layout,
	ErrorHanglerFunc error_handler_func,
	void &mut data ) unsafe : bool
{
	var U1::TestVfs::SourceEntries mut source_entries;
	unsafe
	{
		auto& files_array= cast_ref_unsafe</ [ U1_SourceFile, 1000000 ] />( source_files );
		for( auto mut i= 0s; i < source_file_count; ++i )
		{
			auto &source_file= files_array[i];
			var U1::TestVfs::SourceEntry mut entry
			{
				.file_path= U1::StringToArrayView( source_file.file_path.data, source_file.file_path.size ),
				.file_content= U1::StringToArrayView( source_file.file_content.data, source_file.file_content.size ),
			};
			source_entries.push_back( move(entry) );
		}
	}

	var ust::string8 mut root_file_path_str;
	unsafe{ root_file_path_str= U1::StringToArrayView( root_file_path.data, root_file_path.size ); }

	var U1::TestVfs mut test_vfs( move(source_entries) );
	auto source_graph= U1::LoadSourceGraph( test_vfs, root_file_path_str );

	if( source_graph.have_errors || source_graph.nodes.empty() )
	{
		return false;
	}

	var U1::CodeBuilder mut code_builder( llvm_context, data_layout );
	auto code_builder_res= code_builder.BuildProgram( source_graph );

	unsafe{  LLVMDisposeModule( code_builder_res.llvm_module );  }

	foreach( & err : code_builder_res.errors )
	{
		var U1_StringView text_view{ .data= err.text.front(), .size= err.text.size() };
		unsafe
		{
			error_handler_func( data, err.file_pos.GetLine(), err.file_pos.GetColumn(), u32(err.code), text_view );
		}
	}

	return true;
}

namespace U1
{

fn StringToArrayView( char8 &'x string_start, size_type string_size ) unsafe : ust::array_view_imut</ char8 />'x'
{
	unsafe
	{
		var ust::raw_ptr_mut</char8/> ptr( cast_mut(string_start) );

		return ust::array_view_imut</ char8 />(
			ptr,
			ptr + string_size );
	}
}

class TestVfs final : IVfs
{
public:
	struct SourceEntry
	{
		ust::string8 file_path;
		ust::string8 file_content;
	}
	type SourceEntries= ust::vector</SourceEntry/>;

	fn constructor( ust::string8 mut file_content )
	{
		var SourceEntry mut entry
		{
			.file_path= "_",
			.file_content= move(file_content),
		};
		source_entries_.push_back(move(entry));
	}

	fn constructor( SourceEntries mut source_entries )
		( source_entries_(move(source_entries)) )
	{}

public:
	fn virtual override NormalizeFilePath(
		mut this,
		ust::string8& file_path,
		ust::string8& parent_file_path_normalized ) : ust::string8
	{
		return file_path;
	}

	fn virtual override LoadFile( mut this, ust::string8& path ) : ust::optional</ust::string8/>
	{
		foreach( &entry : source_entries_ )
		{
			if( path == entry.file_path )
			{
				return entry.file_content;
			}
		}
		return ust::optional</ust::string8/>();
	}

private:
	SourceEntries source_entries_;
}

} // namespace U1
