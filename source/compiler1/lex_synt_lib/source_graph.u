import "/string_conversions.u"
import "../tests_common/print.uh"
import "source_graph.uh"

namespace U1
{

fn LoadSourceGraph( IVfs &mut vfs, ust::string8& root_file_path, CppIoStreamRef errors_stream ) : SourceGraph
{
	var SourceGraph mut source_graph;
	LoadSourceGraph_r( vfs, errors_stream, root_file_path, "", source_graph );
	return move(source_graph);
}

// Returns node index or ~0 in case of error.
fn LoadSourceGraph_r(
	IVfs &mut vfs,
	CppIoStreamRef errors_stream,
	ust::string8& file_path,
	ust::string8& parent_file_path,
	SourceGraph& mut source_graph ) : size_type
{
	auto file_path_normalized= vfs.NormalizeFilePath( file_path, parent_file_path );

	// Check, if already loaded.
	for( auto mut i= 0s; i < source_graph.nodes.size(); ++i )
	{
		if( source_graph.nodes[i].file_path_normalized == file_path_normalized )
		{
			return i;
		}
	}

	auto file_content_opt= vfs.LoadFile( file_path_normalized );
	if( file_content_opt.empty() )
	{
		var ust::string8 mut str;
		str+= "Error, can not read file: \"";
		str+= file_path_normalized;
		str+= "\"\n\0";
		unsafe{  U1_PrintStr( errors_stream, str.front() );  }

		source_graph.have_errors= true;
		return ~0s;
	}

	// Reserve place for empty node
	auto node_index= source_graph.nodes.size();
	source_graph.nodes.push_back( SourceGraph::Node() );

	auto mut lex_result= LexicalAnalysis( file_content_opt.get_ref().range() );
	foreach( &error_message : lex_result.error_messages )
	{
		var ust::string8 mut str= file_path_normalized;
		str+= ": error: ";
		str+= error_message;
		str+= "\n\0";
		unsafe{  U1_PrintStr( errors_stream, str.front() );  }
	}
	source_graph.have_errors|= !lex_result.error_messages.empty();

	foreach( &mut lexem : lex_result.lexems )
	{
		lexem.file_pos.SetFileIndex( u32(node_index) );
	}

	var SourceGraph::Node mut node
	{
		.file_path_normalized= file_path_normalized,
		.lexical_error_messages= take(lex_result.error_messages),
	};

	// Recursively load imports.
	// TODO - check for dependency loops.
	var Synt::ImportsList imports= Synt::ParseImports( lex_result.lexems );
	foreach( &import_ : imports )
	{
		auto child= LoadSourceGraph_r( vfs, errors_stream, import_, file_path_normalized, source_graph );
		if( child != ~0s )
		{
			node.children.push_back(child);
		}
	}

	// Merge macroses
	var Synt::MacrosByContextMap mut macros;
	var bool mut macros_ok= true;
	foreach( &child_index : node.children )
	{
		var SourceGraph::Node& src_node= source_graph.nodes[child_index];
		foreach( &context_and_macro : src_node.synt_result.macros )
		{
			if( macros.find( context_and_macro.key() ).empty() )
			{
				macros.insert( context_and_macro.key(), context_and_macro.value() );
				continue;
			}

			var Synt::MacroMap &mut dst_map= macros[context_and_macro.key()];
			foreach( &macro : context_and_macro.value() )
			{
				if( dst_map.find( macro.key() ).empty() )
				{
					dst_map.insert( macro.key(), macro.value() );
				}
				else if( dst_map[ macro.key() ].get_ref().file_pos != macro.value().get_ref().file_pos )
				{
					var Synt::Macro& redefined_macro= macro.value().get_ref();
					var ust::string8 mut str= src_node.file_path_normalized;
					str+= ":";
					str+= ust::to_string8( redefined_macro.file_pos.GetLine() );
					str+= ":";
					str+= ust::to_string8( redefined_macro.file_pos.GetColumn() );
					str+= ": error: macro \"";
					str+= redefined_macro.name;
					str+= "\" redefinition\n\0";
					unsafe{  U1_PrintStr( errors_stream, str.front() );  }
					macros_ok= false;
				}
			}
		}
	}
	source_graph.have_errors|= !macros_ok;

	auto mut synt_result= Synt::SyntaxAnalysis( lex_result.lexems, move(macros) );
	foreach( &error_message : synt_result.error_messages )
	{
		var ust::string8 mut str= file_path_normalized;
		str+= ":";
		str+= ust::to_string8( error_message.file_pos.GetLine() );
		str+= ":";
		str+= ust::to_string8( error_message.file_pos.GetColumn() );
		str+= ": error: ";
		str+= error_message.text;
		str+= "\n\0";
		unsafe{  U1_PrintStr( errors_stream, str.front() );  }
	}
	source_graph.have_errors|= !synt_result.error_messages.empty();
	node.synt_result= move(synt_result);

	source_graph.nodes[node_index]= move(node);
	return node_index;
}

} // namespace U1
