import "keywords.uh"
import "syntax_analyzer.uh"

namespace U
{

namespace Synt
{

fn IsKeyword( Lexem& l, Keyword k ) : bool
{
	return l.lexem_type == Lexem::Type::Identifier && l.text == KeywordToString(k);
}


fn GetBinaryOperatorPriority( BinaryOperatorType binary_operator ) : i32
{
	// If this changed, same code in "syntax_analyzer.cpp" must be changed too!
	if( binary_operator == BinaryOperatorType::Div ||
		binary_operator == BinaryOperatorType::Mul ||
		binary_operator == BinaryOperatorType::Rem )
	{
		return 9;
	}
	if( binary_operator == BinaryOperatorType::Add ||
		binary_operator == BinaryOperatorType::Sub )
	{
		return 8;
	}
	if( binary_operator == BinaryOperatorType::ShiftLeft ||
		binary_operator == BinaryOperatorType::ShiftRight )
	{
		return 7;
	}
	if( binary_operator == BinaryOperatorType::Equal ||
		binary_operator == BinaryOperatorType::NotEqual ||
		binary_operator == BinaryOperatorType::Less ||
		binary_operator == BinaryOperatorType::LessEqual ||
		binary_operator == BinaryOperatorType::Greater ||
		binary_operator == BinaryOperatorType::GreaterEqual )
	{
		return 6;
	}
	if( binary_operator == BinaryOperatorType::And )
	{
		return 5;
	}
	if( binary_operator == BinaryOperatorType::Or )
	{
		return 4;
	}
	if( binary_operator == BinaryOperatorType::Xor )
	{
		return 3;
	}
	if( binary_operator == BinaryOperatorType::LazyLogicalAnd )
	{
		return 2;
	}
	if( binary_operator == BinaryOperatorType::LazyLogicalOr )
	{
		return 1;
	}

	halt;
}

fn IsBinaryOperator( Lexem& lexem ) : bool
{
	return
		lexem.lexem_type == Lexem::Type::Plus ||
		lexem.lexem_type == Lexem::Type::Minus ||
		lexem.lexem_type == Lexem::Type::Star ||
		lexem.lexem_type == Lexem::Type::Slash ||
		lexem.lexem_type == Lexem::Type::Percent ||

		lexem.lexem_type == Lexem::Type::CompareEqual ||
		lexem.lexem_type == Lexem::Type::CompareNotEqual ||
		lexem.lexem_type == Lexem::Type::CompareLess ||
		lexem.lexem_type == Lexem::Type::CompareLessOrEqual ||
		lexem.lexem_type == Lexem::Type::CompareGreater ||
		lexem.lexem_type == Lexem::Type::CompareGreaterOrEqual ||

		lexem.lexem_type == Lexem::Type::And ||
		lexem.lexem_type == Lexem::Type::Or ||
		lexem.lexem_type == Lexem::Type::Xor ||

		lexem.lexem_type == Lexem::Type::ShiftLeft  ||
		lexem.lexem_type == Lexem::Type::ShiftRight ||

		lexem.lexem_type == Lexem::Type::Conjunction ||
		lexem.lexem_type == Lexem::Type::Disjunction;
}


fn LexemToBinaryOperator( Lexem& lexem ) : BinaryOperatorType
{
	if( lexem.lexem_type == Lexem::Type::Plus	){ return BinaryOperatorType::Add; }
	if( lexem.lexem_type == Lexem::Type::Minus	){ return BinaryOperatorType::Sub; }
	if( lexem.lexem_type == Lexem::Type::Star	){ return BinaryOperatorType::Mul; }
	if( lexem.lexem_type == Lexem::Type::Slash	){ return BinaryOperatorType::Div; }
	if( lexem.lexem_type == Lexem::Type::Percent){ return BinaryOperatorType::Rem; }

	if( lexem.lexem_type == Lexem::Type::CompareEqual			){ return BinaryOperatorType::Equal			; }
	if( lexem.lexem_type == Lexem::Type::CompareNotEqual		){ return BinaryOperatorType::NotEqual		; }
	if( lexem.lexem_type == Lexem::Type::CompareLess			){ return BinaryOperatorType::Less			; }
	if( lexem.lexem_type == Lexem::Type::CompareLessOrEqual		){ return BinaryOperatorType::LessEqual		; }
	if( lexem.lexem_type == Lexem::Type::CompareGreater			){ return BinaryOperatorType::Greater		; }
	if( lexem.lexem_type == Lexem::Type::CompareGreaterOrEqual	){ return BinaryOperatorType::GreaterEqual	; }

	if( lexem.lexem_type == Lexem::Type::And ){ return BinaryOperatorType::And; }
	if( lexem.lexem_type == Lexem::Type::Or  ){ return BinaryOperatorType::Or ; }
	if( lexem.lexem_type == Lexem::Type::Xor ){ return BinaryOperatorType::Xor; }

	if( lexem.lexem_type == Lexem::Type::ShiftLeft  ){ return BinaryOperatorType::ShiftLeft ; }
	if( lexem.lexem_type == Lexem::Type::ShiftRight ){ return BinaryOperatorType::ShiftRight; }

	if( lexem.lexem_type == Lexem::Type::Conjunction ){ return BinaryOperatorType::LazyLogicalAnd; }
	if( lexem.lexem_type == Lexem::Type::Disjunction ){ return BinaryOperatorType::LazyLogicalOr ; }

	halt;
}

fn GetMostRightIncompleteBinaryOperatorInTree( BinaryOperator &mut o ) : BinaryOperator &mut
{
	if( !o.r.get_ref().expr.get</EmptyVariant/>().empty() )
	{
		return o;
	}

	// Should be binary operator.
	return GetMostRightIncompleteBinaryOperatorInTree( o.r.get_ref().expr.get</BinaryOperator/>().get_ref() );
}

fn GetDeepestRightBinaryOperatorComponentWithNonLessPriority( BinaryOperator &'x mut o, BinaryOperatorType cur_op_type ) : ust::optional_ref</BinaryOperator, true />'x'
{
	if( GetBinaryOperatorPriority( cur_op_type ) > GetBinaryOperatorPriority( o.operator ) )
	{
		return ust::optional_ref</BinaryOperator, true />(o);
	}

	if_var( &mut right_as_binary_operator : o.r.get_ref().expr.get</BinaryOperator/>() )
	{
		return GetDeepestRightBinaryOperatorComponentWithNonLessPriority( right_as_binary_operator, cur_op_type );
	}

	return ust::optional_ref</BinaryOperator, true />();
}

class SyntaxAnalyzer
{
public:
	fn constructor( this'a', Lexems&'b lexems ) ' a <- b ';

	fn DoAnalyzis( mut this ) : SyntaxAnalysisResult;

private:
	fn ParseExpression( mut this ) : Expression;
	fn ParseTypeName( mut this ) : TypeName;
	fn ParseFunction( mut this ) : Function;

	fn ParseBlock( mut this ) : Block;

	fn ParseReturnOperator( mut this ) : ReturnOperator;

	fn NotEndOfFile( this ) : bool;
	fn NextLexem( mut this );
	fn PushErrorMessage( mut this );

private:
	ust::array_view_imut</Lexem/> it_;
	SyntaxErrorMessages error_messages_;
}

fn SyntaxAnalyzer::constructor( this'a', Lexems&'b lexems ) ' a <- b '
	( it_= lexems.range() )
{
}

fn SyntaxAnalyzer::DoAnalyzis( mut this ) : SyntaxAnalysisResult
{
	var SyntaxAnalysisResult mut res;

	while( NotEndOfFile() )
	{
		if( IsKeyword( it_.front(), Keyword::fn_ ) )
		{
			res.program_elements.push_back( ust::shared_ptr_final</Function/>( ParseFunction() ) );
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	res.error_messages= take(error_messages_);
	return move(res);
}

fn SyntaxAnalyzer::ParseExpression( mut this ) : Expression
{
	var Expression mut root;

	while( NotEndOfFile() )
	{
		var Expression mut current_node;

		if( it_.front().lexem_type == Lexem::Type::Number )
		{
			var NumericConstant mut numeric_constant;
			halt if( it_.front().text.size() < typeinfo</NumberLexemData/>.size_of );

			unsafe
			{
				ust::memory_copy( numeric_constant.num, it_.front().text.front(), typeinfo</NumberLexemData/>.size_of );
			}

			NextLexem();

			var Expression mut expr{ .expr= move(numeric_constant) };
			current_node= move(expr);
		}
		else if( it_.front().lexem_type == Lexem::Type::Identifier )
		{
			var ComplexName mut complex_name;
			complex_name.file_pos= it_.front().file_pos;
			complex_name.name= it_.front().text;

			NextLexem();

			var Expression mut expr{ .expr= move(complex_name) };
			current_node= move(expr);
		}
		else
		{
			break;
		}

		var bool is_binary_operator= IsBinaryOperator( it_.front() );

		if( !root.expr.get</EmptyVariant/>().empty() )
		{
			root= move(current_node);
		}
		else
		{
			// Place to existent tree last component.

			// TODO - replace this call with loop.
			auto &mut most_right_with_null= GetMostRightIncompleteBinaryOperatorInTree( root.expr.get</BinaryOperator/>().get_ref() );
			most_right_with_null.r.get_ref()= move(current_node);
		}

		if( is_binary_operator )
		{
			var BinaryOperator mut binary_operator
			{
				.operator=LexemToBinaryOperator( it_.front() ),
				.l( Expression() ),
				.r( Expression() )
			};

			NextLexem();

			if( !root.expr.get</BinaryOperator/>().empty() )
			{
				auto mut dst_opt= GetDeepestRightBinaryOperatorComponentWithNonLessPriority( root.expr.get</BinaryOperator/>().get_ref(), binary_operator.operator );
				if( !dst_opt.empty() )
				{
					auto &mut dst= dst_opt.get_ref();
					binary_operator.l.get_ref()= take(dst.r.get_ref());
					dst.r.get_ref().expr= move(binary_operator);
					move(dst_opt);
				}
				else
				{
					move(dst_opt);
					binary_operator.l.get_ref()= take(root);
					root.expr= move(binary_operator);
				}
			}
			else
			{
				binary_operator.l.get_ref()= take(root);
				root.expr= move(binary_operator);
			}
		}
		else
		{
			break;
		}
	}

	return move(root);
}

fn SyntaxAnalyzer::ParseTypeName( mut this ) : TypeName
{
	if( it_.front().lexem_type == Lexem::Type::Identifier )
	{
		var ComplexName mut complex_name;
		complex_name.file_pos= it_.front().file_pos;
		complex_name.name= it_.front().text;

		NextLexem();

		return TypeName( move(complex_name) );
	}
	else
	{
		PushErrorMessage();
		return TypeName();
	}
}

fn SyntaxAnalyzer::ParseFunction( mut this ) : Function
{
	var Function mut res{ .file_pos= it_.front().file_pos };

	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
		return Function();
	}
	res.name= it_.front().text;
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
		return Function();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}

		var FunctionType::Arg mut arg;
		arg.file_pos= it_.front().file_pos;
		arg.arg_type= ParseTypeName();

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
			return Function();
		}
		arg.name= it_.front().text;
		NextLexem();

		res.function_type.args.push_back( move(arg) );

		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}
		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::BracketRight ) // Prevent ')' after ','
			{
				PushErrorMessage();
				return Function();
			}
		}
	}

	if( it_.front().lexem_type == Lexem::Type::Colon )
	{
		NextLexem();
		res.function_type.return_type= ParseTypeName();
	}

	if( it_.front().lexem_type == Lexem::Type::BraceLeft )
	{
		res.block.reset( ParseBlock() );
	}
	else if( it_.front().lexem_type == Lexem::Type::Semicolon ){} // Prototype
	else
	{
		PushErrorMessage();
		return Function();
	}

	return move(res);
}

fn SyntaxAnalyzer::ParseBlock( mut this ) : Block
{
	NextLexem(); // {

	var Block mut block;

	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BraceRight )
	{
		if( IsKeyword( it_.front(), Keyword::return_ ) )
		{
			block.elements.push_back( ParseReturnOperator() );
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	return move(block);
}

fn SyntaxAnalyzer::ParseReturnOperator( mut this ) : ReturnOperator
{
	NextLexem(); // return

	var ReturnOperator mut res;

	res.expr= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
		return ReturnOperator();
	}
	NextLexem();

	return move(res);
}

fn SyntaxAnalyzer::NotEndOfFile( this ) : bool
{
	return it_.size() >= 2s;
}

fn SyntaxAnalyzer::NextLexem( mut this )
{
	if( NotEndOfFile() )
	{
		it_.drop_front();
	}
}

fn SyntaxAnalyzer::PushErrorMessage( mut this )
{
	if( error_messages_.empty() || FilePos(error_messages_.back().file_pos) != it_.front().file_pos )
	{
		var SyntaxErrorMessage mut error_message;
		error_message.file_pos= it_.front().file_pos;
		error_message.text= "Syntax error - unexpected lexem";
		error_messages_.push_back( move(error_message) );
	}
}

fn SyntaxAnalysis( Lexems& lexems ) : SyntaxAnalysisResult
{
	var SyntaxAnalyzer mut analyzer(lexems);
	return analyzer.DoAnalyzis();
}

} // namespace Synt

} // namespace U
