import "/shared/shared_ptr_final_nullable.u"
import "/string_conversions.u"
import "keywords.uh"
import "syntax_analyzer.uh"

namespace U1
{

namespace Synt
{

fn IsKeyword( Lexem& l, Keyword k ) : bool
{
	return l.lexem_type == Lexem::Type::Identifier && l.text == KeywordToString(k);
}

fn GetBinaryOperatorPriority( BinaryOperatorType binary_operator ) : i32
{
	// If this changed, same code in "syntax_analyzer.cpp" must be changed too!
	if( binary_operator == BinaryOperatorType::Div ||
		binary_operator == BinaryOperatorType::Mul ||
		binary_operator == BinaryOperatorType::Rem )
	{
		return 9;
	}
	if( binary_operator == BinaryOperatorType::Add ||
		binary_operator == BinaryOperatorType::Sub )
	{
		return 8;
	}
	if( binary_operator == BinaryOperatorType::ShiftLeft ||
		binary_operator == BinaryOperatorType::ShiftRight )
	{
		return 7;
	}
	if( binary_operator == BinaryOperatorType::Equal ||
		binary_operator == BinaryOperatorType::NotEqual ||
		binary_operator == BinaryOperatorType::Less ||
		binary_operator == BinaryOperatorType::LessEqual ||
		binary_operator == BinaryOperatorType::Greater ||
		binary_operator == BinaryOperatorType::GreaterEqual )
	{
		return 6;
	}
	if( binary_operator == BinaryOperatorType::And )
	{
		return 5;
	}
	if( binary_operator == BinaryOperatorType::Or )
	{
		return 4;
	}
	if( binary_operator == BinaryOperatorType::Xor )
	{
		return 3;
	}
	if( binary_operator == BinaryOperatorType::LazyLogicalAnd )
	{
		return 2;
	}
	if( binary_operator == BinaryOperatorType::LazyLogicalOr )
	{
		return 1;
	}

	halt;
}

fn IsBinaryOperator( Lexem& lexem ) : bool
{
	return
		lexem.lexem_type == Lexem::Type::Plus ||
		lexem.lexem_type == Lexem::Type::Minus ||
		lexem.lexem_type == Lexem::Type::Star ||
		lexem.lexem_type == Lexem::Type::Slash ||
		lexem.lexem_type == Lexem::Type::Percent ||

		lexem.lexem_type == Lexem::Type::CompareEqual ||
		lexem.lexem_type == Lexem::Type::CompareNotEqual ||
		lexem.lexem_type == Lexem::Type::CompareLess ||
		lexem.lexem_type == Lexem::Type::CompareLessOrEqual ||
		lexem.lexem_type == Lexem::Type::CompareGreater ||
		lexem.lexem_type == Lexem::Type::CompareGreaterOrEqual ||

		lexem.lexem_type == Lexem::Type::And ||
		lexem.lexem_type == Lexem::Type::Or ||
		lexem.lexem_type == Lexem::Type::Xor ||

		lexem.lexem_type == Lexem::Type::ShiftLeft  ||
		lexem.lexem_type == Lexem::Type::ShiftRight ||

		lexem.lexem_type == Lexem::Type::Conjunction ||
		lexem.lexem_type == Lexem::Type::Disjunction;
}

fn LexemToBinaryOperator( Lexem& lexem ) : BinaryOperatorType
{
	if( lexem.lexem_type == Lexem::Type::Plus	){ return BinaryOperatorType::Add; }
	if( lexem.lexem_type == Lexem::Type::Minus	){ return BinaryOperatorType::Sub; }
	if( lexem.lexem_type == Lexem::Type::Star	){ return BinaryOperatorType::Mul; }
	if( lexem.lexem_type == Lexem::Type::Slash	){ return BinaryOperatorType::Div; }
	if( lexem.lexem_type == Lexem::Type::Percent){ return BinaryOperatorType::Rem; }

	if( lexem.lexem_type == Lexem::Type::CompareEqual			){ return BinaryOperatorType::Equal			; }
	if( lexem.lexem_type == Lexem::Type::CompareNotEqual		){ return BinaryOperatorType::NotEqual		; }
	if( lexem.lexem_type == Lexem::Type::CompareLess			){ return BinaryOperatorType::Less			; }
	if( lexem.lexem_type == Lexem::Type::CompareLessOrEqual		){ return BinaryOperatorType::LessEqual		; }
	if( lexem.lexem_type == Lexem::Type::CompareGreater			){ return BinaryOperatorType::Greater		; }
	if( lexem.lexem_type == Lexem::Type::CompareGreaterOrEqual	){ return BinaryOperatorType::GreaterEqual	; }

	if( lexem.lexem_type == Lexem::Type::And ){ return BinaryOperatorType::And; }
	if( lexem.lexem_type == Lexem::Type::Or  ){ return BinaryOperatorType::Or ; }
	if( lexem.lexem_type == Lexem::Type::Xor ){ return BinaryOperatorType::Xor; }

	if( lexem.lexem_type == Lexem::Type::ShiftLeft  ){ return BinaryOperatorType::ShiftLeft ; }
	if( lexem.lexem_type == Lexem::Type::ShiftRight ){ return BinaryOperatorType::ShiftRight; }

	if( lexem.lexem_type == Lexem::Type::Conjunction ){ return BinaryOperatorType::LazyLogicalAnd; }
	if( lexem.lexem_type == Lexem::Type::Disjunction ){ return BinaryOperatorType::LazyLogicalOr ; }

	halt;
}

fn GetAdditiveAssignmentOperator( Lexem& lexem ) : ust::optional</BinaryOperatorType/>
{
	auto t= lexem.lexem_type;

	if( t == Lexem::Type::AssignAdd ){ return BinaryOperatorType::Add; }
	if( t == Lexem::Type::AssignSub ){ return BinaryOperatorType::Sub; }
	if( t == Lexem::Type::AssignMul ){ return BinaryOperatorType::Mul; }
	if( t == Lexem::Type::AssignDiv ){ return BinaryOperatorType::Div; }
	if( t == Lexem::Type::AssignAnd ){ return BinaryOperatorType::And; }
	if( t == Lexem::Type::AssignRem ){ return BinaryOperatorType::Rem; }
	if( t == Lexem::Type::AssignOr  ){ return BinaryOperatorType::Or ; }
	if( t == Lexem::Type::AssignXor ){ return BinaryOperatorType::Xor; }
	if( t == Lexem::Type::AssignShiftLeft  ){ return BinaryOperatorType::ShiftLeft ; }
	if( t == Lexem::Type::AssignShiftRight ){ return BinaryOperatorType::ShiftRight; }

	return ust::optional</BinaryOperatorType/>();
}

struct BinaryOperatorsChainComponent
{
	Expression expression;
	BinaryOperatorType operator= zero_init; // Value of last component is ignored
	FilePos file_pos;
}

type BinaryOperatorsChain= ust::vector</BinaryOperatorsChainComponent/>;

fn FoldBinaryOperatorsChain( ust::array_view_mut</BinaryOperatorsChainComponent/> chain ) : Expression
{
	// Should be non-empty.

	auto s= chain.size();
	if( s == 1s )
	{
		return take(chain.front().expression);
	}

	// Split binary operators chain using most-right operator with minimal priority. Than recursively process parts.

	auto mut split_op_pos= ~0s;
	auto mut min_priority= 9999;
	for( auto mut i= 0s; i < chain.size() - 1s; ++i )
	{
		auto cur_priority= GetBinaryOperatorPriority( chain[i].operator );
		if( cur_priority <= min_priority )
		{
			min_priority= cur_priority;
			split_op_pos= i;
		}
	}

	var BinaryOperator mut binary_operator
	{
		.l( FoldBinaryOperatorsChain( chain.subrange( 0s, split_op_pos + 1s ) ) ),
		.r( FoldBinaryOperatorsChain( chain.subrange( split_op_pos + 1s,  s ) ) ),
		.operator= chain[ split_op_pos ].operator,
		.file_pos= chain[ split_op_pos ].file_pos,
	};

	return move(binary_operator);
}

fn GetMostRightExpressionInPrefixOperatorsChain( Expression &mut e ) : Expression &mut
{
	if_var( &mut unary_plus : e.get</UnaryPlus/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( unary_plus.expr.get_ref() );
	}
	if_var( &mut unary_minus : e.get</UnaryMinus/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( unary_minus.expr.get_ref() );
	}
	if_var( &mut logical_not : e.get</LogicalNot/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( logical_not.expr.get_ref() );
	}
	if_var( &mut bitwise_not : e.get</BitwiseNot/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( bitwise_not.expr.get_ref() );
	}
	return e;
}

template</type T/>
fn VectorAppend( ust::vector</T/> &mut dst, ust::vector</T/> mut src )
{
	// HACK! We can not move from beginning of the vector. So, inverse vector and move elements from back.
	for( auto mut i= 0s; i < src.size() / 2s; ++i )
	{
		auto j= src.size() - i - 1s;
		src.swap( i, j );
	}
	while( !src.empty() )
	{
		dst.push_back( src.pop_back() );
	}
}

class SyntaxAnalyzer
{
public:
	fn constructor( this'a', Lexems&'b lexems, MacrosPtr mut macros ) ' a <- b ';

	fn DoAnalyzis( mut this ) : SyntaxAnalysisResult;
	fn ParseImports( mut this ) : ImportsList;

private:
	fn ParseNamespaceBody( mut this, Lexem::Type end_lexem ) : NamespaceElements;
	fn ParseNamespace( mut this ) : Namespace;

	fn ParseTemplateArgs( mut this ) : TemplateArgs;
	fn ParseComplexName( mut this ) : ComplexName;
	fn ParseExpression( mut this ) : Expression;
	fn ParseTypeName( mut this ) : TypeName;
	fn ParseArrayType( mut this ) : ArrayType;
	fn ParseTupleType( mut this ) : TupleType;
	fn ParseFunctionType( mut this ) : FunctionType;
	fn ParseFunctionParam( mut this ) : FunctionType::Param;
	fn ParseFunctionTypeEnding( mut this, FunctionType &mut function_type );
	fn ParseInnerReferenceTag( mut this ) : ust::string8;

	fn ParseFunction( mut this ) : Function;

	fn ParseInitializer( mut this, bool parse_expression_initializer  ) : Initializer;
	fn ParseVariableInitializer( mut this ) : Initializer;

	fn ParseBlock( mut this ) : Block;
	fn ParseBlockElements( mut this ) : BlockElements;
	fn ParseVariablesDeclaration( mut this ) : VariablesDeclaration;
	fn ParseAutoVariableDeclaration( mut this ) : AutoVariableDeclaration;
	fn ParseReturnOperator( mut this ) : ReturnOperator;
	fn ParseIfOperator( mut this ) : IfOperator;
	fn ParseStaticIfOperator( mut this ) : StaticIfOperator;
	fn ParseWhileOperator( mut this ) : WhileOperator;
	fn ParseForOperator( mut this ) : BlockElement;
	fn ParseRangeForOperator( mut this ) : RangeForOperator;
	fn ParseCStyleForOperator( mut this ) : CStyleForOperator;
	fn ParseBreakOperator( mut this ) : BreakOperator;
	fn ParseContinueOperator( mut this ) : ContinueOperator;
	fn ParseStaticAssert( mut this ) : StaticAssert;
	fn ParseHalt( mut this ) : BlockElement;

	fn ParseClass( mut this ) : Class;
	fn ParseClassKindAttribute( mut this ) : Class::KindAttribute;
	fn ParseClassParentsList( mut this ) : ust::vector</ComplexName/>;
	fn ParseClassOrderedFlag( mut this ) : bool;
	fn ParseClassBody( mut this ) : ClassElements;
	fn ParseClassBodyElements( mut this ) : ClassElements;
	fn ParseEnum( mut this ) : Enum;
	fn ParseTypeAlias( mut this ) : TypeAlias;

	type SomeTemplate= ust::variant</ tup[ ust::shared_ptr_final</ TypeTemplate />, ust::shared_ptr_final</ FunctionTemplate /> ] />;

	fn ParseTemplate( mut this ) : SomeTemplate;
	fn ParseTemplateSignatureParams( mut this ) : ust::vector</TypeTemplate::SignatureParam/>;

	// Macro related stuff.

	fn ParseMacro( mut this );
	fn ParseMacroMatchBlock( mut this ) : ust::vector</Macro::MatchElement/>;
	fn ParseMacroResultBlock( mut this ) : ust::vector</Macro::ResultElement/>;

	struct ParsedMacroElement
	{
		Lexems lexems;
		Macro::MatchElementKind kind= Macro::MatchElementKind::Lexem;
		ust::vector</ ust::shared_ptr_final</ MacroVariablesMap /> /> sub_elements; // 0 for simple macro variables, 0 or 1 for optionals, 0-many for sequences
	}

	type MacroVariablesMap= ust::unordered_map</ ust::string8, ParsedMacroElement />;
	type MacroVariablesMapsStack= ust::vector</ ust::shared_ptr_final</MacroVariablesMap/> />;

	fn FetchMacro( this, ust::string8& name, Macro::Context context ) : ust::shared_ptr_final_nullable</Macro/>;

	template</type T/>
	fn ExpandMacro( mut this, Macro& macro ) : T
	{
		var Lexems lexems_expanded= ExpandMacroImpl( macro );
		var SyntaxAnalyzer mut syntax_analyzer( lexems_expanded, macros_ );
		var T mut result;
		static_if( ust::is_same_type</T, Expression/>() )
		{
			result = syntax_analyzer.ParseExpression();
		}
		else if( ust::is_same_type</T, BlockElements/>() )
		{
			result = syntax_analyzer.ParseBlockElements();
		}
		else if( ust::is_same_type</T, ClassElements/>() )
		{
			result = syntax_analyzer.ParseClassBodyElements();
		}
		else if( ust::is_same_type</T, NamespaceElements/>() )
		{
			result = syntax_analyzer.ParseNamespaceBody( Lexem::Type::EndOfFile );
		}
		else{ static_assert(false); }

		VectorAppend( error_messages_, syntax_analyzer.error_messages_ );
		return move(result);
	}

	fn ExpandMacroImpl( mut this, Macro& macro ) : Lexems;
	fn MatchMacroBlock( mut this, ust::vector</Macro::MatchElement/>& match_elements ) : ust::shared_ptr_final_nullable</MacroVariablesMap/>;

	type UniqueMacroIdentifiersMap= ust::unordered_map</ ust::string8, ust::string8 />;

	fn ExpandMacroBlock(
		mut this,
		ust::vector</Macro::ResultElement/>& result_elements,
		MacroVariablesMapsStack &mut macro_variables_maps_stack,
		UniqueMacroIdentifiersMap &mut unique_macro_indentifiers_map,
		FilePos& expansion_file_pos ) : Lexems;

	fn FetchMacroVariable( MacroVariablesMapsStack& macro_variables_maps_stack, ust::string8& variable_name ) : ust::optional</ParsedMacroElement/>;

	// Utilities.
	fn NotEndOfFile( this ) : bool;
	fn NextLexem( mut this );
	fn PushErrorMessage( mut this );
	fn PushMacroErrorMessage( mut this, FilePos& file_pos, ust::string8 mut text );

private:
	ust::array_view_imut</Lexem/> it_;
	SyntaxErrorMessages error_messages_;

	MacrosPtr macros_;
}

fn SyntaxAnalyzer::constructor( this'a', Lexems&'b lexems, MacrosPtr mut macros ) ' a <- b '
	( it_= lexems.range(), macros_(move(macros)) )
{
}

fn SyntaxAnalyzer::DoAnalyzis( mut this ) : SyntaxAnalysisResult
{
	var SyntaxAnalysisResult mut res;

	res.imports_list= ParseImports();

	while( NotEndOfFile() && it_.front().lexem_type == Lexem::Type::MacroIdentifier && it_.front().text == "macro" )
	{
		ParseMacro();
	}

	res.program_elements= ParseNamespaceBody( Lexem::Type::EndOfFile );
	res.error_messages= take(error_messages_);

	{
		auto mut lock= macros_.lock_mut();
		res.macros= take(lock.get_ref());
	}

	return move(res);
}

fn SyntaxAnalyzer::ParseImports( mut this ) : ImportsList
{
	var ImportsList mut imports_list;
	while( NotEndOfFile() )
	{
		if( !IsKeyword( it_.front(), Keyword::import_ ) )
		{
			break;
		}
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::String )
		{
			PushErrorMessage();
		}
		imports_list.push_back( it_.front().text );
		NextLexem();
	}

	return move(imports_list);
}

fn SyntaxAnalyzer::ParseNamespaceBody( mut this, Lexem::Type end_lexem ) : NamespaceElements
{
	var NamespaceElements mut namespace_elements;
	while( NotEndOfFile() && it_.front().lexem_type != end_lexem  )
	{
		if( IsKeyword( it_.front(), Keyword::fn_ ) || IsKeyword( it_.front(), Keyword::op_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Function/>( ParseFunction() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Class/>( ParseClass() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::enum_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Enum/>( ParseEnum() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::type_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</TypeAlias/>( ParseTypeAlias() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::template_ ) )
		{
			auto t= ParseTemplate();
			variant_visit( &v : t )
			{
				namespace_elements.push_back( v );
			}
		}
		else if( IsKeyword( it_.front(), Keyword::namespace_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Namespace/>( ParseNamespace() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::var_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</VariablesDeclaration/>( ParseVariablesDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::auto_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</AutoVariableDeclaration/>( ParseAutoVariableDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::static_assert_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</StaticAssert/>( ParseStaticAssert() ) );
		}
		else
		{
			if( it_.front().lexem_type == Lexem::Type::Identifier )
			{
				auto macro= FetchMacro( it_.front().text, Macro::Context::Namespace );
				if( !macro.empty() )
				{
					var NamespaceElements mut expanded_namespace_elements= this.ExpandMacro</NamespaceElements/>( macro.get_ref() ); // TODO - fix this, remove explicit "this"
					VectorAppend( namespace_elements, move(expanded_namespace_elements) );
					continue;
				}
			}

			PushErrorMessage();
			break;
		}
	}

	return move(namespace_elements);
}

fn SyntaxAnalyzer::ParseNamespace( mut this ) : Namespace
{
	if( !IsKeyword( it_.front(), Keyword::namespace_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	var Namespace mut namespace_
	{
		.file_pos= it_.front().file_pos,
		.name= it_.front().text,
	};
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	namespace_.elements= ParseNamespaceBody( Lexem::Type::BraceRight );

	if( it_.front().lexem_type != Lexem::Type::BraceRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	return namespace_;
}

fn SyntaxAnalyzer::ParseTemplateArgs( mut this ) : TemplateArgs
{
	var TemplateArgs mut template_args;

	if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{
			NextLexem();
			break;
		}

		template_args.push_back( ParseExpression() );

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{}
		else if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
			}
		}
	}

	return move(template_args);
}

fn SyntaxAnalyzer::ParseComplexName( mut this ) : ComplexName
{
	var ComplexName mut complex_name{ .file_pos= it_.front().file_pos };
	if( IsKeyword( it_.front(), Keyword::typeof_ ) )
	{
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::BracketLeft )
		{
			PushErrorMessage();
		}
		NextLexem();

		var Typeof mut typeof_{ .expr( ParseExpression() ) };
		complex_name.start= move(typeof_);

		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();
	}
	else if( it_.front().lexem_type == Lexem::Type::Identifier )
	{
		complex_name.start= it_.front().text;
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
		{
			complex_name.tail.push_back( ust::box</ TemplateArgs />( ParseTemplateArgs() ) );
		}
	}
	else if( it_.front().lexem_type == Lexem::Type::Scope )
	{
		complex_name.start= EmptyVariant();
	}
	else
	{
		PushErrorMessage();
	}

	while( NotEndOfFile() && it_.front().lexem_type == Lexem::Type::Scope )
	{
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}
		complex_name.tail.push_back( it_.front().text );
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
		{
			complex_name.tail.push_back( ust::box</ TemplateArgs />( ParseTemplateArgs() ) );
		}
	}

	return move(complex_name);
}

fn SyntaxAnalyzer::ParseExpression( mut this ) : Expression
{
	var BinaryOperatorsChain mut binary_operators_chain;

	while( NotEndOfFile() )
	{
		var Expression mut current_node;
		var Expression mut prefix_operator;

		// Prefix operators.
		while( NotEndOfFile() )
		{
			if( it_.front().lexem_type == Lexem::Type::Plus )
			{
				var UnaryPlus mut unary_plus{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(unary_plus);
			}
			else if( it_.front().lexem_type == Lexem::Type::Minus )
			{
				var UnaryMinus mut unary_minus{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(unary_minus);
			}
			else if( it_.front().lexem_type == Lexem::Type::Not )
			{
				var LogicalNot mut logical_not{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(logical_not);
			}
			else if( it_.front().lexem_type == Lexem::Type::Tilda )
			{
				var BitwiseNot mut bitwise_not{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(bitwise_not);
			}
			else
			{
				break;
			}
		}

		// Main component.
		if( it_.front().lexem_type == Lexem::Type::Number )
		{
			var NumericConstant mut numeric_constant{ .file_pos= it_.front().file_pos };
			halt if( it_.front().text.size() < typeinfo</NumberLexemData/>.size_of );

			unsafe
			{
				ust::memory_copy( numeric_constant.num, it_.front().text.front(), typeinfo</NumberLexemData/>.size_of );
			}

			NextLexem();

			current_node= move(numeric_constant);
		}
		else if( it_.front().lexem_type == Lexem::Type::String )
		{
			var StringLiteral mut string_literal
			{
				.file_pos= it_.front().file_pos,
				.value= it_.front().text,
			};
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::LiteralSuffix )
			{
				string_literal.type_suffix= it_.front().text;
				NextLexem();
			}

			current_node= move(string_literal);
		}
		else if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
		{
			current_node= ust::box</ ArrayType />( ParseArrayType() );
		}
		else if( IsKeyword( it_.front(), Keyword::tup_ ) )
		{
			current_node= ust::box</ TupleType />( ParseTupleType() );
		}
		else if( IsKeyword( it_.front(), Keyword::false_ ) )
		{
			var BooleanConstant mut boolean_constant{ .file_pos= it_.front().file_pos, .value= false };
			NextLexem();
			current_node= move(boolean_constant);
		}
		else if( IsKeyword( it_.front(), Keyword::true_  ) )
		{
			var BooleanConstant mut boolean_constant{ .file_pos= it_.front().file_pos, .value= true  };
			NextLexem();
			current_node= move(boolean_constant);
		}
		else if( IsKeyword( it_.front(), Keyword::fn_ ) )
		{
			current_node= ust::box</FunctionType/>( ParseFunctionType() );
		}
		else if( IsKeyword( it_.front(), Keyword::typeinfo_ ) )
		{
			var Typeinfo mut typeinfo_{ .file_pos= it_.front().file_pos };
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			typeinfo_.type_name= ParseTypeName();

			if( it_.front().lexem_type != Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			current_node= move(typeinfo_);
		}
		else if( IsKeyword( it_.front(), Keyword::cast_ref_ ) )
		{
			auto file_pos= it_.front().file_pos;
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			var TypeName mut t= ParseTypeName();

			if( it_.front().lexem_type != Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			var Expression mut e= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			var CastRef mut cast{ .file_pos= file_pos, .t(move(t)), .expression(move(e)) };
			current_node= move(cast);
		}
		else if( IsKeyword( it_.front(), Keyword::cast_ref_unsafe_ ) )
		{
			auto file_pos= it_.front().file_pos;
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			var TypeName mut t= ParseTypeName();

			if( it_.front().lexem_type != Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			var Expression mut e= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			var CastRefUnsafe mut cast{ .file_pos= file_pos, .t(move(t)), .expression(move(e)) };
			current_node= move(cast);
		}
		else if( IsKeyword( it_.front(), Keyword::cast_imut_ ) )
		{
			auto file_pos= it_.front().file_pos;
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			var Expression mut e= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			var CastImut mut cast{ .file_pos= file_pos, .expression(move(e)) };
			current_node= move(cast);
		}
		else if( IsKeyword( it_.front(), Keyword::cast_mut_ ) )
		{
			auto file_pos= it_.front().file_pos;
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			var Expression mut e= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			var CastMut mut cast{ .file_pos= file_pos, .expression(move(e)) };
			current_node= move(cast);
		}
		else if( IsKeyword( it_.front(), Keyword::move_ ) )
		{
			var MoveOperator mut move_operator{ .file_pos= it_.front().file_pos };

			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			move_operator.variable_name= it_.front().text;
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			current_node= move(move_operator);
		}
		else if( it_.front().lexem_type == Lexem::Type::Identifier )
		{
			auto macro= FetchMacro( it_.front().text, Macro::Context::Expression );
			if( !macro.empty() )
			{
				current_node= this.ExpandMacro</Expression/>( macro.get_ref() ); // TODO - fix this, remove explicit "this"
			}
			else
			{
				current_node= ParseComplexName();
			}
		}
		else if( it_.front().lexem_type == Lexem::Type::Scope )
		{
			current_node= ParseComplexName();
		}
		else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
		{
			var BracketExpression mut bracket_expression{ .file_pos= it_.front().file_pos, .expr(Expression()) };
			NextLexem();

			bracket_expression.expr.get_ref()= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			current_node= move(bracket_expression);
		}
		else
		{
			break;
		}

		// Postfix operators.
		while( NotEndOfFile() )
		{
			if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
			{
				auto file_pos= it_.front().file_pos;
				NextLexem();

				auto mut index= ParseExpression();

				if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
				{
					PushErrorMessage();
				}
				NextLexem();

				var IndexationOperator mut indexation_operator
				{
					.file_pos= file_pos,
					.value(take(current_node)),
					.index(move(index))
				};

				current_node= move(indexation_operator);
			}
			else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
			{
				var CallOperator mut call_operator
				{
					.file_pos= it_.front().file_pos,
					.value(take(current_node))
				};
				NextLexem();

				while( NotEndOfFile() )
				{
					if( it_.front().lexem_type == Lexem::Type::BracketRight )
					{
						NextLexem();
						break;
					}

					call_operator.args.push_back( ust::shared_ptr_final</Expression/>( ParseExpression() ) );

					if( it_.front().lexem_type== Lexem::Type::Comma )
					{
						NextLexem();
						if( it_.front().lexem_type== Lexem::Type::BracketRight )
						{
							PushErrorMessage();
						}
					}
					else if( it_.front().lexem_type == Lexem::Type::BracketRight )
					{
						NextLexem();
						break;
					}
				}

				current_node= move(call_operator);
			}
			else if( it_.front().lexem_type == Lexem::Type::Dot )
			{
				var MemberAccessOperator mut member_access_operator
				{
					.file_pos =it_.front().file_pos,
					.value(take(current_node))
				};
				NextLexem();

				if( it_.front().lexem_type != Lexem::Type::Identifier )
				{
					PushErrorMessage();
				}
				member_access_operator.member_name= it_.front().text;
				NextLexem();

				if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
				{
					member_access_operator.template_args.reset( ParseTemplateArgs() );
				}

				current_node= move(member_access_operator);
			}
			else
			{
				break;
			}
		}

		if( prefix_operator.get</EmptyVariant/>().empty() )
		{
			GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= take(current_node);
			current_node= take(prefix_operator);
		}

		var BinaryOperatorsChainComponent mut comp{ .expression= move(current_node) };
		binary_operators_chain.push_back( move(comp) );

		if( IsBinaryOperator( it_.front() ) )
		{
			binary_operators_chain.back().operator= LexemToBinaryOperator( it_.front() );
			binary_operators_chain.back().file_pos= it_.front().file_pos;
			NextLexem();
		}
		else
		{
			break;
		}
	}

	if( binary_operators_chain.empty() )
	{
		return Expression();
	}
	return FoldBinaryOperatorsChain( binary_operators_chain.range() );
}

fn SyntaxAnalyzer::ParseTypeName( mut this ) : TypeName
{
	if( IsKeyword( it_.front(), Keyword::fn_ ) )
	{
		return ust::box</FunctionType/>( ParseFunctionType() );
	}
	else if( IsKeyword( it_.front(), Keyword::tup_ ) )
	{
		return ust::box</TupleType/>( ParseTupleType() );
	}
	else if( it_.front().lexem_type == Lexem::Type::Identifier || it_.front().lexem_type == Lexem::Type::Scope )
	{
		return ParseComplexName();
	}
	else if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
	{
		return ust::box</ArrayType/>( ParseArrayType() );
	}
	else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
	{
		// Type name inside (). We needs this for better parsing of function pointer types, for example.

		NextLexem();

		auto mut type_name= ParseTypeName();

		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(type_name);
	}
	else
	{
		PushErrorMessage();
		return TypeName();
	}
}

fn SyntaxAnalyzer::ParseArrayType( mut this ) : ArrayType
{
	if( it_.front().lexem_type != Lexem::Type::SquareBracketLeft )
	{
		PushErrorMessage();
	}
	var ArrayType mut array_type{ .file_pos= it_.front().file_pos };
	NextLexem();

	array_type.element_type= ParseTypeName();

	if( it_.front().lexem_type != Lexem::Type::Comma )
	{
		PushErrorMessage();
	}
	NextLexem();

	array_type.element_count= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(array_type);
}

fn SyntaxAnalyzer::ParseTupleType( mut this ) : TupleType
{
	var TupleType mut tuple_type{ .file_pos= it_.front().file_pos };

	halt if( !IsKeyword( it_.front(), Keyword::tup_ ) );
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::SquareBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
	{
		while(NotEndOfFile())
		{
			tuple_type.elements.push_back( ParseTypeName() );
			if( it_.front().lexem_type != Lexem::Type::Comma )
			{
				break;
			}
			NextLexem();
		}
	}

	if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(tuple_type);
}

fn SyntaxAnalyzer::ParseFunctionType( mut this ) : FunctionType
{
	var FunctionType mut function_type{ .file_pos= it_.front().file_pos };

	if( !IsKeyword( it_.front(), Keyword::fn_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}

		function_type.params.push_back( ParseFunctionParam() );

		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}
		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::BracketRight ) // Prevent ')' after ','
			{
				PushErrorMessage();
				break;
			}
		}
	}

	ParseFunctionTypeEnding( function_type );

	return move(function_type);
}

fn SyntaxAnalyzer::ParseFunctionParam( mut this ) : FunctionType::Param
{
	var FunctionType::Param mut param{ .file_pos= it_.front().file_pos, .t= ParseTypeName() };

	if( it_.front().lexem_type == Lexem::Type::And )
	{
		param.reference_modifier= ReferenceModifier::Reference;
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::Apostrophe )
		{
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			param.reference_tag= it_.front().text;
			NextLexem();
		}
	}

	if( IsKeyword( it_.front(), Keyword::mut_ ) )
	{
		param.mutability_modifier= MutabilityModifier::Mutable;
		NextLexem();
	}
	else if( IsKeyword( it_.front(), Keyword::imut_ ) )
	{
		param.mutability_modifier= MutabilityModifier::Immutable;
		NextLexem();
	}

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	param.name= it_.front().text;
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Apostrophe )
	{
		param.inner_reference_tag= ParseInnerReferenceTag();
	}

	return move(param);
}

fn SyntaxAnalyzer::ParseFunctionTypeEnding( mut this, FunctionType &mut function_type )
{
	if( it_.front().lexem_type == Lexem::Type::Apostrophe )
	{
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::Apostrophe )
		{
			// Empty list.
			NextLexem();
		}
		else
		{
			while( NotEndOfFile() )
			{
				var FunctionType::ReferencePollution mut reference_pollution;

				if( it_.front().lexem_type != Lexem::Type::Identifier )
				{
					PushErrorMessage();
				}
				reference_pollution.dst= it_.front().text;
				NextLexem();

				if( it_.front().lexem_type != Lexem::Type::LeftArrow )
				{
					PushErrorMessage();
				}
				NextLexem();

				if( it_.front().lexem_type != Lexem::Type::Identifier )
				{
					PushErrorMessage();
				}
				reference_pollution.src= it_.front().text;
				NextLexem();

				function_type.references_pollution.push_back( move(reference_pollution) );

				if( it_.front().lexem_type == Lexem::Type::Apostrophe )
				{
					NextLexem();
					break;
				}
				else if( it_.front().lexem_type == Lexem::Type::Comma )
				{
					NextLexem();
					continue;
				}
				else
				{
					PushErrorMessage();
					break;
				}
			}
		}
	}

	if( IsKeyword( it_.front(), Keyword::unsafe_ ) )
	{
		NextLexem();
		function_type.is_unsafe= true;
	}

	if( it_.front().lexem_type != Lexem::Type::Colon )
	{
		return;
	}
	NextLexem();

	function_type.return_type= ParseTypeName();

	if( it_.front().lexem_type == Lexem::Type::And )
	{
		NextLexem();
		function_type.return_value_reference_modifier= ReferenceModifier::Reference;

		if( it_.front().lexem_type == Lexem::Type::Apostrophe )
		{
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			function_type.return_value_reference_tag= it_.front().text;
			NextLexem();
		}

		if( IsKeyword( it_.front(), Keyword::mut_ ) )
		{
			function_type.return_value_mutability_modifier= MutabilityModifier::Mutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::imut_ ) )
		{
			function_type.return_value_mutability_modifier= MutabilityModifier::Immutable;
			NextLexem();
		}
	}
	else if( it_.front().lexem_type == Lexem::Type::Apostrophe )
	{
		function_type.return_value_reference_tag= ParseInnerReferenceTag();
	}
}

fn SyntaxAnalyzer::ParseInnerReferenceTag( mut this ) : ust::string8
{
	if( it_.front().lexem_type != Lexem::Type::Apostrophe )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	var ust::string8 mut tag= it_.front().text;
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Apostrophe )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(tag);
}

fn SyntaxAnalyzer::ParseFunction( mut this ) : Function
{
	auto is_operator= IsKeyword( it_.front(), Keyword::op_ );

	if( !( IsKeyword( it_.front(), Keyword::fn_ ) || IsKeyword( it_.front(), Keyword::op_ ) ) )
	{
		PushErrorMessage();
	}

	var Function mut res{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( IsKeyword( it_.front(), Keyword::virtual_ ) )
	{
		NextLexem();
		res.virtual_kind= Function::VirtualKind::DeclareVirtual;
		if( IsKeyword( it_.front(), Keyword::override_ ) )
		{
			res.virtual_kind= Function::VirtualKind::VirtualOverride;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::final_ ) )
		{
			res.virtual_kind= Function::VirtualKind::VirtualFinal;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::pure_ ) )
		{
			res.virtual_kind= Function::VirtualKind::VirtualPure;
			NextLexem();
		}
	}
	if( IsKeyword( it_.front(), Keyword::constexpr_ ) )
	{
		res.constexpr_= true;
		NextLexem();
	}
	if( IsKeyword( it_.front(), Keyword::nomangle_ ) )
	{
		res.no_mangle= true;
		NextLexem();
	}
	if( IsKeyword( it_.front(), Keyword::enable_if_ ) )
	{
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::BracketLeft )
		{
			PushErrorMessage();
		}
		NextLexem();

		res.condition.reset( ParseExpression() );

		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();
	}

	if( is_operator )
	{
		if( it_.front().lexem_type == Lexem::Type::Scope )
		{
			res.name.push_back( "" );
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
		}

		while( NotEndOfFile() )
		{
			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				break;
			}
			res.name.push_back( it_.front().text );
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Scope )
			{
				PushErrorMessage();
			}
			NextLexem();
		}

		auto l= it_.front().lexem_type;
		auto mut o= OverloadedOperator::None;
			 if( l == Lexem::Type::Plus    ){ o= OverloadedOperator::Add; }
		else if( l == Lexem::Type::Minus   ){ o= OverloadedOperator::Sub; }
		else if( l == Lexem::Type::Star    ){ o= OverloadedOperator::Mul; }
		else if( l == Lexem::Type::Slash   ){ o= OverloadedOperator::Div; }
		else if( l == Lexem::Type::Percent ){ o= OverloadedOperator::Rem; }
		else if( l == Lexem::Type::CompareEqual    ){ o= OverloadedOperator::Equal   ; }
		else if( l == Lexem::Type::CompareNotEqual ){ o= OverloadedOperator::NotEqual; }
		else if( l == Lexem::Type::CompareLess           ){ o= OverloadedOperator::Less        ; }
		else if( l == Lexem::Type::CompareLessOrEqual    ){ o= OverloadedOperator::LessEqual   ; }
		else if( l == Lexem::Type::CompareGreater        ){ o= OverloadedOperator::Greater     ; }
		else if( l == Lexem::Type::CompareGreaterOrEqual ){ o= OverloadedOperator::GreaterEqual; }
		else if( l == Lexem::Type::And ){ o= OverloadedOperator::And; }
		else if( l == Lexem::Type::Or  ){ o= OverloadedOperator::Or ; }
		else if( l == Lexem::Type::Xor ){ o= OverloadedOperator::Xor; }
		else if( l == Lexem::Type::ShiftLeft  ){ o= OverloadedOperator::ShiftLeft ; }
		else if( l == Lexem::Type::ShiftRight ){ o= OverloadedOperator::ShiftRight; }
		else if( l == Lexem::Type::AssignAdd ){ o= OverloadedOperator::AssignAdd; }
		else if( l == Lexem::Type::AssignSub ){ o= OverloadedOperator::AssignSub; }
		else if( l == Lexem::Type::AssignMul ){ o= OverloadedOperator::AssignMul; }
		else if( l == Lexem::Type::AssignDiv ){ o= OverloadedOperator::AssignDiv; }
		else if( l == Lexem::Type::AssignRem ){ o= OverloadedOperator::AssignRem; }
		else if( l == Lexem::Type::AssignAnd ){ o= OverloadedOperator::AssignAnd; }
		else if( l == Lexem::Type::AssignOr  ){ o= OverloadedOperator::AssignOr ; }
		else if( l == Lexem::Type::AssignXor ){ o= OverloadedOperator::AssignXor; }
		else if( l == Lexem::Type::AssignShiftLeft  ){ o= OverloadedOperator::AssignShiftLeft ; }
		else if( l == Lexem::Type::AssignShiftRight ){ o= OverloadedOperator::AssignShiftRight; }
		else if( l == Lexem::Type::Not   ){ o= OverloadedOperator::LogicalNot; }
		else if( l == Lexem::Type::Tilda ){ o= OverloadedOperator::BitwiseNot; }
		else if( l == Lexem::Type::Assignment ){ o= OverloadedOperator::Assign; }
		else if( l == Lexem::Type::Increment ){ o= OverloadedOperator::Increment; }
		else if( l == Lexem::Type::Decrement ){ o= OverloadedOperator::Decrement; }
		else if( l == Lexem::Type::SquareBracketLeft )
		{
			o= OverloadedOperator::Indexing;

			NextLexem();
			if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
			{
				PushErrorMessage();
			}
		}
		else if( l == Lexem::Type::BracketLeft )
		{
			o= OverloadedOperator::Call;

			NextLexem();
			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
		}
		else
		{
			PushErrorMessage();
		}
		NextLexem();

		res.operator= o;
		res.name.push_back( OverloadedOperatorToString(o) );
	}
	else
	{
		while( true )
		{
			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
				return Function();
			}
			res.name.push_back( it_.front().text );
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Scope )
			{
				break;
			}
			NextLexem();
		}
	}

	res.function_type.file_pos= it_.front().file_pos;
	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
		return Function();
	}
	NextLexem();

	auto is_constructor_or_destructor=
		res.name.back() == KeywordToString( Keyword::constructor_ ) || res.name.back() == KeywordToString( Keyword::destructor_ );

	if( IsKeyword( it_.front(), Keyword::this_ ) || IsKeyword( it_.front(), Keyword::mut_ ) || IsKeyword( it_.front(), Keyword::imut_ ) )
	{
		var FunctionType::Param mut this_param
		{
			.name= KeywordToString( Keyword::this_ ),
			.reference_tag= KeywordToString( Keyword::this_ ), // Implicit set name for tag of "this" to "this".
		};

		if( IsKeyword( it_.front(), Keyword::mut_ ) )
		{
			this_param.mutability_modifier= MutabilityModifier::Mutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::imut_ ) )
		{
			this_param.mutability_modifier= MutabilityModifier::Immutable;
			NextLexem();
		}

		if( !IsKeyword( it_.front(), Keyword::this_ ) )
		{
			PushErrorMessage();
		}
		this_param.file_pos= it_.front().file_pos;
		NextLexem();

		if( is_constructor_or_destructor ){ this_param.mutability_modifier= MutabilityModifier::Mutable; }

		if( it_.front().lexem_type == Lexem::Type::Apostrophe )
		{
			this_param.inner_reference_tag= ParseInnerReferenceTag();
		}

		res.function_type.params.push_back( move(this_param) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			// Disallov constructions, like "fn f( mut this, ){}"
			if( it_.front().lexem_type == Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
		}
	}

	// If method is constructor or destructor and "this" not explicitly specified, add it.
	// It's easier add "this" here, than dealing with implicit "this" in CodeBuilder.
	if( is_constructor_or_destructor && res.function_type.params.empty() )
	{
		var FunctionType::Param mut this_param
		{
			.file_pos= it_.front().file_pos,
			.name= KeywordToString( Keyword::this_ ),
			.mutability_modifier= MutabilityModifier::Mutable,
		};
		res.function_type.params.push_back( move(this_param) );
	}

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}

		res.function_type.params.push_back( ParseFunctionParam() );

		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}
		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::BracketRight ) // Prevent ')' after ','
			{
				PushErrorMessage();
				return Function();
			}
		}
	}

	ParseFunctionTypeEnding( res.function_type );

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();
	}
	else if( it_.front().lexem_type == Lexem::Type::Assignment )
	{
		NextLexem();

		if( IsKeyword( it_.front(), Keyword::default_ ) )
		{
			res.body_kind= Function::BodyKind::BodyGenerationRequired;
		}
		else if( IsKeyword( it_.front(), Keyword::delete_ ) )
		{
			res.body_kind= Function::BodyKind::BodyGenerationDisabled;
		}
		else
		{
			PushErrorMessage();
		}

		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Semicolon )
		{
			PushErrorMessage();
		}
		NextLexem();
	}
	else
	{
		if( it_.front().lexem_type == Lexem::Type::BracketLeft )
		{
			var StructNamedInitializer mut constructor_initializer_list{ .file_pos= it_.front().file_pos };
			NextLexem();

			while( NotEndOfFile() )
			{
				if( it_.front().lexem_type == Lexem::Type::BracketRight )
				{
					NextLexem();
					break;
				}

				if( it_.front().lexem_type != Lexem::Type::Identifier )
				{
					PushErrorMessage();
					break;
				}

				var StructNamedInitializer::Member mut member_initializer
				{
					.file_pos= it_.front().file_pos,
					.name= it_.front().text,
					.initializer( Initializer() ),
				};
				NextLexem();

				member_initializer.initializer.get_ref()= ParseVariableInitializer();
				if( !member_initializer.initializer.get_ref().get</EmptyVariant/>().empty() )
				{
					PushErrorMessage();
				}

				constructor_initializer_list.members_initializers.push_back( move(member_initializer) );

				if( it_.front().lexem_type == Lexem::Type::Comma )
				{
					NextLexem();
				}
				else if( it_.front().lexem_type != Lexem::Type::BracketRight )
				{
					PushErrorMessage();
					break;
				}
			}

			res.constructor_initializer_list.reset( move(constructor_initializer_list) );
		}

		if( it_.front().lexem_type == Lexem::Type::BraceLeft )
		{
			res.block.reset( ParseBlock() );
		}
		else
		{
			PushErrorMessage();
		}
	}
	return move(res);
}

fn SyntaxAnalyzer::ParseInitializer( mut this, bool parse_expression_initializer ) : Initializer
{
	if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
	{
		var SequenceInitializer mut sequence_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();

		while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::SquareBracketRight )
		{
			sequence_initializer.elements_initializers.push_back( ust::box</Initializer/>( ParseInitializer( true ) ) );
			if( it_.front().lexem_type == Lexem::Type::Comma )
			{
				NextLexem();
			}
			else
			{
				break;
			}
			// TODO - parse continious flag here
		}
		if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(sequence_initializer);
	}
	else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
	{
		/// TODO - fix case, like :    var [ i32, 1] x[ (1 + 2) * 3 ];
		var ConstructorInitializer mut constructor_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();

		while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			constructor_initializer.args.push_back( ust::shared_ptr_final</ Expression />( ParseExpression() ) );
			if( it_.front().lexem_type  == Lexem::Type::Comma )
			{
				NextLexem();
				// Disallow comma after closing bracket
				if( it_.front().lexem_type  == Lexem::Type::BracketRight )
				{
					PushErrorMessage();
				}
			}
			else
			{
				break;
			}
		}
		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(constructor_initializer);
	}
	else if( it_.front().lexem_type == Lexem::Type::BraceLeft )
	{
		var StructNamedInitializer mut struct_named_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();

		while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BraceRight )
		{
			if( it_.front().lexem_type != Lexem::Type::Dot )
			{
				PushErrorMessage();
			}
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			auto& name= it_.front().text;
			auto& file_pos= it_.front().file_pos;
			NextLexem();

			auto mut initializer= ParseVariableInitializer();
			if( !initializer.get</EmptyVariant/>().empty() )
			{
				PushErrorMessage();
			}

			var StructNamedInitializer::Member mut member_initializer
			{
				.file_pos= file_pos,
				.name= name,
				.initializer( move(initializer) ),
			};
			struct_named_initializer.members_initializers.push_back( move(member_initializer) );

			if( it_.front().lexem_type == Lexem::Type::Comma )
			{
				NextLexem();
			}
		}
		if( it_.front().lexem_type != Lexem::Type::BraceRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(struct_named_initializer);
	}
	else if( IsKeyword( it_.front(), Keyword::zero_init_ ) )
	{
		var ZeroInitializer mut zero_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();
		return move(zero_initializer);
	}
	else if( IsKeyword( it_.front(), Keyword::uninitialized_ ) )
	{
		var UninitializedInitializer mut uninitialized_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();
		return move(uninitialized_initializer);
	}
	else if( parse_expression_initializer )
	{
		// In some cases usage of expression in initializer is forbidden.
		return ParseExpression();
	}
	else
	{
		PushErrorMessage();
		return EmptyVariant();
	}
}

fn SyntaxAnalyzer::ParseVariableInitializer( mut this ) : Initializer
{
	if( it_.front().lexem_type == Lexem::Type::Assignment )
	{
		NextLexem();
		if( IsKeyword( it_.front(), Keyword::zero_init_ ) )
		{
			var ZeroInitializer mut zero_initializer{ .file_pos= it_.front().file_pos };
			NextLexem();
			return Initializer( move(zero_initializer) );
		}
		if( IsKeyword( it_.front(), Keyword::uninitialized_ ) )
		{
			var UninitializedInitializer mut uninitialized_initializer{ .file_pos= it_.front().file_pos };
			NextLexem();
			return move(uninitialized_initializer);
		}
		else
		{
			return ParseExpression();
		}
	}
	else if(
		it_.front().lexem_type == Lexem::Type::BracketLeft ||
		it_.front().lexem_type == Lexem::Type::SquareBracketLeft ||
		it_.front().lexem_type == Lexem::Type::BraceLeft )
	{
		return ParseInitializer( false );
	}

	return Initializer( EmptyVariant() );
}

fn SyntaxAnalyzer::ParseBlock( mut this ) : Block
{
	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}

	var Block mut block{ .file_pos= it_.front().file_pos };

	NextLexem(); // {

	block.elements= ParseBlockElements();

	block.end_file_pos= it_.front().file_pos;

	if( it_.front().lexem_type == Lexem::Type::BraceRight )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	return move(block);
}

fn SyntaxAnalyzer::ParseBlockElements( mut this ) : BlockElements
{
	var BlockElements mut block_elements;

	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BraceRight && it_.front().lexem_type != Lexem::Type::EndOfFile )
	{
		if( it_.front().lexem_type == Lexem::Type::BraceLeft )
		{
			block_elements.push_back( ust::box</Block/>(ParseBlock()) );
		}
		else if( IsKeyword( it_.front(), Keyword::safe_ ) )
		{
			NextLexem();
			auto mut inner_block= ParseBlock();
			inner_block.safety= Block::Safety::Safe;
			block_elements.push_back( ust::box</Block/>(move(inner_block)) );
		}
		else if( IsKeyword( it_.front(), Keyword::unsafe_ ) )
		{
			NextLexem();
			auto mut inner_block= ParseBlock();
			inner_block.safety= Block::Safety::Unsafe;
			block_elements.push_back( ust::box</Block/>(move(inner_block)) );
		}
		else if( IsKeyword( it_.front(), Keyword::var_ ) )
		{
			block_elements.push_back( ParseVariablesDeclaration() );
		}
		else if( IsKeyword( it_.front(), Keyword::auto_ ) )
		{
			block_elements.push_back( ParseAutoVariableDeclaration() );
		}
		else if( IsKeyword( it_.front(), Keyword::return_ ) )
		{
			block_elements.push_back( ParseReturnOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::if_ ) )
		{
			block_elements.push_back( ParseIfOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::static_if_ ) )
		{
			block_elements.push_back( ParseStaticIfOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::while_ ) )
		{
			block_elements.push_back( ParseWhileOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::for_ ) )
		{
			block_elements.push_back( ParseForOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::break_ ) )
		{
			block_elements.push_back( ParseBreakOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::continue_ ) )
		{
			block_elements.push_back( ParseContinueOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::static_assert_ ) )
		{
			block_elements.push_back( ParseStaticAssert() );
		}
		else if( IsKeyword( it_.front(), Keyword::halt_ ) )
		{
			block_elements.push_back( ParseHalt() );
		}
		else if( it_.front().lexem_type == Lexem::Type::Increment )
		{
			var IncrementOperator mut increment_operator{ .file_pos= it_.front().file_pos };
			NextLexem();
			increment_operator.expression= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::Semicolon )
			{
				PushErrorMessage();
			}
			NextLexem();

			block_elements.push_back( move(increment_operator) );
		}
		else if( it_.front().lexem_type == Lexem::Type::Decrement )
		{
			var DecrementOperator mut decrement_operator{ .file_pos= it_.front().file_pos };
			NextLexem();
			decrement_operator.expression= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::Semicolon )
			{
				PushErrorMessage();
			}
			NextLexem();

			block_elements.push_back( move(decrement_operator) );
		}
		else
		{
			if( it_.front().lexem_type == Lexem::Type::Identifier )
			{
				auto macro= FetchMacro( it_.front().text, Macro::Context::Block );
				if( !macro.empty() )
				{
					var BlockElements mut expanded_block_elements= this.ExpandMacro</BlockElements/>( macro.get_ref() ); // TODO - fix this, remove explicit "this"
					VectorAppend( block_elements, move(expanded_block_elements) );
					continue;
				}
			}

			auto mut expr= ParseExpression();

			auto additive_assignment_operator_type= GetAdditiveAssignmentOperator( it_.front() );
			if( !additive_assignment_operator_type.empty() )
			{
				auto file_pos= it_.front().file_pos;
				NextLexem();
				var AdditiveAssignmentOperator mut additive_assignment_operator
				{
					.file_pos= file_pos,
					.operator= additive_assignment_operator_type.get_ref(),
					.l(move(expr)),
					.r(ParseExpression()),
				};

				block_elements.push_back( move(additive_assignment_operator) );
			}
			else if( it_.front().lexem_type == Lexem::Type::Assignment )
			{
				auto file_pos= it_.front().file_pos;
				NextLexem();
				var AssignmentOperator mut assignment_operator
				{
					.file_pos= file_pos,
					.l( move(expr) ),
					.r( ParseExpression() ),
				};

				block_elements.push_back( move(assignment_operator) );
			}
			else
			{
				block_elements.push_back( move(expr) );
			}

			if( it_.front().lexem_type == Lexem::Type::Semicolon )
			{
				NextLexem();
			}
			else
			{
				PushErrorMessage();
			}
		}
	}

	return move(block_elements);
}

fn SyntaxAnalyzer::ParseVariablesDeclaration( mut this ) : VariablesDeclaration
{
	var VariablesDeclaration mut variables_declaration{ .file_pos= it_.front().file_pos };

	NextLexem(); // var

	variables_declaration.t= ParseTypeName();

	while( NotEndOfFile() )
	{
		var VariablesDeclaration::VariableEntry mut variable_entry;

		if( it_.front().lexem_type == Lexem::Type::And )
		{
			variable_entry.reference_modifier= ReferenceModifier::Reference;
			NextLexem();
		}

		if( IsKeyword( it_.front(), Keyword::mut_ ) )
		{
			variable_entry.mutability_modifier= MutabilityModifier::Mutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::imut_ ) )
		{
			variable_entry.mutability_modifier= MutabilityModifier::Immutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::constexpr_ ) )
		{
			variable_entry.mutability_modifier= MutabilityModifier::Constexpr;
			NextLexem();
		}

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
			break;
		}
		variable_entry.file_pos= it_.front().file_pos;
		variable_entry.name= it_.front().text;
		NextLexem();

		variable_entry.initializer= ParseVariableInitializer();

		variables_declaration.variables.push_back( move(variable_entry) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			continue;
		}
		if( it_.front().lexem_type == Lexem::Type::Semicolon )
		{
			NextLexem();
			break;
		}
	}

	return move(variables_declaration);
}

fn SyntaxAnalyzer::ParseAutoVariableDeclaration( mut this ) : AutoVariableDeclaration
{
	var AutoVariableDeclaration mut variable_declaration;

	NextLexem(); // auto

	if( it_.front().lexem_type == Lexem::Type::And )
	{
		variable_declaration.reference_modifier= ReferenceModifier::Reference;
		NextLexem();
	}

	if( IsKeyword( it_.front(), Keyword::mut_ ) )
	{
		variable_declaration.mutability_modifier= MutabilityModifier::Mutable;
		NextLexem();
	}
	else if( IsKeyword( it_.front(), Keyword::imut_ ) )
	{
		variable_declaration.mutability_modifier= MutabilityModifier::Immutable;
		NextLexem();
	}
	else if( IsKeyword( it_.front(), Keyword::constexpr_ ) )
	{
		variable_declaration.mutability_modifier= MutabilityModifier::Constexpr;
		NextLexem();
	}

	variable_declaration.name= it_.front().text;
	variable_declaration.file_pos= it_.front().file_pos;
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Assignment )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	variable_declaration.initializer_expression= ParseExpression();

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	return move(variable_declaration);
}

fn SyntaxAnalyzer::ParseReturnOperator( mut this ) : ReturnOperator
{
	var ReturnOperator mut res{ .file_pos= it_.front().file_pos };
	NextLexem(); // return

	res.expr= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
		return ReturnOperator();
	}
	NextLexem();

	return move(res);
}

fn SyntaxAnalyzer::ParseIfOperator( mut this ) : IfOperator
{
	auto start_file_pos= it_.front().file_pos;
	NextLexem(); // "if" or "static_if"

	var IfOperator mut if_operator{ .file_pos= start_file_pos };

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	auto mut if_expression= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}

	var IfOperator::Branch mut first_branch
	{
		.file_pos= start_file_pos,
		.condition= move(if_expression),
		.block( ParseBlock() )
	};

	if_operator.branches.push_back( move(first_branch) );

	while( NotEndOfFile() )
	{
		auto else_file_pos= it_.front().file_pos;
		if( !IsKeyword( it_.front(), Keyword::else_ ) )
		{
			break;
		}
		NextLexem();

		// Optional if.
		var Expression mut condition;
		if( IsKeyword( it_.front(), Keyword::if_ ) )
		{
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}

			NextLexem();

			condition= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}

			NextLexem();
		}
		// Block - common for "else" and "else if".
		if( it_.front().lexem_type != Lexem::Type::BraceLeft )
		{
			PushErrorMessage();
		}

		var IfOperator::Branch mut branch
		{
			.file_pos= else_file_pos,
			.condition= move(condition),
			.block( ParseBlock() )
		};
		if_operator.end_file_pos= branch.block.get_ref().end_file_pos;
		if_operator.branches.push_back( move(branch) );

		if( !if_operator.branches.back().condition.get</EmptyVariant/>().empty() )
		{
			break;
		}
	}

	return move(if_operator);
}

fn SyntaxAnalyzer::ParseStaticIfOperator( mut this ) : StaticIfOperator
{
	if( !IsKeyword( it_.front(), Keyword::static_if_ ) )
	{
		PushErrorMessage();
	}

	var StaticIfOperator mut static_if_operator
	{
		.file_pos= it_.front().file_pos,
		.if_operator= ParseIfOperator()
	};
	return move(static_if_operator);
}

fn SyntaxAnalyzer::ParseWhileOperator( mut this ) : WhileOperator
{
	auto start_file_pos= it_.front().file_pos;
	NextLexem(); // while

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	auto mut condition= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}

	var WhileOperator mut while_operator
	{
		.file_pos= start_file_pos,
		.condition= move(condition),
		.block( ParseBlock() )
	};
	return move(while_operator);
}

fn SyntaxAnalyzer::ParseForOperator( mut this ) : BlockElement
{
	if( it_.size() >= 3s )
	{
		var Lexem& next_lexem= it_[2s];
		if( IsKeyword( next_lexem, Keyword::var_ ) || IsKeyword( next_lexem, Keyword::auto_ ) || next_lexem.lexem_type == Lexem::Type::Semicolon )
		{
			return ParseCStyleForOperator();
		}
	}

	return ParseRangeForOperator();
}

fn SyntaxAnalyzer::ParseRangeForOperator( mut this ) : RangeForOperator
{
	var RangeForOperator mut for_operator{ .file_pos= it_.front().file_pos, .block(Block()) };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::And )
	{
		for_operator.reference_modifier= ReferenceModifier::Reference;
		NextLexem();
	}
	if( IsKeyword( it_.front(), Keyword::mut_ ) )
	{
		for_operator.mutability_modifier= MutabilityModifier::Mutable;
		NextLexem();
	}
	else if( IsKeyword( it_.front(), Keyword::imut_ ) )
	{
		for_operator.mutability_modifier= MutabilityModifier::Immutable;
		NextLexem();
	}

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	for_operator.loop_variable_name= it_.front().text;
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Colon )
	{
		PushErrorMessage();
	}
	NextLexem();

	for_operator.sequence= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	for_operator.block.get_ref()= ParseBlock();

	return move(for_operator);
}

fn SyntaxAnalyzer::ParseCStyleForOperator( mut this ) : CStyleForOperator
{
	var CStyleForOperator mut for_operator{ .file_pos= it_.front().file_pos, .block(Block()) };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	// Varaibles declaration
	if( IsKeyword( it_.front(), Keyword::var_ ) )
	{
		for_operator.variable_declaration_part= ParseVariablesDeclaration();
	}
	else if( IsKeyword( it_.front(), Keyword::auto_ ) )
	{
		for_operator.variable_declaration_part= ParseAutoVariableDeclaration();
	}
	else if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	// Condition.
	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		for_operator.loop_condition= ParseExpression();
	}

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	// Iteration part.

	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		if( it_.front().lexem_type == Lexem::Type::Increment )
		{
			var IncrementOperator mut increment_operator{ .file_pos= it_.front().file_pos };
			NextLexem();
			increment_operator.expression= ParseExpression();

			for_operator.iteration_part_elements.push_back( move(increment_operator) );
		}
		else if( it_.front().lexem_type == Lexem::Type::Decrement )
		{
			var DecrementOperator mut decrement_operator{ .file_pos= it_.front().file_pos };
			NextLexem();
			decrement_operator.expression= ParseExpression();

			for_operator.iteration_part_elements.push_back( move(decrement_operator) );
		}
		else
		{
			var Expression mut expression_l= ParseExpression();

			auto additive_assignment_operator_type= GetAdditiveAssignmentOperator( it_.front() );
			if( !additive_assignment_operator_type.empty() )
			{
				auto file_pos= it_.front().file_pos;
				NextLexem();
				var AdditiveAssignmentOperator mut additive_assignment_operator
				{
					.file_pos= file_pos,
					.operator= additive_assignment_operator_type.get_ref(),
					.l(move(expression_l)),
					.r(ParseExpression()),
				};

				for_operator.iteration_part_elements.push_back( move(additive_assignment_operator) );
			}
			else if( it_.front().lexem_type == Lexem::Type::Assignment )
			{
				auto file_pos= it_.front().file_pos;
				NextLexem();
				var AssignmentOperator mut assignment_operator
				{
					.file_pos= file_pos,
					.l(move(expression_l)),
					.r( ParseExpression() ),
				};

				for_operator.iteration_part_elements.push_back( move(assignment_operator) );
			}
			else
			{
				for_operator.iteration_part_elements.push_back( move(expression_l) );
			}
		}

		if( it_.front().lexem_type != Lexem::Type::Comma )
		{
			break;
		}
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::BracketRight ) // forbid ) after ,
		{
			PushErrorMessage();
		}
	}

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	for_operator.block.get_ref()= ParseBlock();

	return move(for_operator);
}

fn SyntaxAnalyzer::ParseBreakOperator( mut this ) : BreakOperator
{
	var BreakOperator mut break_operator{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(break_operator);
}

fn SyntaxAnalyzer::ParseContinueOperator( mut this ) : ContinueOperator
{
	var ContinueOperator mut continue_operator{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(continue_operator);
}

fn SyntaxAnalyzer::ParseStaticAssert( mut this ) : StaticAssert
{
	if( !IsKeyword( it_.front(), Keyword::static_assert_ ) )
	{
		PushErrorMessage();
	}

	var StaticAssert mut static_assert_{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	static_assert_.expression= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(static_assert_);
}

fn SyntaxAnalyzer::ParseHalt( mut this ) : BlockElement
{
	if( !IsKeyword( it_.front(), Keyword::halt_ ) )
	{
		PushErrorMessage();
	}
	auto file_pos= it_.front().file_pos;
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();

		var Halt mut halt_{ .file_pos= file_pos };
		return move(halt_);
	}
	else
	{
		var HaltIf mut halt_if{ .file_pos= file_pos };

		if( !IsKeyword( it_.front(), Keyword::if_ ) )
		{
			PushErrorMessage();
		}
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::BracketLeft )
		{
			PushErrorMessage();
		}
		NextLexem();

		halt_if.condition= ParseExpression();

		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Semicolon )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(halt_if);
	}
}

fn SyntaxAnalyzer::ParseClass( mut this ) : Class
{
	var Class mut class_;

	auto is_struct= IsKeyword( it_.front(), Keyword::struct_ );
	auto is_class= IsKeyword( it_.front(), Keyword::class_ );
	if( !( is_struct || is_class ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	class_.file_pos= it_.front().file_pos;
	class_.name= it_.front().text;
	NextLexem();

	if( is_struct )
	{
		class_.kind_attribute= Class::KindAttribute::Struct;
	}
	else
	{
		class_.kind_attribute= ParseClassKindAttribute();
		class_.parents= ParseClassParentsList();
	}
	class_.keep_fields_order= ParseClassOrderedFlag();

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();
		class_.is_forward_declaration= true;
	}
	else
	{
		class_.class_elements= ParseClassBody();
		class_.is_forward_declaration= false;
	}
	return move(class_);
}

fn SyntaxAnalyzer::ParseClassBody( mut this ) : ClassElements
{
	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	auto mut class_elements= ParseClassBodyElements();

	if( it_.front().lexem_type != Lexem::Type::BraceRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(class_elements);
}

fn SyntaxAnalyzer::ParseClassBodyElements( mut this ) : ClassElements
{
	var ClassElements mut class_elements;

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BraceRight || it_.front().lexem_type == Lexem::Type::EndOfFile )
		{
			break;
		}
		else if( IsKeyword( it_.front(), Keyword::public_ ) )
		{
			var ClassVisibilityLabel mut class_visibility_label{ .file_pos= it_.front().file_pos, .visibility= ClassVisibility::Public };
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Colon )
			{
				PushErrorMessage();
			}
			NextLexem();

			class_elements.push_back( move(class_visibility_label) );
		}
		else if( IsKeyword( it_.front(), Keyword::protected_ ) )
		{
			var ClassVisibilityLabel mut class_visibility_label{ .file_pos= it_.front().file_pos, .visibility= ClassVisibility::Protected };
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Colon )
			{
				PushErrorMessage();
			}
			NextLexem();

			class_elements.push_back( move(class_visibility_label) );
		}
		else if( IsKeyword( it_.front(), Keyword::private_ ) )
		{
			var ClassVisibilityLabel mut class_visibility_label{ .file_pos= it_.front().file_pos, .visibility= ClassVisibility::Private };
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Colon )
			{
				PushErrorMessage();
			}
			NextLexem();

			class_elements.push_back( move(class_visibility_label) );
		}
		else if( IsKeyword( it_.front(), Keyword::fn_ ) || IsKeyword( it_.front(), Keyword::op_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</Function/>( ParseFunction() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</Class/>( ParseClass() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::enum_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</Enum/>( ParseEnum() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::type_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</TypeAlias/>( ParseTypeAlias() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::template_ ) )
		{
			auto t= ParseTemplate();
			variant_visit( &v : t )
			{
				class_elements.push_back( v );
			}
		}
		else if( IsKeyword( it_.front(), Keyword::var_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</VariablesDeclaration/>( ParseVariablesDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::auto_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</AutoVariableDeclaration/>( ParseAutoVariableDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::static_assert_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</StaticAssert/>( ParseStaticAssert() ) );
		}
		else
		{
			if( it_.front().lexem_type == Lexem::Type::Identifier )
			{
				auto macro= FetchMacro( it_.front().text, Macro::Context::Class );
				if( !macro.empty() )
				{
					var ClassElements mut expanded_class_elements= this.ExpandMacro</ClassElements/>( macro.get_ref() ); // TODO - fix this, remove explicit "this"
					VectorAppend( class_elements, move(expanded_class_elements) );
					continue;
				}
			}

			var ClassField mut class_field;
			class_field.t= ParseTypeName();

			if( it_.front().lexem_type == Lexem::Type::And )
			{
				class_field.reference_modifier= ReferenceModifier::Reference;
				NextLexem();
			}

			if( IsKeyword( it_.front(), Keyword::mut_ ) )
			{
				class_field.mutability_modifier= MutabilityModifier::Mutable;
				NextLexem();
			}
			else if( IsKeyword( it_.front(), Keyword::imut_ ) )
			{
				class_field.mutability_modifier= MutabilityModifier::Immutable;
				NextLexem();
			}

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			class_field.file_pos= it_.front().file_pos;
			class_field.name= it_.front().text;
			NextLexem();

			class_field.initializer= ParseVariableInitializer();

			if( it_.front().lexem_type != Lexem::Type::Semicolon )
			{
				PushErrorMessage();
			}
			NextLexem();

			class_elements.push_back( ust::shared_ptr_final</ ClassField />( move(class_field) ) );
		}
	}

	return move(class_elements);
}

fn SyntaxAnalyzer::ParseClassKindAttribute( mut this ) : Class::KindAttribute
{
	if( IsKeyword( it_.front(), Keyword::final_ ) )
	{
		NextLexem();
		return Class::KindAttribute::Final;
	}
	if( IsKeyword( it_.front(), Keyword::polymorph_ ) )
	{
		NextLexem();
		return Class::KindAttribute::Polymorph;
	}
	if( IsKeyword( it_.front(), Keyword::interface_ ) )
	{
		NextLexem();
		return Class::KindAttribute::Interface;
	}
	if( IsKeyword( it_.front(), Keyword::abstract_ ) )
	{
		NextLexem();
		return Class::KindAttribute::Abstract;
	}

	return Class::KindAttribute::Class;
}

fn SyntaxAnalyzer::ParseClassParentsList( mut this ) : ust::vector</ComplexName/>
{
	if( it_.front().lexem_type != Lexem::Type::Colon )
	{
		return ust::vector</ComplexName/>();
	}
	NextLexem();

	var ust::vector</ComplexName/> mut parents_list;

	while( NotEndOfFile() )
	{
		parents_list.push_back( ParseComplexName() );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
		}
		else
		{
			break;
		}
	}

	return move(parents_list);
}

fn SyntaxAnalyzer::ParseClassOrderedFlag( mut this ) : bool
{
	if( IsKeyword( it_.front(), Keyword::ordered_ ) )
	{
		NextLexem();
		return true;
	}

	return false;
}

fn SyntaxAnalyzer::ParseEnum( mut this ) : Enum
{
	if( !IsKeyword( it_.front(), Keyword::enum_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}

	var Enum mut enum_
	{
		.file_pos= it_.front().file_pos,
		.name= it_.front().text,
	};
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Colon )
	{
		NextLexem();
		enum_.underlaying_type= ParseComplexName();
	}

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}
		var Enum::Element mut element
		{
			.file_pos= it_.front().file_pos,
			.name= it_.front().text,
		};
		NextLexem();

		enum_.elements.push_back( move(element) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::BraceRight )
			{
				NextLexem();
				break;
			}
		}
		else if( it_.front().lexem_type == Lexem::Type::BraceRight )
		{
			NextLexem();
			break;
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	return move(enum_);
}

fn SyntaxAnalyzer::ParseTypeAlias( mut this ) : TypeAlias
{
	if( !IsKeyword( it_.front(), Keyword::type_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}

	var TypeAlias mut type_alias
	{
		.file_pos= it_.front().file_pos,
		.name= it_.front().text,
	};
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Assignment )
	{
		PushErrorMessage();
	}
	NextLexem();

	type_alias.type_name= ParseTypeName();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(type_alias);
}

fn SyntaxAnalyzer::ParseTemplate( mut this ) : SomeTemplate
{
	auto template_file_pos= it_.front().file_pos;

	if( !IsKeyword( it_.front(), Keyword::template_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	// Template args.
	if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	var ust::vector</TemplateParam/> mut params;
	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{
			NextLexem();
			break;
		}

		var TemplateParam mut param;
		if( IsKeyword( it_.front(), Keyword::type_ ) )
		{
			NextLexem();
		}
		else
		{
			param.t= ParseComplexName();
		}

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}

		var ComplexName mut param_name{ .file_pos= it_.front().file_pos, .start= it_.front().text };
		NextLexem();

		param.name= move(param_name);

		params.push_back( move(param) );

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{}
		else if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
				break;
			}
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	if( IsKeyword( it_.front(), Keyword::type_ ) )
	{
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}
		auto template_name= it_.front().text;
		auto type_alias_file_pos= it_.front().file_pos;
		NextLexem();

		auto mut is_short_form= false;
		var ust::vector</TypeTemplate::SignatureParam/> mut signature_params;
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
		{
			is_short_form= false;
			signature_params= ParseTemplateSignatureParams();
		}
		else
		{
			is_short_form= true;
		}

		if( it_.front().lexem_type != Lexem::Type::Assignment )
		{
			PushErrorMessage();
		}
		NextLexem();

		auto mut type_name= ParseTypeName();

		if( it_.front().lexem_type != Lexem::Type::Semicolon )
		{
			PushErrorMessage();
		}
		NextLexem();

		var TypeAlias mut type_alias
		{
			.file_pos= type_alias_file_pos,
			.name= "_", // Give special name for all template type aliases.
			.type_name= move(type_name),
		};
		var TypeTemplate mut type_template
		{
			.file_pos= template_file_pos,
			.name= template_name,
			.something( ust::shared_ptr_final</TypeAlias/>( move(type_alias) ) ),
			.params= move(params),
			.signature_params= move(signature_params),
			.is_short_form= is_short_form,
		};

		return ust::shared_ptr_final</TypeTemplate/>(move(type_template));
	}
	else if( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) )
	{
		auto is_struct= IsKeyword( it_.front(), Keyword::struct_ );
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}
		auto template_name= it_.front().text;
		auto class_file_pos= it_.front().file_pos;
		NextLexem();

		auto mut is_short_form= false;
		var ust::vector</TypeTemplate::SignatureParam/> mut signature_params;
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
		{
			is_short_form= false;
			signature_params= ParseTemplateSignatureParams();
		}
		else
		{
			is_short_form= true;
		}

		var Class mut class_
		{
			.file_pos= class_file_pos,
			.name= "_", // Give special name for all template classes
		};

		if( is_struct )
		{
			class_.kind_attribute= Class::KindAttribute::Struct;
		}
		else
		{
			class_.kind_attribute= ParseClassKindAttribute();
			class_.parents= ParseClassParentsList();
		}
		class_.keep_fields_order= ParseClassOrderedFlag();

		class_.class_elements= ParseClassBody();

		var TypeTemplate mut type_template
		{
			.file_pos= template_file_pos,
			.name= template_name,
			.something( ust::shared_ptr_final</Class/>( move(class_) ) ),
			.params= move(params),
			.signature_params= move(signature_params),
			.is_short_form= is_short_form,
		};

		return ust::shared_ptr_final</TypeTemplate/>(move(type_template));
	}
	else if( IsKeyword( it_.front(), Keyword::fn_ ) || IsKeyword( it_.front(), Keyword::op_ ) )
	{
		var FunctionTemplate mut function_template
		{
			.file_pos= template_file_pos,
			.params= move(params),
			.function( ParseFunction() ),
		};

		auto mut name= function_template.function.get_ref().name.back();
		function_template.name= move(name);

		return ust::shared_ptr_final</FunctionTemplate/>( move(function_template) );
	}
	else
	{
		PushErrorMessage();

		// Fill dummpy
		var TypeTemplate mut type_template
		{
			.something( ust::shared_ptr_final</TypeAlias/>( TypeAlias() ) ),
			.params= move(params),
			.is_short_form= false,
		};

		return ust::shared_ptr_final</TypeTemplate/>(move(type_template));
	}
}

fn SyntaxAnalyzer::ParseTemplateSignatureParams( mut this ) : ust::vector</TypeTemplate::SignatureParam/>
{
	var ust::vector</TypeTemplate::SignatureParam/> mut signature_params;

	if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{
			NextLexem();
			break;
		}

		var TypeTemplate::SignatureParam mut param;
		param.name= ParseExpression();

		if( it_.front().lexem_type == Lexem::Type::Assignment )
		{
			NextLexem();
			param.default_value= ParseExpression();
		}

		signature_params.push_back(move(param));

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{}
		else if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
				break;
			}
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	return move(signature_params);
}

fn SyntaxAnalyzer::ParseMacro( mut this )
{
	NextLexem(); // Skip "?macro"
	var Macro mut macro;

	// Macro name and context
	if( it_.front().lexem_type != Lexem::Type::MacroBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	macro.file_pos= it_.front().file_pos;
	macro.name= it_.front().text;
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Colon )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	var FilePos macro_context_file_pos= it_.front().file_pos;
	var ust::string8& macro_context_str= it_.front().text;
	NextLexem();

	var Macro::Context mut macro_context= Macro::Context::Expression;
		 if( macro_context_str == "expr"      ) { macro_context= Macro::Context::Expression; }
	else if( macro_context_str == "block"     ) { macro_context= Macro::Context::Block; }
	else if( macro_context_str == "class"     ) { macro_context= Macro::Context::Class; }
	else if( macro_context_str == "namespace" ) { macro_context= Macro::Context::Namespace; }
	else
	{
		PushMacroErrorMessage( macro_context_file_pos, "\"" + macro_context_str + "\" unknown macro context" );
	}

	// Match block
	macro.match_template_elements= ParseMacroMatchBlock();

	if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::RightArrow )
	{
		PushErrorMessage();
	}
	NextLexem();

	// Result block
	if( it_.front().lexem_type != Lexem::Type::MacroBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	macro.result_template_elements= ParseMacroResultBlock();

	if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	// Inset result macro.
	auto macros_copy= macros_;
	auto mut macros_lock= macros_copy.lock_mut();
	var MacrosByContextMap &mut macros_by_context= macros_lock.get_ref();

	if( macros_by_context.find( macro_context ).empty() )
	{
		macros_by_context.insert( macro_context, MacroMap() );
	}
	var MacroMap &mut macro_map= macros_by_context[ macro_context ];

	if( macro_map.find( macro.name ).empty() )
	{
		macro_map.insert( ust::string8(macro.name), ust::shared_ptr_final</Macro/>( move(macro) ) );
	}
	else
	{
		PushMacroErrorMessage( cast_imut(macro).file_pos, "\"" + macro.name + "\" macro redefinition." );
		move(macro);
	}
}

fn SyntaxAnalyzer::ParseMacroMatchBlock( mut this ) : ust::vector</Macro::MatchElement/>
{
	var ust::vector</Macro::MatchElement/> mut match_elements;

	var ust::unordered_map</ ust::string8, i32 /> mut elements_set; // TODO - use unordered_set
	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::MacroBracketRight )
	{
		if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft ||
			it_.front().lexem_type == Lexem::Type::MacroUniqueIdentifier )
		{
			PushErrorMessage();
			break;
		}
		if( it_.front().lexem_type == Lexem::Type::MacroIdentifier )
		{
			var FilePos match_element_file_pos= it_.front().file_pos;
			var Macro::MatchElement mut match_element{ .name= it_.front().text };
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Colon )
			{
				PushErrorMessage();
			}
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			var FilePos element_type_file_pos= it_.front().file_pos;
			var ust::string8& element_type= it_.front().text;
			NextLexem();

				 if( element_type == "ident" ) { match_element.kind= Macro::MatchElementKind::Identifier; }
			else if( element_type == "ty"    ) { match_element.kind= Macro::MatchElementKind::Typename; }
			else if( element_type == "expr"  ) { match_element.kind= Macro::MatchElementKind::Expression; }
			else if( element_type == "block" ) { match_element.kind= Macro::MatchElementKind::Block; }
			else if( element_type == "opt"   )
			{
				if( it_.front().lexem_type != Lexem::Type::MacroBracketLeft )
				{
					PushErrorMessage();
				}
				NextLexem();

				auto mut sub_elements= ParseMacroMatchBlock();

				if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
				{
					PushErrorMessage();
				}
				NextLexem();

				match_element.sub_elements= ust::shared_ptr_final_nullable</ ust::vector</Macro::MatchElement/> />( move(sub_elements) );
				match_element.kind= Macro::MatchElementKind::Optional;
			}
			else if( element_type == "rep" )
			{
				if( it_.front().lexem_type != Lexem::Type::MacroBracketLeft )
				{
					PushErrorMessage();
				}
				NextLexem();

				auto mut sub_elements= ParseMacroMatchBlock();

				if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
				{
					PushErrorMessage();
				}
				NextLexem();

				// Separator.
				if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft )
				{
					NextLexem();

					if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft ||
						it_.front().lexem_type == Lexem::Type::MacroBracketRight ||
						it_.front().lexem_type == Lexem::Type::MacroIdentifier ||
						it_.front().lexem_type == Lexem::Type::MacroUniqueIdentifier )
					{
						PushErrorMessage();
					}
					match_element.lexem= it_.front();
					NextLexem();

					if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
					{
						PushErrorMessage();
					}
					NextLexem();
				}
				else
				{
					match_element.lexem.lexem_type= Lexem::Type::EndOfFile;
				}

				match_element.sub_elements= ust::shared_ptr_final_nullable</ ust::vector</Macro::MatchElement/> />( move(sub_elements) );
				match_element.kind= Macro::MatchElementKind::Repeated;
			}
			else
			{
				PushMacroErrorMessage( element_type_file_pos, "\"" + element_type + "\" unknown macro variable type" );
			}

			// Check if name is ok.
			if( U1::IsKeyword( match_element.name ) )
			{
				PushMacroErrorMessage( match_element_file_pos, "Using keyword as macro element name." );
			}
			if( !elements_set.find( match_element.name ).empty() )
			{
				PushMacroErrorMessage( match_element_file_pos, "\"" + match_element.name + "\" macro parameter redefinition." );
			}
			elements_set.insert( match_element.name, 0 );

			match_elements.push_back( move(match_element) );
		}
		else
		{
			var Macro::MatchElement mut match_element{ .lexem= it_.front() };
			match_elements.push_back( move(match_element) );
			NextLexem();
		}
	}

	// Determine block check lexem kind, check for errors.
	for( auto mut i= 0s; i < match_elements.size(); ++i )
	{
		var Macro::MatchElementKind element_kind= match_elements[i].kind;
		if( !( element_kind == Macro::MatchElementKind::Optional || element_kind == Macro::MatchElementKind::Repeated ) )
		{
			continue;
		}

		var FilePos match_element_file_pos= it_.front().file_pos; // TODO - get REAL value.

		var ust::optional</Lexem/> mut start_lexem, mut end_lexem;

		if( !cast_imut(match_elements)[i].sub_elements.get_ref().empty() &&
			 cast_imut(match_elements)[i].sub_elements.get_ref().front().kind == Macro::MatchElementKind::Lexem )
		{
			start_lexem= match_elements[i].sub_elements.get_ref().front().lexem;
		}
		if( i + 1s < match_elements.size() && match_elements[i+1s].kind == Macro::MatchElementKind::Lexem )
		{
			end_lexem= match_elements[i+1s].lexem;
		}

		if( !start_lexem.empty() )
		{
			match_elements[i].block_check_lexem_kind= Macro::BlockCheckLexemKind::LexemAtBlockStart;
		}
		else if( !end_lexem.empty() )
		{
			match_elements[i].block_check_lexem_kind= Macro::BlockCheckLexemKind::LexemAfterBlockEnd;
		}
		else
		{
			PushMacroErrorMessage( match_element_file_pos, "Expected lexem at start or after \"" + match_elements[i].name + "\" element." );
		}

		if( element_kind == Macro::MatchElementKind::Optional )
		{
			if( !start_lexem.empty() && !end_lexem.empty() &&
				start_lexem.get_ref().lexem_type == end_lexem.get_ref().lexem_type &&
				start_lexem.get_ref().text == end_lexem.get_ref().text )
			{
				PushMacroErrorMessage( match_element_file_pos, "Start lexem of optional macro block must be different from first lexem after optional block." );
			}
		}
		if( element_kind == Macro::MatchElementKind::Repeated )
		{
			if( match_elements[i].lexem.lexem_type != Lexem::Type::EndOfFile ) // Non-empty separator
			{
				if( !end_lexem.empty() &&
					match_elements[i].lexem.lexem_type == end_lexem.get_ref().lexem_type &&
					match_elements[i].lexem.text == end_lexem.get_ref().text )
				{
					PushMacroErrorMessage( match_element_file_pos, "Separator lexem of repeated macro block must be different from first lexem after repeated block." );
				}
			}
			else // Empty separator
			{
				if( !start_lexem.empty() && !end_lexem.empty() &&
					start_lexem.get_ref().lexem_type == end_lexem.get_ref().lexem_type &&
					start_lexem.get_ref().text == end_lexem.get_ref().text )
				{
					PushMacroErrorMessage( match_element_file_pos, "Start lexem of repeated macro block without separator must be different from first lexem after repeated block." );
				}
			}
		}
	}

	return move(match_elements);
}

fn SyntaxAnalyzer::ParseMacroResultBlock( mut this ) : ust::vector</Macro::ResultElement/>
{
	var ust::vector</Macro::ResultElement/> mut result_elements;

	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::MacroBracketRight )
	{
		if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft )
		{
			PushErrorMessage();
			break;
		}
		else if( it_.front().lexem_type == Lexem::Type::MacroIdentifier )
		{
			var Macro::ResultElement mut result_element{ .name= it_.front().text };
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft )
			{
				NextLexem();

				auto mut sub_elements= ParseMacroResultBlock();

				if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
				{
					PushErrorMessage();
				}
				NextLexem();

				// Separator.
				if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft )
				{
					NextLexem();

					if( it_.front().lexem_type == Lexem::Type::MacroBracketLeft ||
						it_.front().lexem_type == Lexem::Type::MacroBracketRight ||
						it_.front().lexem_type == Lexem::Type::MacroIdentifier ||
						it_.front().lexem_type == Lexem::Type::MacroUniqueIdentifier )
					{
						PushErrorMessage();
					}
					result_element.lexem= it_.front();
					NextLexem();

					if( it_.front().lexem_type != Lexem::Type::MacroBracketRight )
					{
						PushErrorMessage();
					}
					NextLexem();
				}
				else
				{
					result_element.lexem.lexem_type= Lexem::Type::EndOfFile;
				}

				result_element.sub_elements= ust::shared_ptr_final_nullable</ ust::vector</Macro::ResultElement/> />( move(sub_elements) );
				result_element.kind= Macro::ResultElementKind::VariableElementWithMacroBlock;
			}
			else
			{
				result_element.kind= Macro::ResultElementKind::VariableElement;
			}

			result_elements.push_back( move(result_element) );
		}
		else
		{
			var Macro::ResultElement mut result_element{ .lexem= it_.front() };
			result_elements.push_back( move(result_element) );
			NextLexem();
		}
	}

	return move(result_elements);
}

fn SyntaxAnalyzer::FetchMacro( this, ust::string8& name, Macro::Context context ) : ust::shared_ptr_final_nullable</Macro/>
{
	auto macros_lock= macros_.lock_imut();
	var MacrosByContextMap& macros_by_context= macros_lock.get_ref();
	if_var( &macro_map : macros_by_context.find( context ) )
	{
		if_var( &macro : macro_map.find( name ) )
		{
			return macro;
		}
	}

	return ust::shared_ptr_final_nullable</Macro/>();
}

fn SyntaxAnalyzer::ExpandMacroImpl( mut this, Macro& macro ) : Lexems
{
	var FilePos expansion_file_pos= it_.front().file_pos;
	NextLexem(); // Skip macro name itself.

	auto macro_variables_map_opt= MatchMacroBlock( macro.match_template_elements );
	if( macro_variables_map_opt.empty() )
	{
		return Lexems();
	}

	var MacroVariablesMapsStack mut macro_variables_maps_stack;
	macro_variables_maps_stack.push_back( ust::to_non_nullable(macro_variables_map_opt) );

	var UniqueMacroIdentifiersMap mut unique_macro_indentifiers_map;

	auto mut lexems= ExpandMacroBlock( macro.result_template_elements, macro_variables_maps_stack, unique_macro_indentifiers_map, expansion_file_pos );

	var Lexem end_of_file_lexem{ .lexem_type= Lexem::Type::EndOfFile };
	lexems.push_back( end_of_file_lexem );
	lexems.push_back( end_of_file_lexem );

	return move(lexems);
}

fn SyntaxAnalyzer::MatchMacroBlock( mut this, ust::vector</Macro::MatchElement/>& match_elements ) : ust::shared_ptr_final_nullable</MacroVariablesMap/>
{
	var MacroVariablesMap mut macro_variables_map;
	for( auto mut i= 0s; i < match_elements.size(); ++i )
	{
		auto& match_element= match_elements[i];

		if( match_element.kind == Macro::MatchElementKind::Lexem )
		{
			if( !( it_.front().lexem_type == match_element.lexem.lexem_type && it_.front().text == match_element.lexem.text ) )
			{
				PushErrorMessage();
				return ust::shared_ptr_final_nullable</MacroVariablesMap/>();
			}
			NextLexem();
			continue;
		}

		var ParsedMacroElement mut element{ .kind= match_element.kind };
		auto range_before= it_;

			 if( match_element.kind == Macro::MatchElementKind::Identifier )
		{
			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			NextLexem();
		}
		else if( match_element.kind == Macro::MatchElementKind::Typename )
		{
			ParseTypeName();
		}
		else if( match_element.kind == Macro::MatchElementKind::Expression )
		{
			ParseExpression();
		}
		else if( match_element.kind == Macro::MatchElementKind::Block )
		{
			ParseBlock();
		}
		else if( match_element.kind == Macro::MatchElementKind::Optional )
		{
			var bool mut has_value= true;

			var ust::vector</Macro::MatchElement/>& sub_elements= match_element.sub_elements.get_ref();
			if( match_element.block_check_lexem_kind == Macro::BlockCheckLexemKind::LexemAfterBlockEnd &&
				i + 1s < match_elements.size() )
			{
				var Lexem& terminator_lexem= match_elements[i+1s].lexem;
				has_value= !( it_.front().lexem_type == terminator_lexem.lexem_type && it_.front().text == terminator_lexem.text );
			}
			else if( match_element.block_check_lexem_kind == Macro::BlockCheckLexemKind::LexemAtBlockStart &&
				!sub_elements.empty() )
			{
				var Lexem& check_lexem= sub_elements.front().lexem;
				has_value= it_.front().lexem_type == check_lexem.lexem_type && it_.front().text == check_lexem.text;
			}
			else{ /* case of previous error*/ }

			if( has_value )
			{
				auto sub_variables_map_opt= MatchMacroBlock( sub_elements );
				if( sub_variables_map_opt.empty() )
				{
					return ust::shared_ptr_final_nullable</MacroVariablesMap/>();
				}
				element.sub_elements.push_back( ust::to_non_nullable(sub_variables_map_opt) );
			}
		}
		else if( match_element.kind == Macro::MatchElementKind::Repeated )
		{
			var ust::vector</Macro::MatchElement/>& sub_elements= match_element.sub_elements.get_ref();
			if( match_element.block_check_lexem_kind == Macro::BlockCheckLexemKind::LexemAfterBlockEnd &&
				i + 1s < match_elements.size() )
			{
				var Lexem& terminator_lexem= match_elements[i+1s].lexem;
				while( NotEndOfFile() &&
					!( it_.front().lexem_type == terminator_lexem.lexem_type && it_.front().text == terminator_lexem.text ) )
				{
					auto sub_variables_map_opt= MatchMacroBlock( sub_elements );
					if( sub_variables_map_opt.empty() )
					{
						return ust::shared_ptr_final_nullable</MacroVariablesMap/>();
					}
					element.sub_elements.push_back( ust::to_non_nullable(sub_variables_map_opt) );

					// Process separator
					if( match_element.lexem.lexem_type != Lexem::Type::EndOfFile )
					{
						if( it_.front().lexem_type == match_element.lexem.lexem_type && it_.front().text == match_element.lexem.text )
						{
							NextLexem(); // Separator detected
							if( it_.front().lexem_type == terminator_lexem.lexem_type && it_.front().text == terminator_lexem.text )
							{
								// Disable end lexem after separator.
								PushErrorMessage();
								return ust::shared_ptr_final_nullable</MacroVariablesMap/>();
							}
						}
						else
						{
							break; // no separator - finish sequence
						}
					}
				}
			}
			else if( match_element.block_check_lexem_kind == Macro::BlockCheckLexemKind::LexemAtBlockStart &&
				!sub_elements.empty() )
			{
				var Lexem& check_lexem= sub_elements.front().lexem;
				while( NotEndOfFile() &&
					it_.front().lexem_type == check_lexem.lexem_type && it_.front().text == check_lexem.text )
				{
					auto sub_variables_map_opt= MatchMacroBlock( sub_elements );
					if( sub_variables_map_opt.empty() )
					{
						return ust::shared_ptr_final_nullable</MacroVariablesMap/>();
					}
					element.sub_elements.push_back( ust::to_non_nullable(sub_variables_map_opt) );

					// Process separator
					if( match_element.lexem.lexem_type != Lexem::Type::EndOfFile )
					{
						if( it_.front().lexem_type == match_element.lexem.lexem_type && it_.front().text == match_element.lexem.text )
						{
							NextLexem(); // Separator detected
							// After separator must be start lexem of block.
							if( !( it_.front().lexem_type == check_lexem.lexem_type && it_.front().text == check_lexem.text ) )
							{
								PushErrorMessage();
								return ust::shared_ptr_final_nullable</MacroVariablesMap/>();
							}
						}
						else
						{
							break; // no separator - finish sequence
						}
					}
				}
			}
			else{ /* case of some previous error */ }
		}
		else{ halt; }

		auto range_after= it_;
		auto range_size= range_before.size() - range_after.size();
		foreach( &lexem : range_before.subrange( 0s, range_size ) )
		{
			element.lexems.push_back( lexem );
		}

		// Redefinition checked before, while parsing macro itself.
		macro_variables_map.insert( match_element.name, move(element) );
	}

	return ust::shared_ptr_final_nullable</MacroVariablesMap/>( move(macro_variables_map) );
}

fn SyntaxAnalyzer::ExpandMacroBlock(
	mut this,
	ust::vector</Macro::ResultElement/>& result_elements,
	MacroVariablesMapsStack &mut macro_variables_maps_stack,
	UniqueMacroIdentifiersMap &mut unique_macro_indentifiers_map,
	FilePos& expansion_file_pos ) : Lexems
{
	var Lexems mut lexems_expanded;
	foreach( &result_element : result_elements )
	{
		if( result_element.kind == Macro::ResultElementKind::Lexem )
		{
			if( result_element.lexem.lexem_type == Lexem::Type::MacroUniqueIdentifier )
			{
				if( unique_macro_indentifiers_map.find( result_element.lexem.text ).empty() )
				{
					// TODO - maybe also add something to distinct macro identifiers from different macro expansions?
					var ust::string8 mut name= "_macro_ident_";
					name+= result_element.lexem.text;
					name+= "_";
					name+= ust::to_string8(unique_macro_indentifiers_map.size());
					unique_macro_indentifiers_map.insert( result_element.lexem.text, move(name) );
				}

				var Lexem mut result_lexem
				{
					.lexem_type= Lexem::Type::Identifier,
					.text= unique_macro_indentifiers_map[ result_element.lexem.text ],
				};
				lexems_expanded.push_back( move(result_lexem) );
			}
			else
			{
				lexems_expanded.push_back( result_element.lexem );
			}
		}
		else if( result_element.kind == Macro::ResultElementKind::VariableElement )
		{
			auto variable_opt= FetchMacroVariable( macro_variables_maps_stack, result_element.name );
			if( variable_opt.empty() )
			{
				PushMacroErrorMessage( expansion_file_pos, "\"" + result_element.name + "\" - not found" );
				continue;
			}

			foreach( &lexem : variable_opt.get_ref().lexems )
			{
				lexems_expanded.push_back( lexem );
			}
		}
		else if( result_element.kind == Macro::ResultElementKind::VariableElementWithMacroBlock )
		{
			auto variable_opt= FetchMacroVariable( macro_variables_maps_stack, result_element.name );
			if( variable_opt.empty() )
			{
				PushMacroErrorMessage( expansion_file_pos, "\"" + result_element.name + "\" - not found" );
				continue;
			}

			var ParsedMacroElement& variable= variable_opt.get_ref();
			if( !( variable.kind == Macro::MatchElementKind::Optional || variable.kind == Macro::MatchElementKind::Repeated ) )
			{
				PushMacroErrorMessage( expansion_file_pos, "Expected optional or repated" );
				continue;
			}

			foreach( &variable_element : variable.sub_elements )
			{
				macro_variables_maps_stack.push_back( variable_element );

				auto mut internal_lexems_expanded= ExpandMacroBlock( result_element.sub_elements.get_ref(), macro_variables_maps_stack, unique_macro_indentifiers_map, expansion_file_pos );
				VectorAppend( lexems_expanded, move(internal_lexems_expanded) );

				macro_variables_maps_stack.drop_back();

				// Separator.
				if( result_element.lexem.lexem_type != Lexem::Type::EndOfFile &&
					ust::ref_to_int(variable_element) != ust::ref_to_int(variable.sub_elements.back()) )
				{
					lexems_expanded.push_back( result_element.lexem );
				}
			}
		}
		else { halt; }
	}

	return move(lexems_expanded);
}

fn SyntaxAnalyzer::FetchMacroVariable( MacroVariablesMapsStack& macro_variables_maps_stack, ust::string8& variable_name ) : ust::optional</ParsedMacroElement/>
{
	// Search variable from top to bottom.
	for( auto mut i= 0s; i < macro_variables_maps_stack.size(); ++i )
	{
		auto j= macro_variables_maps_stack.size() - i - 1s;
		var MacroVariablesMap& macro_variables_map= macro_variables_maps_stack[j].get_ref();
		auto ref= macro_variables_map.find( variable_name );
		if( !ref.empty() )
		{
			return ref.get_ref();
		}
	}

	return ust::optional</ParsedMacroElement/>();
}

fn SyntaxAnalyzer::NotEndOfFile( this ) : bool
{
	return it_.size() >= 2s;
}

fn SyntaxAnalyzer::NextLexem( mut this )
{
	if( NotEndOfFile() )
	{
		it_.drop_front();
	}
}

fn SyntaxAnalyzer::PushErrorMessage( mut this )
{
	if( error_messages_.empty() || FilePos(error_messages_.back().file_pos) != it_.front().file_pos )
	{
		var SyntaxErrorMessage mut error_message
		{
			.file_pos= it_.front().file_pos,
			.text= "Syntax error - unexpected lexem: \"" + it_.front().text + "\""
		};
		error_messages_.push_back( move(error_message) );
	}
}

fn SyntaxAnalyzer::PushMacroErrorMessage( mut this, FilePos& file_pos, ust::string8 mut text )
{
	var SyntaxErrorMessage mut error_message{ .file_pos= file_pos, .text= move(text) };
	error_messages_.push_back( move(error_message) );
}

fn SyntaxAnalysis( Lexems& lexems, MacrosByContextMap mut macros ) : SyntaxAnalysisResult
{
	var SyntaxAnalyzer mut analyzer( lexems, MacrosPtr( move(macros) ) );
	return analyzer.DoAnalyzis();
}

fn ParseImports( Lexems& lexems ) : ImportsList
{
	var SyntaxAnalyzer mut analyzer(lexems, MacrosPtr( MacrosByContextMap() ) );
	return analyzer.ParseImports();
}

} // namespace Synt

} // namespace U1
