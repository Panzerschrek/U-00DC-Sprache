import "keywords.uh"
import "syntax_analyzer.uh"

namespace U
{

namespace Synt
{

fn IsKeyword( Lexem& l, Keyword k ) : bool
{
	return l.lexem_type == Lexem::Type::Identifier && l.text == KeywordToString(k);
}


fn GetBinaryOperatorPriority( BinaryOperatorType binary_operator ) : i32
{
	// If this changed, same code in "syntax_analyzer.cpp" must be changed too!
	if( binary_operator == BinaryOperatorType::Div ||
		binary_operator == BinaryOperatorType::Mul ||
		binary_operator == BinaryOperatorType::Rem )
	{
		return 9;
	}
	if( binary_operator == BinaryOperatorType::Add ||
		binary_operator == BinaryOperatorType::Sub )
	{
		return 8;
	}
	if( binary_operator == BinaryOperatorType::ShiftLeft ||
		binary_operator == BinaryOperatorType::ShiftRight )
	{
		return 7;
	}
	if( binary_operator == BinaryOperatorType::Equal ||
		binary_operator == BinaryOperatorType::NotEqual ||
		binary_operator == BinaryOperatorType::Less ||
		binary_operator == BinaryOperatorType::LessEqual ||
		binary_operator == BinaryOperatorType::Greater ||
		binary_operator == BinaryOperatorType::GreaterEqual )
	{
		return 6;
	}
	if( binary_operator == BinaryOperatorType::And )
	{
		return 5;
	}
	if( binary_operator == BinaryOperatorType::Or )
	{
		return 4;
	}
	if( binary_operator == BinaryOperatorType::Xor )
	{
		return 3;
	}
	if( binary_operator == BinaryOperatorType::LazyLogicalAnd )
	{
		return 2;
	}
	if( binary_operator == BinaryOperatorType::LazyLogicalOr )
	{
		return 1;
	}

	halt;
}

fn IsBinaryOperator( Lexem& lexem ) : bool
{
	return
		lexem.lexem_type == Lexem::Type::Plus ||
		lexem.lexem_type == Lexem::Type::Minus ||
		lexem.lexem_type == Lexem::Type::Star ||
		lexem.lexem_type == Lexem::Type::Slash ||
		lexem.lexem_type == Lexem::Type::Percent ||

		lexem.lexem_type == Lexem::Type::CompareEqual ||
		lexem.lexem_type == Lexem::Type::CompareNotEqual ||
		lexem.lexem_type == Lexem::Type::CompareLess ||
		lexem.lexem_type == Lexem::Type::CompareLessOrEqual ||
		lexem.lexem_type == Lexem::Type::CompareGreater ||
		lexem.lexem_type == Lexem::Type::CompareGreaterOrEqual ||

		lexem.lexem_type == Lexem::Type::And ||
		lexem.lexem_type == Lexem::Type::Or ||
		lexem.lexem_type == Lexem::Type::Xor ||

		lexem.lexem_type == Lexem::Type::ShiftLeft  ||
		lexem.lexem_type == Lexem::Type::ShiftRight ||

		lexem.lexem_type == Lexem::Type::Conjunction ||
		lexem.lexem_type == Lexem::Type::Disjunction;
}

fn LexemToBinaryOperator( Lexem& lexem ) : BinaryOperatorType
{
	if( lexem.lexem_type == Lexem::Type::Plus	){ return BinaryOperatorType::Add; }
	if( lexem.lexem_type == Lexem::Type::Minus	){ return BinaryOperatorType::Sub; }
	if( lexem.lexem_type == Lexem::Type::Star	){ return BinaryOperatorType::Mul; }
	if( lexem.lexem_type == Lexem::Type::Slash	){ return BinaryOperatorType::Div; }
	if( lexem.lexem_type == Lexem::Type::Percent){ return BinaryOperatorType::Rem; }

	if( lexem.lexem_type == Lexem::Type::CompareEqual			){ return BinaryOperatorType::Equal			; }
	if( lexem.lexem_type == Lexem::Type::CompareNotEqual		){ return BinaryOperatorType::NotEqual		; }
	if( lexem.lexem_type == Lexem::Type::CompareLess			){ return BinaryOperatorType::Less			; }
	if( lexem.lexem_type == Lexem::Type::CompareLessOrEqual		){ return BinaryOperatorType::LessEqual		; }
	if( lexem.lexem_type == Lexem::Type::CompareGreater			){ return BinaryOperatorType::Greater		; }
	if( lexem.lexem_type == Lexem::Type::CompareGreaterOrEqual	){ return BinaryOperatorType::GreaterEqual	; }

	if( lexem.lexem_type == Lexem::Type::And ){ return BinaryOperatorType::And; }
	if( lexem.lexem_type == Lexem::Type::Or  ){ return BinaryOperatorType::Or ; }
	if( lexem.lexem_type == Lexem::Type::Xor ){ return BinaryOperatorType::Xor; }

	if( lexem.lexem_type == Lexem::Type::ShiftLeft  ){ return BinaryOperatorType::ShiftLeft ; }
	if( lexem.lexem_type == Lexem::Type::ShiftRight ){ return BinaryOperatorType::ShiftRight; }

	if( lexem.lexem_type == Lexem::Type::Conjunction ){ return BinaryOperatorType::LazyLogicalAnd; }
	if( lexem.lexem_type == Lexem::Type::Disjunction ){ return BinaryOperatorType::LazyLogicalOr ; }

	halt;
}

fn GetAdditiveAssignmentOperator( Lexem& lexem ) : ust::optional</BinaryOperatorType/>
{
	auto t= lexem.lexem_type;

	if( t == Lexem::Type::AssignAdd ){ return BinaryOperatorType::Add; }
	if( t == Lexem::Type::AssignSub ){ return BinaryOperatorType::Sub; }
	if( t == Lexem::Type::AssignMul ){ return BinaryOperatorType::Mul; }
	if( t == Lexem::Type::AssignDiv ){ return BinaryOperatorType::Div; }
	if( t == Lexem::Type::AssignAnd ){ return BinaryOperatorType::And; }
	if( t == Lexem::Type::AssignRem ){ return BinaryOperatorType::Rem; }
	if( t == Lexem::Type::AssignOr  ){ return BinaryOperatorType::Or ; }
	if( t == Lexem::Type::AssignXor ){ return BinaryOperatorType::Xor; }
	if( t == Lexem::Type::AssignShiftLeft  ){ return BinaryOperatorType::ShiftLeft ; }
	if( t == Lexem::Type::AssignShiftRight ){ return BinaryOperatorType::ShiftRight; }

	return ust::optional</BinaryOperatorType/>();
}

fn GetMostRightIncompleteBinaryOperatorInTree( BinaryOperator &mut o ) : BinaryOperator &mut
{
	if( !o.r.get_ref().get</EmptyVariant/>().empty() )
	{
		return o;
	}

	// Should be binary operator.
	return GetMostRightIncompleteBinaryOperatorInTree( o.r.get_ref().get</BinaryOperator/>().get_ref() );
}

fn GetDeepestRightBinaryOperatorComponentWithNonLessPriority( BinaryOperator &'x mut o, BinaryOperatorType cur_op_type ) : BinaryOperator &mut
{
	if_var( &mut right_as_binary_operator : o.r.get_ref().get</BinaryOperator/>() )
	{
		if( GetBinaryOperatorPriority( cur_op_type ) > GetBinaryOperatorPriority( right_as_binary_operator.operator ) )
		{
			return GetDeepestRightBinaryOperatorComponentWithNonLessPriority( right_as_binary_operator, cur_op_type );
		}
	}
	return o;
}

fn GetMostRightExpressionInPrefixOperatorsChain( Expression &mut e ) : Expression &mut
{
	if_var( &mut unary_plus : e.get</UnaryPlus/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( unary_plus.expr.get_ref() );
	}
	if_var( &mut unary_minus : e.get</UnaryMinus/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( unary_minus.expr.get_ref() );
	}
	if_var( &mut logical_not : e.get</LogicalNot/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( logical_not.expr.get_ref() );
	}
	if_var( &mut bitwise_not : e.get</BitwiseNot/>() )
	{
		return GetMostRightExpressionInPrefixOperatorsChain( bitwise_not.expr.get_ref() );
	}
	return e;
}

class SyntaxAnalyzer
{
public:
	fn constructor( this'a', Lexems&'b lexems ) ' a <- b ';

	fn DoAnalyzis( mut this ) : SyntaxAnalysisResult;

private:
	fn ParseNamespaceBody( mut this, Lexem::Type end_lexem ) : NamespaceElements;
	fn ParseNamespace( mut this ) : Namespace;

	fn ParseTemplateParameters( mut this ) : TemplateParameters;
	fn ParseComplexName( mut this ) : ComplexName;
	fn ParseExpression( mut this ) : Expression;
	fn ParseTypeName( mut this ) : TypeName;
	fn ParseArrayType( mut this ) : ArrayType;
	fn ParseFunction( mut this ) : Function;

	fn ParseInitializer( mut this, bool parse_expression_initializer  ) : Initializer;
	fn ParseVariableInitializer( mut this ) : Initializer;

	fn ParseBlock( mut this ) : Block;
	fn ParseVariablesDeclaration( mut this ) : VariablesDeclaration;
	fn ParseAutoVariableDeclaration( mut this ) : AutoVariableDeclaration;
	fn ParseReturnOperator( mut this ) : ReturnOperator;
	fn ParseIfOperator( mut this ) : IfOperator;
	fn ParseWhileOperator( mut this ) : WhileOperator;
	fn ParseBreakOperator( mut this ) : BreakOperator;
	fn ParseContinueOperator( mut this ) : ContinueOperator;
	fn ParseStaticAssert( mut this ) : StaticAssert;
	fn ParseHalt( mut this ) : BlockElement;

	fn ParseClass( mut this ) : Class;
	fn ParseClassBody( mut this ) : ClassElements;
	fn ParseEnum( mut this ) : Enum;
	fn ParseTypeAlias( mut this ) : TypeAlias;
	fn ParseClassTemplate( mut this ) : ClassTemplate;

	fn NotEndOfFile( this ) : bool;
	fn NextLexem( mut this );
	fn PushErrorMessage( mut this );

private:
	ust::array_view_imut</Lexem/> it_;
	SyntaxErrorMessages error_messages_;
}

fn SyntaxAnalyzer::constructor( this'a', Lexems&'b lexems ) ' a <- b '
	( it_= lexems.range() )
{
}

fn SyntaxAnalyzer::DoAnalyzis( mut this ) : SyntaxAnalysisResult
{
	var SyntaxAnalysisResult mut res;

	res.program_elements= ParseNamespaceBody( Lexem::Type::EndOfFile );

	res.error_messages= take(error_messages_);
	return move(res);
}

fn SyntaxAnalyzer::ParseNamespaceBody( mut this, Lexem::Type end_lexem ) : NamespaceElements
{
	var NamespaceElements mut namespace_elements;
	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == end_lexem )
		{
			break;
		}
		else if( IsKeyword( it_.front(), Keyword::fn_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Function/>( ParseFunction() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Class/>( ParseClass() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::enum_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Enum/>( ParseEnum() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::type_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</TypeAlias/>( ParseTypeAlias() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::template_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</ClassTemplate/>( ParseClassTemplate() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::namespace_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</Namespace/>( ParseNamespace() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::var_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</VariablesDeclaration/>( ParseVariablesDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::auto_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</AutoVariableDeclaration/>( ParseAutoVariableDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::static_assert_ ) )
		{
			namespace_elements.push_back( ust::shared_ptr_final</StaticAssert/>( ParseStaticAssert() ) );
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	return move(namespace_elements);
}

fn SyntaxAnalyzer::ParseNamespace( mut this ) : Namespace
{
	if( !IsKeyword( it_.front(), Keyword::namespace_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	var Namespace mut namespace_
	{
		.file_pos= it_.front().file_pos,
		.name= it_.front().text,
	};
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	namespace_.elements= ParseNamespaceBody( Lexem::Type::BraceRight );

	if( it_.front().lexem_type != Lexem::Type::BraceRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	return namespace_;
}

fn SyntaxAnalyzer::ParseTemplateParameters( mut this ) : TemplateParameters
{
	var TemplateParameters mut template_parameters;

	if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{
			NextLexem();
			break;
		}

		template_parameters.push_back( ParseExpression() );

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{}
		else if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
			}
		}
	}

	return move(template_parameters);
}

fn SyntaxAnalyzer::ParseComplexName( mut this ) : ComplexName
{
	var ComplexName mut complex_name{ .file_pos= it_.front().file_pos };
	if( it_.front().lexem_type == Lexem::Type::Identifier )
	{
		complex_name.name= it_.front().text;
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
		{
			complex_name.tail.push_back( ust::box</ TemplateParameters />( ParseTemplateParameters() ) );
		}
	}
	else if( it_.front().lexem_type == Lexem::Type::Scope )
	{}
	else
	{
		PushErrorMessage();
	}

	while( NotEndOfFile() && it_.front().lexem_type == Lexem::Type::Scope )
	{
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}
		complex_name.tail.push_back( it_.front().text );
		NextLexem();

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketLeft )
		{
			complex_name.tail.push_back( ust::box</ TemplateParameters />( ParseTemplateParameters() ) );
		}
	}

	return move(complex_name);
}

fn SyntaxAnalyzer::ParseExpression( mut this ) : Expression
{
	var Expression mut root;

	while( NotEndOfFile() )
	{
		var Expression mut current_node;
		var Expression mut prefix_operator;

		// Prefix operators.
		while( NotEndOfFile() )
		{
			if( it_.front().lexem_type == Lexem::Type::Plus )
			{
				var UnaryPlus mut unary_plus{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(unary_plus);
			}
			else if( it_.front().lexem_type == Lexem::Type::Minus )
			{
				var UnaryMinus mut unary_minus{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(unary_minus);
			}
			else if( it_.front().lexem_type == Lexem::Type::Not )
			{
				var LogicalNot mut logical_not{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(logical_not);
			}
			else if( it_.front().lexem_type == Lexem::Type::Tilda )
			{
				var BitwiseNot mut bitwise_not{ .file_pos= it_.front().file_pos, .expr(Expression()) };
				NextLexem();
				GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= move(bitwise_not);
			}
			else
			{
				break;
			}
		}

		// Main component.
		if( it_.front().lexem_type == Lexem::Type::Number )
		{
			var NumericConstant mut numeric_constant{ .file_pos= it_.front().file_pos };
			halt if( it_.front().text.size() < typeinfo</NumberLexemData/>.size_of );

			unsafe
			{
				ust::memory_copy( numeric_constant.num, it_.front().text.front(), typeinfo</NumberLexemData/>.size_of );
			}

			NextLexem();

			current_node= move(numeric_constant);
		}
		else if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
		{
			current_node= ust::box</ ArrayType />( ParseArrayType() );
		}
		else if( IsKeyword( it_.front(), Keyword::false_ ) )
		{
			var BooleanConstant mut boolean_constant{ .file_pos= it_.front().file_pos, .value= false };
			NextLexem();
			current_node= move(boolean_constant);
		}
		else if( IsKeyword( it_.front(), Keyword::true_  ) )
		{
			var BooleanConstant mut boolean_constant{ .file_pos= it_.front().file_pos, .value= true  };
			NextLexem();
			current_node= move(boolean_constant);
		}
		else if( it_.front().lexem_type == Lexem::Type::Identifier || it_.front().lexem_type == Lexem::Type::Scope )
		{
			current_node= ParseComplexName();
		}
		else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
		{
			var BracketExpression mut bracket_expression{ .file_pos= it_.front().file_pos, .expr(Expression()) };
			NextLexem();

			bracket_expression.expr.get_ref()= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
			NextLexem();

			current_node= move(bracket_expression);
		}
		else
		{
			break;
		}

		// Postfix operators.
		while( NotEndOfFile() )
		{
			if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
			{
				var IndexationOperator mut indexation_operator
				{
					.file_pos= it_.front().file_pos,
					.value(take(current_node)),
					.index(Expression())
				};
				NextLexem();

				indexation_operator.index.get_ref()= ParseExpression();

				if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
				{
					PushErrorMessage();
				}
				NextLexem();

				current_node= move(indexation_operator);
			}
			else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
			{
				var CallOperator mut call_operator
				{
					.file_pos= it_.front().file_pos,
					.value(take(current_node))
				};
				NextLexem();

				while( NotEndOfFile() )
				{
					if( it_.front().lexem_type == Lexem::Type::BracketRight )
					{
						NextLexem();
						break;
					}

					call_operator.args.push_back( ust::shared_ptr_final</Expression/>( ParseExpression() ) );

					if( it_.front().lexem_type== Lexem::Type::Comma )
					{
						NextLexem();
						if( it_.front().lexem_type== Lexem::Type::BracketRight )
						{
							PushErrorMessage();
						}
					}
					else if( it_.front().lexem_type == Lexem::Type::BracketRight )
					{
						NextLexem();
						break;
					}
				}

				current_node= move(call_operator);
			}
			else if( it_.front().lexem_type == Lexem::Type::Dot )
			{
				var MemberAccessOperator mut member_access_operator
				{
					.file_pos =it_.front().file_pos,
					.value(take(current_node))
				};
				NextLexem();

				if( it_.front().lexem_type != Lexem::Type::Identifier )
				{
					PushErrorMessage();
				}
				member_access_operator.member_name= it_.front().text;
				NextLexem();

				current_node= move(member_access_operator);
			}
			else
			{
				break;
			}
		}

		if( prefix_operator.get</EmptyVariant/>().empty() )
		{
			GetMostRightExpressionInPrefixOperatorsChain( prefix_operator )= take(current_node);
			current_node= take(prefix_operator);
		}

		var bool is_binary_operator= IsBinaryOperator( it_.front() );

		if( !root.get</EmptyVariant/>().empty() )
		{
			root= move(current_node);
		}
		else
		{
			// Place to existent tree last component.

			// TODO - replace this call with loop.
			auto &mut most_right_with_null= GetMostRightIncompleteBinaryOperatorInTree( root.get</BinaryOperator/>().get_ref() );
			most_right_with_null.r.get_ref()= move(current_node);
		}

		if( is_binary_operator )
		{
			var BinaryOperator mut binary_operator
			{
				.file_pos= it_.front().file_pos,
				.operator=LexemToBinaryOperator( it_.front() ),
				.l( Expression() ),
				.r( Expression() )
			};
			NextLexem();

			if( !root.get</BinaryOperator/>().empty() )
			{
				if( GetBinaryOperatorPriority( binary_operator.operator ) <= GetBinaryOperatorPriority( root.get</BinaryOperator/>().get_ref().operator ) )
				{
					binary_operator.l.get_ref()= take(root);
					root= move(binary_operator);
				}
				else
				{
					auto &mut dst= GetDeepestRightBinaryOperatorComponentWithNonLessPriority( root.get</BinaryOperator/>().get_ref(), binary_operator.operator );
					binary_operator.l.get_ref()= take(dst.r.get_ref());
					dst.r.get_ref()= move(binary_operator);
				}
			}
			else
			{
				binary_operator.l.get_ref()= take(root);
				root= move(binary_operator);
			}
		}
		else
		{
			break;
		}
	}

	return move(root);
}

fn SyntaxAnalyzer::ParseTypeName( mut this ) : TypeName
{
	if( it_.front().lexem_type == Lexem::Type::Identifier || it_.front().lexem_type == Lexem::Type::Scope )
	{
		return ParseComplexName();
	}
	else if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
	{
		return ust::box</ArrayType/>( ParseArrayType() );
	}
	else
	{
		PushErrorMessage();
		return TypeName();
	}
}

fn SyntaxAnalyzer::ParseArrayType( mut this ) : ArrayType
{
	if( it_.front().lexem_type != Lexem::Type::SquareBracketLeft )
	{
		PushErrorMessage();
	}
	var ArrayType mut array_type{ .file_pos= it_.front().file_pos };
	NextLexem();

	array_type.element_type= ParseTypeName();

	if( it_.front().lexem_type != Lexem::Type::Comma )
	{
		PushErrorMessage();
	}
	NextLexem();

	array_type.element_count= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(array_type);
}

fn SyntaxAnalyzer::ParseFunction( mut this ) : Function
{
	var Function mut res{ .file_pos= it_.front().file_pos };

	NextLexem();

	while( true )
	{
		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
			return Function();
		}
		res.name.push_back( it_.front().text );
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Scope )
		{
			break;
		}
		NextLexem();
	}

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
		return Function();
	}
	NextLexem();

	if( IsKeyword( it_.front(), Keyword::this_ ) )
	{
		var FunctionType::Arg mut this_arg
		{
			.file_pos= it_.front().file_pos,
			.name= it_.front().text
		};
		NextLexem();
		res.function_type.args.push_back( move(this_arg) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			// Disallov constructions, like "fn f( mut this, ){}"
			if( it_.front().lexem_type == Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
		}
	}
	else if( IsKeyword( it_.front(), Keyword::mut_ ) || IsKeyword( it_.front(), Keyword::imut_ ) )
	{
		auto mutability_modifier= select( IsKeyword( it_.front(), Keyword::mut_ ) ? MutabilityModifier::Mutable : MutabilityModifier::Immutable );
		NextLexem();

		if( !IsKeyword( it_.front(), Keyword::this_ ) )
		{
			PushErrorMessage();
		}

		var FunctionType::Arg mut this_arg
		{
			.file_pos= it_.front().file_pos,
			.name= it_.front().text,
			.mutability_modifier= mutability_modifier,
		};
		NextLexem();
		res.function_type.args.push_back( move(this_arg) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			// Disallov constructions, like "fn f( mut this, ){}"
			if( it_.front().lexem_type == Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}
		}
	}

	// If method is constructor or destructor and "this" not explicitly specified, add it.
	// It's easier add "this" here, than dealing with implicit "this" in CodeBuilder.
	if( ( res.name.back() == KeywordToString( Keyword::constructor_ ) || res.name.back() == KeywordToString( Keyword::destructor_ ) ) &&
		res.function_type.args.empty() )
	{
		var FunctionType::Arg mut this_arg
		{
			.file_pos= it_.front().file_pos,
			.name= KeywordToString( Keyword::this_ ),
			.mutability_modifier= MutabilityModifier::Mutable,
		};
		res.function_type.args.push_back( move(this_arg) );
	}

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}

		var FunctionType::Arg mut arg{ .file_pos= it_.front().file_pos, .arg_type= ParseTypeName() };

		if( it_.front().lexem_type == Lexem::Type::And )
		{
			arg.reference_modifier= ReferenceModifier::Reference;
			NextLexem();
		}

		if( IsKeyword( it_.front(), Keyword::mut_ ) )
		{
			arg.mutability_modifier= MutabilityModifier::Mutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::imut_ ) )
		{
			arg.mutability_modifier= MutabilityModifier::Immutable;
			NextLexem();
		}

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
			return Function();
		}
		arg.name= it_.front().text;
		NextLexem();

		res.function_type.args.push_back( move(arg) );

		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}
		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::BracketRight ) // Prevent ')' after ','
			{
				PushErrorMessage();
				return Function();
			}
		}
	}

	if( it_.front().lexem_type == Lexem::Type::Colon )
	{
		NextLexem();
		res.function_type.return_type= ParseTypeName();

		if( it_.front().lexem_type == Lexem::Type::And )
		{
			NextLexem();
			res.function_type.return_value_reference_modifier= ReferenceModifier::Reference;

			if( IsKeyword( it_.front(), Keyword::mut_ ) )
			{
				res.function_type.return_value_mutability_modifier= MutabilityModifier::Mutable;
				NextLexem();
			}
			else if( IsKeyword( it_.front(), Keyword::imut_ ) )
			{
				res.function_type.return_value_mutability_modifier= MutabilityModifier::Immutable;
				NextLexem();
			}
		}
	}

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();
	}
	else
	{
		if( it_.front().lexem_type == Lexem::Type::BracketLeft )
		{
			var StructNamedInitializer mut constructor_initializer_list{ .file_pos= it_.front().file_pos };
			NextLexem();

			while( NotEndOfFile() )
			{
				if( it_.front().lexem_type == Lexem::Type::BracketRight )
				{
					NextLexem();
					break;
				}

				if( it_.front().lexem_type != Lexem::Type::Identifier )
				{
					PushErrorMessage();
					break;
				}

				var StructNamedInitializer::Member mut member_initializer
				{
					.file_pos= it_.front().file_pos,
					.name= it_.front().text,
					.initializer( Initializer() ),
				};
				NextLexem();

				member_initializer.initializer.get_ref()= ParseVariableInitializer();
				if( !member_initializer.initializer.get_ref().get</EmptyVariant/>().empty() )
				{
					PushErrorMessage();
				}

				constructor_initializer_list.members_initializers.push_back( move(member_initializer) );

				if( it_.front().lexem_type == Lexem::Type::Comma )
				{
					NextLexem();
				}
				else if( it_.front().lexem_type != Lexem::Type::BracketRight )
				{
					PushErrorMessage();
					break;
				}
			}

			res.constructor_initializer_list.reset( move(constructor_initializer_list) );
		}

		if( it_.front().lexem_type == Lexem::Type::BraceLeft )
		{
			res.block.reset( ParseBlock() );
		}
		else
		{
			PushErrorMessage();
		}
	}
	return move(res);
}

fn SyntaxAnalyzer::ParseInitializer( mut this, bool parse_expression_initializer ) : Initializer
{
	if( it_.front().lexem_type == Lexem::Type::SquareBracketLeft )
	{
		var SequenceInitializer mut sequence_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();

		while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::SquareBracketRight )
		{
			sequence_initializer.elements_initializers.push_back( ust::box</Initializer/>( ParseInitializer( true ) ) );
			if( it_.front().lexem_type == Lexem::Type::Comma )
			{
				NextLexem();
			}
			else
			{
				break;
			}
			// TODO - parse continious flag here
		}
		if( it_.front().lexem_type != Lexem::Type::SquareBracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(sequence_initializer);
	}
	else if( it_.front().lexem_type == Lexem::Type::BracketLeft )
	{
		/// TODO - fix case, like :    var [ i32, 1] x[ (1 + 2) * 3 ];
		var ConstructorInitializer mut constructor_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();

		while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			constructor_initializer.args.push_back( ust::shared_ptr_final</ Expression />( ParseExpression() ) );
			if( it_.front().lexem_type  == Lexem::Type::Comma )
			{
				NextLexem();
				// Disallow comma after closing bracket
				if( it_.front().lexem_type  == Lexem::Type::BracketRight )
				{
					PushErrorMessage();
				}
			}
			else
			{
				break;
			}
		}
		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(constructor_initializer);
	}
	else if( it_.front().lexem_type == Lexem::Type::BraceLeft )
	{
		var StructNamedInitializer mut struct_named_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();

		while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BraceRight )
		{
			if( it_.front().lexem_type != Lexem::Type::Dot )
			{
				PushErrorMessage();
			}
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			auto& name= it_.front().text;
			auto& file_pos= it_.front().file_pos;
			NextLexem();

			auto mut initializer= ParseVariableInitializer();
			if( !initializer.get</EmptyVariant/>().empty() )
			{
				PushErrorMessage();
			}

			var StructNamedInitializer::Member mut member_initializer
			{
				.file_pos= file_pos,
				.name= name,
				.initializer( move(initializer) ),
			};
			struct_named_initializer.members_initializers.push_back( move(member_initializer) );

			if( it_.front().lexem_type == Lexem::Type::Comma )
			{
				NextLexem();
			}
		}
		if( it_.front().lexem_type != Lexem::Type::BraceRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(struct_named_initializer);
	}
	else if( IsKeyword( it_.front(), Keyword::zero_init_ ) )
	{
		var ZeroInitializer mut zero_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();
		return move(zero_initializer);
	}
	else if( IsKeyword( it_.front(), Keyword::uninitialized_ ) )
	{
		var UninitializedInitializer mut uninitialized_initializer{ .file_pos= it_.front().file_pos };
		NextLexem();
		return move(uninitialized_initializer);
	}
	else if( parse_expression_initializer )
	{
		// In some cases usage of expression in initializer is forbidden.
		return ParseExpression();
	}
	else
	{
		PushErrorMessage();
		return EmptyVariant();
	}
}

fn SyntaxAnalyzer::ParseVariableInitializer( mut this ) : Initializer
{
	if( it_.front().lexem_type == Lexem::Type::Assignment )
	{
		NextLexem();
		if( IsKeyword( it_.front(), Keyword::zero_init_ ) )
		{
			var ZeroInitializer mut zero_initializer{ .file_pos= it_.front().file_pos };
			NextLexem();
			return Initializer( move(zero_initializer) );
		}
		if( IsKeyword( it_.front(), Keyword::uninitialized_ ) )
		{
			var UninitializedInitializer mut uninitialized_initializer{ .file_pos= it_.front().file_pos };
			NextLexem();
			return move(uninitialized_initializer);
		}
		else
		{
			return ParseExpression();
		}
	}
	else if(
		it_.front().lexem_type == Lexem::Type::BracketLeft ||
		it_.front().lexem_type == Lexem::Type::SquareBracketLeft ||
		it_.front().lexem_type == Lexem::Type::BraceLeft )
	{
		return ParseInitializer( false );
	}

	return Initializer( EmptyVariant() );
}

fn SyntaxAnalyzer::ParseBlock( mut this ) : Block
{
	var Block mut block{ .file_pos= it_.front().file_pos };

	NextLexem(); // {

	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BraceRight )
	{
		if( it_.front().lexem_type == Lexem::Type::BraceLeft )
		{
			block.elements.push_back( ust::box</Block/>(ParseBlock()) );
		}
		else if( IsKeyword( it_.front(), Keyword::var_ ) )
		{
			block.elements.push_back( ParseVariablesDeclaration() );
		}
		else if( IsKeyword( it_.front(), Keyword::auto_ ) )
		{
			block.elements.push_back( ParseAutoVariableDeclaration() );
		}
		else if( IsKeyword( it_.front(), Keyword::return_ ) )
		{
			block.elements.push_back( ParseReturnOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::if_ ) )
		{
			block.elements.push_back( ParseIfOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::while_ ) )
		{
			block.elements.push_back( ParseWhileOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::break_ ) )
		{
			block.elements.push_back( ParseBreakOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::continue_ ) )
		{
			block.elements.push_back( ParseContinueOperator() );
		}
		else if( IsKeyword( it_.front(), Keyword::static_assert_ ) )
		{
			block.elements.push_back( ParseStaticAssert() );
		}
		else if( IsKeyword( it_.front(), Keyword::halt_ ) )
		{
			block.elements.push_back( ParseHalt() );
		}
		else if( it_.front().lexem_type == Lexem::Type::Increment )
		{
			var IncrementOperator mut increment_operator{ .file_pos= it_.front().file_pos };
			NextLexem();
			increment_operator.expression= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::Semicolon )
			{
				PushErrorMessage();
			}
			NextLexem();

			block.elements.push_back( move(increment_operator) );
		}
		else if( it_.front().lexem_type == Lexem::Type::Decrement )
		{
			var DecrementOperator mut decrement_operator{ .file_pos= it_.front().file_pos };
			NextLexem();
			decrement_operator.expression= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::Semicolon )
			{
				PushErrorMessage();
			}
			NextLexem();

			block.elements.push_back( move(decrement_operator) );
		}
		else
		{
			auto mut expr= ParseExpression();

			auto additive_assignment_operator_type= GetAdditiveAssignmentOperator( it_.front() );
			if( !additive_assignment_operator_type.empty() )
			{
				var AdditiveAssignmentOperator mut additive_assignment_operator
				{
					.file_pos= it_.front().file_pos,
					.operator= additive_assignment_operator_type.get_ref(),
					.l= move(expr),
				};
				NextLexem();

				additive_assignment_operator.r= ParseExpression();

				block.elements.push_back( move(additive_assignment_operator) );
			}
			else if( it_.front().lexem_type == Lexem::Type::Assignment )
			{
				var AssignmentOperator mut assignment_operator{ .file_pos= it_.front().file_pos };
				NextLexem();

				assignment_operator.l= move(expr);
				assignment_operator.r= ParseExpression();

				block.elements.push_back( move(assignment_operator) );
			}
			else
			{
				block.elements.push_back( move(expr) );
			}

			if( it_.front().lexem_type == Lexem::Type::Semicolon )
			{
				NextLexem();
			}
			else
			{
				PushErrorMessage();
			}
		}
	}

	block.end_file_pos= it_.front().file_pos;

	if( it_.front().lexem_type == Lexem::Type::BraceRight )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	return move(block);
}

fn SyntaxAnalyzer::ParseVariablesDeclaration( mut this ) : VariablesDeclaration
{
	var VariablesDeclaration mut variables_declaration{ .file_pos= it_.front().file_pos };

	NextLexem(); // var

	variables_declaration.t= ParseTypeName();

	while( NotEndOfFile() )
	{
		var VariablesDeclaration::VariableEntry mut variable_entry;

		if( it_.front().lexem_type == Lexem::Type::And )
		{
			variable_entry.reference_modifier= ReferenceModifier::Reference;
			NextLexem();
		}

		if( IsKeyword( it_.front(), Keyword::mut_ ) )
		{
			variable_entry.mutability_modifier= MutabilityModifier::Mutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::imut_ ) )
		{
			variable_entry.mutability_modifier= MutabilityModifier::Immutable;
			NextLexem();
		}
		else if( IsKeyword( it_.front(), Keyword::constexpr_ ) )
		{
			variable_entry.mutability_modifier= MutabilityModifier::Constexpr;
			NextLexem();
		}

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
			break;
		}
		variable_entry.file_pos= it_.front().file_pos;
		variable_entry.name= it_.front().text;
		NextLexem();

		variable_entry.initializer= ParseVariableInitializer();

		variables_declaration.variables.push_back( move(variable_entry) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			continue;
		}
		if( it_.front().lexem_type == Lexem::Type::Semicolon )
		{
			NextLexem();
			break;
		}
	}

	return move(variables_declaration);
}

fn SyntaxAnalyzer::ParseAutoVariableDeclaration( mut this ) : AutoVariableDeclaration
{
	var AutoVariableDeclaration mut variable_declaration;

	NextLexem(); // auto

	if( it_.front().lexem_type == Lexem::Type::And )
	{
		variable_declaration.reference_modifier= ReferenceModifier::Reference;
		NextLexem();
	}

	if( IsKeyword( it_.front(), Keyword::mut_ ) )
	{
		variable_declaration.mutability_modifier= MutabilityModifier::Mutable;
		NextLexem();
	}
	else if( IsKeyword( it_.front(), Keyword::imut_ ) )
	{
		variable_declaration.mutability_modifier= MutabilityModifier::Immutable;
		NextLexem();
	}
	else if( IsKeyword( it_.front(), Keyword::constexpr_ ) )
	{
		variable_declaration.mutability_modifier= MutabilityModifier::Constexpr;
		NextLexem();
	}

	variable_declaration.name= it_.front().text;
	variable_declaration.file_pos= it_.front().file_pos;
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Assignment )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	variable_declaration.initializer_expression= ParseExpression();

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();
	}
	else
	{
		PushErrorMessage();
	}

	return move(variable_declaration);
}

fn SyntaxAnalyzer::ParseReturnOperator( mut this ) : ReturnOperator
{
	var ReturnOperator mut res{ .file_pos= it_.front().file_pos };
	NextLexem(); // return

	res.expr= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
		return ReturnOperator();
	}
	NextLexem();

	return move(res);
}

fn SyntaxAnalyzer::ParseIfOperator( mut this ) : IfOperator
{
	auto start_file_pos= it_.front().file_pos;
	NextLexem(); // if

	var IfOperator mut if_operator{ .file_pos= start_file_pos };

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	auto mut if_expression= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}

	var IfOperator::Branch mut first_branch
	{
		.file_pos= start_file_pos,
		.condition= move(if_expression),
		.block( ParseBlock() )
	};

	if_operator.branches.push_back( move(first_branch) );

	while( NotEndOfFile() )
	{
		auto else_file_pos= it_.front().file_pos;
		if( !IsKeyword( it_.front(), Keyword::else_ ) )
		{
			break;
		}
		NextLexem();

		// Optional if.
		var Expression mut condition;
		if( IsKeyword( it_.front(), Keyword::if_ ) )
		{
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::BracketLeft )
			{
				PushErrorMessage();
			}

			NextLexem();

			condition= ParseExpression();

			if( it_.front().lexem_type != Lexem::Type::BracketRight )
			{
				PushErrorMessage();
			}

			NextLexem();
		}
		// Block - common for "else" and "else if".
		if( it_.front().lexem_type != Lexem::Type::BraceLeft )
		{
			PushErrorMessage();
		}

		var IfOperator::Branch mut branch
		{
			.file_pos= else_file_pos,
			.condition= move(condition),
			.block( ParseBlock() )
		};
		if_operator.branches.push_back( move(branch) );

		if( !if_operator.branches.back().condition.get</EmptyVariant/>().empty() )
		{
			break;
		}
	}

	return move(if_operator);
}

fn SyntaxAnalyzer::ParseWhileOperator( mut this ) : WhileOperator
{
	auto start_file_pos= it_.front().file_pos;
	NextLexem(); // while

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	auto mut condition= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}

	var WhileOperator mut while_operator
	{
		.file_pos= start_file_pos,
		.condition= move(condition),
		.block( ParseBlock() )
	};
	return move(while_operator);
}

fn SyntaxAnalyzer::ParseBreakOperator( mut this ) : BreakOperator
{
	var BreakOperator mut break_operator{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(break_operator);
}

fn SyntaxAnalyzer::ParseContinueOperator( mut this ) : ContinueOperator
{
	var ContinueOperator mut continue_operator{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(continue_operator);
}

fn SyntaxAnalyzer::ParseStaticAssert( mut this ) : StaticAssert
{
	if( !IsKeyword( it_.front(), Keyword::static_assert_ ) )
	{
		PushErrorMessage();
	}

	var StaticAssert mut static_assert_{ .file_pos= it_.front().file_pos };
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	static_assert_.expression= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::BracketRight )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(static_assert_);
}

fn SyntaxAnalyzer::ParseHalt( mut this ) : BlockElement
{
	if( !IsKeyword( it_.front(), Keyword::halt_ ) )
	{
		PushErrorMessage();
	}
	auto file_pos= it_.front().file_pos;
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Semicolon )
	{
		NextLexem();

		var Halt mut halt_{ .file_pos= file_pos };
		return move(halt_);
	}
	else
	{
		var HaltIf mut halt_if{ .file_pos= file_pos };

		if( !IsKeyword( it_.front(), Keyword::if_ ) )
		{
			PushErrorMessage();
		}
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::BracketLeft )
		{
			PushErrorMessage();
		}
		NextLexem();

		halt_if.condition= ParseExpression();

		if( it_.front().lexem_type != Lexem::Type::BracketRight )
		{
			PushErrorMessage();
		}
		NextLexem();

		if( it_.front().lexem_type != Lexem::Type::Semicolon )
		{
			PushErrorMessage();
		}
		NextLexem();

		return move(halt_if);
	}
}

fn SyntaxAnalyzer::ParseClass( mut this ) : Class
{
	var Class mut class_;

	if( !( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	class_.file_pos= it_.front().file_pos;
	class_.name= it_.front().text;
	NextLexem();

	class_.class_elements= ParseClassBody();
	return move(class_);
}

fn SyntaxAnalyzer::ParseClassBody( mut this ) : ClassElements
{
	var ClassElements mut class_elements;

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BraceRight )
		{
			NextLexem();
			break;
		}
		else if( IsKeyword( it_.front(), Keyword::fn_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</Function/>( ParseFunction() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</Class/>( ParseClass() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::enum_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</Enum/>( ParseEnum() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::type_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</TypeAlias/>( ParseTypeAlias() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::template_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</ClassTemplate/>( ParseClassTemplate() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::var_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</VariablesDeclaration/>( ParseVariablesDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::auto_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</AutoVariableDeclaration/>( ParseAutoVariableDeclaration() ) );
		}
		else if( IsKeyword( it_.front(), Keyword::static_assert_ ) )
		{
			class_elements.push_back( ust::shared_ptr_final</StaticAssert/>( ParseStaticAssert() ) );
		}
		else
		{
			var ClassField mut class_field;
			class_field.t= ParseTypeName();

			if( it_.front().lexem_type == Lexem::Type::And )
			{
				class_field.reference_modifier= ReferenceModifier::Reference;
				NextLexem();
			}

			if( IsKeyword( it_.front(), Keyword::mut_ ) )
			{
				class_field.mutability_modifier= MutabilityModifier::Mutable;
				NextLexem();
			}
			else if( IsKeyword( it_.front(), Keyword::imut_ ) )
			{
				class_field.mutability_modifier= MutabilityModifier::Immutable;
				NextLexem();
			}

			if( it_.front().lexem_type != Lexem::Type::Identifier )
			{
				PushErrorMessage();
			}
			class_field.file_pos= it_.front().file_pos;
			class_field.name= it_.front().text;
			NextLexem();

			if( it_.front().lexem_type != Lexem::Type::Semicolon )
			{
				PushErrorMessage();
			}
			NextLexem();

			class_elements.push_back( ust::shared_ptr_final</ ClassField />( move(class_field) ) );
		}
	}

	return move(class_elements);
}

fn SyntaxAnalyzer::ParseEnum( mut this ) : Enum
{
	if( !IsKeyword( it_.front(), Keyword::enum_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}

	var Enum mut enum_
	{
		.file_pos= it_.front().file_pos,
		.name= it_.front().text,
	};
	NextLexem();

	if( it_.front().lexem_type == Lexem::Type::Colon )
	{
		NextLexem();
		enum_.underlaying_type= ParseComplexName();
	}

	if( it_.front().lexem_type != Lexem::Type::BraceLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}
		var Enum::Element mut element
		{
			.file_pos= it_.front().file_pos,
			.name= it_.front().text,
		};
		NextLexem();

		enum_.elements.push_back( move(element) );

		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::BraceRight )
			{
				NextLexem();
				break;
			}
		}
		else if( it_.front().lexem_type == Lexem::Type::BraceRight )
		{
			NextLexem();
			break;
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	return move(enum_);
}

fn SyntaxAnalyzer::ParseTypeAlias( mut this ) : TypeAlias
{
	if( !IsKeyword( it_.front(), Keyword::type_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}

	var TypeAlias mut type_alias
	{
		.file_pos= it_.front().file_pos,
		.name= it_.front().text,
	};
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Assignment )
	{
		PushErrorMessage();
	}
	NextLexem();

	type_alias.type_name= ParseTypeName();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
	}
	NextLexem();

	return move(type_alias);
}

fn SyntaxAnalyzer::ParseClassTemplate( mut this ) : ClassTemplate
{
	auto template_file_pos= it_.front().file_pos;

	if( !IsKeyword( it_.front(), Keyword::template_ ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	// Template args.
	if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	var ust::vector</ClassTemplate::Arg/> mut args;
	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{
			NextLexem();
			break;
		}

		var ClassTemplate::Arg mut arg;
		if( IsKeyword( it_.front(), Keyword::type_ ) )
		{
			NextLexem();
		}
		else
		{
			arg.t= ParseComplexName();
		}

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
		}

		var ComplexName mut arg_name{ .file_pos= it_.front().file_pos, .name= it_.front().text };
		NextLexem();

		arg.name= move(arg_name);

		args.push_back( move(arg) );

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{}
		else if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
				break;
			}
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	// Class declaration.

	if( !( IsKeyword( it_.front(), Keyword::struct_ ) || IsKeyword( it_.front(), Keyword::class_ ) ) )
	{
		PushErrorMessage();
	}
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
	}
	auto mut class_name= it_.front().text;
	auto class_file_pos= it_.front().file_pos;
	NextLexem();

	// Signature args.
	if( it_.front().lexem_type != Lexem::Type::TemplateBracketLeft )
	{
		PushErrorMessage();
	}
	NextLexem();

	var ust::vector</ClassTemplate::SignatureArg/> mut signature_args;
	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{
			NextLexem();
			break;
		}

		var ClassTemplate::SignatureArg mut arg;
		arg.name= ParseExpression();

		if( it_.front().lexem_type == Lexem::Type::Assignment )
		{
			NextLexem();
			arg.default_value= ParseExpression();
		}

		signature_args.push_back(move(arg));

		if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
		{}
		else if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();
			if( it_.front().lexem_type == Lexem::Type::TemplateBracketRight )
			{
				PushErrorMessage();
				break;
			}
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	// Class elements;

	var Class mut class_
	{
		.file_pos= class_file_pos,
		.name= move(class_name),
		.class_elements= ParseClassBody(),
	};
	var ClassTemplate mut class_template
	{
		.file_pos= template_file_pos,
		.class_(move(class_)),
		.args= move(args),
		.signature_args= move(signature_args),
	};

	return move(class_template);
}

fn SyntaxAnalyzer::NotEndOfFile( this ) : bool
{
	return it_.size() >= 2s;
}

fn SyntaxAnalyzer::NextLexem( mut this )
{
	if( NotEndOfFile() )
	{
		it_.drop_front();
	}
}

fn SyntaxAnalyzer::PushErrorMessage( mut this )
{
	if( error_messages_.empty() || FilePos(error_messages_.back().file_pos) != it_.front().file_pos )
	{
		var SyntaxErrorMessage mut error_message
		{
			.file_pos= it_.front().file_pos,
			.text= "Syntax error - unexpected lexem: \"" + it_.front().text + "\""
		};
		error_messages_.push_back( move(error_message) );
	}
}

fn SyntaxAnalysis( Lexems& lexems ) : SyntaxAnalysisResult
{
	var SyntaxAnalyzer mut analyzer(lexems);
	return analyzer.DoAnalyzis();
}

} // namespace Synt

} // namespace U
