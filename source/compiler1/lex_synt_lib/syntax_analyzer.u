import "keywords.uh"
import "syntax_analyzer.uh"

namespace U
{

namespace Synt
{

fn IsKeyword( Lexem& l, Keyword k ) : bool
{
	return l.lexem_type == Lexem::Type::Identifier && l.text == KeywordToString(k);
}

class SyntaxAnalyzer
{
public:
	fn constructor( this'a', Lexems&'b lexems ) ' a <- b ';

	fn DoAnalyzis( mut this ) : SyntaxAnalysisResult;

private:
	fn ParseExpression( mut this ) : Expression;
	fn ParseTypeName( mut this ) : TypeName;
	fn ParseFunction( mut this ) : Function;

	fn ParseBlock( mut this ) : Block;

	fn ParseReturnOperator( mut this ) : ReturnOperator;

	fn NotEndOfFile( this ) : bool;
	fn NextLexem( mut this );
	fn PushErrorMessage( mut this );

private:
	ust::array_view_imut</Lexem/> it_;
	SyntaxErrorMessages error_messages_;
}

fn SyntaxAnalyzer::constructor( this'a', Lexems&'b lexems ) ' a <- b '
	( it_= lexems.range() )
{
}

fn SyntaxAnalyzer::DoAnalyzis( mut this ) : SyntaxAnalysisResult
{
	var SyntaxAnalysisResult mut res;

	while( NotEndOfFile() )
	{
		if( IsKeyword( it_.front(), Keyword::fn_ ) )
		{
			res.program_elements.push_back( ParseFunction() );
		}
		else
		{
			break;
		}
	}

	return move(res);
}

fn SyntaxAnalyzer::ParseExpression( mut this ) : Expression
{
	if( it_.front().lexem_type == Lexem::Type::Number )
	{
		var NumericConstant mut numeric_constant;
		halt if( it_.front().text.size() < typeinfo</NumberLexemData/>.size_of );

		unsafe
		{
			ust::memory_copy( numeric_constant.num, it_.front().text.front(), typeinfo</NumberLexemData/>.size_of );
		}

		var Expression mut expr;
		expr.expr= move(numeric_constant);
		return move(expr);
	}
	else
	{
		PushErrorMessage();
		return Expression();
	}
}

fn SyntaxAnalyzer::ParseTypeName( mut this ) : TypeName
{
	if( it_.front().lexem_type == Lexem::Type::Identifier )
	{
		var ComplexName mut complex_name;
		complex_name.name= it_.front().text;

		NextLexem();

		return TypeName( move(complex_name) );
	}
	else
	{
		PushErrorMessage();
		return TypeName();
	}
}

fn SyntaxAnalyzer::ParseFunction( mut this ) : Function
{
	var Function mut res{ .file_pos= it_.front().file_pos };

	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::Identifier )
	{
		PushErrorMessage();
		return Function();
	}
	res.name= it_.front().text;
	NextLexem();

	if( it_.front().lexem_type != Lexem::Type::BracketLeft )
	{
		PushErrorMessage();
		return Function();
	}
	NextLexem();

	while( NotEndOfFile() )
	{
		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}

		var FunctionType::Arg mut arg;
		arg.arg_type= ParseTypeName();

		if( it_.front().lexem_type != Lexem::Type::Identifier )
		{
			PushErrorMessage();
			return Function();
		}
		arg.name= it_.front().text;
		NextLexem();

		res.function_type.args.push_back( move(arg) );

		if( it_.front().lexem_type == Lexem::Type::BracketRight )
		{
			NextLexem();
			break;
		}
		if( it_.front().lexem_type == Lexem::Type::Comma )
		{
			NextLexem();

			if( it_.front().lexem_type == Lexem::Type::BracketRight ) // Prevent ')' after ','
			{
				PushErrorMessage();
				return Function();
			}
		}
	}

	if( it_.front().lexem_type == Lexem::Type::BraceLeft )
	{
		res.block.reset( ParseBlock() );
	}
	else if( it_.front().lexem_type == Lexem::Type::Semicolon ){} // Prototype
	else
	{
		PushErrorMessage();
		return Function();
	}

	return move(res);
}

fn SyntaxAnalyzer::ParseBlock( mut this ) : Block
{
	NextLexem(); // {

	var Block mut block;

	while( NotEndOfFile() && it_.front().lexem_type != Lexem::Type::BraceRight )
	{
		if( IsKeyword( it_.front(), Keyword::return_ ) )
		{
			block.elements.push_back( ParseReturnOperator() );
		}
		else
		{
			PushErrorMessage();
			break;
		}
	}

	return move(block);
}

fn SyntaxAnalyzer::ParseReturnOperator( mut this ) : ReturnOperator
{
	NextLexem(); // return

	var ReturnOperator mut res;

	res.expr= ParseExpression();

	if( it_.front().lexem_type != Lexem::Type::Semicolon )
	{
		PushErrorMessage();
		return ReturnOperator();
	}
	NextLexem();

	return move(res);
}

fn SyntaxAnalyzer::NotEndOfFile( this ) : bool
{
	return it_.size() >= 2s;
}

fn SyntaxAnalyzer::NextLexem( mut this )
{
	if( NotEndOfFile() )
	{
		it_.drop_front();
	}
}

fn SyntaxAnalyzer::PushErrorMessage( mut this )
{
	if( error_messages_.empty() || FilePos(error_messages_.back().file_pos) != it_.front().file_pos )
	{
		var SyntaxErrorMessage mut error_message;
		error_message.file_pos= it_.front().file_pos;
		error_message.text= "Syntax error - unexpected lexem";
		error_messages_.push_back( move(error_message) );
	}
}

fn SyntaxAnalysis( Lexems& lexems ) : SyntaxAnalysisResult
{
	var SyntaxAnalyzer mut analyzer(lexems);
	return analyzer.DoAnalyzis();
}

} // namespace Synt

} // namespace U
