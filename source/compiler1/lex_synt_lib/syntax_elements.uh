import "/box.u"
import "/box_nullable.u"
import "/optional.u"
import "/shared/shared_ptr_final.u"
import "/string.u"
import "/variant.u"
import "/vector.u"
import "lexical_analyzer.uh"
import "operators.uh"


namespace U
{

namespace Synt
{

struct ComplexName
{
	// TODO - make really comples
	ust::string8 name;
}

struct NumericConstant
{
	FilePos file_pos;
	NumberLexemData num= zero_init;
}

struct BinaryOperator
{
	ust::box</Expression/> l;
	ust::box</Expression/> r;
	BinaryOperatorType operator;
}

struct BracketExpression
{
	ust::box</Expression/> expr;
}

// HACK! use struct to prevent globals loop.
struct Expression
{
	ust::variant</ tup[
		NumericConstant,
		BinaryOperator,
		BracketExpression ] /> expr;
}

struct FunctionType
{
	struct Arg
	{
		TypeName arg_type;
		ust::string8 name;
	}
	ust::vector</Arg/> args;
	ust::optional</TypeName/> return_type; // Empty means "void"
}

// HACK! use struct to prevent globals loop.
type TypeName=
	ust::variant</ tup[
		ComplexName,
		ust::box</FunctionType/> ] />;

struct ReturnOperator
{
	Expression expr;
}

struct EmptyReturnOperator
{
}

type BlockElement = ust::variant</ tup[
	ReturnOperator,
	EmptyReturnOperator ] />;

struct Block
{
	FilePos file_pos;
	FilePos end_file_pos;
	ust::vector</BlockElement/> elements;
}

struct Function
{
	FilePos file_pos;
	ust::string8 name;
	FunctionType function_type;
	ust::box_nullable</Block/> block; // null for prototype
}

type ProgramElement= ust::variant</ tup[
	ust::shared_ptr_final</Function/>
	 ] />;

type ProgramElements= ust::vector</ProgramElement/>;

} // namespace Synt

} // namespace U
