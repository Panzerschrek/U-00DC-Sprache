import "/box.u"
import "/box_nullable.u"
import "/optional.u"
import "/shared/shared_ptr_final.u"
import "/string.u"
import "/variant.u"
import "/vector.u"
import "lexical_analyzer.uh"
import "operators.uh"


namespace U
{

namespace Synt
{

enum MutabilityModifier : u8
{
	None,
	Mutable,
	Immutable,
	Constexpr,
}

enum ReferenceModifier : u8
{
	None,
	Reference,
}

struct EmptyVariant{} // used as stub

type TemplateArgs= ust::vector</Expression/>;

struct ComplexName
{
	FilePos file_pos;
	ust::string8 name; // Empty for "::" start.

	type TailComponent= ust::variant</ tup[ ust::string8, ust::box</TemplateArgs/> ] />;
	ust::vector</ TailComponent /> tail;
}

struct NumericConstant
{
	FilePos file_pos;
	NumberLexemData num= zero_init;
}

struct BooleanConstant
{
	FilePos file_pos;
	bool value;
}

struct BinaryOperator
{
	FilePos file_pos;
	ust::shared_ptr_final</Expression/> l;
	ust::shared_ptr_final</Expression/> r;
	BinaryOperatorType operator;
}

struct BracketExpression
{
	FilePos file_pos;
	ust::box</Expression/> expr;
}

struct IndexationOperator
{
	FilePos file_pos;
	ust::box</Expression/> value;
	ust::box</Expression/> index;
}

struct CallOperator
{
	FilePos file_pos;
	ust::box</Expression/> value;
	ust::vector</ ust::shared_ptr_final</Expression/> /> args;
}

struct MemberAccessOperator
{
	FilePos file_pos;
	ust::box</Expression/> value;
	ust::string8 member_name;
}

struct UnaryPlus
{
	FilePos file_pos;
	ust::box</Expression/> expr;
}

struct UnaryMinus
{
	FilePos file_pos;
	ust::box</Expression/> expr;
}

struct LogicalNot
{
	FilePos file_pos;
	ust::box</Expression/> expr;
}

struct BitwiseNot
{
	FilePos file_pos;
	ust::box</Expression/> expr;
}

type Expression= ust::variant</ tup[
	EmptyVariant,
	NumericConstant,
	BooleanConstant,
	ComplexName,
	BinaryOperator,
	BracketExpression,
	IndexationOperator,
	CallOperator,
	MemberAccessOperator,
	UnaryPlus,
	UnaryMinus,
	LogicalNot,
	BitwiseNot,
	ust::box</ArrayType/>
	] />;

struct ArrayType
{
	FilePos file_pos;
	TypeName element_type;
	Expression element_count;
}

struct FunctionType
{
	struct Arg
	{
		FilePos file_pos;
		TypeName arg_type;
		ReferenceModifier reference_modifier= ReferenceModifier::None;
		MutabilityModifier mutability_modifier= MutabilityModifier::None;
		ust::string8 name;
	}
	ust::vector</Arg/> args;

	ust::optional</TypeName/> return_type; // Empty means "void"
	MutabilityModifier return_value_mutability_modifier= MutabilityModifier::None;
	ReferenceModifier return_value_reference_modifier= ReferenceModifier::None;
}

type TypeName= ust::variant</ tup[
	ComplexName,
	ust::box</ArrayType/>,
	ust::box</FunctionType/>
	] />;

struct SequenceInitializer
{
	FilePos file_pos;
	ust::vector</ ust::box</ Initializer /> /> elements_initializers;
}

struct StructNamedInitializer
{
	FilePos file_pos;

	struct Member
	{
		FilePos file_pos;
		ust::string8 name;
		ust::box</ Initializer /> initializer;
	}

	ust::vector</ Member /> members_initializers;
}

struct ConstructorInitializer
{
	FilePos file_pos;
	ust::vector</ ust::shared_ptr_final</Expression/> /> args;
}

struct ZeroInitializer
{
	FilePos file_pos;
}

struct UninitializedInitializer
{
	FilePos file_pos;
}

type Initializer= ust::variant</ tup [
	EmptyVariant,
	Expression,
	SequenceInitializer,
	StructNamedInitializer,
	ConstructorInitializer,
	ZeroInitializer,
	UninitializedInitializer
	] />;

struct Block
{
	FilePos file_pos;
	FilePos end_file_pos;
	ust::vector</BlockElement/> elements;
}

struct VariablesDeclaration
{
	struct VariableEntry
	{
		FilePos file_pos;
		ReferenceModifier reference_modifier= ReferenceModifier::None;
		MutabilityModifier mutability_modifier= MutabilityModifier::None;
		ust::string8 name;
		Initializer initializer;
	}

	FilePos file_pos;
	TypeName t;
	ust::vector</VariableEntry/> variables;
}

struct AutoVariableDeclaration
{
	FilePos file_pos;
	ReferenceModifier reference_modifier= ReferenceModifier::None;
	MutabilityModifier mutability_modifier= MutabilityModifier::None;
	ust::string8 name;
	Expression initializer_expression;
}

struct ReturnOperator
{
	FilePos file_pos;
	Expression expr;
}

struct AssignmentOperator
{
	FilePos file_pos;
	Expression l;
	Expression r;
}

struct AdditiveAssignmentOperator
{
	FilePos file_pos;
	BinaryOperatorType operator;
	ust::shared_ptr_final</Expression/> l;
	ust::shared_ptr_final</Expression/> r;
}

struct IncrementOperator
{
	FilePos file_pos;
	Expression expression;
}

struct DecrementOperator
{
	FilePos file_pos;
	Expression expression;
}

struct IfOperator
{
	struct Branch
	{
		FilePos file_pos;
		// Condition - EmptyVariant for last if.
		Expression condition;
		ust::box</Block/> block;
	}

	FilePos file_pos;
	FilePos end_file_pos;
	ust::vector</Branch/> branches;
}

struct WhileOperator
{
	FilePos file_pos;
	Expression condition;
	ust::box</Block/> block;
}

struct BreakOperator
{
	FilePos file_pos;
}

struct ContinueOperator
{
	FilePos file_pos;
}

struct StaticAssert
{
	FilePos file_pos;
	Expression expression;
}

struct Halt
{
	FilePos file_pos;
}

struct HaltIf
{
	FilePos file_pos;
	Expression condition;
}

type BlockElement = ust::variant</ tup[
	ust::box</Block/>,
	VariablesDeclaration,
	AutoVariableDeclaration,
	ReturnOperator,
	AssignmentOperator,
	AdditiveAssignmentOperator,
	IncrementOperator,
	DecrementOperator,
	Expression,
	IfOperator,
	WhileOperator,
	BreakOperator,
	ContinueOperator,
	StaticAssert,
	Halt,
	HaltIf
	] />;

struct Function
{
	FilePos file_pos;
	ust::vector</ ust::string8 /> name; // A, A::B, A::B::C::D, ::A, ::A::B
	OverloadedOperator operator= OverloadedOperator::None;
	FunctionType function_type;
	ust::box_nullable</Block/> block; // null for prototype
	ust::box_nullable</StructNamedInitializer/> constructor_initializer_list;
}

struct TypeAlias
{
	FilePos file_pos;
	ust::string8 name;
	TypeName type_name;
}

struct ClassField
{
	FilePos file_pos;
	ust::string8 name;
	TypeName t;
	MutabilityModifier mutability_modifier= MutabilityModifier::None;
	ReferenceModifier reference_modifier= ReferenceModifier::None;
}

type ClassElement= ust::variant</ tup[
	ust::shared_ptr_final</Function/>,
	ust::shared_ptr_final</Class/>,
	ust::shared_ptr_final</Enum/>,
	ust::shared_ptr_final</TypeAlias/>,
	ust::shared_ptr_final</TypeTemplate/>,
	ust::shared_ptr_final</ClassField/>,
	ust::shared_ptr_final</VariablesDeclaration/>,
	ust::shared_ptr_final</AutoVariableDeclaration/>,
	ust::shared_ptr_final</StaticAssert/>
	] />;

type ClassElements= ust::vector</ClassElement/>;

struct Class
{
	FilePos file_pos;
	ust::string8 name;
	ClassElements class_elements;
	bool is_forward_declaration= false;
}

struct Enum
{
	FilePos file_pos;
	ust::string8 name;
	ComplexName underlaying_type;

	struct Element
	{
		FilePos file_pos;
		ust::string8 name;
	}

	ust::vector</Element/> elements;
}

struct TypeTemplate
{
	FilePos file_pos;
	ust::string8 name;

	struct Param
	{
		Expression t; // Actually, only ComplexName. Empty if type parameter.
		Expression name; // Actually, only name with one component
	}
	ust::vector</Param/> params;

	struct SignatureParam
	{
		FilePos file_pos;
		Expression name;
		Expression default_value;
	}
	ust::vector</SignatureParam/> signature_params;

	// Short form means that template argumenst are also signature arguments.
	bool is_short_form;

	ust::variant</ tup[
		ust::shared_ptr_final</Class/>,
		ust::shared_ptr_final</TypeAlias/>
	] /> something;
}

struct Namespace
{
	FilePos file_pos;
	ust::string8 name;
	NamespaceElements elements;
}

type NamespaceElement= ust::variant</ tup[
	ust::shared_ptr_final</Function/>,
	ust::shared_ptr_final</Class/>,
	ust::shared_ptr_final</Enum/>,
	ust::shared_ptr_final</TypeAlias/>,
	ust::shared_ptr_final</TypeTemplate/>,
	ust::shared_ptr_final</Namespace/>, // TODO do we really need shared_ptr here?
	ust::shared_ptr_final</VariablesDeclaration/>,
	ust::shared_ptr_final</AutoVariableDeclaration/>,
	ust::shared_ptr_final</StaticAssert/>
	] />;

type NamespaceElements= ust::vector</NamespaceElement/>;

type ProgramElement= NamespaceElement;
type ProgramElements= ust::vector</ProgramElement/>;

fn GetFilePos( Initializer& initializer ) : FilePos;
fn GetFilePos( Expression& expression ) : FilePos;
fn GetFilePos( BlockElement& block_element ) : FilePos;

} // namespace Synt

} // namespace U
