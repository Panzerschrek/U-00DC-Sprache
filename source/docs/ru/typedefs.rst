Псевдонимы типов
================

В Ü имеется возможность задать новое имя для существующего типа. Для этого надо объявить его с использованием ключевого слова ``type``, имени псевдонима и описания исходного типа после =.
Объявление псевдонима помещается в пространство, в котором оно объявлено. Имя псевдонима можно использовать везде, где нужно имя типа.

.. code-block:: u_spr

   type MyInt = i32;
   
   fn Bar( MyInt x );
   
   fn Foo()
   {
      var MyInt x= 0;
      Bar(x);
   }

Объявление псевдонима типа не создаёт новый тип, а лишь создаёт имя для обращения к существующему типу.
Из этого следует, что тип сам по себе и его псевдонимы взаимозаменяемы. Также взаимозаменяемы различные псевдонимы для одного и того же типа.

.. code-block:: u_spr

   type MyInt = i32;
   type I32 = i32;
   
   fn Bar( i32 x );
   
   fn Foo()
   {
       var MyInt x= 0;
       var I32 y= 0;
       var MyInt y_copy= y; // Используем значение, объявленное с использованием псевдонима "I32", для инициализации переменной, объявленной с использованием псевдонима "MyInt".
       var I32 x_copy= x; // Аналогично, но в другую сторону.
       Bar(x); // "MyInt" есть "i32", а значит так можно.
       Bar(y); // "I32" есть "i32", а значит так можно.
   }

Псевдонимы можно задавать для любых типов:

.. code-block:: u_spr
   
   type IntVec3 = [ i32, 3 ]; // Псевдоним для массива
   type FloatPair = tup[ f32, f32 ]; // Псевдоним для кортежа
   
   struct S{}
   type SAlias = S; // Псевдоним для структуры
   
   type AnotherVec = IntVec3; // Псевдоним для псевдонима массива
   
   fn Foo()
   {
       var IntVec3 v[ 0, 1, 2 ];
       var FloatPair p[ 0.25f, 0.33f ];
       var SAlias s{};
       var AnotherVec v2[ 55, 625, 111 ];
   }
