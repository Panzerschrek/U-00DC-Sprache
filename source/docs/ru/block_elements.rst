Элементы тела функций
=====================

Тело функции состоит из последовательного набора элементов. Ниже перечислены основные из них.

***********************
*Объявление переменных*
***********************
См. :doc:`variables`.

****************************
*Объявление auto переменной*
****************************
См. :ref:`auto-variables`.

*******************
*Простое выражение*
*******************

Обычно оно необходимо, чтобы позвать какую-либо функцию, имеющую сторонние эффекты.
Разрешено объявлять простые выражения без побочных эффектов, но это не имеет особого смысла.

.. code-block:: u_spr

   Foo(); // Вызов какой-то функции, возможно, имеющей сторонние эффекты
   Add( 5, 7 ); // Вызов функции, не имеющей эффектов
   1 + 2; // Так тоже можно, но не особо то и нужно

**************
*Присваивание*
**************

Состоит из левой части, которой присваивается значение и правой, из которой берётся значение.

.. code-block:: u_spr

   x = 2; // Присваиваем переменной числовое значение
   x = Foo() + Bar() - 66; // Присваиваем переменной значение сложного выражения
   Min( x, y )= 0; // Так тоже можно, если результатом функции "Min" будет изменяемая ссылка

*************************************
*Выполнение операции с присваиванием*
*************************************

Существуют следующие операции с присваиванием:

* ``+=`` - добавление
* ``-=`` - вычитание
* ``*=`` - домножение
* ``/=`` - деление
* ``%=`` - взятие остатка от деления
* ``&=`` - побитовое AND
* ``|=`` - побитовое OR
* ``^=`` - побитовое XOR
* ``=<<`` - сдвиг вправо
* ``=>>`` - сдвиг в лево

Операция с присваиванием аналогична вызову соответствующего бинарного оператора для левого и правого выражений с последующим присваиванием получившегося значения левому выражению.

.. code-block:: u_spr

   x += 2; // Увеличиваем значение переменной "x" на 2
   x /= Foo() + Bar() - 66; // Делим переменную "x" на результат выражения справа, после чего сохраняем результат в неё же
   Min( x, y ) &= 0xFF; // Зануляем старшые биты для переменной - результата выполнения функции "Min"

***********************
*Инкремент и Декремент*
***********************

``++`` увеличивает значение выражения целочисленного типа на единицу, ``--`` уменьшает.

.. code-block:: u_spr

   ++ x;
   -- x;
   ++ Min( x, y );

*************************************
*Элементы контроля потока управления*
*************************************
См. :doc:`control_flow`.

***************
*static_assert*
***************
См. :doc:`static_assert`.

******
*halt*
******
См. :doc:`halt`.

******
*Блок*
******

Блок состоит их набора элементов в ``{}`` скобках. Блок может включать в себя все вышеперечисленные элементы а также другие блоки.

Блок необходим прежде всего для ограничения области видимости переменных. Переменная, объявленная в блоке, будет видна только в нём и во внутренних блоках.
Переменные, объявленные в блоке, имеют время жизни, ограниченное им. При выходе потока управления из блока перестают существовать все переменные, объявленные в нём.

В блоке можно объявить переменную с тем же именем, что и во внешнем блоке, после чего переменная из внешнего блока будет недоступна.

.. code-block:: u_spr

   fn Foo()
   {
       var i32 mut x= 0;
       {
            ++x; // Изменили значение внешней переменной
            var f64 mut x= 3.14; // Объявили переменную с тем же именем, что во внешнем блоке. Теперь переменная "x" из внешнего блока будет недоступна до конца этого блока.
            x= 0.0; // Изменили значение переменной текущего блока
            var i32 mut y= 0;
       }
       --y; // Ошибка - имя "y" не найдено
   }

Блок можно пометить меткой и использовать эту метку в ``break`` операторах, использующихся в этом блоке.
При этом ``break`` для блоков работает только с указанием метки.
``break`` без метки будет считаться относящимся к циклу, в котором он находится, а не к блоку с меткой.
``continue`` к блоку с меткой не возможен, при попытке его использовать компилятор породит ошибку.

.. code-block:: u_spr

   fn Foo(bool cond)
   {
      {
          if( cond )
          {
              break label block_end;
          }
          // some other code
      } label block_end
   }

Существуют также ``unsafe`` блоки.
См. :ref:`unsafe-blocks`.

***************
*Оператор with*
***************

Данный оператор позволяет выполнить какие-либо действия над результатом выражения, продлив, если надо, время жизни временных переменных этого выражения.
Данный оператор содержит опциональные модификаторы ссылочности и изменяемости а также имя, которое назначается результату выражения.

``with`` удобно использовать как альтернативу блоку, в котором объявляется какая-либо переменная и выполняются операции над нею, в случае, когда надо ограничить время жизни этой переменной.
Также ``with`` удобно использовать в шаблонном коде, когда точно не известно, чем является результат выражения - ссылкой или переменной, т. к. в отличие от объявления переменных через ``var`` или ``auto``, в ``with`` дозволяется создание ссылки на временную переменную.

Примеры использования:

.. code-block:: u_spr

   with( x : Foo() )
   {
       Bar(x);
       return x + 1;
   }

.. code-block:: u_spr

   with( &mut x : s.Get() )
   {
       ++x;
   }
