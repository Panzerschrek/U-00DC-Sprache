Генерация методов
=================

В Ü ряд методов структур и классов может быть сгенерирован самим компилятором, нету нужны расписывать тела этих методов вручную.

К методам, которые компилятор может сгенерировать, относятся:

* Конструкторы по умолчанию
* Конструкторы копирования
* Копирующие операторы присваивания
* Деструкторы

Для того, чтобы какой-то метод мог быть сгенерировн, должен быть соблюдён ряд условий:

* Для генерации конструктора по умолчанию необходимо, чтобы в классе или структуре все поля могли быть инициализированы по умолчанию и чтобы в классе или структуре не было ссылочных полей.
* Для генерации конструктора копирования необходимо, чтобы в классе или структуре все поля были конструируемы копированием.
* Для генерации копирующего оператора присваивания необходимо, чтобы в классе или структуре все поля могли быть копируемы присваиванием и чтобы не было неизменяемых или ссылочных полей.
* Деструктор может быть сгенерирован всегда.

Но возможность генерации метода не означает, что он будет сгенерирован. Явное объявление метода всегда отменяет его генерацию. Кроме того, есть ещё ряд условий:

* Конструктор по умолчанию будет сгенерирован, только если нету явно объявленного конструктора по умолчанию и если нету явно объявленных других конструкторов, исключая конструктор копирования.
* Конструктор копирования и оператор присваивания будут сгенерированы только для структур. Для классов они не могут быть сгенерированы явно.

А что же делать, если надо управлять генерацией методов явно? Для этого есть специальные конструкции - "= delete" и "= default".
Данные конструкции указываются вместо тела соотвествующего метода при объявлении.
"= delete" сообщает компилятору, что данный метод не надо генерировать, даже если можно.
"= default" сообщает компилятору, что данный метод надо генерировать. Если данный метод сгенерировать не получится, будет порождена ошибка.

Примеры:

.. code-block:: c++

   class A
   {
   public:
       fn constructor(i32 x) (x_= x) {}
       fn constructor()= default; // Без этого конструктор не был бы сгенерирован, т. к. есть явный конструктор кроме конструктора копирования.
       fn constructor(A& other)= default; // Без этого конструктор не был бы сгенерирован, т. к это класс.
       op=(mut this, A& other)= default; // Без этого конструктор не был бы сгенерирован, т. к это класс.
   
   private:
       i32 x_= 0;
   }
   
   struct B
   {
       fn constructor(B& other)= default; // Без этого конструктор был бы сгенерирован, т. к это структура.
       op=(mut this, B& other)= default; // Без этого конструктор был бы сгенерирован, т. к это структура.
       i32 x;
   }
