Лямбды
======

Лямбды в Ü - это безымянные функциональные объекты, объявляемые в контексте выражения.
Они могут быть использованы как функции (вызваны).

Объявляется лямбда с использованием ключевого слова ``lambda``, после которого следует описание параметров/возвращаемого значения и других атрибутов, свойственных функциям.
Далее следует тело лямбды.
Не существует каких-либо ограничений на содержимое тела лямбды - разрешено всё то, что и в обычных функциях.

.. code-block:: u_spr

   auto f= lambda( i32 x ) : i32 { return x / 3; };

Результат выражения лямбды - это значение типа лямбды.
Тип этот - некий генерируемый компилятором класс, уникальный для каждой лямбды.
Класс этот имеет перегруженный оператор вызова ``()``, который создаётся из указанного тела лямбды.


*******************
*Захват переменных*
*******************

Одной из важных особенностей лямбд в Ü является возможность использования локальных переменных и аргументов функций из окружающего контекста.
Чтобы их использовать, следует написать ``[=]`` после ключевого слова ``lambda``.

.. code-block:: u_spr

   var i32 scale= 11;
   auto f= lambda[=]( i32 x ) : i32 { return x * scale; };

При использовании ``[=]`` компилятор обнаружит все использования внешних переменных.
При создании объекта лямбды все эти переменные будут скопированы в объект лямбды.
По сути захваченные переменные становятся скрытыми полями класса лямбды.

Поскольку при использовании ``[=]`` переменные копируются в лямбду, после создания объекта лямбды они могут быть изменены или даже разрушены, что никак не повлияет на объект лямбды.

.. code-block:: u_spr

   var i32 mut scale= 11;
   auto f= lambda[=]( i32 x ) : i32 { return x * scale; };
   scale= 0; // Меняем исходную переменную
   halt if( f( 5 ) != 55 ); // Лямбда все ещё содержит копию старого значения переменной


***************
*Захват ссылок*
***************

Также можно объявить лямбду, которая захватывает ссылки на переменные, вместо их копирования.
Изменяемость этих ссылок определяется изменяемостью исходных переменных.
Захваченные по ссылке переменные становятся ссылочными полями в классе лямбды.

.. code-block:: u_spr

   var f32 mut x= 0.0f;
   {
       auto f= lambda[&]() { x += 1.0f; }; // Переменная "x" захвачена по изменяемой ссылке и будет изменена в вызове лямбды.
       f();
       f();
   }
   halt if( x != 2.0f ); // Переменная "x" должна приобрести новое значение после вызовов лямбды.

Для лямбд, захватывающих ссылки, действуют все те же правила контроля ссылок, что и для других типов со ссылками внутри.


*******************************
*Детали функционирования лямбд*
*******************************

Класс лямбды является сгенерированным и не имеет доступного программисту имени.
При этом это не сильно мешает работе с лямбдами.
Шаблонный код с ними работает, как с любыми другими типами.
Для объявления локальной переменной лямбды можно использовать ``auto``.
Также возможно использование ``typeof``.

.. code-block:: u_spr

   auto f= lambda(){};
   var typeof(f) f_copy= f;

Лямбды с захватом это просто классы с полями, соответствующими захваченным переменным.
Для захваченных по значению переменных должным образом вызываются деструкторы.
В зависимости от состава полей генерируются или нет конструктор копирования и оператор копирующего присваивания.
``non_sync`` тэг для лямбд выводится на основании их полей.

.. code-block:: u_spr

   var i32 x= 0, y= 0;
   auto f= lambda[=]() : i32 { return x + y; };
   static_assert( typeinfo</ typeof(f) />.size_of == typeinfo</i32/>.size_of * 2s );
   auto f_copy= f;

Тип лямбды является ``constexpr``, если все поля лямбды являются ``constexpr`` типами.
При этом отдельно существует ``constexpr`` свойство для оператора ``()`` - оно выводится по тем же правилам, что и для шаблонных функций.
Из этого следует, что можно объявить объект-лямбду как ``constexpr``, но вызвать как ``constexpr`` его будет нельзя, если оператор ``()`` не является ``constexpr``.

.. code-block:: u_spr

   // Объект лямбды является "constexpr".
   auto constexpr f= lambda() { unsafe{} };
   // А вот вызов этой лямбды уже не может быть "constexpr", т. к. лямбда содержит "unsafe" блок внутри.
   f();

Для классов лямбд создаются внутренние ссылочные теги.
Под каждую захваченную по ссылке переменную создаётся свой тег.
Также создаются уникальные теги под каждый внутренний тег захваченных по значению переменных.

.. code-block:: u_spr

   auto x= 0;
   auto f= lambda[&]() : i32 { return x; };
   static_assert( typeinfo</ typeof(f) />.reference_tag_count == 1s );

Оператор ``()`` лямбды принимает ``this`` как неизменяемую ссылку.
Поэтому в лямбдах нельзя менять захваченные по значению переменные.
Сам ``this`` оператора ``()`` в лямбдах не доступен.

.. code-block:: u_spr

   auto mut x= 0;
   auto f=
       lambda[=]()
       {
           auto& this_ref= this; // Ошибка - "this" не доступен.
           ++x; // Ошибка - нельзя изменить захваченную по значению переменную.
       };

Лямбды не могут захватывать ``this`` внутри методов с ``this`` параметром.
Не могут быть захвачены и отдельные поля структур/классов.
Но можно создать локальные копии/ссылки для ``this`` или его частей, и уже их захватить в лямбду.

.. code-block:: u_spr

   struct S
   {
       i32 x;
       fn Foo( this )
       {
           auto& x_ref= x; // Создаём локальную ссылку на поле структуры.
           auto f=
               lambda[&]() : i32
               {
                   return x_ref; // Захватываем локальную ссылку.
               };
           f();
       }
   }

Из лямбды, вложенной в другую лямбду, не работает захват переменных внешних по отношению ко внешней лямбде.
Но можно внутри внешней лямбды создать ссылку/копию для такой переменной и захватить уже её из внутренней лямбды.

.. code-block:: u_spr

   auto x= 123;
   auto f0=
       lambda[=]() : i32
       {
           auto x_copy= x; // Захватываем внешнюю по отношению к "f0" переменную.
           auto f1=
               lambda[=]() : i32
               {
                   return x_copy; // Захватываем внешнюю по отношению к "f1" переменную.
               };
           return f1();
       };

Важное свойство лямбд, отличающее их от других функций - автовывод ссылочной нотации.
Поэтому вручную её указывать не надо.

.. code-block:: u_spr

   // Автоматически будет вычислено, что лямбда возвращает ссылку на параметр #0.
   auto f= lambda( i32& x ) : i32& { return x; };
