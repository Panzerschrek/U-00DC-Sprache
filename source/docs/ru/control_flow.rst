Поток управления
================

В Ü существует ряд конструкций по управлению потоком управления.

*********
*Условия*
*********

Оператор ``if`` позволяет выполнить какой-либо участок кода только при выполнение какого-то условия.
Условие в операторе ``if`` должно иметь тип ``bool``.

.. code-block:: u_spr

   if( x > y )
   {
       ++x;
   }

Можно указать действие, которое будет выполнено в случае, если условие не выполнилось:

.. code-block:: u_spr

   if( x > y )
   {
       ++x;
   }
   else
   {
       ++y;
   }

Можно указать несколько условий и действий при их выполнении:

.. code-block:: u_spr

   if( x > y )
   {
       ++x;
   }
   else if( y > x )
   {
       ++y;
   }
   else if( z )
   {
       return;
   }
   else
   {
       ++x;
       ++y;
   }

*********************
*Статические условия*
*********************

Существует особый вид условного оператора - ``static_if``. Он принимает только ``constexpr`` выражения в качестве условий.
Соотвественно, какая ветвь условия будет выполнятся - определяется статически, при компиляции.
Ветви, которые не должны исполняться, компилироваться не вообще будут.

.. code-block:: u_spr

   static_if( typeinfo</size_type/>.size_of == 8s )
   {
       return 0; // Скомпилируется или эта ветвь
   }
   else if( typeinfo</size_type/>.size_of == 4s )
   {
       return 1; // Или эта
   }
   else
   {
       // В экзотических случаях может скомпилироваться и эта ветвь
       static_assert(false); // но компиляция упадёт на этом ассерте
       halt;
   }

************
*Цикл while*
************

Оператор ``while`` позволяет выполнять какие-либо действия, пока условие истинно.
Условие в операторе ``while`` должно иметь тип ``bool``.

.. code-block:: u_spr

   while( x > 0 )
   {
       --x;
   }

Можно выйти из цикла преждевременно, используя оператор ``break``:

.. code-block:: u_spr

   while( x > 0 )
   {
       x /= 5;
       if( x == 1 )
       {
           break;
       }
   }

Можно перейти к следующей итерации цикла, используя оператор ``continue``:

.. code-block:: u_spr

   while( x > 0 )
   {
       x /= 3;
       if( x == 5 )
       {
           continue;
       }
       --x;
   }

**********
*Цикл for*
**********

Также в Ü есть цикл ``for``, похожий на таковой в C++.
Состоит он из трёх частей - части объявления переменных, части условия и части операций конца итерации. Части разделяются при помощи ``;``.
Каждая часть является опциональной, если не указана часть условия, цикл будет выполняться бесконечно или завершится при помощи ``break``.
Цикл for позволяет выполнить какое-либо действие в конце итерации всегда, каждый оператор ``continue`` будет осуществлять переход на действие в конце итерации.

Примеры цикла ``for``:

.. code-block:: u_spr

   auto mut x= 0;
   for( auto mut i= 0; i < 10; ++i )  // Объявление переменных через auto
   {
      x+= i * i;
   }

.. code-block:: u_spr

   auto mut x= 0;
   for( var i32 mut i= 0, mut j= 2; i < 5; ++i, j*= 2 ) // Объявление переменных через var, более одного действия в конце итерации
   {
      x+= i * j;
   }

.. code-block:: u_spr

   for( auto mut i = 1; ; i <<= 1u ) // Цикл с пустым условием
   {
      if( i < 0 ){ break; }
   }

.. code-block:: u_spr

   for( ; ; ) // Цикл совсем без всего
   {
      break;
   }

.. code-block:: u_spr

   for( var u32 mut x= 0u; x < 100u; ++x )
   {
      if( SomeFunc(x) ){ continue; } // После continue будет вызван код ++x
      SomeFunc2(x);
   }

********************
*Возврат из функции*
********************

Исполнение функции, не возвращающей значение, заканчивается, когда поток исполнения достигает конца тела функции.
Если зачем-то нужно завершить исполнение функции раньше, можно использовать оператор ``return``.

.. code-block:: u_spr

   fn Clamp( i32 &mut x )
   {
       if( x >= 0 )
       {
           return;
       }
       x= 0;
   }

Функции, возвращающие значения, должны завершаться во всех случаях оператором ``return`` со значением.
Тип значения в операторе ``return`` должен совпадать с типом возвращаемого значения функции.

.. code-block:: u_spr

   fn Add( i32 x, i32 y ) : i32
   {
       return x + y;
   }

Компилятор проверяет, во всех ли случаях функция возвращает значение, и, если это не так, будет порождена ошибка.

.. code-block:: u_spr

   fn Clamp( i32 &mut x ) : bool
   {
       if( x >= 0 )
       {
           return false;
       }
       x= 0;
       // Ошибка, функция возвращает значение не во всех случаях.
   }

.. code-block:: u_spr

   fn Clamp( i32 &mut x ) : bool
   {
       if( x >= 0 )
       {
           return false;
       }
       else
       {
           x= 0;
           return true;
       }
       // Всё в порядке, функция возвращает значение всегда
   }
