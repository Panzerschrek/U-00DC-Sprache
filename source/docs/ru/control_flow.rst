Поток управления
================

В Ü существует ряд конструкций по управлению потоком управления.

*********
*Условия*
*********

Оператор ``if`` позволяет выполнить какой-либо участок кода только при выполнение какого-то условия.
Условие в операторе ``if`` должно иметь тип ``bool``.

.. code-block:: u_spr

   if( x > y )
   {
       ++x;
   }

Можно указать действие, которое будет выполнено в случае, если условие не выполнилось:

.. code-block:: u_spr

   if( x > y )
   {
       ++x;
   }
   else
   {
       ++y;
   }

Можно указать несколько условий и действий при их выполнении:

.. code-block:: u_spr

   if( x > y )
   {
       ++x;
   }
   else if( y > x )
   {
       ++y;
   }
   else if( z )
   {
       return;
   }
   else
   {
       ++x;
       ++y;
   }

*********************
*Статические условия*
*********************

Существует особый вид условного оператора - ``static_if``. Он принимает только ``constexpr`` выражения в качестве условий.
Соотвественно, какая ветвь условия будет выполнятся - определяется статически, при компиляции.
Ветви, которые не должны исполняться, компилироваться не вообще будут.

.. code-block:: u_spr

   static_if( typeinfo</size_type/>.size_of == 8s )
   {
       return 0; // Скомпилируется или эта ветвь
   }
   else static_if( typeinfo</size_type/>.size_of == 4s )
   {
       return 1; // Или эта
   }
   else
   {
       // В экзотических случаях может скомпилироваться и эта ветвь
       static_assert(false); // но компиляция упадёт на этом ассерте
       halt;
   }

************************
*Комбинирование условий*
************************

Условные операторы различных видов - ``if``, ``static_if`` а также :ref:`if-coro-advance` можно комбинировать друг с другом любым образом.
После ``else`` любого из этих операторов может следовать любой другой из этих операторов.
Фактически добавление любого из условных операторов после ``else`` аналогично добавлению блока после ``else``, содержащего внутри этот оператор.

К примеру, такой код:

.. code-block:: u_spr

   static_if( static_condition )
   {
       Action0();
   }
   else if( dynamic_condition )
   {
       Action1();
   }
   else if_coro_advance( x : some_gen )
   {
       Action2(x);
   }
   else
   {
       Action3(x);
   }

Эквивалентен такому коду:

.. code-block:: u_spr

   static_if( static_condition )
   {
       Action0();
   }
   else
   {
       if( dynamic_condition )
       {
           Action1()
       }
       else
       {
           if_coro_advance( x : some_gen )
           {
               Action2(x);
           }
           else
           {
               Action3(x);
           }
       }
   }


************
*Цикл while*
************

Оператор ``while`` позволяет выполнять какие-либо действия, пока условие истинно.
Условие в операторе ``while`` должно иметь тип ``bool``.

.. code-block:: u_spr

   while( x > 0 )
   {
       --x;
   }

Можно выйти из цикла преждевременно, используя оператор ``break``:

.. code-block:: u_spr

   while( x > 0 )
   {
       x /= 5;
       if( x == 1 )
       {
           break;
       }
   }

Можно перейти к следующей итерации цикла, используя оператор ``continue``:

.. code-block:: u_spr

   while( x > 0 )
   {
       x /= 3;
       if( x == 5 )
       {
           continue;
       }
       --x;
   }

Цикл ``while`` (а также циклы других типов) можно пометить меткой (с использованием ключевого слова ``label``) и использовать эту метку в ``break`` и ``continue``.
Таким образом можно реализовать продолжение внешнего цикла или выход из внешнего цикла.

.. code-block:: u_spr

   while( Cond0() ) label outer
   {
       while( Cond1() )
       {
           if( Cond2() )
           {
               continue label outer; // продолжить внешний цикл
           }
           if( Cond3() )
           {
               break label outer; // завершить внешний цикл
           }
       }
   }


**********
*Цикл for*
**********

Также в Ü есть цикл ``for``, похожий на таковой в C++.
Состоит он из трёх частей - части объявления переменных, части условия и части операций конца итерации. Части разделяются при помощи ``;``.
Каждая часть является опциональной, если не указана часть условия, цикл будет выполняться бесконечно или завершится при помощи ``break``.
Цикл for позволяет выполнить какое-либо действие в конце итерации всегда, каждый оператор ``continue`` будет осуществлять переход на действие в конце итерации.

Примеры цикла ``for``:

.. code-block:: u_spr

   auto mut x= 0;
   for( auto mut i= 0; i < 10; ++i )  // Объявление переменных через auto
   {
      x+= i * i;
   }

.. code-block:: u_spr

   auto mut x= 0;
   for( var i32 mut i= 0, mut j= 2; i < 5; ++i, j*= 2 ) // Объявление переменных через var, более одного действия в конце итерации
   {
      x+= i * j;
   }

.. code-block:: u_spr

   for( auto mut i = 1; ; i <<= 1u ) // Цикл с пустым условием
   {
      if( i < 0 ){ break; }
   }

.. code-block:: u_spr

   for( ; ; ) // Цикл совсем без всего
   {
      break;
   }

.. code-block:: u_spr

   for( var u32 mut x= 0u; x < 100u; ++x )
   {
      if( SomeFunc(x) ){ continue; } // После continue будет вызван код ++x
      SomeFunc2(x);
   }

***********
*Цикл loop*
***********

В Ü есть цикл ``loop``, который является самым простым (безусловным) циклом.
Он не содержит даже условия и в этом плане отчасти эквивалентен циклу ``while`` с условием, всегда равным ``true``.
Завершить такой цикл можно только при помощи операторов ``break`` и ``return``, ну или ``continue`` к метке внешнего цикла.
Имеет смысл использовать этот цикл, когда условие завершение цикла вычислимо только в блоке самого цикла.

.. code-block:: u_spr

   loop
   {
      // Some code
      if( SomeCondition() )
      {
         break;
      }
   }

Важной особенностью цикла ``loop`` является тот факт, что если тело цикла не содержит ``break`` операторов (относящихся к этому циклу), код после этого цикла считается недостижимым.

.. code-block:: u_spr

   loop
   {
      if( SomeCondition() )
      {
         return;
      }
   }
   auto x = 0; // Компилятор породит здесь ошибку, т. к. этот код недостижим.

********************
*Возврат из функции*
********************

Исполнение функции, не возвращающей значение, заканчивается, когда поток исполнения достигает конца тела функции.
Если зачем-то нужно завершить исполнение функции раньше, можно использовать оператор ``return``.

.. code-block:: u_spr

   fn Clamp( i32 &mut x )
   {
       if( x >= 0 )
       {
           return;
       }
       x= 0;
   }

Функции, возвращающие значения, должны завершаться во всех случаях оператором ``return`` со значением.
Тип значения в операторе ``return`` должен совпадать с типом возвращаемого значения функции.

.. code-block:: u_spr

   fn Add( i32 x, i32 y ) : i32
   {
       return x + y;
   }

Компилятор проверяет, во всех ли случаях функция возвращает значение, и, если это не так, будет порождена ошибка.

.. code-block:: u_spr

   fn Clamp( i32 &mut x ) : bool
   {
       if( x >= 0 )
       {
           return false;
       }
       x= 0;
       // Ошибка, функция возвращает значение не во всех случаях.
   }

.. code-block:: u_spr

   fn Clamp( i32 &mut x ) : bool
   {
       if( x >= 0 )
       {
           return false;
       }
       else
       {
           x= 0;
           return true;
       }
       // Всё в порядке, функция возвращает значение всегда
   }
