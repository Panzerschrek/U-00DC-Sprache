Lambdas
=======

Lambdas in Ü are nameless functional objects that are defined in expression context.
They may be used as functions (may be called).

A lambda is declared with usage of the ``lambda`` keyword, after that follow parameters/return value and other function attributes.
Further follows a lambda body.
There are no any lambda body limitations - all constructions as in normal functions are allowed.

.. code-block:: u_spr

   auto f= lambda( i32 x ) : i32 { return x / 3; };

A lambda expression result is a value of a lambda type.
This type is a generated by the compiler class, which is unique for each lambda.
This class has overloaded ``()`` operator, which is created from the specified lambda body.


*******************
*Variables capture*
*******************

One of the important lambda features in Ü is the possibility to capture local variables and function arguments from the surrounding context.
``[=]`` after the ``lambda`` keyword should be specified in order to do this.

.. code-block:: u_spr

   var i32 scale= 11;
   auto f= lambda[=]( i32 x ) : i32 { return x * scale; };

If ``[=]`` is used, the compiler will find all usages of external variables.
When a lambda object is constructed, all these variables are copied into it.
Such captured variables become effectively hidden lambda class fields.

Since with usage of ``[=]`` variables are copied into the lambda, they may be modified or even destroyed, but this will not affect the lambda object.

.. code-block:: u_spr

   var i32 mut scale= 11;
   auto f= lambda[=]( i32 x ) : i32 { return x * scale; };
   scale= 0; // Change the source variable
   halt if( f( 5 ) != 55 ); // Lambda still contains a copy of the old variable value


********************
*References capture*
********************

It's also possible to define a lambda that captures references to variables instead of making copies.
Mutability of these references is determined by the mutability of source variables.
Captured by reference variables become reference fields in the lambda class.

.. code-block:: u_spr

   var f32 mut x= 0.0f;
   {
       auto f= lambda[&]() { x += 1.0f; }; // "x" variable is captured by mutable reference and will be modified in lambda call.
       f();
       f();
   }
   halt if( x != 2.0f ); // "x" variable should have new value after lambda calls.

All reference checking rules work for lambdas that capture references, as for any other types with references inside.


*******************************
*Lambdas functionality details*
*******************************

A lambda class is generated and has no accessible by the programmer name.
But this doesn't prevent any usage of lambdas.
Templates work with lambdas fine - as with any other types.
For a lambda variable declaration ``auto`` may be used.
Also it's possible to use ``typeof``.

.. code-block:: u_spr

   auto f= lambda(){};
   var typeof(f) f_copy= f;

Lambdas with captures are just classes with fields that correspond to captured variables.
For captured by value variables destructors are called properly.
Copy constructor and copy assignment operator may or may not be generated depending on captured variable types.
``non_sync`` tag for lambdas is calculated based on captured variable types.

.. code-block:: u_spr

   var i32 x= 0, y= 0;
   auto f= lambda[=]() : i32 { return x + y; };
   static_assert( typeinfo</ typeof(f) />.size_of == typeinfo</i32/>.size_of * 2s );
   auto f_copy= f;

A lambda type is ``constexpr`` if all lambda fields are of ``constexpr`` types.
Additionally there is ``constexpr`` property for lambda ``()`` operator - it is calculated exactly like for template functions.
Because of that it's possible to define a lambda object as ``constexpr``, but it may not be possible to call it in ``constexpr`` context, if ``()`` operator is not ``constexpr``.

.. code-block:: u_spr

   // Lambda object is "constexpr".
   auto constexpr f= lambda() { unsafe{} };
   // But a call of this lambda can't be "constexpr", because the lambda body contains "unsafe" block inside.
   f();

Inner reference tags are created for lambda classes.
For each captured by reference variable its own reference tag is created.
Also unique reference tags are created for each inner reference tag of a captured by value variable.

.. code-block:: u_spr

   auto x= 0;
   auto f= lambda[&]() : i32 { return x; };
   static_assert( typeinfo</ typeof(f) />.reference_tag_count == 1s );


``()`` operator of a lambda has ``this`` parameter as immutable reference.
Thus it's not possible to change captured by value variables inside a lambda.
``this`` itself of the ``()`` in lambdas is unavailable.

.. code-block:: u_spr

   auto mut x= 0;
   auto f=
       lambda[=]()
       {
           auto& this_ref= this; // Error - "this" is unavailable.
           ++x; // Error - can't change captured by value variable.
       };

Lambdas can't capture ``this`` in methods with ``this`` parameter.
Fields of structs and classes can't be captured directly either.
But it's possible to create local variables/references for ``this`` or its parts and capture them.

.. code-block:: u_spr

   struct S
   {
       i32 x;
       fn Foo( this )
       {
           auto& x_ref= x; // Create a local reference for the struct field.
           auto f=
               lambda[&]() : i32
               {
                   return x_ref; // Capture a local reference.
               };
           f();
       }
   }

From a lambda that is inside another lambda it's not possible to capture a variable that is external relative to the outer lambda.
But it's possible to create a reference/copy for such variable in the outer lambda and capture it in the inner lambda.

.. code-block:: u_spr

   auto x= 123;
   auto f0=
       lambda[=]() : i32
       {
           auto x_copy= x; // Capture an external relative to "f0" variable.
           auto f1=
               lambda[=]() : i32
               {
                   return x_copy; // Capture an external relative to "f1" variable.
               };
           return f1();
       };

The important lambdas property that is different from other functions is the auto reference notation calculation.
Thus it's unnecessary to specify reference notation for lambdas manually.

.. code-block:: u_spr

   // It will be calculated that this lambda returns a reference to parameter #0.
   auto f= lambda( i32& x ) : i32& { return x; };
