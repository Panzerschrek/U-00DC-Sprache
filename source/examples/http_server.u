import "/main_wrapper.u"
import "/stdout.u"
import "/string_conversions.u"
import "/tcp_listener.u"

pretty_main
{
	var ust::socket_address_v4 address( ust::ip_address_v4( 0u ), 57854u16 );

	ust::stdout_print(
		ust::concat(
			"starting TCP server listening on address ",
			address.get_ip().to_string(),
			" and port ",
			ust::to_string8( address.get_port() ),
			"\n",
			"Press Ctrl+C to stop it\n" ) );

	var ust::tcp_listener mut listener= ust::tcp_listener::create_and_bind( address ).try_take();

	loop
	{
		auto [ mut stream, client_address ] = listener.accept().try_take();

		if_var( &a_v4 : client_address.get</ust::socket_address_v4/>() )
		{
			ust::stdout_print( ust::concat( "Incoming connection from ", a_v4.get_ip().to_string(), "\n" ) );
		}
		if_var( &a_v6 : client_address.get</ust::socket_address_v4/>() )
		{
			ust::stdout_print( ust::concat( "Incoming connection from ", a_v6.get_ip().to_string(), "\n" ) );
		}

		WriteAll( stream, g_http_response_status_line );
		WriteAll( stream, g_http_respense_headers );
		WriteAll( stream, g_http_respense_header_end_marker );
		WriteAll( stream, g_html_page_contents );
	}
}

fn WriteAll( ust::tcp_stream &mut stream, ust::string_view8 message )
{
	for( auto mut offset= 0s; offset < message.size(); )
	{
		var size_type bytes_written= stream.write( CastRangeToBytesRange( message ).subrange_start( offset ) ).try_take();
		offset+= bytes_written;
	}
}

auto& g_http_line_end= "\r\n";

auto g_http_response_status_line= "HTTP/1.1 200 OK" + g_http_line_end;
auto g_http_respense_headers= "Content-Type: text/html" + g_http_line_end;
auto g_http_respense_header_end_marker= g_http_line_end;

auto g_html_page_contents=
"<html>" +
	"<head>" +
	"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />" +
	"</head>" +
	"<body>" +
		"Simple HTTP server example<br>" +
		"Einfaches Beispiel eines HTTP-Servers<br>" +
		"Простой пример HTTP сервера<br>" +
	"</body>" +
"</html>" +
g_http_line_end;

// It's safe to cast between ranges of chars and bytes.
// TODO - create a library function for this?
template</bool is_mutable/>
fn CastRangeToBytesRange( ust::random_access_range</char8, is_mutable/> r ) : ust::random_access_range</byte8, is_mutable/>
{
	return unsafe( ust::random_access_range</byte8, is_mutable/>( ust::ptr_cast_to_byte8( r.data() ), r.size() ) );
}
