// This example demonstraits usage of TCP listener class, which is used to implement a simple HTTP server.

import "/main_wrapper.u"
import "/stdout.u"
import "/string_conversions.u"
import "/tcp_listener.u"

pretty_main
{
	// Use ipv4 address, but ipv6 addresses may be used too.
	var ust::socket_address_v4 address( ust::ip_address_v4( ust::make_array( 127u8, 0u8, 0u8, 1u8 ) ), 57854u16 );

	ust::stdout_print(
		ust::concat(
			"starting TCP server listening on address ",
			address.get_ip().to_string(),
			" and port ",
			ust::to_string8( address.get_port() ),
			"\n" ) );

	ust::stdout_print(
		ust::concat(
			"Open it in browser via link like \"http://",
			address.get_ip().to_string(),
			":",
			ust::to_string8( address.get_port() ),
			"\"\n",
			"Press Ctrl+C to stop it\n" ) );

	// Create listener port.
	var ust::tcp_listener mut listener= ust::tcp_listener::create_and_bind( address ).try_take();

	// Connections accept loop.
	loop
	{
		auto [ mut stream, client_address ] = listener.accept().try_take();

		if_var( &a_v4 : client_address.get</ust::socket_address_v4/>() )
		{
			ust::stdout_print( ust::concat( "Incoming connection from ", a_v4.get_ip().to_string(), "\n" ) );
		}
		if_var( &a_v6 : client_address.get</ust::socket_address_v4/>() )
		{
			ust::stdout_print( ust::concat( "Incoming connection from ", a_v6.get_ip().to_string(), "\n" ) );
		}

		// In this simple example we handle each connection synchronously.
		// But generally it's preffered to move request processing into another thread(s).

		// Status lines goes first.
		WriteAll( stream, g_http_response_status_line );
		// Then headers follow.
		WriteAll( stream, g_http_respense_headers );
		WriteAll( stream, ust::concat( "Content-Length: ", ust::to_string8( typeinfo</ typeof(g_html_page_contents) />.size_of ), g_http_line_end ) );
		// Actual message is separated via empty line.
		WriteAll( stream, g_http_respense_header_end_marker );
		// Actual HTML page (or some other contents).
		WriteAll( stream, g_html_page_contents );
	}
}

fn WriteAll( ust::tcp_stream &mut stream, ust::string_view8 message )
{
	// Write in loop, since sometimes the whole message at once can't be written.
	for( auto mut offset= 0s; offset < message.size(); )
	{
		var size_type bytes_written= stream.write( CastRangeToBytesRange( message ).subrange_start( offset ) ).try_take();
		offset+= bytes_written;
	}
}

auto& g_http_line_end= "\r\n";

auto g_http_response_status_line= "HTTP/1.1 200 OK" + g_http_line_end;
auto g_http_respense_headers= "Content-Type: text/html" + g_http_line_end;
auto g_http_respense_header_end_marker= g_http_line_end;

auto g_html_page_contents=
"<html>" +
	"<head>" +
	"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />" +
	"</head>" +
	"<body>" +
		"Simple HTTP server example<br>" +
		"Einfaches Beispiel eines HTTP-Servers<br>" +
		"Простой пример HTTP сервера<br>" +
	"</body>" +
"</html>" +
g_http_line_end;

// It's safe to cast between ranges of chars and bytes.
// TODO - create a library function for this?
template</bool is_mutable/>
fn CastRangeToBytesRange( ust::random_access_range</char8, is_mutable/> r ) : ust::random_access_range</byte8, is_mutable/>
{
	return unsafe( ust::random_access_range</byte8, is_mutable/>( ust::ptr_cast_to_byte8( r.data() ), r.size() ) );
}
