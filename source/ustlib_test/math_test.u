//##success_test
import "../ustlib/math.u"

auto constexpr MyNan= ust::nan</f32/>();

template</type T/>
fn ExpectNear( T a, T b, T eps )
{
	halt if( eps < T(0) );

	auto diff= a - b;
	if( diff < T(0) )
	{ halt if( diff < -eps ); }
	else
	{ halt if( diff > +eps ); }
}

template</type T/>
fn DoTest()
{
	halt if( ust::nan</T/>() == ust::nan</T/>() );
	halt if( ust::nan</T/>() == T(0.0) );

	// inf
	halt if( ust:: plus_inf</T/>() != ust:: plus_inf</T/>() );
	halt if( ust::minus_inf</T/>() != ust::minus_inf</T/>() );
	halt if( ust:: plus_inf</T/>() <= T(0.0) );
	halt if( ust::minus_inf</T/>() >= T(0.0) );
	halt if( ust::minus_inf</T/>() >= ust::plus_inf</T/>() );

	// sqrt
	halt if( ust::sqrt( T(0.0) ) != T(0.0) );
	halt if( ust::sqrt( T(-0.0) ) != T(0.0) );
	halt if( ust::sqrt( T(1.0) ) != T(1.0) );
	halt if( ust::sqrt( T(4.0) ) != T(2.0) );
	halt if( ust::sqrt( T(9.0) ) != T(3.0) );
	halt if( ust::sqrt( T(10000.0) ) != T(100.0) );
	halt if( ust::sqrt( T(0.09) ) != T(0.3) );
	halt if( ust::sqrt( T(40.96) ) != T(6.4) );
	halt if( ust::sqrt( T(-1.0) ) == ust::sqrt( T(-1.0) ) ); // result for negative values is nan
	halt if( ust::sqrt( ust::nan</T/>() ) == ust::sqrt( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::sqrt( ust:: plus_inf</T/>() ) != ust::sqrt( ust:: plus_inf</T/>() ) ); // result for infinity is infinity
	halt if( ust::sqrt( ust::minus_inf</T/>() ) == ust::sqrt( ust::minus_inf</T/>() ) ); // result for minus infinity is nan

	// exp
	halt if( ust::exp( T(0.0) ) != T(1.0) );
	ExpectNear( ust::exp( T(+1) ), T(2.718281828), T(1.0e-5) );
	ExpectNear( ust::exp( T(-1) ), T(1.0 / 2.718281828), T(1.0e-5) );
	ExpectNear( ust::exp( T(+1) ), T(2.718281828), T(1.0e-5) );
	ExpectNear( ust::exp( T(2.302585) ), T(10), T(1.0e-5) );
	halt if( ust::exp( ust::nan</T/>() ) == ust::exp( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::exp( ust:: plus_inf</T/>() ) != ust::plus_inf</T/>() ); // result for infinity is infinity
	halt if( ust::exp( ust::minus_inf</T/>() ) != T(0) ); // result for minus infinity is zero

	// exp2
	halt if( ust::exp2( T(0.0) ) != T(1.0) );
	halt if( ust::exp2( T(1.0) ) != T(2.0) );
	halt if( ust::exp2( T(-1.0) ) != T(0.5) );
	halt if( ust::exp2( T(2.0) ) != T(4.0) );
	halt if( ust::exp2( T(10.0) ) != T(1024.0) );
	ExpectNear( ust::exp2( T(6.643856) ), T(100.0), T(1.0e-3) );
	halt if( ust::exp2( ust::nan</T/>() ) == ust::exp2( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::exp2( ust:: plus_inf</T/>() ) != ust::plus_inf</T/>() ); // result for infinity is infinity
	halt if( ust::exp2( ust::minus_inf</T/>() ) != T(0) ); // result for minus infinity is zero

	// log
	halt if( ust::log( T(0.0) ) >= T(-1e24) );
	halt if( ust::log( T(1.0) ) != T(0.0) );
	ExpectNear( ust::log( T(2.718281828) ), T(1.0), T(1.0e-5) );
	ExpectNear( ust::log( T(10.0) ), T(2.302585), T(1.0e-5) );
	halt if( ust::log( ust::nan</T/>() ) == ust::log( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::log( T(-1) ) == ust::log( T(-1) ) ); // result for negative value is nan
	halt if( ust::log( ust::minus_inf</T/>() ) == ust::log( ust::minus_inf</T/>() ) ); // result for minus infinity is nan
	halt if( ust::log( ust::plus_inf</T/>() ) != ust::log( ust::plus_inf</T/>() ) ); // result for infinity is infinity

	// log2
	halt if( ust::log2( T(0.0) ) >= T(-1e24) );
	halt if( ust::log2( T(1.0) ) != T(0.0) );
	ExpectNear( ust::log2( T(2.0) ), T(1.0), T(1.0e-5) );
	ExpectNear( ust::log2( T(4.0) ), T(2.0), T(1.0e-5) );
	ExpectNear( ust::log2( T(1024.0) ), T(10.0), T(1.0e-5) );
	ExpectNear( ust::log2( T(100.0) ), T(6.643856), T(1.0e-5) );
	halt if( ust::log2( ust::nan</T/>() ) == ust::log2( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::log2( T(-1) ) == ust::log2( T(-1) ) ); // result for negative value is nan
	halt if( ust::log2( ust::minus_inf</T/>() ) == ust::log2( ust::minus_inf</T/>() ) ); // result for minus infinity is nan
	halt if( ust::log2( ust::plus_inf</T/>() ) != ust::log2( ust::plus_inf</T/>() ) ); // result for infinity is infinity

	var T pi(3.1415926535);
	auto two_pi= T(2.0) * pi;
	auto pi2= pi / T(2);
	auto pi3= pi / T(3);
	auto pi4= pi / T(4);
	auto pi6= pi / T(6);
	var T half_sqrt2= ust::sqrt( T(2.0) ) / T(2.0);
	var T half_sqrt3= ust::sqrt( T(3.0) ) / T(2.0);

	// sin
	halt if( ust::sin( T(0.0) ) != T(0.0) );
	ExpectNear( ust::sin( pi6 ), T(0.5), T(1.0e-5) );
	ExpectNear( ust::sin( pi4 ), half_sqrt2, T(1.0e-5) );
	ExpectNear( ust::sin( two_pi + pi4 ), half_sqrt2, T(1.0e-5) );
	ExpectNear( ust::sin( pi3 ), half_sqrt3, T(1.0e-5) );
	ExpectNear( ust::sin( two_pi + pi3 ), half_sqrt3, T(1.0e-5) );
	ExpectNear( ust::sin( pi2 ), T(1.0), T(1.0e-5) );
	ExpectNear( ust::sin( pi ), T(0.0), T(1.0e-5) );
	ExpectNear( ust::sin( -pi2 ), T(-1.0), T(1.0e-5) );
	halt if( ust::sin( ust::nan</T/>() ) == ust::sin( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::sin( ust::plus_inf </T/>() ) == ust::sin( ust::plus_inf </T/>() ) ); // result for infinity is nan
	halt if( ust::sin( ust::minus_inf</T/>() ) == ust::sin( ust::minus_inf</T/>() ) ); // result for minus infinity is nan

	// cos
	halt if( ust::cos( T(0.0) ) != T(1.0) );
	ExpectNear( ust::cos( pi6 ), half_sqrt3, T(1.0e-5) );
	ExpectNear( ust::cos( pi4 ), half_sqrt2, T(1.0e-5) );
	ExpectNear( ust::cos( two_pi + pi4 ), half_sqrt2, T(1.0e-5) );
	ExpectNear( ust::cos( pi3 ), T(0.5), T(1.0e-5) );
	ExpectNear( ust::cos( two_pi + pi3 ), T(0.5), T(1.0e-5) );
	ExpectNear( ust::cos( pi2 ), T(0.0), T(1.0e-5) );
	ExpectNear( ust::cos( pi ), T(-1.0), T(1.0e-5) );
	ExpectNear( ust::cos( -pi2 ), T(0.0), T(1.0e-5) );
	halt if( ust::cos( ust::nan</T/>() ) == ust::cos( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::cos( ust::plus_inf </T/>() ) == ust::cos( ust::plus_inf </T/>() ) ); // result for infinity is nan
	halt if( ust::cos( ust::minus_inf</T/>() ) == ust::cos( ust::minus_inf</T/>() ) ); // result for minus infinity is nan

	// tan
	halt if( ust::tan( T(0.0) ) != T(0.0) );
	ExpectNear( ust::tan( pi6 ), T(1.0) / ust::sqrt( T(3.0) ), T(1.0e-5) );
	ExpectNear( ust::tan( pi4 ), T(1.0), T(1.0e-5) );
	ExpectNear( ust::tan( pi + pi4 ), T(1.0), T(1.0e-5) );
	ExpectNear( ust::tan( pi3 ), ust::sqrt( T(3.0) ), T(1.0e-5) );
	ExpectNear( ust::tan( pi + pi3 ), ust::sqrt( T(3.0) ), T(1.0e-5) );
	ExpectNear( ust::tan( pi ), T(0.0), T(1.0e-5) );
	halt if( ust::tan( ust::nan</T/>() ) == ust::tan( ust::nan</T/>() ) ); // result for nan is nan
	halt if( ust::tan( ust::plus_inf </T/>() ) == ust::tan( ust::plus_inf </T/>() ) ); // result for infinity is nan
	halt if( ust::tan( ust::minus_inf</T/>() ) == ust::tan( ust::minus_inf</T/>() ) ); // result for minus infinity is nan
}

fn U_Main() : i32
{
	DoTest</f32/>();
	DoTest</f64/>();

	return 0;
}
