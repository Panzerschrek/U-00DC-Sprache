//##success_test
import "../ustlib/assert.u"
import "../ustlib/scoped_array.u"
import "../ustlib/string.u"

struct DefaultConstructible
{
	f32 x= -8.5f;
	u32 y= 5555u;
}

// This container is lightweight - contains only pointer and size.
static_assert(
	typeinfo</ ust::array_over_external_memory</i32/> />.size_of ==
	2s * typeinfo</size_type/>.size_of );

fn nomangle main() : i32
{
	{ // Filler constructor.
		auto arr= unsafe( ust::array_over_external_memory</i32/>( alloca</i32/>(8s), 8s, 33 ) );
		assert( arr.size() == 8s );
		assert( !arr.empty() );
		foreach( x : arr )
		{
			assert( x == 33 );
		}
	}
	{ // Filler constructor for zero elements.
		auto arr= unsafe( ust::array_over_external_memory</i32/>( alloca</i32/>(0s), 0s, 33 ) );
		assert( arr.size() == 0s );
	}

	{ // Default constructor.
		auto arr= unsafe( ust::array_over_external_memory</DefaultConstructible/>( alloca</DefaultConstructible/>(3s), 3s ) );
		assert( arr.size() == 3s );
		assert( !arr.empty() );
		foreach( &s : arr )
		{
			assert( s.x == -8.5f );
			assert( s.y == 5555u );
		}
	}
	{ // Default constructor with zero elements.
		auto arr= unsafe( ust::array_over_external_memory</DefaultConstructible/>( alloca</DefaultConstructible/>(0s), 0s ) );
		assert( arr.size() == 0s );
		assert( arr.empty() );
	}
	{ // Construct from iterator.
		var [ ust::string8, 3 ] strings[ "Quick", "Brown", "Fox" ];
		var ust::array_view_imut</ust::string8/> strings_view= strings;

		auto arr=
			unsafe( ust::array_over_external_memory</ust::string8/>(
				alloca</ust::string8/>(strings_view.size()),
				strings_view.size(),
				strings_view.iter() ) );

		assert( !arr.empty() );
		assert( arr.size() == 3s );
		assert( arr[0s] == "Quick" );
		assert( arr[1s] == "Brown" );
		assert( arr[2s] == "Fox" );
	}
	{ // Construct from iterator greater than needed.
		var [ f32, 5 ] floats[ 1.0f, 2.0f, 4.0f, 8.0f, 16.0f ];
		var ust::array_view_imut</f32/> floats_view= floats;

		auto arr=
			unsafe( ust::array_over_external_memory</f32/>(
				alloca</f32/>(3s),
				3s,
				floats_view.iter() ) );

		assert( !arr.empty() );
		assert( arr.size() == 3s );
		assert( arr[0s] == 1.0f );
		assert( arr[1s] == 2.0f );
		assert( arr[2s] == 4.0f );
	}
	{ // Construct mutable array.
		auto mut arr= unsafe( ust::array_over_external_memory</u32/>( alloca</u32/>(24s), 24s, 0u ) );

		assert( !arr.empty() );
		assert( arr.size() == 24s );
		for( auto mut i= 0s; i < arr.size(); ++i )
		{
			arr[i]= u32(i);
		}

		auto mut i= 0u;
		foreach( &n : arr )
		{
			assert( n == i );
			++i;
		}
	}
	{ // Front/back methods.
		var [ f32, 4 ] floats[ -1.0f, -2.0f, -4.0f, -8.0f ];
		var ust::array_view_imut</f32/> floats_view= floats;

		auto arr=
			unsafe( ust::array_over_external_memory</f32/>(
				alloca</f32/>(4s),
				4s,
				floats_view.iter() ) );

		assert( !arr.empty() );
		assert( arr.size() == 4s );
		assert( arr.front() == -1.0f );
		assert( arr.back() == -8.0f );
	}
	{ // Construct mutable array - modify it in foreach loop.
		auto mut arr= unsafe( ust::array_over_external_memory</u32/>( alloca</u32/>(5s), 5s, 0u ) );

		assert( !arr.empty() );
		assert( arr.size() == 5s );

		auto mut i= 0u;
		foreach( &mut n : arr )
		{
			n= i * i;
			++i;
		}

		assert( arr[0s] == 0u );
		assert( arr[1s] == 1u );
		assert( arr[2s] == 4u );
		assert( arr[3s] == 9u );
		assert( arr[4s] ==16u );
	}

	return 0;
}
