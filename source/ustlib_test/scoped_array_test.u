//##success_test
import "../ustlib/assert.u"
import "../ustlib/scoped_array.u"
import "../ustlib/string.u"

struct DefaultConstructible
{
	f32 x= -8.5f;
	u32 y= 5555u;
}

struct IntWrapper
{
	i32 x;
	fn conversion_constructor( i32 in_x )
		( x= in_x )
	{}
}

// This container is lightweight - contains only pointer and size.
static_assert(
	typeinfo</ ust::array_over_external_memory</i32/> />.size_of ==
	2s * typeinfo</size_type/>.size_of );

fn nomangle main() : i32
{
	{ // Filler constructor.
		auto arr= unsafe( ust::array_over_external_memory</i32/>( alloca</i32/>(8s), 8s, 33 ) );
		assert( arr.size() == 8s );
		assert( !arr.empty() );
		foreach( x : arr )
		{
			assert( x == 33 );
		}
	}
	{ // Filler constructor for zero elements.
		auto arr= unsafe( ust::array_over_external_memory</i32/>( alloca</i32/>(0s), 0s, 33 ) );
		assert( arr.size() == 0s );
	}

	{ // Default constructor.
		auto arr= unsafe( ust::array_over_external_memory</DefaultConstructible/>( alloca</DefaultConstructible/>(3s), 3s ) );
		assert( arr.size() == 3s );
		assert( !arr.empty() );
		foreach( &s : arr )
		{
			assert( s.x == -8.5f );
			assert( s.y == 5555u );
		}
	}
	{ // Default constructor with zero elements.
		auto arr= unsafe( ust::array_over_external_memory</DefaultConstructible/>( alloca</DefaultConstructible/>(0s), 0s ) );
		assert( arr.size() == 0s );
		assert( arr.empty() );
	}
	{ // Construct from iterator.
		var [ ust::string8, 3 ] strings[ "Quick", "Brown", "Fox" ];
		var ust::array_view_imut</ust::string8/> strings_view= strings;

		auto arr=
			unsafe( ust::array_over_external_memory</ust::string8/>(
				alloca</ust::string8/>(strings_view.size()),
				strings_view.size(),
				strings_view.iter() ) );

		assert( !arr.empty() );
		assert( arr.size() == 3s );
		assert( arr[0s] == "Quick" );
		assert( arr[1s] == "Brown" );
		assert( arr[2s] == "Fox" );
	}
	{ // Construct from iterator greater than needed.
		var [ f32, 5 ] floats[ 1.0f, 2.0f, 4.0f, 8.0f, 16.0f ];
		var ust::array_view_imut</f32/> floats_view= floats;

		auto arr=
			unsafe( ust::array_over_external_memory</f32/>(
				alloca</f32/>(3s),
				3s,
				floats_view.iter() ) );

		assert( !arr.empty() );
		assert( arr.size() == 3s );
		assert( arr[0s] == 1.0f );
		assert( arr[1s] == 2.0f );
		assert( arr[2s] == 4.0f );
	}
	{ // Construct mutable array.
		auto mut arr= unsafe( ust::array_over_external_memory</u32/>( alloca</u32/>(24s), 24s, 0u ) );

		assert( !arr.empty() );
		assert( arr.size() == 24s );
		for( auto mut i= 0s; i < arr.size(); ++i )
		{
			arr[i]= u32(i);
		}

		auto mut i= 0u;
		foreach( &n : arr )
		{
			assert( n == i );
			++i;
		}
	}
	{ // Front/back methods.
		var [ f32, 4 ] floats[ -1.0f, -2.0f, -4.0f, -8.0f ];
		var ust::array_view_imut</f32/> floats_view= floats;

		auto arr=
			unsafe( ust::array_over_external_memory</f32/>(
				alloca</f32/>(4s),
				4s,
				floats_view.iter() ) );

		assert( !arr.empty() );
		assert( arr.size() == 4s );
		assert( arr.front() == -1.0f );
		assert( arr.back() == -8.0f );
	}
	{ // Construct mutable array - modify it in foreach loop.
		auto mut arr= unsafe( ust::array_over_external_memory</u32/>( alloca</u32/>(5s), 5s, 0u ) );

		assert( !arr.empty() );
		assert( arr.size() == 5s );

		auto mut i= 0u;
		foreach( &mut n : arr )
		{
			n= i * i;
			++i;
		}

		assert( arr[0s] == 0u );
		assert( arr[1s] == 1u );
		assert( arr[2s] == 4u );
		assert( arr[3s] == 9u );
		assert( arr[4s] ==16u );
	}
	{ // scoped_array macro
		scoped_array( ints, i32, 40s, 878 )
		static_assert( same_type</ typeof(ints), ust::array_view_imut</i32/> /> );

		assert( ints.size() == 40s );
		assert( !ints.empty() );
		foreach( x : ints )
		{
			assert( x == 878 );
		}
	}
	{ // scoped_array macro for default-constructible type.
		scoped_array( arr, DefaultConstructible, 7s )
		static_assert( same_type</ typeof(arr), ust::array_view_imut</DefaultConstructible/> /> );

		assert( arr.size() == 7s );
		assert( !arr.empty() );
		foreach( &s : arr )
		{
			assert( s.x == -8.5f );
			assert( s.y == 5555u );
		}
	}
	{ // scoped_array for mutable array.
		scoped_array( mut squares, u32, 12s, 0u )
		static_assert( same_type</ typeof(squares), ust::array_view_mut</u32/> /> );

		assert( !squares.empty() );
		assert( squares.size() == 12s );

		auto mut i= 0u;
		foreach( &mut n : squares.iter() )
		{
			n= i * i;
			++i;
		}

		assert( squares[0s] ==   0u );
		assert( squares[1s] ==   1u );
		assert( squares[2s] ==   4u );
		assert( squares[3s] ==   9u );
		assert( squares[4s] ==  16u );
		assert( squares[10s]== 100u );
		assert( squares[11s]== 121u );
	}
	{ // scoped_array - construct from iterator.
		var [ ust::string8, 3 ] strings[ "Quick", "Brown", "Fox" ];
		var ust::array_view_imut</ust::string8/> strings_view= strings;

		scoped_array( arr, ust::string8, strings_view.size(), strings_view.iter() )
		static_assert( same_type</ typeof(arr), ust::array_view_imut</ust::string8/> /> );

		assert( !arr.empty() );
		assert( arr.size() == 3s );
		assert( arr[0s] == "Quick" );
		assert( arr[1s] == "Brown" );
		assert( arr[2s] == "Fox" );
	}
	{ // scoped_array - construct from iterator of compatible type.
		var [ i32, 4 ] ints[ 55, 66, 77, 88 ];
		var ust::array_view_imut</i32/> ints_view= ints;

		scoped_array( arr, IntWrapper, ints_view.size(), ints_view.iter() )
		static_assert( same_type</ typeof(arr), ust::array_view_imut</IntWrapper/> /> );

		assert( !arr.empty() );
		assert( arr.size() == 4s );
		assert( arr[0s] == 55 );
		assert( arr[1s] == 66 );
		assert( arr[2s] == 77 );
		assert( arr[3s] == 88 );
	}
	return 0;
}
