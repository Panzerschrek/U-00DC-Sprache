//##success_test
import "../ustlib/thread.u"
import "../ustlib/shared_mt/shared_ptr_mt_mut.u"
import "../ustlib/vector.u"

fn Bar(){}

struct CallableObject
{
	i32 &mut x;
	op()( mut this )
	{
		++x;
	}
}

fn Get42() : i32
{
	return 42;
}

struct Incrementer
{
	ust::shared_ptr_mt_mut</ i32 /> ptr;
	op()( mut this )
	{
		auto mut lock= ptr.lock_mut();
		++lock.get_ref();
	}
}

fn U_Main() : i32
{
	{
		// Can create thread for function.
		auto thread= ust::thread_create( (fn())(Bar) );
	}
	{
		// Can create thread for callable object.
		var i32 mut x= 0, mut y= 0;
		var CallableObject mut obj{ .x= x };

		{
			auto thread= ust::thread_create( move(obj) );
			// While thread is alive, we can do something.
			++y;
		}
		halt if( x != 1 );
		halt if( y != 1 );
	}
	{
		// Can het result of thread.
		var ust::thread_ret</ fn() : i32, i32 /> mut thread( (fn() : i32 )( Get42 ) );
		var i32 res= thread.join( move(thread) );
		halt if( res != 42 );
	}
	{
		var ust::shared_ptr_mt_mut</ i32 /> ptr(0);
		var size_type mut i(0);
		var ust::vector</ ust::thread</Incrementer/> /> mut threads;
		while( i < size_type(64) )
		{
			var Incrementer incrementer{ .ptr= ptr };
			threads.push_back( ust::thread_create(incrementer) );
			++i;
		}

		while( ptr.lock_imut().get_ref() < 4 ) {} // Wait a bit.

		threads.clear(); // Make join here.
		halt if( ptr.lock_imut().get_ref() != 64 );
	}

	return 0;
}
