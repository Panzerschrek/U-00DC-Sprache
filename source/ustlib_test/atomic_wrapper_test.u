//##success_test
import "../ustlib/assert.u"
import "../ustlib/atomic_wrapper.u"
import "../ustlib/stdout.u"
import "../ustlib/string_conversions.u"

fn nomangle main() : i32
{
	{ // Basic usage.
		var i32 mut x= -6;
		var ust::atomic_wrapper</i32/> w(x);
		assert( w.load() == -6 );
		assert( w.load() == -6 );
	}
	{ // Basic usage for unsigned integer.
		var u32 mut x= 687u;
		var ust::atomic_wrapper</u32/> w(x);
		assert( w.load() == 687u );
		assert( w.load() == 687u );
	}
	{ // Basic load and store.

		var i32 mut x= 9;

		var ust::atomic_wrapper</i32/> w(x);
		assert( w.load() == 9 );

		w.store(78);
		assert( w.load() == 78 );

		w.store(-123);
		assert( w.load() == -123 );
	}
	{ // Basic add.

		var u32 mut x= 8u;

		var ust::atomic_wrapper</u32/> w(x);
		assert( w.load() == 8u );

		assert( w.add( 7u ) == 8u );
		assert( w.load() == 15u );

		assert( w.add( 100u ) == 15u );
		assert( w.load() == 115u );
	}
	{ // Basic sub.

		var i32 mut x= 765;

		var ust::atomic_wrapper</i32/> w(x);
		assert( w.load() == 765 );

		assert( w.sub( 5 ) == 765 );
		assert( w.load() == 760 );

		assert( w.sub( 60 ) == 760 );
		assert( w.load() == 700 );

		assert( w.sub( 1000 ) == 700 );
		assert( w.load() == -300 );
	}
	{ // Basic inc.

		var i32 mut x= -1;

		var ust::atomic_wrapper</i32/> w(x);
		assert( w.load() == -1 );

		assert( w.inc() == -1 );
		assert( w.load() == 0 );

		assert( w.inc() ==  0 );
		assert( w.load() == 1 );

		assert( w.inc() ==  1 );
		assert( w.load() == 2 );
	}
	{ // Basic dec.

		var u32 mut x= 100u;

		var ust::atomic_wrapper</u32/> w(x);
		assert( w.load() == 100u );

		assert( w.dec() == 100u );
		assert( w.load() == 99u );

		assert( w.dec() ==  99u );
		assert( w.load() == 98u );

		assert( w.dec() ==  98u );
		assert( w.load() == 97u );
	}
	{ // Usage via multiple references.

		var i32 mut x= 0;
		var ust::atomic_wrapper</i32/> w0(x), w1(w0), w2(w1);

		assert( w0.add(5) == 0 );
		assert( w1.add(7) == 5 );
		assert( w2.add(10) == 12 );
		assert( w0.load() == 22 );
		assert( w1.inc() == 22 );
		assert( w2.dec() == 23 );
		assert( w0.load() == 22 );
	}
	{ // Creation function usage.
		var i32 mut x= 0;
		auto w= ust::make_atomic_wrapper(x);
		assert( w.add(5) == 0 );
		assert( w.sub(10) == 5 );
		assert( w.load() == -5 );
	}
	{ // Usage via multiple references.

		var u32 mut x= 128u;
		auto w0= ust::make_atomic_wrapper(x);
		auto w1= w0;

		assert( w0.add(100u) == 128u );
		assert( w1.sub(200u) == 228u );
		assert( w0.load() == 28u );
		assert( w1.load() == 28u );
		w0.store( 12345u );
		assert( w1.load() == 12345u );
	}
	{ // compare_exchange_strong
		var i32 mut x= 111, mut y= 77;
		auto w= ust::make_atomic_wrapper(x);
		assert( !w.compare_exchange_strong( y, 7 ) );
		assert( w.load() == 111 );
		assert( y == 111 );
	}
	{ // compare_exchange_strong
		var i32 mut x= 14, mut y= 14;
		auto w= ust::make_atomic_wrapper(x);
		assert( w.compare_exchange_strong( y, 85 ) );
		assert( w.load() == 85 );
		assert( y == 14 );
	}

	return 0;
}
