//##success_test
import "../ustlib/math.u"
import "../ustlib/optional.u"
import "../ustlib/optional_ref.u"
import "../ustlib/random_access_range.u"
import "../ustlib/string.u"
import "../ustlib/vector.u"
import "../ustlib/unordered_set.u"


type IntRangeMut = ust::random_access_range_mut </i32/>;
type IntRangeImut= ust::random_access_range_imut</i32/>;

class NonCopyable
{
	i32 x;
	fn constructor( i32 in_x ) ( x= in_x ) {}
}

static_assert( !typeinfo</NonCopyable/>.is_copy_constructible );

template</ size_type size0, size_type size1 />
fn constexpr string_equals( [ char8, size0 ]& s0, [ char8, size1 ]& s1 ) : bool
{
	if( size0 != size1 ) { return false; }

	for( var size_type mut i(0); i < size0; ++i )
	{
		if( s0[i] != s1[i] ) { return false; }
	}
	return true;
}

template</type T/>
fn constexpr GetNextMethodIndex() : size_type
{
	auto mut index= 0s;
	for( &func : typeinfo</T/>.functions_list )
	{
		if( string_equals( func.name, "next" ) )
		{
			return index;
		}
		++index;
	}
	halt; // Not found.
}

template</type T/> fn IsOptional( ust::optional</T/>& t ) : bool
{
	return true;
}

template</type T/> fn IsOptional( T& t ) : bool
{
	return false;
}

template</type T/> fn IsOptionalRefMut( ust::optional_ref</T, true/>& t ) : bool
{
	return true;
}

template</type T/> fn IsOptionalRefMut( T& t ) : bool
{
	return false;
}

template</type T/> fn IsOptionalRefImut( ust::optional_ref</T, false/>& t ) : bool
{
	return true;
}

template</type T/> fn IsOptionalRefImut( T& t ) : bool
{
	return false;
}

class C
{
	i32 x;
	fn constructor( i32 in_x ) ( x= in_x ) {}
}

struct CWrapper
{
	C c;
}

class CSequenceIterator
{
public:
	fn next( mut this ) : ust::optional</C/>
	{
		if( x >= 10 )
		{
			return ust::null_optional;
		}
		var ust::optional</C/> mut res( C(x) );
		++x;
		return move(res);
	}

private:
	i32 x= 0;
}

class CSequenceIteratorCreator
{
	fn iter() : auto
	{
		return ust::wrap_raw_iterator( CSequenceIterator() );
	}
}

struct IVec2
{
	i32 x;
	i32 y;

	fn GetY( this ) : i32&
	{
		return y;
	}
}

fn SquareInt( i32 x ) : i32
{
	return x * x;
}

fn nomangle main() : i32
{
	{ // Basic iteration.
		var [ i32, 4 ] ints[ 44, 33, 22, 11 ];
		auto mut it= IntRangeImut( ints ).iter();
		var size_type mut num_iterations= 0s;
		loop
		{
			var ust::optional_ref_imut</i32/> ref= it.next();
			if( ref.empty() )
			{
				break;
			}
			halt if( ref.try_deref() != ints[ num_iterations ] );
			++num_iterations;
		}
		halt if( num_iterations != 4s );
	}
	{ // Basic iteration with mutation.
		var [ i32, 4 ] mut ints[ 10, 11, 12, 13 ];
		var size_type mut num_iterations= 0s;
		with( mut it : IntRangeMut( ints ).iter() )
		{
			loop
			{
				var ust::optional_ref_mut</i32/> ref= it.next();
				if( ref.empty() )
				{
					break;
				}
				ref.try_deref() *= 3;
				++num_iterations;
			}
		}
		halt if( num_iterations != 4s );
		halt if( ints[0] != 30 );
		halt if( ints[1] != 33 );
		halt if( ints[2] != 36 );
		halt if( ints[3] != 39 );
	}
	{ // Basic iteration with foreach.
		var [ i32, 4 ] ints[ 44, 33, 22, 11 ];
		var size_type mut num_iterations= 0s;
		foreach( &i : IntRangeImut( ints ) )
		{
			halt if( i != ints[ num_iterations ] );
			++num_iterations;
		}
		halt if( num_iterations != 4s );
	}
	{ // Basic iteration with mutation via foreacg.
		var [ i32, 4 ] mut ints[ 10, 11, 12, 13 ];
		var size_type mut num_iterations= 0s;
		foreach( &mut i : IntRangeMut( ints ) )
		{
			i*= 3;
			++num_iterations;
		}
		halt if( num_iterations != 4s );
		halt if( ints[0] != 30 );
		halt if( ints[1] != 33 );
		halt if( ints[2] != 36 );
		halt if( ints[3] != 39 );
	}
	{ // Immutable iteration over noncopyable type.
		var [ NonCopyable, 3 ] arr[ (43), (54), (65) ];
		var size_type mut num_iterations= 0s;
		foreach( &v : ust::array_view_imut</NonCopyable/>( arr ) )
		{
			halt if( v.x != arr[num_iterations].x );
			++num_iterations;
		}
		halt if( num_iterations != 3s );
	}
	{ // Mutable iteration over noncopyable type.
		var [ NonCopyable, 3 ] mut arr[ (0), (0), (0) ];
		var size_type mut num_iterations= 0s;
		foreach( &mut v : ust::array_view_mut</NonCopyable/>( arr ) )
		{
			v.x= i32(num_iterations) * 10;
			++num_iterations;
		}
		halt if( num_iterations != 3s );
		halt if( arr[0].x != 0 );
		halt if( arr[1].x != 10 );
		halt if( arr[2].x != 20 );
	}
	{ // Inspect result types.
		var IntRangeImut range;
		auto mut it= range.iter();
		auto next_res= it.next();
		halt if( IsOptional(next_res) );
		halt if( !IsOptionalRefImut(next_res) );
		halt if( IsOptionalRefMut(next_res) );
	}
	{ // Inspect result types.
		var IntRangeMut range;
		auto mut it= range.iter();
		auto next_res= it.next();
		halt if( IsOptional(next_res) );
		halt if( IsOptionalRefImut(next_res) );
		halt if( !IsOptionalRefMut(next_res) );
	}
	{ // Iterator is copyable.
		var [ i32, 4 ] ints[ 44, 33, 22, 11 ];
		auto mut it= IntRangeImut( ints ).iter();
		auto mut it_copy= it; // Make copy.

		// Iterate over copy.
		var size_type mut num_iterations= 0s;
		loop
		{
			var ust::optional_ref_imut</i32/> ref= it_copy.next();
			if( ref.empty() )
			{
				break;
			}
			halt if( ref.try_deref() != ints[ num_iterations ] );
			++num_iterations;
		}
		halt if( num_iterations != 4s );

		// Iterate over original iterator.
		num_iterations= 0s;
		loop
		{
			var ust::optional_ref_imut</i32/> ref= it.next();
			if( ref.empty() )
			{
				break;
			}
			halt if( ref.try_deref() != ints[ num_iterations ] );
			++num_iterations;
		}
		halt if( num_iterations != 4s );
	}
	{
		// Should properly handle iterator returning values.
		var size_type mut num_iterations= 0s;
		foreach( c : CSequenceIteratorCreator() )
		{
			halt if( c.x != i32(num_iterations) );
			++num_iterations;
		}
		halt if( num_iterations != 10s );
	}
	{
		// Should properly handle iterator returning values and create a reference for temp value.
		var size_type mut num_iterations= 0s;
		foreach( &c : CSequenceIteratorCreator() )
		{
			halt if( c.x != i32(num_iterations) );
			++num_iterations;
		}
		halt if( num_iterations != 10s );
	}
	{
		// Should properly handle iterator returning values and move such values.
		var ust::vector</C/> mut values;
		var size_type mut num_iterations= 0s;
		foreach( mut c : CSequenceIteratorCreator() )
		{
			values.push_back( move(c) );
		}
		halt if( values.size() != 10s );

		num_iterations= 0s;
		foreach( &c : values )
		{
			halt if( c.x != i32(num_iterations) );
			++num_iterations;
		}
		++num_iterations;
	}
	{ // "first" method.
		var [ i32, 4 ] ints[ 88, 44, 22, 11 ];
		halt if( IntRangeImut(ints).iter().first().try_deref() != 88 );
	}
	{ // "first" method for empty sequence - should return nothing.
		halt if( !IntRangeImut().iter().first().empty() );
	}
	{ // "last" method.
		var [ i32, 4 ] ints[ 88, 44, 22, 11 ];
		halt if( IntRangeImut(ints).iter().last().try_deref() != 11 );
	}
	{ // ";ast" method for empty sequence - should return nothing.
		halt if( !IntRangeImut().iter().last().empty() );
	}
	{ // Count for sequence of known length.
		var [ i32, 42 ] arr= zero_init;
		halt if( IntRangeImut(arr).iter().count() != 42s );
	}
	{ // Count for sequence of with possible dynamic length.
		halt if( CSequenceIteratorCreator().iter().count() != 10s );
	}
	{ // Collect into vector.
		var [ i32, 4 ] ints[ 88, 44, 22, 11 ];
		var ust::vector</i32/> vec= IntRangeImut(ints).iter().collect</ ust::vector</i32/> />();
		halt if( vec.size() != 4s );
		halt if( vec[0s] != 88 );
		halt if( vec[1s] != 44 );
		halt if( vec[2s] != 22 );
		halt if( vec[3s] != 11 );
	}
	{ // Collect into vector for empty sequence.
		var [ i32, 0 ] ints[ ];
		auto vec= IntRangeImut(ints).iter().collect</ ust::vector</i32/> />();
		halt if( vec.size() != 0s );
	}
	{ // Collect into vector for noncopyable type.
		var ust::vector</C/> vec= CSequenceIteratorCreator().iter().collect</ ust::vector</C/> />();
		halt if( vec.size() != 10s );
		for( auto mut i= 0s; i < 10s; ++i )
		{
			halt if( vec[i].x != i32(i) );
		}
	}
	{ // Collect into unordered set. Result should be deduplicated.
		var [ i32, 6 ] ints[ 15, 23, -5, 15, 23, 125 ];
		auto ints_set= IntRangeImut(ints).iter().collect</ ust::unordered_set</i32/> />();
		halt if( ints_set.size() != 4s );
		halt if( !ints_set.exists( 15 ) );
		halt if( !ints_set.exists( 23 ) );
		halt if( !ints_set.exists( -5 ) );
		halt if( !ints_set.exists( 125 ) );
	}
	{ // Collect into string.
		auto str= ust::string_view8( "Gott muss ein Arschloch sein" ).iter().collect</ ust::string8 />();
		halt if( str != "Gott muss ein Arschloch sein" );
	}
	{ // "all" method.
		var [ i32, 4 ] ints[ 5, -3, 77, 11 ];
		var i32 zero= 0;
		var bool all_positive= IntRangeImut(ints).iter().all( lambda[&]( i32 x ) : bool { return x > zero; } );
		halt if( all_positive );
		var bool all_odd= IntRangeImut(ints).iter().all( lambda[=]( i32& x ) : bool { return ( x & 1 ) != zero; } );
		halt if( !all_odd );
	}
	{ // "all" method for empty sequence - should return "true".
		var bool all_empty= IntRangeImut().iter().all( lambda( i32 x ) : bool { return false; } );
		halt if( !all_empty );
	}
	{ // "any" method.
		var [ i32, 4 ] ints[ 5, -3, 77, 11 ];
		var i32 zero= 0;
		var bool any_positive= IntRangeImut(ints).iter().any( lambda[&]( i32 x ) : bool { return x > zero; } );
		halt if( !any_positive );
		var bool any_even= IntRangeImut(ints).iter().any( lambda[=]( i32& x ) : bool { return ( x & 1 ) == zero; } );
		halt if( any_even );
	}
	{ // "any" method for empty sequence - should return "false".
		var bool any_empty= IntRangeImut().iter().any( lambda( i32& x ) : bool { return true; } );
		halt if( any_empty );
	}
	{ // "fold" method.
		var [ i32, 4 ] ints[ 67, 5, 123, -11 ];
		var i32 sum= IntRangeImut(ints).iter().fold( 100, lambda( i32 x, i32 y ) : i32 { return x + y; } );
		halt if( sum != 100 + 67 + 5 + 123 - 11 );
	}
	{ // "fold" method - calculate product.
		var [ i32, 4 ] ints[ 13, 5, 20, 7 ];
		var i32 product= IntRangeImut(ints).iter().fold( 3, lambda( i32 x, i32 y ) : i32 { return x * y; } );
		halt if( product != 3 * 13 * 5 * 20 * 7 );
	}
	{ // "fold" method for non-commutative function.
		var [ i32, 4 ] ints[ 67, 5, 123, -11 ];
		var i32 diff= IntRangeImut(ints).iter().fold( 1000, lambda( i32& x, i32& y ) : i32 { return x - y; } );
		halt if( diff != 1000 - 67 - 5 - 123 + 11 );
	}
	{ // "fold" for empty sequence returns initial value.
		var i32 res= IntRangeImut().iter().fold( 1234, lambda( i32 x, i32 y ) : i32 { return x + y; } );
		halt if( res != 1234 );
	}
	{ // "filter" method.
		var [ i32, 5 ] ints[ 67, -1234, 5, 123, -11 ];
		auto non_negative_ints=
			IntRangeImut(ints)
			.iter()
			.filter( lambda( i32& x ) : bool { return x > 0; } )
			.collect</ ust::vector</i32/> /> ();
		halt if( non_negative_ints.size() != 3s );
		halt if( non_negative_ints[0s] != 67 );
		halt if( non_negative_ints[1s] != 5 );
		halt if( non_negative_ints[2s] != 123 );
	}
	{ // "filter" method with capturing lambda insize.
		var [ i32, 11 ] ints[ 5, 16, 99, 786, 100, 674, 105, 33, -55, -77, 91 ];
		var i32 center= 100;
		auto near_center=
			IntRangeImut(ints)
			.iter()
			.filter( lambda[&]( i32& x ) : bool { return ust::abs( x - center ) < 10; } )
			.collect</ ust::vector</i32/> /> ();
		halt if( near_center.size() != 4s );
		halt if( near_center[0s] != 99 );
		halt if( near_center[1s] != 100 );
		halt if( near_center[2s] != 105 );
		halt if( near_center[3s] != 91 );
	}
	{ // "map" method for values.
		var [ i32, 3 ] ints[ 7, 5, 3 ];
		auto floats=
			IntRangeImut(ints)
			.iter()
			.map( lambda( i32 x ) : f32 { return f32(x); } )
			.collect</ ust::vector</f32/> />();
		halt if( floats.size() != 3s );
		halt if( floats[0s] != 7.0f );
		halt if( floats[1s] != 5.0f );
		halt if( floats[2s] != 3.0f );
	}
	{ // "map" for immutable reference mapping.
		var[ IVec2, 3 ] vecs[ { .x=1, .y=2 }, { .x=3, .y=4 }, { .x=5, .y=6 } ];
		var size_type mut i= 0s;
		foreach( &y : ust::random_access_range_imut</IVec2/>(vecs).iter().map( lambda( IVec2& vec ) : i32& { return vec.y; } ) )
		{
			halt if( y != i32(i) * 2 + 2 );
			++i;
		}
	}
	{ // "map" for mutable reference mapping.
		var[ IVec2, 5 ] mut vecs= zero_init;
		{
			var size_type mut i= 0s;
			auto mut it= ust::random_access_range_mut</IVec2/>(vecs).iter().map( lambda( IVec2 &mut vec ) : i32 &mut { return vec.x; } );
			loop
			{
				auto next_res= it.next();
				if( next_res.empty() )
				{
					break;
				}
				next_res.try_deref()= i32(i) * 5;
				++i;
			}
		}

		halt if( vecs[0].x !=  0 );
		halt if( vecs[1].x !=  5 );
		halt if( vecs[2].x != 10 );
		halt if( vecs[3].x != 15 );
		halt if( vecs[4].x != 20 );
	}
	{ // "map" for source iterator producing move-only values.
		auto wrappers=
			CSequenceIteratorCreator()
			.iter()
			.map(
				lambda( C mut c ) : CWrapper
				{
					var CWrapper mut wrapper{ .c= move(c) };
					return move(wrapper);
				} )
			.collect</ ust::vector</ CWrapper /> />();

		halt if( wrappers.size() != 10s );
		auto mut i= 0;
		foreach( &wrapper : wrappers )
		{
			halt if( wrapper.c.x != i );
			++i;
		}
	}
	{ // "map" method with function pointer.
		var [ i32, 4 ] ints[ 5, 42, -11, 17 ];
		auto squares=
			IntRangeImut(ints)
			.iter()
			.map( SquareInt )
			.collect</ ust::vector</i32/> />();
		halt if( squares.size() != 4s );
		halt if( squares[0s] != 25 );
		halt if( squares[1s] != 1764 );
		halt if( squares[2s] != 121 );
		halt if( squares[3s] != 289 );
	}
	{ // "map" for immutable reference mapping using function pointer for member function.
		var[ IVec2, 3 ] vecs[ { .x= 0, .y= 1 }, { .x= 0, .y= 4 }, { .x= 0, .y= 9 } ];
		var i32 mut i= 0;
		foreach( &y : ust::random_access_range_imut</IVec2/>(vecs).iter().map( IVec2::GetY ) )
		{
			halt if( y != (i + 1) * (i + 1) );
			++i;
		}
	}
	{ // "filter_map" method
		var [ i32, 7 ] ints[ -3, 42, 87, -34, -76, 77, -11 ];
		auto non_negative_floats=
			IntRangeImut(ints)
			.iter()
			.filter_map(
				lambda[]( i32& x ) : ust::optional</f32/>
				{
					if( x < 0 ) { return ust::null_optional; }
					return f32(x);
				} )
			.collect</ ust::vector</f32/> />();
		var [ f32, 3 ] expected_result[ 42.0f, 87.0f, 77.0f ];
		halt if( non_negative_floats.range() != expected_result );
	}
	{ // "filter_map" method for references.
		var[ IVec2, 4 ] vecs[ { .x= 34, .y= 0 }, { .x= -11, .y= 77 }, { .x= 83, .y= 9 }, { .x= -64, .y= -67 } ];
		auto zero= 0;
		auto non_negative_xs=
			ust::random_access_range_imut</IVec2/>(vecs)
			.iter()
			.filter_map(
				lambda[&zero]( IVec2& vec ) : ust::optional_ref_imut</i32/>
				{
					if( vec.x < zero ) { return ust::null_optional_ref; }
					return ust::optional_ref_imut</i32/>(vec.x);
				} )
			.collect</ ust::vector</i32/> />();
		var [ i32, 2 ] expected_result[ 34, 83 ];
		halt if( non_negative_xs.range() != expected_result );
	}
	{ // "filter_map" for non-copyable value.
		auto c_vec=
			CSequenceIteratorCreator()
			.iter()
			.filter_map(
				lambda( C mut c ) : ust::optional</CWrapper/>
				{
					if( (c.x & 1) != 0 ) { return ust::null_optional; }
					var CWrapper mut wrapper{ .c= move(c) };
					return move(wrapper);
				})
				.collect</ ust::vector</CWrapper/> />();
			halt if( c_vec.size() != 5s );
			auto mut i= 0;
			foreach( &c_wrapper : c_vec )
			{
				halt if( c_wrapper.c.x != i * 2 );
				++i;
			}
	}
	{ // "chain" method.
		var [ i32, 3 ] ints0[ 11, 22, 33 ];
		var [ i32, 4 ] ints1[ 44, 55, 66, 77 ];
		auto ints_combined=
			IntRangeImut(ints0)
			.iter()
			.chain( IntRangeImut(ints1).iter() )
			.collect</ ust::vector</i32/> />();
		var [ i32, 7 ] expected_result[ 11, 22, 33, 44, 55, 66, 77 ];
		halt if( ints_combined.range() != expected_result );
	}
	{ // "chain" method for mutation.
		var [ i32, 3 ] mut ints0[ 11, 22, 33 ];
		var [ i32, 4 ] mut ints1[ 44, 55, 66, 77 ];
		foreach ( &mut i : IntRangeMut(ints0).iter().chain( IntRangeMut(ints1).iter() ) )
		{
			i*= -2;
		}
		halt if( ints0[0] != -22 );
		halt if( ints0[1] != -44 );
		halt if( ints0[2] != -66 );
		halt if( ints1[0] != -88 );
		halt if( ints1[1] != -110 );
		halt if( ints1[2] != -132 );
		halt if( ints1[3] != -154 );
	}

	return 0;
}
