// Compile it with following command:
//	./build-release-clang-llvm-src/compiler0/Compiler external_await_test.u -o other/test.ll -filetype=ll -O2
//
// With async calls inlining enabled "Bar.resume" doesn't contain "malloc" for "Foo" frame.
// The same is true for "Baz.resume".

import "source/ustlib/imports/vector.u"

fn async Foo( i32 x ) : i32
{
	yield;
	yield;
	yield;
	return 11 * x;
}

fn async Foo64( i64 x ) : i64
{
	yield;
	return 1523i64 * x + x;
}

fn async nomangle Bar() : f32
{
	var i32 res= ExternalAwait( Foo(15) ).await;
	return f32(res) * 1.5f;
}

fn async nomangle Baz() : i64
{
	var tup[ i32, i64 ] res= ExternalAwait2( Foo(25), Foo64(637i64) ).await;
	return i64(res[0]) * res[1];
}

fn async nomangle Lol() : i32
{
	var [ i32, 4 ] res= ExternalAwaitMultiple( ust::make_array( Foo( 2 ), Foo( 3 ), Foo( 5 ), Foo( 7 ) ) ).await;
	return res[0] * res[1] * res[2] * res[3];
}

fn async nomangle Wtf( ust::array_view_imut</i32/> nums ) : i32
{
	auto res=
		ExternalAwaitMultipleVec( ust::make_vector_from_mapped_range(
			nums,
			lambda( i32 x ) : (async : i32)
			{
				return Foo(x);
			} ) ).await;

	var i32 mut product= 0;
	foreach( n : res )
	{
		product *= n;
	}
	return product;
}

template</type T/>
fn async ExternalAwait( ( async : T ) mut f ) : T
{
	unsafe
	{
		var raw_coro_handle handle= cast_ref_unsafe</coro_struct/>(f).handle;

		// Ensure given async function isn't done yet (we can resume it).
		halt if( coro_done_impl( handle ) );

		ExternalAwaitImpl( handle );

		// Perform yield loop until given function isn't done.
		loop
		{
			yield;

			if( coro_done_impl( handle ) )
			{
				break;
			}
		}

		var T mut res= uninitialized;

		ust::memory_copy_aligned(
			typeinfo</T/>.align_of,
			ust::ptr_cast_to_byte8( $<(res) ),
			handle + typeinfo</size_type/>.size_of * 2s,
			typeinfo</T/>.size_of );

		return res;
	}
}

fn ExternalAwaitImpl( raw_coro_handle coro_handle ) unsafe;

template</type A, type B/>
fn async ExternalAwait2( ( async : A ) mut a, ( async : B ) mut b ) : tup[ A, B ]
{
	unsafe
	{
		var raw_coro_handle handle_a= cast_ref_unsafe</coro_struct/>(a).handle;
		var raw_coro_handle handle_b= cast_ref_unsafe</coro_struct/>(b).handle;

		// Ensure given async functions aren't done yet (we can resume them).
		halt if( coro_done_impl( handle_a ) );
		halt if( coro_done_impl( handle_b ) );

		ExternalAwaitImpl2( handle_a, handle_b );

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			if( coro_done_impl( handle_a ) & coro_done_impl( handle_b ) )
			{
				break;
			}
		}

		var tup[ A, B ] mut res= uninitialized;

		ust::memory_copy_aligned(
			typeinfo</A/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[0]) ),
			handle_a + typeinfo</size_type/>.size_of * 2s,
			typeinfo</A/>.size_of );

		ust::memory_copy_aligned(
			typeinfo</B/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[1]) ),
			handle_b + typeinfo</size_type/>.size_of * 2s,
			typeinfo</B/>.size_of );

		return res;
	}
}

 fn ExternalAwaitImpl2( raw_coro_handle a, raw_coro_handle b ) unsafe;

template</type T, size_type S/>
fn async ExternalAwaitMultiple( [ ( async : T ), S ] mut a ) : [ T, S ]
{
	unsafe
	{
		var [ raw_coro_handle, S ] mut handles= uninitialized;
		for( auto mut i= 0s; i < S; ++i )
		{
			var raw_coro_handle handle= cast_ref_unsafe</coro_struct/>( a[i] ).handle;

			halt if( coro_done_impl( handle ) );

			handles[i]= handle;
		}

		ExternalAwaitMultipleImpl( handles );

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			var bool mut done= true;
			for( auto mut i= 0s; i < S; ++i )
			{
				done &= coro_done_impl( handles[i] );
			}
			if(done)
			{
				break;
			}
		}

		var [ T, S ] mut res= uninitialized;

		for( auto mut i= 0s; i < S; ++i )
		{
			ust::memory_copy_aligned(
				typeinfo</T/>.align_of,
				ust::ptr_cast_to_byte8( $<(res[i]) ),
				handles[i] + typeinfo</size_type/>.size_of * 2s,
				typeinfo</T/>.size_of );
		}

		return res;
	}
}

template</type T />
fn async ExternalAwaitMultipleVec( ust::vector</ ( async : T ) /> mut a ) : ust::vector</T/>
{
	unsafe
	{
		for( auto mut i= 0s; i < a.size(); ++i )
		{
			halt if( coro_done_impl( cast_ref_unsafe</coro_struct/>( a[i] ).handle  ) );
		}

		// Coro struct contains single handle - raw pointer. Just cast arrays here.
		ExternalAwaitMultipleImpl(
			ust::array_view_imut</raw_coro_handle/>(
				cast_ref_unsafe</ $(raw_coro_handle) />( a.data() ),
				a.size() ) );

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			var bool mut done= true;
			foreach( &h : a )
			{
				done &= coro_done_impl( cast_ref_unsafe</coro_struct/>( h ).handle );
			}
			if(done)
			{
				break;
			}
		}

		var ust::vector</T/> mut res( a.size(), T(0) );

		for( auto mut i= 0s; i < a.size(); ++i )
		{
			ust::memory_copy_aligned(
				typeinfo</T/>.align_of,
				ust::ptr_cast_to_byte8( $<(res[i]) ),
				cast_ref_unsafe</coro_struct/>( a[i] ).handle + typeinfo</size_type/>.size_of * 2s,
				typeinfo</T/>.size_of );
		}

		return res;
	}
}

fn ExternalAwaitMultipleImpl( ust::array_view_imut</raw_coro_handle/> a ) unsafe;

struct coro_struct
{
	raw_coro_handle handle;
}

type raw_coro_handle= $(byte8);

fn nomangle coro_done_impl( raw_coro_handle coro_handle ) unsafe : bool;
