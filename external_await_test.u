// Compile it with following command:
//	./build-release-clang-llvm-src/compiler0/Compiler external_await_test.u -o other/test.ll -filetype=ll -O2
//
// With async calls inlining enabled "Bar.resume" doesn't contain "malloc" for "Foo" frame.
// The same is true for "Baz.resume".

import "source/ustlib/imports/vector.u"

class Destructible
{
public:
	fn constructor(i32 x)
		( x_= x )
	{}

	fn destructor()
	{
		DestroyImpl(x_);
	}

private:
	fn DestroyImpl(i32 x);

private:
	i32 x_;
}

fn async Foo( i32 x ) : i32
{
	yield;
	yield;
	yield;
	return 11 * x;
}

fn async Foo64( i64 x ) : i64
{
	yield;
	return 1523i64 * x + x;
}

fn async nomangle Bar() : f32
{
	var Destructible d(1111);
	var i32 res= ExternalAwait( Foo(15) ).await;
	BarEnd();
	return f32(res) * 1.5f;
}

fn BarEnd();

fn async nomangle Baz() : i64
{
	var Destructible d(2222);
	var tup[ i32, i64 ] res= ExternalAwait2( Foo(25), Foo64(637i64) ).await;
	BazEnd();
	return i64(res[0]) * res[1];
}

fn BazEnd();

fn async nomangle Lol() : i32
{
	var Destructible d(3333);
	var [ i32, 8 ] res= ExternalAwaitMultiple( ust::make_array( Foo( 2 ), Foo( 3 ), Foo( 5 ), Foo( 7 ), Foo( 11 ), Foo( 13 ), Foo( 17 ), Foo( 19 ) ) ).await;
	LolEnd();
	return res[0] * res[1] * res[2] * res[3] * res[4] * res[5] * res[6] * res[7];
}

fn LolEnd();

fn async nomangle BarBazLol() : f64
{
	var Destructible d(112233);
	// Multiple await with async functions containing other multiple awaits inside.
	var tup[ f32, i64, i32 ] res= ExternalAwait3( Bar(), Baz(), Lol() ).await;
	BarBazLolEnd();
	return f64(res[0]) * f64(res[1]) + f64(res[2]);
}

fn BarBazLolEnd();

fn async nomangle Wtf( ust::array_view_imut</i32/> nums ) : i32
{
	auto res=
		ExternalAwaitMultipleVec( ust::make_vector_from_mapped_range(
			nums,
			lambda( i32 x ) : (async : i32)
			{
				return Foo(x);
			} ) ).await;

	var i32 mut product= 1;
	foreach( n : res )
	{
		product *= n;
	}
	return product;
}

template</type T/>
fn async ExternalAwait( ( async : T ) mut f ) : T
{
	unsafe
	{
		var raw_coro_handle handle= LoadCoroHandle(f);

		// Ensure given async function isn't done yet (we can resume it).
		halt if( coro_done_impl( handle ) );

		ExternalAwaitImpl( handle );

		// Perform yield loop until given function isn't done.
		loop
		{
			yield;

			if( coro_done_impl( handle ) )
			{
				break;
			}
		}

		var T mut res= uninitialized;

		ust::memory_copy_aligned(
			typeinfo</T/>.align_of,
			ust::ptr_cast_to_byte8( $<(res) ),
			handle + typeinfo</size_type/>.size_of * 2s,
			typeinfo</T/>.size_of );

		return res;
	}
}

template</type A, type B/>
fn async ExternalAwait2( ( async : A ) mut a, ( async : B ) mut b ) : tup[ A, B ]
{
	unsafe
	{
		var raw_coro_handle handle_a= LoadCoroHandle(a);
		var raw_coro_handle handle_b= LoadCoroHandle(b);

		// Ensure given async functions aren't done yet (we can resume them).
		halt if( coro_done_impl( handle_a ) );
		halt if( coro_done_impl( handle_b ) );

		ExternalAwaitImpl( handle_a );
		ExternalAwaitImpl( handle_b );

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			if( coro_done_impl( handle_a ) & coro_done_impl( handle_b ) )
			{
				break;
			}
		}

		var tup[ A, B ] mut res= uninitialized;

		ust::memory_copy_aligned(
			typeinfo</A/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[0]) ),
			handle_a + typeinfo</size_type/>.size_of * 2s,
			typeinfo</A/>.size_of );

		ust::memory_copy_aligned(
			typeinfo</B/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[1]) ),
			handle_b + typeinfo</size_type/>.size_of * 2s,
			typeinfo</B/>.size_of );

		return res;
	}
}

template</type A, type B, type C/>
fn async ExternalAwait3( ( async : A ) mut a, ( async : B ) mut b, ( async : C ) mut c ) : tup[ A, B, C ]
{
	unsafe
	{
		var raw_coro_handle handle_a= LoadCoroHandle(a);
		var raw_coro_handle handle_b= LoadCoroHandle(b);
		var raw_coro_handle handle_c= LoadCoroHandle(c);

		// Ensure given async functions aren't done yet (we can resume them).
		halt if( coro_done_impl( handle_a ) );
		halt if( coro_done_impl( handle_b ) );
		halt if( coro_done_impl( handle_c ) );

		ExternalAwaitImpl( handle_a );
		ExternalAwaitImpl( handle_b );
		ExternalAwaitImpl( handle_c );

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			if( coro_done_impl( handle_a ) & coro_done_impl( handle_b ) & coro_done_impl( handle_c ) )
			{
				break;
			}
		}

		var tup[ A, B, C ] mut res= uninitialized;

		ust::memory_copy_aligned(
			typeinfo</A/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[0]) ),
			handle_a + typeinfo</size_type/>.size_of * 2s,
			typeinfo</A/>.size_of );

		ust::memory_copy_aligned(
			typeinfo</B/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[1]) ),
			handle_b + typeinfo</size_type/>.size_of * 2s,
			typeinfo</B/>.size_of );

		ust::memory_copy_aligned(
			typeinfo</C/>.align_of,
			ust::ptr_cast_to_byte8( $<(res[2]) ),
			handle_c + typeinfo</size_type/>.size_of * 2s,
			typeinfo</C/>.size_of );

		return res;
	}
}

template</type T, size_type S/>
fn async ExternalAwaitMultiple( [ ( async : T ), S ] mut a ) : [ T, S ]
{
	unsafe
	{
		for( auto mut i= 0s; i < S; ++i )
		{
			var raw_coro_handle handle= LoadCoroHandle( a[i] );
			halt if( coro_done_impl( handle ) );
			ExternalAwaitImpl( handle );
		}

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			var bool mut done= true;
			for( auto mut i= 0s; i < S; ++i )
			{
				done &= coro_done_impl( LoadCoroHandle( a[i] ) );
			}
			if(done)
			{
				break;
			}
		}

		var [ T, S ] mut res= uninitialized;

		for( auto mut i= 0s; i < S; ++i )
		{
			ust::memory_copy_aligned(
				typeinfo</T/>.align_of,
				ust::ptr_cast_to_byte8( $<(res[i]) ),
				LoadCoroHandle( a[i] ) + typeinfo</size_type/>.size_of * 2s,
				typeinfo</T/>.size_of );
		}

		return res;
	}
}

template</type T />
fn async ExternalAwaitMultipleVec( ust::vector</ ( async : T ) /> mut a ) : ust::vector</T/>
{
	unsafe
	{
		for( auto mut i= 0s; i < a.size(); ++i )
		{
			var raw_coro_handle handle= LoadCoroHandle( a[i] );
			halt if( coro_done_impl( handle ) );
			ExternalAwaitImpl( handle );
		}

		// Perform yield loop until given functions aren't done.
		loop
		{
			yield;

			var bool mut done= true;
			foreach( &h : a )
			{
				done &= coro_done_impl( LoadCoroHandle(h) );
			}
			if(done)
			{
				break;
			}
		}

		var ust::vector</T/> mut res( a.size(), T(0) );

		for( auto mut i= 0s; i < a.size(); ++i )
		{
			ust::memory_copy_aligned(
				typeinfo</T/>.align_of,
				ust::ptr_cast_to_byte8( res.data() + i ),
				LoadCoroHandle( a[i] ) + typeinfo</size_type/>.size_of * 2s,
				typeinfo</T/>.size_of );
		}

		return res;
	}
}

// Registers an async function as child function of current running one.
// You need to call it for each child async function to be registered.
// Use a function accepting single coroutine argument directly, because passing an array of coroutines may surprisingly lead to deoptimization of coroutine heap allocations.
fn ExternalAwaitImpl( raw_coro_handle coro_handle ) unsafe;

template</type C/>
fn LoadCoroHandle( C& c ) : raw_coro_handle
{
	static_assert( typeinfo</C/>.is_coroutine );
	static_assert( typeinfo</C/>.size_of == typeinfo</raw_coro_handle/>.size_of );

	// use "memcpy" instead of "cast_ref_unsafe", because this allows to avoid problems with TBAA.
	unsafe
	{
		var raw_coro_handle mut res= uninitialized;
		ust::memory_copy_aligned(
			typeinfo</raw_coro_handle/>.align_of,
			ust::ptr_cast_to_byte8( $<(res) ),
			ust::ptr_cast_to_byte8( $<( cast_mut(c) ) ),
			typeinfo</raw_coro_handle/>.size_of );
		return res;
	}
}

type raw_coro_handle= $(byte8);

fn nomangle coro_done_impl( raw_coro_handle coro_handle ) unsafe : bool;
