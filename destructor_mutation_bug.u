// HUGE BUG!
// This source demonstrates an example of reference protection defect, which allows to mutate an object when a reference to it exists.

// Compile it with "O0" and run it with "valigrind" in order to find the bug.

import "source/ustlib/vector.u"

struct MutRef
{
	ust::vector</i32/> &mut vec;
	fn destructor()
	{
		// Clear and reset memory.
		vec= ust::vector</i32/>();
	}
}

fn Foo( ust::vector</i32/> &mut vec ) : i32 &mut
{
	vec.push_back( 42 );
	// Create a reference to "vec" inside "r".
	var MutRef mut r{ .vec= vec };
	// Read reference to first element of vector and return it.
	// But prior to return call destructor of "r", which invalidates returned reference.
	return r.vec.front();
}

fn nomangle main() : i32
{
	var ust::vector</i32/> mut vec;
	vec.push_back( 42 );
	Foo( vec )= 0; // Write into freed memory.

	return 0;
}
